<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" 
ipr="trust200902" 
docName="draft-ietf-6tisch-minimal-security-15" 
number="9031"
category="std" 
obsoletes="" 
updates="" 
submissionType="IETF" 
consensus="true"
xml:lang="en" 
tocInclude="true" 
sortRefs="true" 
symRefs="true" 
tocDepth="2" 
version="3">

  <!-- xml2rfc v2v3 conversion 2.46.0 -->
  <front>

    <title abbrev="CoJP for 6TiSCH">Constrained Join Protocol (CoJP) for 6TiSCH</title>
    <seriesInfo name="RFC" value="9031"/>

    <author initials="M." surname="Vučinić" fullname="Mališa Vučinić" role="editor">
      <organization>Inria</organization>
      <address>
        <postal>
          <street>2 Rue Simone Iff</street>
          <city>Paris</city>
          <code>75012</code>
          <country>France</country>
        </postal>
        <email>malisa.vucinic@inria.fr</email>
      </address>
    </author>
    <author initials="J." surname="Simon" fullname="Jonathan Simon">
      <organization>Analog Devices</organization>
      <address>
        <postal>
          <street>32990 Alvarado-Niles Road, Suite 910</street>
          <city>Union City</city>
          <region>CA</region>
          <code>94587</code>
          <country>United States of America</country>
        </postal>
        <email>jonathan.simon@analog.com</email>
      </address>
    </author>
    <author initials="K." surname="Pister" fullname="Kris Pister">
      <organization>University of California Berkeley</organization>
      <address>
        <postal>
          <street>512 Cory Hall</street>
          <city>Berkeley</city>
          <region>CA</region>
          <code>94720</code>
          <country>United States of America</country>
        </postal>
        <email>pister@eecs.berkeley.edu</email>
      </address>
    </author>
    <author initials="M." surname="Richardson" fullname="Michael Richardson">
      <organization>Sandelman Software Works</organization>
      <address>
        <postal>
          <street>470 Dawson Avenue</street>
          <city>Ottawa</city>
          <region>ON</region>
          <code>K1Z5V7</code>
          <country>Canada</country>
        </postal>
        <email>mcr+ietf@sandelman.ca</email>
      </address>
    </author>
    <date year="2021" month="May"/>
    <area>Internet</area>
    <workgroup>6TiSCH</workgroup>
    <keyword>bootstrapping</keyword>
    <keyword>onboarding</keyword>
    <keyword>oscore</keyword>
    <abstract>
      <t>This document describes the minimal framework required for 
a new device, called a "pledge", to securely join a 6TiSCH (IPv6 over 
the Time-Slotted Channel Hopping mode of IEEE 802.15.4) network.
The framework requires that the pledge and the JRC (Join Registrar/Coordinator, a central entity), share a symmetric key.
How this key is provisioned is out of scope of this document.
Through a single CoAP (Constrained Application Protocol) request-response 
exchange secured by OSCORE (Object Security for Constrained RESTful Environments), 
the pledge requests admission into the network, and the JRC configures it with link-layer keying material and other parameters.
The JRC may at any time update the parameters through another request-response exchange secured by OSCORE.
This specification defines the Constrained Join Protocol and its CBOR 
(Concise Binary Object Representation) data structures, and it describes 
how to configure the rest of the 6TiSCH communication stack for this join process to occur in a secure manner.
Additional security mechanisms may be added on top of this minimal framework.</t>
    </abstract>
  </front>
  <middle>

<section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>This document defines a "secure join" solution for a new device, 
called a "pledge", to securely join a 6TiSCH network.
The term "secure join" refers to network access authentication, authorization,
and parameter distribution as defined in <xref target="RFC9030" format="default"/>.
The Constrained Join Protocol (CoJP) defined in this document handles parameter distribution needed for a pledge to become a joined node.
Mutual authentication during network access and implicit authorization are 
achieved through the use of a secure channel as configured according to this document.
This document also specifies a configuration of different layers of the 6TiSCH protocol stack that reduces the Denial of Service (DoS) attack surface during the join process.</t>
      <t>This document presumes a 6TiSCH network as described by
    <xref target="RFC7554" format="default"/> and
    <xref target="RFC8180" format="default"/>.
By design, nodes in a 6TiSCH network <xref target="RFC7554" format="default"/> 
have their radio turned off most of the time in order to conserve energy.
As a consequence, the link used by a new device for joining the network has limited bandwidth <xref target="RFC8180" format="default"/>.
The secure join solution defined in this document therefore keeps the number of over-the-air exchanges to a minimum.</t>
      <t>The microcontrollers at the heart of 6TiSCH nodes have small 
amounts of code memory.
It is therefore paramount to reuse existing protocols available as part of the 6TiSCH stack.
At the application layer, the 6TiSCH stack already relies on 
CoAP <xref target="RFC7252" format="default"/> for web transfer and 
on OSCORE <xref target="RFC8613" format="default"/> for its end-to-end security.
The secure join solution defined in this document therefore reuses those two protocols as its building blocks.</t>
      <t>CoJP is a generic protocol that can be used as-is in all modes 
of IEEE Std 802.15.4 <xref target="IEEE802.15.4" format="default"/>, including 
the Time-Slotted Channel Hopping (TSCH) mode on which 6TiSCH is based.
CoJP may also be used in other (low-power) networking technologies where 
efficiency in terms of communication overhead and code footprint is important.
In such a case, it may be necessary to define through companion documents 
the configuration parameters specific to the technology in question.
The overall process is described in <xref target="join-process-overview" format="default"/>, 
and the configuration of the stack is specific to 6TiSCH.</t>
      <t>CoJP assumes the presence of a Join Registrar/Coordinator (JRC), a central entity.
The configuration defined in this document assumes that the pledge and the JRC share a unique symmetric cryptographic key, called PSK (pre-shared key).
The PSK is used to configure OSCORE to provide a secure channel to CoJP.
How the PSK is installed is out of scope of this document: this may happen during the provisioning phase or by a key exchange protocol that may precede the execution of CoJP.</t>
      <t>When the pledge seeks admission to a 6TiSCH network, it first 
synchronizes to it by initiating the passive scan defined in 
<xref target="IEEE802.15.4" format="default"/>.
The pledge then exchanges CoJP messages with the JRC; for this end-to-end 
communication to happen, the messages are forwarded by nodes, called Join Proxies,
that are already part of the 6TiSCH network.
The messages exchanged allow the JRC and the pledge to mutually 
authenticate based on the properties provided by OSCORE.
They also allow the JRC to configure the pledge with link-layer 
keying material, a short identifier, and other parameters.
After this secure join process successfully completes, the joined node 
can interact with its neighbors to request additional bandwidth using 
the 6TiSCH Operation Sublayer (6top) Protocol <xref target="RFC8480" format="default"/> 
and can start sending application traffic.</t>
</section>

    <section anchor="terminology" numbered="true" toc="default">
      <name>Terminology</name>

        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
    "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
    interpreted as described in BCP 14 <xref target="RFC2119"/> <xref
    target="RFC8174"/> when, and only when, they appear in all capitals, as
    shown here.
        </t>

      <t>The reader is expected to be familiar with the terms and concepts defined in
    <xref target="RFC9030" format="default"/>,
    <xref target="RFC7252" format="default"/>,
    <xref target="RFC8613" format="default"/>, and
    <xref target="RFC8152" format="default"/>.</t>
      <t>The specification also includes a set of informative specifications using the Concise Data Definition Language (CDDL) <xref target="RFC8610" format="default"/>.</t>
      <t>The following terms defined in <xref target="RFC9030" format="default"/> 
are used extensively throughout this document:</t>
      <ul spacing="normal">
        <li>pledge</li>
        <li>joined node</li>
        <li>Join Proxy (JP)</li>
        <li>Join Registrar/Coordinator (JRC)</li>
        <li>Enhanced Beacon (EB)</li>
        <li>join protocol</li>
        <li>join process</li>
      </ul>
      <t>The following terms defined in <xref target="RFC8505" format="default"/> are also used throughout this document:</t>
      <ul spacing="normal">
        <li>6LoWPAN Border Router (6LBR)</li>
        <li>6LoWPAN Node (6LN)</li>
      </ul>
      <t>The term "6LBR" is used interchangeably with the term "DODAG root" 
defined in <xref target="RFC6550" format="default"/> on the assumption that 
the two entities are co-located, as recommended by 
<xref target="RFC9030" format="default"/>.</t>
      <t>The term "pledge", as used throughout the document, explicitly denotes non-6LBR devices attempting to join the network using their IEEE Std 802.15.4 network interface.
The device that attempts to join as the 6LBR of the network and does so over another network interface is explicitly denoted as the "6LBR pledge".
When the text applies equally to the pledge and the 6LBR pledge, 
the "(6LBR) pledge" form is used.</t>
      <t>In addition, we use generic terms "pledge identifier" and "network identifier".
See <xref target="provisioning" format="default"/>.</t>

</section>
    <section anchor="provisioning" numbered="true" toc="default">
      <name>Provisioning Phase</name>
      <t>The (6LBR) pledge is provisioned with certain parameters before attempting to join the network, and the same parameters are provisioned to the JRC.
There are many ways by which this provisioning can be done.
Physically, the parameters can be written into the (6LBR) pledge with a number of mechanisms, such as
    using a JTAG (Joint Test Action Group) interface,
    using a serial (craft) console interface,
    pushing buttons simultaneously on different devices,
    configuring over-the-air in a Faraday cage, etc.
The provisioning can be done by the vendor, the manufacturer, the integrator, etc.</t>
      <t>Details of how this provisioning is done are out of scope of this document.
What is assumed is that there can be a secure, private conversation between the JRC and the (6LBR) pledge, and that the two devices can exchange the parameters.</t>
      <t>Parameters that are provisioned to the (6LBR) pledge include:</t>
      <dl spacing="normal">
        <dt>pledge identifier:</dt>
<dd>The pledge identifier identifies the (6LBR) pledge.
The pledge identifier <bcp14>MUST</bcp14> be unique in the set of all pledge identifiers managed by a JRC.
The pledge identifier uniqueness is an important security requirement, 
as discussed in <xref target="sec_considerations" format="default"/>.
The pledge identifier is typically the globally unique 64-bit Extended 
Unique Identifier (EUI-64) of the IEEE Std 802.15.4 device, in which 
case it is provisioned by the hardware manufacturer.  The pledge 
identifier is used to generate the IPv6 addresses of the (6LBR) 
pledge and to identify it during the execution of the join protocol.
Depending on the configuration, the pledge identifier may also be 
used after the join process to identify the joined node.
For privacy reasons (see <xref target="privacy_considerations" format="default"/>), 
it is possible to use a pledge identifier different from the EUI-64.
For example, a pledge identifier may be a random byte string, 
but care needs to be taken that such a string meets the uniqueness requirement.</dd>
        <dt>Pre-Shared Key (PSK):</dt>
<dd>A symmetric cryptographic key shared between the (6LBR) pledge and the JRC.
To look up the PSK for a given pledge, the JRC additionally needs to store 
the corresponding pledge identifier.
Each (6LBR) pledge <bcp14>MUST</bcp14> be provisioned with a unique PSK.
The PSK <bcp14>MUST</bcp14> be a cryptographically strong key, with at 
least 128 bits of entropy, indistinguishable by feasible computation 
from a random uniform string of the same length.
How the PSK is generated and/or provisioned is out of scope of this specification.
This could be done during a provisioning step, or companion documents 
can specify the use of a key-agreement protocol.
Common pitfalls when generating PSKs are discussed in 
<xref target="sec_considerations" format="default"/>.
In the case of recommissioning a device to a new owner, the PSK <bcp14>MUST</bcp14> be changed.
Note that the PSK is different from the link-layer keys K1 and K2 
specified in <xref target="RFC8180" format="default"/>.
The PSK is a long-term secret used to protect the execution of the secure 
join protocol specified in this document; the link-layer keys are transported as part of the secure join protocol.</dd>
        <dt>Optionally, a network identifier:</dt>
<dd>The network identifier identifies the 6TiSCH network.
The network identifier <bcp14>MUST</bcp14> be carried within Enhanced Beacon (EB) frames.
Typically, the 16-bit Personal Area Network Identifier (PAN ID) 
defined in <xref target="IEEE802.15.4" format="default"/> is used as the network identifier.
However, PAN ID is not considered a stable network identifier as it may change during network 
lifetime if a collision with another network is detected.
Companion documents can specify the use of a different network identifier for join purposes, 
but this is out of scope of this specification.
Provisioning the network identifier to a pledge is <bcp14>RECOMMENDED</bcp14>.
However, due to operational constraints, the network identifier may not be 
known at the time of provisioning.
If this parameter is not provisioned to the pledge, the pledge 
will attempt to join one advertised network at a time, which significantly prolongs the join process.
This parameter <bcp14>MUST</bcp14> be provisioned to the 6LBR pledge.</dd>
        <dt>Optionally, any non-default algorithms:</dt>
<dd>The default algorithms are specified in <xref target="mti_algos" format="default"/>.
When algorithm identifiers are not provisioned, the use of these default algorithms is implied.</dd>
      </dl>
      <t>Additionally, the 6LBR pledge that is not co-located 
with the JRC needs to be provisioned with the following:</t>
      <dl spacing="normal">
        <dt>Global IPv6 address of the JRC:</dt>
<dd>This address is used by the 6LBR pledge to address the JRC during the join process.
The 6LBR pledge may also obtain the IPv6 address of the JRC through other available 
mechanisms, such as DHCPv6 <xref target="RFC8415" format="default"/>, 
Generic Autonomic Signaling Protocol (GRASP) <xref target="RFC8990" format="default"/>, 
or Multicast DNS (mDNS) <xref target="RFC6762" format="default"/>; 
the use of these mechanisms is out of scope of this document.
Pledges do not need to be provisioned with this address as they 
discover it dynamically through CoJP.</dd>
      </dl>

</section>
    <section anchor="join-process-overview" numbered="true" toc="default">
      <name>Join Process Overview</name>
      <t>This section describes the steps taken by a pledge in a 6TiSCH network.
When a pledge seeks admission to a 6TiSCH network, the following exchange occurs:</t>
      <ol spacing="normal" type="1">
        <li>The pledge listens for an Enhanced Beacon (EB) frame <xref target="IEEE802.15.4" format="default"/>.
This frame provides network synchronization information, 
telling the device when it can send a frame to the node 
sending the beacons, which acts as a Join Proxy (JP) for the pledge, 
and when it can expect to receive a frame.
The EB provides the link-layer address of the JP, 
and it may also provide its link-local IPv6 address.</li>
        <li>The pledge configures its link-local IPv6 address and advertises it to the JP using Neighbor Discovery.
The advertisement step may be omitted if the link-local address has been derived from a known unique interface identifier, such as an EUI-64 address.</li>
        <li>The pledge sends a Join Request to the JP in order to securely identify itself to the network.
The Join Request is forwarded to the JRC.</li>
        <li>In the case of successful processing of the request, the pledge receives a Join Response from the JRC (via the JP).
The Join Response contains configuration parameters necessary for the pledge to join the network.</li>
      </ol>
      <t>From the pledge's perspective, joining is a local phenomenon -- 
the pledge only interacts with the JP, and it needs not know how far it 
is from the 6LBR or how to route to the JRC.
Only after establishing one or more link-layer keys does it need to know about the particulars of a 6TiSCH network.</t>
      <t>The join process is shown as a transaction diagram in <xref target="fig_overview_diagram" format="default"/>:</t>
      <figure anchor="fig_overview_diagram">
        <name>Overview of a successful join process.</name>
        <artwork align="center" name="" type="" alt=""><![CDATA[
+--------+                 +-------+                 +--------+
| pledge |                 |  JP   |                 |  JRC   |
|        |                 |       |                 |        |
+--------+                 +-------+                 +--------+
   |                          |                          |
   |<---Enhanced Beacon (1)---|                          |
   |                          |                          |
   |<-Neighbor Discovery (2)->|                          |
   |                          |                          |
   |-----Join Request (3a)----|----Join Request (3a)---->| \
   |                          |                          | | CoJP
   |<----Join Response (3b)---|----Join Response (3b)----| /
   |                          |                          |
]]></artwork>
      </figure>
      <t>As for other nodes in the network, the 6LBR node may act as the JP.
The 6LBR may in addition be co-located with the JRC.</t>
      <t>The details of each step are described in the following sections.</t>

<section anchor="step-eb" numbered="true" toc="default">
        <name>Step 1 - Enhanced Beacon</name>
        <t>The pledge synchronizes to the network by listening for, 
and receiving, an EB sent by a node already in the network.
This process is entirely defined by <xref target="IEEE802.15.4" format="default"/> 
and described in <xref target="RFC7554" format="default"/>.</t>
        <t>Once the pledge hears an EB, it synchronizes to the joining schedule using the cells contained in the EB.
The pledge can hear multiple EBs; the selection of which EB to use 
is out of the scope for this document and is discussed in <xref target="RFC7554" format="default"/>.
Implementers should make use of information such as the following:
    which network identifier the EB contains,
    the value of the Join Metric field within EBs,
    whether the source link-layer address of the EB has been tried before,
    at which signal strength the different EBs were received, etc.
In addition, the pledge may be preconfigured to search for EBs with a specific network identifier.</t>
        <t>If the pledge is not provisioned with the network identifier, 
it attempts to join one network at a time, as described in <xref target="join_request" format="default"/>.</t>
        <t>Once the pledge selects the EB, it synchronizes to it and transitions into a low-power mode.
It follows the schedule information contained in the EB, 
which indicates the slots that the pledge may use for the join process.
During the remainder of the join process, the node that has sent the EB to the pledge acts as the JP.</t>
        <t>At this point, the pledge may either proceed to step 2 or 
continue to listen for additional EBs.</t>

</section>
      <section anchor="step-nd" numbered="true" toc="default">
        <name>Step 2 - Neighbor Discovery</name>
        <t>The pledge forms its link-local IPv6 address based on 
the interface identifier per <xref target="RFC4944" format="default"/>.
The pledge <bcp14>MAY</bcp14> perform the Neighbor Solicitation / Neighbor Advertisement 
exchange with the JP per <xref target="RFC8505" section="5.6" sectionFormat="of" format="default"/>.
Per <xref target="RFC8505" format="default"/>, there is no need to perform duplicate address detection for the link-local address.
The pledge and the JP use their link-local IPv6 addresses for all subsequent communication during the join process.</t>
        <t>Note that Neighbor Discovery exchanges at this point are not protected with link-layer security as the pledge is not in possession of the keys.
How the JP accepts these unprotected frames is discussed in <xref target="llreq" format="default"/>.</t>

</section>
      <section anchor="step-cojp" numbered="true" toc="default">
        <name>Step 3 - Constrained Join Protocol (CoJP) Execution</name>
        <t>The pledge triggers the join exchange of the Constrained Join Protocol (CoJP).
The join exchange consists of two messages: the Join Request message 
(<xref target="step-join-request">Step 3a</xref>) 
and the Join Response message, conditioned on the successful security 
processing of the request (<xref target="step-join-response">Step 3b</xref>).</t>
        <t>All CoJP messages are exchanged over a secure end-to-end 
channel that provides confidentiality, data authenticity, and replay protection.
Frames carrying CoJP messages are not protected with link-layer security when exchanged between the pledge and the JP as the pledge is not in possession of the link-layer keys in use.
How the JP and pledge accept these unprotected frames is discussed in <xref target="llreq" format="default"/>.
When frames carrying CoJP messages are exchanged between nodes that have already joined the network, the link-layer security is applied according to the security configuration used in the network.</t>

<section anchor="step-join-request" numbered="true" toc="default">
          <name>Step 3a - Join Request</name>
          <t>The Join Request is a message sent from the pledge to the JP, 
and which the JP forwards to the JRC.
The pledge indicates in the Join Request the role it requests to play in the network, as well as the identifier of the network it requests to join.
The JP forwards the Join Request to the JRC on the existing links.
How exactly this happens is out of scope of this document; some networks 
may wish to dedicate specific link-layer resources for this join traffic.</t>

</section>
        <section anchor="step-join-response" numbered="true" toc="default">
          <name>Step 3b - Join Response</name>
          <t>The Join Response is sent by the JRC to the pledge, and it is forwarded through the JP.
The packet containing the Join Response travels from the JRC to the JP using the operating routes in the network.
The JP delivers it to the pledge.
The JP operates as an application-layer proxy, see <xref target="join_proxy" format="default"/>.</t>
          <t>The Join Response contains various parameters needed by 
the pledge to become a fully operational network node.
These parameters include the link-layer key(s) currently in use in the network, the short address assigned to the pledge, the IPv6 address of the JRC needed by the pledge to operate as the JP, among others.</t>

</section>
      </section>
      <section anchor="the-special-case-of-the-6lbr-pledge-joining" numbered="true" toc="default">
        <name>The Special Case of the 6LBR Pledge Joining</name>
        <t>The 6LBR pledge performs <xref target="step-cojp" format="default"/> 
of the join process just like any other pledge, albeit over a different network interface.
There is no JP intermediating the communication between the 6LBR pledge and the JRC, as described in <xref target="netreq" format="default"/>.
The other steps of the described join process do not apply to the 6LBR pledge.
How the 6LBR pledge obtains an IPv6 address and triggers the execution 
of CoJP is out of scope of this document.</t>

</section>
    </section>
    <section anchor="llreq" numbered="true" toc="default">
      <name>Link-Layer Configuration</name>
      <t>In an operational 6TiSCH network, all frames use link-layer frame security <xref target="RFC8180" format="default"/>.
The IEEE Std 802.15.4 security attributes include frame authenticity 
and optionally frame confidentiality (i.e., encryption).</t>
      <t>Any node sending EB frames <bcp14>MUST</bcp14> be prepared to act as a JP for potential pledges.</t>
      <t>The pledge does not initially perform an authenticity check of the EB frames
because it does not possess the link-layer key(s) in use.
The pledge is still able to parse the contents of the received EBs and 
synchronize to the network, as EBs are not encrypted <xref target="RFC8180" format="default"/>.</t>
      <t>When sending frames during the join process, the pledge sends unencrypted and unauthenticated frames at the link layer.
In order for the join process to be possible, the JP must accept these unsecured frames for the duration of the join process.
This behavior may be implemented by setting the "secExempt" attribute in the IEEE Std 802.15.4 security configuration tables.
It is expected that the lower layer provides an interface to indicate to 
the upper layer that unsecured frames are being received from a device.
The upper layer can use that information to determine that a join process 
is in place and that the unsecured frames should be processed.
How the JP makes such a determination and interacts with the lower layer is out of scope of this specification.
The JP can additionally use information such as the value of the 
join rate parameter (<xref target="configuration_object" format="default"/>) 
set by the JRC, physical button press, etc.</t>
      <t>When the pledge initially synchronizes with the network, 
it has no means of verifying the authenticity of EB frames.
Because an attacker can craft a frame that looks like a legitimate EB frame, 
this opens up a DoS vector, as discussed in <xref target="sec_considerations" format="default"/>.</t>

<section anchor="timedistribution" numbered="true" toc="default">
        <name>Distribution of Time</name>
        <t>Nodes in a 6TiSCH network keep a global notion of time 
known as the Absolute Slot Number.
The Absolute Slot Number is used in the construction of the 
link-layer nonce, as defined in <xref target="IEEE802.15.4" format="default"/>.
The pledge initially synchronizes with the EB frame sent by the JP 
and uses the value of the Absolute Slot Number found in the 
TSCH Synchronization Information Element.
At the time of the synchronization, the EB frame can neither be authenticated nor its freshness verified.
During the join process, the pledge sends frames that are unprotected at the link-layer and protected end-to-end instead.
The pledge does not obtain the time information as the output of the join process as this information is local to the network and may not be known at the JRC.</t>
        <t>This enables an attack on the pledge where the attacker replays to the pledge legitimate EB frames obtained from the network and acts as a man-in-the-middle between the pledge and the JP.
The EB frames will make the pledge believe that the replayed Absolute Slot Number value is the current notion of time in the network.
By forwarding the join traffic to the legitimate JP, the attacker enables the pledge to join the network.
Under different conditions relating to the reuse of the pledge's short address by the JRC or its attempt to rejoin the network, this may cause the pledge to reuse the link-layer nonce in the first frame it sends protected after the join process is completed.</t>
        <t>For this reason, all frames originated at the JP and 
destined to the pledge during the join process <bcp14>MUST</bcp14> 
be authenticated at the link layer using the key that is normally in use in the network.
Link-layer security processing at the pledge for these frames will fail as the pledge is not yet in possession of the key.
The pledge acknowledges these frames without link-layer security, and JP accepts the unsecured acknowledgment due to the secExempt attribute set for the pledge.
The frames should be passed to the upper layer for processing using the promiscuous mode of <xref target="IEEE802.15.4" format="default"/> or another appropriate mechanism.
When the upper-layer processing on the pledge is completed, 
and the link-layer keys are configured, the upper layer <bcp14>MUST</bcp14> 
trigger the security processing of the corresponding frame.
Once the security processing of the frame carrying the Join Response 
message is successful, the current Absolute Slot Number kept locally 
at the pledge <bcp14>SHALL</bcp14> be declared as valid.</t>

</section>
    </section>
    <section anchor="netreq" numbered="true" toc="default">
      <name>Network-Layer Configuration</name>
      <t>The pledge and the JP <bcp14>SHOULD</bcp14> keep a separate neighbor cache for untrusted entries and use it to store each other's information during the join process.
Mixing neighbor entries belonging to pledges and nodes that are 
part of the network opens up the JP to a DoS attack, as the attacker 
may fill the JP's neighbor table and prevent the discovery of legitimate neighbors.</t>
      <t>Once the pledge obtains link-layer keys and becomes a joined node, 
it is able to securely communicate with its neighbors, 
obtain the network IPv6 prefix, and form its global IPv6 address.
The joined node then undergoes an independent process to bootstrap its neighbor cache entries, possibly with a node that formerly acted as a JP, following <xref target="RFC8505" format="default"/>.
From the point of view of the JP, there is no relationship between the neighbor cache entry belonging to a pledge and the joined node that formerly acted as a pledge.</t>
      <t>The pledge does not communicate with the JRC at the network layer.
This allows the pledge to join without knowing the IPv6 address of the JRC.
Instead, the pledge communicates with the JP at the network layer using link-local addressing, and with the JRC at the application layer, as specified in <xref target="join_proxy" format="default"/>.</t>
      <t>The JP communicates with the JRC over global IPv6 addresses.
The JP discovers the network IPv6 prefix and configures its global IPv6 address upon successful completion of the join process and the obtention of link-layer keys.
The pledge learns the IPv6 address of the JRC from the Join Response, as specified in <xref target="join_response" format="default"/>; it uses it once joined in order to operate as a JP.</t>
      <t>As a special case, the 6LBR pledge may have an additional 
network interface that it uses in order to obtain the configuration 
parameters from the JRC and to start advertising the 6TiSCH network.
This additional interface needs to be configured with a global IPv6 address, 
by a mechanism that is out of scope of this document.
The 6LBR pledge uses this interface to directly communicate with the JRC using global IPv6 addressing.</t>
      <t>The JRC can be co-located on the 6LBR.
In this special case, the IPv6 address of the JRC can be omitted from the Join Response message for space optimization.
The 6LBR then <bcp14>MUST</bcp14> set the DODAGID field in the RPL 
DODAG Information Objects (DIOs) <xref target="RFC6550" format="default"/> to its IPv6 address.
The pledge learns the address of the JRC once joined and upon the 
reception of the first RPL DIO message, and uses it to operate as a JP.</t>

<section anchor="traffic_join_request" numbered="true" toc="default">
        <name>Identification of Unauthenticated Traffic</name>
        <t>The traffic that is proxied by the JP comes from unauthenticated pledges, and there may be an arbitrary amount of it.
In particular, an attacker may send fraudulent traffic in an attempt to overwhelm the network.</t>
        <t>When operating as part of a 6TiSCH minimal network 
<xref target="RFC8180" format="default"/> using distributed scheduling algorithms, 
the traffic from unauthenticated pledges may cause intermediate nodes to request additional bandwidth.
An attacker could use this property to cause the network to overcommit bandwidth (and energy) to the join process.</t>
        <t>The JP is aware of what traffic originates from unauthenticated pledges, and so can avoid allocating additional bandwidth itself.
The JP implements a data cap on outgoing join traffic by 
implementing the recommendation of 1 packet per 3 seconds in 
<xref target="RFC8085" section="3.1.3" sectionFormat="of" format="default"/>.
This can be achieved with the congestion control mechanism 
specified in <xref target="RFC7252" section="4.7" sectionFormat="of" format="default"/>.
This cap will not protect intermediate nodes as they cannot tell join traffic from regular traffic.
Despite the data cap implemented separately on each JP, 
the aggregate join traffic from many JPs may cause intermediate nodes to decide to allocate additional cells.
It is undesirable to do so in response to the traffic originated from unauthenticated pledges.
In order to permit the intermediate nodes to avoid this, the traffic needs to be tagged.
<xref target="RFC2597" format="default"/> defines a set of 
per-hop behaviors that may be encoded into the Diffserv Code Points (DSCPs).
Based on the DSCP, intermediate nodes can decide whether to act on a given packet.</t>

<section anchor="traffic-from-jp-to-jrc" numbered="true" toc="default">
          <name>Traffic from JP to JRC</name>
          <t>The JP <bcp14>SHOULD</bcp14> set the DSCP of packets that it 
produces as part of the forwarding process to AF43 code point 
(See <xref target="RFC2597" section="6" sectionFormat="of" format="default"/>).
A JP that does not require a specific DSCP value on forwarded traffic 
should set it to zero so that it is compressed out.</t>
          <t>A Scheduling Function (SF) running on 6TiSCH nodes <bcp14>SHOULD NOT</bcp14> allocate additional cells as a result of traffic with code point AF43.
Companion SF documents <bcp14>SHOULD</bcp14> specify how this recommended behavior is achieved.</t>

</section>
        <section anchor="traffic-from-jrc-to-jp" numbered="true" toc="default">
          <name>Traffic from JRC to JP</name>
          <t>The JRC <bcp14>SHOULD</bcp14> set the DSCP of 
Join Response packets addressed to the JP to the AF42 code point.
AF42 has lower drop probability than AF43, giving this traffic priority in buffers over the traffic going towards the JRC.</t>
          <t>The 6LBR links are often the most congested within a DODAG, 
and from that point down, there is progressively less (or equal) congestion.
If the 6LBR paces itself when sending Join Response traffic, 
then it ought to never exceed the bandwidth allocated to the best effort traffic cells.
If the 6LBR has the capacity (if it is not constrained), then it 
should provide some buffers in order to satisfy the Assured Forwarding behavior.</t>
          <t>Companion SF documents <bcp14>SHOULD</bcp14> specify how traffic with code point AF42 is handled with respect to cell allocation.
If the recommended behavior described in this section is not followed, 
the network may become prone to the attack discussed in <xref target="traffic_join_request" format="default"/>.</t>

</section>
      </section>
    </section>
    <section anchor="join_proxy" numbered="true" toc="default">
      <name>Application-Layer Configuration</name>
      <t>The CoJP join exchange in <xref target="fig_overview_diagram" format="default"/> is carried over CoAP <xref target="RFC7252" format="default"/> and the secure channel provided by OSCORE <xref target="RFC8613" format="default"/>.
The (6LBR) pledge acts as a CoAP client; the JRC acts as a CoAP server.
The JP implements CoAP forward proxy functionality <xref target="RFC7252" format="default"/>.
Because the JP can also be a constrained device, it cannot implement a cache.</t>
      <t>The pledge designates a JP as a proxy by including the 
Proxy-Scheme option in the CoAP requests that it sends to the JP.
The pledge also includes in the requests the Uri-Host option with 
its value set to the well-known JRC's alias, as specified in <xref target="join_request" format="default"/>.</t>
      <t>The JP resolves the alias to the IPv6 address of the 
JRC that it learned when it acted as a pledge and joined the network.
This allows the JP to reach the JRC at the network layer and forward the requests on behalf of the pledge.</t>

<section anchor="statelessness-of-the-jp" numbered="true" toc="default">
        <name>Statelessness of the JP</name>
        <t>The CoAP proxy defined in <xref target="RFC7252" format="default"/> 
keeps per-client state information in order to forward the response towards the originator of the request.
This state information includes at least
    the CoAP token,
    the IPv6 address of the client, and
    the UDP source port number.
Since the JP can be a constrained device that acts as a CoAP proxy, 
memory limitations make it prone to a DoS attack.</t>
        <t>This DoS vector on the JP can be mitigated by making the JP act as a stateless CoAP proxy, where "state" encompasses the information related to individual pledges.
The JP can wrap the state it needs to keep for a given pledge throughout the network stack in a "state object" and include it as a CoAP token in the forwarded request to the JRC.
The JP may use the CoAP token as defined in <xref target="RFC7252" format="default"/>, 
if the size of the serialized state object permits, or use the extended 
CoAP token defined in <xref target="RFC8974" format="default"/> 
to transport the state object.
The JRC and any other potential proxy on the JP-JRC path <bcp14>MUST</bcp14> 
support extended token lengths, as defined in <xref target="RFC8974" format="default"/>.
Since the CoAP token is echoed back in the response, the JP is able to decode the state object and configure the state needed to forward the response to the pledge.
The information that the JP needs to encode in the state object to operate 
in a fully stateless manner with respect to a given pledge is implementation specific.</t>
        <t>It is <bcp14>RECOMMENDED</bcp14> that the JP operates in a 
stateless manner and signals the per-pledge state within the CoAP token 
for every request that it forwards into the network on behalf of unauthenticated pledges.
When the JP is operating in a stateless manner, the security considerations from 
<xref target="RFC8974" format="default"/> apply, and the type of the CoAP message that the JP forwards on behalf of the pledge <bcp14>MUST</bcp14> be non-confirmable (NON), regardless of the message type received from the pledge.
The use of a non-confirmable message by the JP alleviates the JP from keeping CoAP message exchange state.
The retransmission burden is then entirely shifted to the pledge.
A JP that operates in a stateless manner still needs to keep congestion control state with the JRC, see <xref target="sec_considerations" format="default"/>.
Recommended values of CoAP settings for use during the join process, both by the pledge and the JP, are given in <xref target="parameters" format="default"/>.</t>
        <t>Note that in some networking stack implementations, a fully (per-pledge) stateless operation of the JP may be challenging from the implementation's point of view.
In those cases, the JP may operate as a stateful proxy that stores 
the per-pledge state until the response is received or timed out, but this comes at a price of a DoS vector.</t>

</section>
      <section anchor="parameters" numbered="true" toc="default">
        <name>Recommended Settings</name>
        <t>This section gives <bcp14>RECOMMENDED</bcp14> values of CoAP settings during the join process.</t>
        <table align="center">
          <name>Recommended CoAP settings.</name>
          <thead>
            <tr>
              <th>Name</th>
              <th>Default Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>ACK_TIMEOUT</td>
              <td>10 seconds</td>
            </tr>
            <tr>
              <td>ACK_RANDOM_FACTOR</td>
              <td>1.5</td>
            </tr>
            <tr>
              <td>MAX_RETRANSMIT</td>
              <td>4</td>
            </tr>
            <tr>
              <td>NSTART</td>
              <td>1</td>
            </tr>
            <tr>
              <td>DEFAULT_LEISURE</td>
              <td>5 seconds</td>
            </tr>
            <tr>
              <td>PROBING_RATE</td>
              <td>1 byte/second</td>
            </tr>
          </tbody>
        </table>
        <t>These values may be configured to values specific to the deployment.
The default values have been chosen to accommodate a wide range of deployments, taking into account dense networks.</t>
        <t>The PROBING_RATE value at the JP is controlled by the join rate parameter, see <xref target="configuration_object" format="default"/>.
Following <xref target="RFC7252" format="default"/>, the average data rate in sending to the JRC must not exceed PROBING_RATE.
For security reasons, the average data rate <bcp14>SHOULD</bcp14> 
be measured over a rather short window, e.g., ACK_TIMEOUT, 
see <xref target="sec_considerations" format="default"/>.</t>

</section>
      <section anchor="oscore_sec_context" numbered="true" toc="default">
        <name>OSCORE</name>
        <t>Before the (6LBR) pledge and the JRC start exchanging CoAP messages protected with OSCORE, they need to derive the OSCORE security context from the provisioned parameters, as discussed in <xref target="provisioning" format="default"/>.</t>
        <t>The OSCORE security context <bcp14>MUST</bcp14> be derived per 
<xref target="RFC8613" section="3" sectionFormat="of" format="default"/>.</t>
        <ul spacing="normal">
          <li>The Master Secret <bcp14>MUST</bcp14> be the PSK.</li>
          <li>The Master Salt <bcp14>MUST</bcp14> be the empty byte string.</li>
          <li>The ID Context <bcp14>MUST</bcp14> be set to the pledge identifier.</li>
          <li>The ID of the pledge <bcp14>MUST</bcp14> be set to the empty byte string.
This identifier is used as the OSCORE Sender ID of the pledge in the security context derivation, since the pledge initially acts as a CoAP client.</li>
          <li>The ID of the JRC <bcp14>MUST</bcp14> be set to the byte string 0x4a5243 ("JRC" in ASCII).
This identifier is used as the OSCORE Recipient ID of the pledge in the security context derivation, as the JRC initially acts as a CoAP server.</li>
          <li>The Algorithm <bcp14>MUST</bcp14> be set to the value 
from <xref target="RFC8152" format="default"/>, agreed to out-of-band 
by the same mechanism used to provision the PSK.
The default is AES-CCM-16-64-128.</li>
          <li>The key derivation function <bcp14>MUST</bcp14> be agreed out-of-band by the same mechanism used to provision the PSK.
Default is HKDF SHA-256 <xref target="RFC5869" format="default"/>.</li>
        </ul>
        <t>Since the pledge's OSCORE Sender ID is the empty byte string, 
when constructing the OSCORE option, the pledge sets the 'kid' flag in the 
OSCORE flag bits but indicates a 0-length 'kid'.
The pledge transports its pledge identifier within the 'kid context' field of the OSCORE option.
The derivation in <xref target="RFC8613" format="default"/> results in OSCORE keys and a Common Initialization Vector (IV) for each side of the conversation.
Nonces are constructed by XORing the Common IV with the current sequence number.
For details on nonce and OSCORE option construction, refer to <xref target="RFC8613" format="default"/>.</t>
        <t>Implementations <bcp14>MUST</bcp14> ensure that multiple CoAP requests, including to different JRCs, are properly incrementing the sequence numbers, so that the same sequence number is never reused in distinct requests protected under the same PSK.
The pledge typically sends requests to different JRCs if it is not provisioned with the network identifier and attempts to join one network at a time.
Failure to comply will break the security guarantees of the Authenticated Encryption with Associated Data (AEAD) algorithm because of nonce reuse.</t>
        <t>This OSCORE security context is used for the
    initial joining of the (6LBR) pledge, where the (6LBR) pledge acts as a CoAP client,
    as well as for any later parameter updates, where the JRC acts as a CoAP client and the joined node as a CoAP server, as discussed in <xref target="update" format="default"/>.
Note that when the (6LBR) pledge and the JRC change roles between 
CoAP client and CoAP server, the same OSCORE security context as 
initially derived remains in use, and the derived parameters are unchanged, 
for example, Sender ID when sending and Recipient ID when receiving 
(see <xref target="RFC8613" section="3.1" sectionFormat="of" format="default"/>).
A (6LBR) pledge is expected to have exactly one OSCORE security context with the JRC.</t>

<section anchor="persistency" numbered="true" toc="default">
          <name>Replay Window and Persistency</name>
          <t>Both the (6LBR) pledge and the JRC <bcp14>MUST</bcp14> 
implement a replay-protection mechanism.
The use of the default OSCORE replay-protection mechanism specified in 
<xref target="RFC8613" section="3.2.2" sectionFormat="of" format="default"/> is <bcp14>RECOMMENDED</bcp14>.</t>
          <t>Implementations <bcp14>MUST</bcp14> ensure that mutable OSCORE context parameters (Sender Sequence Number, Replay Window) are stored in persistent memory.
A technique detailed in <xref target="RFC8613" section="B.1.1" sectionFormat="of" format="default"/> 
that prevents reuse of sequence numbers <bcp14>MUST</bcp14> be implemented.
Each update of the OSCORE Replay Window <bcp14>MUST</bcp14> be written to persistent memory.</t>
          <t>This is an important security requirement in order to guarantee nonce uniqueness and resistance to replay attacks across reboots and rejoins.
Traffic between the (6LBR) pledge and the JRC is rare, making security outweigh the cost of writing to persistent memory.</t>

</section>
        <section anchor="oscore_error_handling" numbered="true" toc="default">
          <name>OSCORE Error Handling</name>
          <t>Errors raised by OSCORE during the join process <bcp14>MUST</bcp14> be silently dropped, with no error response being signaled.
The pledge <bcp14>MUST</bcp14> silently discard any response not protected with OSCORE, including error codes.</t>
          <t>Such errors may happen for a number of reasons, including
    failed lookup of an appropriate security context (e.g., the pledge attempting to join a wrong network),
    failed decryption,
    positive Replay Window lookup,
    formatting errors (possibly due to malicious alterations in transit).
Silently dropping OSCORE messages prevents a DoS attack on the pledge where the attacker could send bogus error responses, forcing the pledge to attempt joining one network at a time, until all networks have been tried.</t>

</section>
        <section anchor="mti_algos" numbered="true" toc="default">
          <name>Mandatory-to-Implement Algorithms</name>
          <t>The mandatory-to-implement AEAD algorithm for use with OSCORE is AES-CCM-16-64-128 from <xref target="RFC8152" format="default"/>.
This is the algorithm used for securing IEEE Std 802.15.4 frames, and hardware acceleration for it is present in virtually all compliant radio chips.
With this choice, CoAP messages are protected with an 8-byte CCM authentication tag, and the algorithm uses 13-byte long nonces.</t>
          <t>The mandatory-to-implement hash algorithm is SHA-256 <xref target="RFC4231" format="default"/>.
The mandatory-to-implement key derivation function is HKDF <xref target="RFC5869" format="default"/>, instantiated with a SHA-256 hash.
See <xref target="lightweight" format="default"/> for implementation guidance when code footprint is important.</t>

</section>
      </section>
    </section>
    <section anchor="join_protocol" numbered="true" toc="default">
      <name>Constrained Join Protocol (CoJP)</name>
      <t>The Constrained Join Protocol (CoJP) is a lightweight protocol over CoAP <xref target="RFC7252" format="default"/> and a secure channel provided by OSCORE <xref target="RFC8613" format="default"/>.
CoJP allows a (6LBR) pledge to request admission into a network managed by the JRC.
It enables the JRC to configure the pledge with the necessary parameters.
The JRC may update the parameters at any time, by reaching out to the joined node that formerly acted as a (6LBR) pledge.
For example, network-wide rekeying can be implemented by updating the keying material on each node.</t>
      <t>CoJP relies on the security properties provided by OSCORE.
This includes end-to-end confidentiality, data authenticity, replay protection, and a secure binding of responses to requests.</t>
      <figure anchor="fig-stack">
        <name>Abstract layering of CoJP.</name>
        <artwork align="center" name="" type="" alt=""><![CDATA[
+-----------------------------------+
|  Constrained Join Protocol (CoJP) |
+-----------------------------------+
+-----------------------------------+  \
|         Requests / Responses      |  |
|-----------------------------------|  |
|               OSCORE              |  | CoAP
|-----------------------------------|  |
|           Messaging Layer         |  |
+-----------------------------------+  /
+-----------------------------------+
|                UDP                |
+-----------------------------------+
]]></artwork>
      </figure>
      <t>When a (6LBR) pledge requests admission to a given network, it undergoes the CoJP join exchange that consists of:</t>
      <ul spacing="normal">
        <li>The Join Request message, sent by the (6LBR) pledge to the JRC, potentially proxied by the JP.
The Join Request message and its mapping to CoAP is specified in <xref target="join_request" format="default"/>.</li>
        <li>The Join Response message, sent by the JRC to the (6LBR) pledge, if the JRC successfully processes the Join Request using OSCORE and it determines through a mechanism that is out of scope of this specification that the (6LBR) pledge is authorized to join the network.
The Join Response message is potentially proxied by the JP.
The Join Response message and its mapping to CoAP is specified in <xref target="join_response" format="default"/>.</li>
      </ul>
      <t>When the JRC needs to update the parameters of a joined node 
that formerly acted as a (6LBR) pledge, it executes the CoJP parameter update exchange 
that consists of the following:</t>
      <ul spacing="normal">
        <li>The Parameter Update message, sent by the JRC to the joined node that formerly acted as a (6LBR) pledge.
The Parameter Update message and its mapping to CoAP is specified in <xref target="parameter_update" format="default"/>.</li>
      </ul>
      <t>The payload of CoJP messages is encoded with CBOR <xref target="RFC8949" format="default"/>.
The CBOR data structures that may appear as the payload of different CoJP messages are specified in <xref target="cbor_objects" format="default"/>.</t>

<section anchor="join" numbered="true" toc="default">
        <name>Join Exchange</name>
        <t>This section specifies the messages exchanged when the (6LBR) pledge requests admission and configuration parameters from the JRC.</t>

<section anchor="join_request" numbered="true" toc="default">
          <name>Join Request Message</name>
          <t>The Join Request message that the (6LBR) pledge sends <bcp14>SHALL</bcp14> be mapped to a CoAP request:</t>
          <ul spacing="normal">
            <li>The request method is POST.</li>
            <li>The type is Confirmable (CON).</li>
            <li>The Proxy-Scheme option is set to "coap".</li>
            <li>The Uri-Host option is set to "6tisch.arpa".
This is an anycast type of identifier of the JRC that is resolved to its IPv6 address by the JP or the 6LBR pledge.</li>
            <li>The Uri-Path option is set to "j".</li>
            <li>The OSCORE option <bcp14>SHALL</bcp14> be set according to <xref target="RFC8613" format="default"/>.
  The OSCORE security context used is the one derived in <xref target="oscore_sec_context" format="default"/>.
  The OSCORE 'kid context' allows the JRC to retrieve the security context for a given pledge.</li>
            <li>The payload is a Join_Request CBOR object, as defined in <xref target="join_request_object" format="default"/>.</li>
          </ul>
          <t>Since the Join Request is a confirmable message, the transmission at (6LBR) pledge will be controlled by CoAP's retransmission mechanism.
The JP, when operating in a stateless manner, forwards this Join Request as a non-confirmable (NON) CoAP message, as specified in <xref target="join_proxy" format="default"/>.
If the CoAP implementation at the (6LBR) pledge declares the 
message transmission a failure, the (6LBR) pledge <bcp14>SHOULD</bcp14> 
attempt to join a 6TiSCH network advertised with a different network identifier.
See <xref target="parameters" format="default"/> for recommended values of CoAP settings to use during the join exchange.</t>
          <t>If all join attempts to advertised networks have failed, the (6LBR) pledge <bcp14>SHOULD</bcp14> signal the presence of an error condition, through some out-of-band mechanism.</t>
          <t>BCP 190 <xref target="RFC8820" format="default"/> 
provides guidelines on URI design and ownership.  It recommends that 
whenever a third party wants to mandate a URI to web authority that 
it <bcp14>SHOULD</bcp14> go under "/.well-known" (per <xref target="RFC8615" format="default"/>).
In the case of CoJP, the Uri-Host option is always set to "6tisch.arpa", 
and based upon the recommendations in <xref target="RFC8820" section="1" sectionFormat="of" format="default"/>, 
it is asserted that this document is the owner of the CoJP service.
As such, the concerns of <xref target="RFC8820" format="default"/> do not apply, 
and thus the Uri-Path is only "j".</t>

</section>
        <section anchor="join_response" numbered="true" toc="default">
          <name>Join Response Message</name>
          <t>The Join Response message that the JRC sends <bcp14>SHALL</bcp14> be mapped to a CoAP response:</t>
          <ul spacing="normal">
            <li>The Response Code is 2.04 (Changed).</li>
            <li>The payload is a Configuration CBOR object, as defined in <xref target="configuration_object" format="default"/>.</li>
          </ul>

</section>
      </section>
      <section anchor="update" numbered="true" toc="default">
        <name>Parameter Update Exchange</name>
        <t>During the network lifetime, parameters returned as part of the Join Response may need to be updated.
One typical example is the update of link-layer keying material for the network, a process known as rekeying.
This section specifies a generic mechanism when this parameter update is initiated by the JRC.</t>
        <t>At the time of the join, the (6LBR) pledge acts as a 
CoAP client and requests the network parameters through a representation 
of the "/j" resource exposed by the JRC.
In order for the update of these parameters to happen, the JRC needs to asynchronously contact the joined node.
The use of the CoAP Observe option for this purpose is not feasible due to the change in the IPv6 address when the pledge becomes the joined node and obtains a global address.</t>
        <t>Instead, once the (6LBR) pledge receives and successfully validates the Join Response and so becomes a joined node, it becomes a CoAP server.
The joined node creates a CoAP service at the Uri-Host value of "6tisch.arpa", and the joined node exposes the "/j" resource that is used by the JRC to update the parameters.
Consequently, the JRC operates as a CoAP client when updating the parameters.
The request/response exchange between the JRC and the (6LBR) pledge happens over the already-established OSCORE secure channel.</t>

<section anchor="parameter_update" numbered="true" toc="default">
          <name>Parameter Update Message</name>
          <t>The Parameter Update message that the JRC sends to the joined node <bcp14>SHALL</bcp14> be mapped to a CoAP request:</t>
          <ul spacing="normal">
            <li>The request method is POST.</li>
            <li>The type is Confirmable (CON).</li>
            <li>The Uri-Host option is set to "6tisch.arpa".</li>
            <li>The Uri-Path option is set to "j".</li>
            <li>The OSCORE option <bcp14>SHALL</bcp14> be set according to <xref target="RFC8613" format="default"/>.
  The OSCORE security context used is the one derived in <xref target="oscore_sec_context" format="default"/>.
  When a joined node receives a request with the Sender ID set to 0x4a5243 (ID of the JRC), it is able to correctly retrieve the security context with the JRC.</li>
            <li>The payload is a Configuration CBOR object, as defined in <xref target="configuration_object" format="default"/>.</li>
          </ul>
          <t>The JRC has implicit knowledge of the global IPv6 address 
of the joined node, as it knows the pledge identifier that the joined 
node used when it acted as a pledge and the IPv6 network prefix.
The JRC uses this implicitly derived IPv6 address of the joined node to directly address CoAP messages to it.</t>
          <t>If the JRC does not receive a response to a 
Parameter Update message, it attempts multiple retransmissions as 
configured by the underlying CoAP retransmission mechanism triggered for confirmable messages.
Finally, if the CoAP implementation declares the transmission a failure, 
the JRC may consider this as a hint that the joined node is no longer in the network.
How the JRC decides when to stop attempting to contact a previously 
joined node is out of scope of this specification, but the security 
considerations on the reuse of assigned resources apply, as discussed 
in <xref target="sec_considerations" format="default"/>.</t>

</section>
      </section>
      <section anchor="error-handling" numbered="true" toc="default">
        <name>Error Handling</name>

<section anchor="cojp_error_handling" numbered="true" toc="default">
          <name>CoJP CBOR Object Processing</name>
          <t>CoJP CBOR objects are transported within both CoAP requests and responses.
This section describes handling the cases in which certain CoJP CBOR object 
parameters are not supported by the implementation or their processing fails.
See <xref target="oscore_error_handling" format="default"/> for the handling of errors that may be raised by the underlying OSCORE implementation.</t>
          <t>When such a parameter is detected in a CoAP request (Join Request message, Parameter Update message), a Diagnostic Response message <bcp14>MUST</bcp14> be returned.
A Diagnostic Response message maps to a CoAP response and is specified in <xref target="error_response_message" format="default"/>.</t>
          <t>When a parameter that cannot be acted upon is encountered while processing a CoJP object in a CoAP response (Join Response message), a (6LBR) pledge <bcp14>SHOULD</bcp14> reattempt to join.
In this case, the (6LBR) pledge <bcp14>SHOULD</bcp14> include the Unsupported Configuration CBOR object within the Join Request object in the following Join Request message.
The Unsupported Configuration CBOR object is self-contained and enables the (6LBR) pledge to signal any parameters that the implementation of the networking stack may not support.
A (6LBR) pledge <bcp14>MUST NOT</bcp14> attempt more than COJP_MAX_JOIN_ATTEMPTS number of attempts to join if the processing of the Join Response message fails each time.
If the COJP_MAX_JOIN_ATTEMPTS number of attempts is reached without 
success, the (6LBR) pledge <bcp14>SHOULD</bcp14> signal the presence 
of an error condition through some out-of-band mechanism.</t>
          <t>Note that COJP_MAX_JOIN_ATTEMPTS relates to the 
application-layer handling of the CoAP response and is different from 
CoAP's MAX_RETRANSMIT setting, which drives the retransmission mechanism 
of the underlying CoAP message.</t>

</section>
        <section anchor="error_response_message" numbered="true" toc="default">
          <name>Diagnostic Response Message</name>
          <t>The Diagnostic Response message is returned for any CoJP request when the processing of the payload failed.
The Diagnostic Response message is protected by OSCORE as any other CoJP  message.</t>
          <t>The Diagnostic Response message <bcp14>SHALL</bcp14> be mapped to a CoAP response:</t>
          <ul spacing="normal">
            <li>The Response Code is 4.00 (Bad Request).</li>
            <li>The payload is an Unsupported Configuration CBOR object, 
as defined in <xref target="unsupported_configuration_object" format="default"/>, 
containing more information about the parameter that triggered the sending of this message.</li>
          </ul>

</section>
        <section anchor="failure_handling" numbered="true" toc="default">
          <name>Failure Handling</name>
          <t>The parameter update exchange may be triggered at any time 
during the network lifetime, which may span several years.
During this period, a joined node or the JRC may experience unexpected 
events such as reboots or complete failures.</t>
          <t>This document mandates that the mutable parameters in the 
security context are written to persistent memory (see 
<xref target="persistency" format="default"/>) by both the JRC and pledges 
(joined nodes).
As the pledge (joined node) is typically a constrained device that handles 
the write operations to persistent memory in a predictable manner, the 
retrieval of mutable security-context parameters is feasible across reboots 
such that there is no risk of AEAD nonce reuse due to reinitialized 
Sender Sequence Numbers or of a replay attack due to the reinitialized Replay Window.
The JRC may be hosted on a generic machine where the write operation to 
persistent memory may lead to unpredictable delays due to caching.
If a reboot event occurs at the JRC before the cached data is written 
to persistent memory, the loss of mutable security-context parameters 
is likely, which consequently poses the risk of AEAD nonce reuse.</t>
          <t>In the event of a complete device failure, where the mutable 
security-context parameters cannot be retrieved, it is expected that a 
failed joined node will be replaced with a new physical device, using 
a new pledge identifier and a PSK.
When such a failure event occurs at the JRC, it is possible that the 
static information on provisioned pledges, like PSKs and pledge identifiers, 
can be retrieved through available backups.
However, it is likely that the information about joined nodes, their 
assigned short identifiers and mutable security-context parameters, 
is lost.
  If this is the case, the network administrator <bcp14>MUST</bcp14> force  
  all the networks managed by the failed JRC to rejoin through out-of-band
  means during the process of JRC reinitialization, e.g., 
  reinitialize the 6LBR nodes and freshly generate dynamic 
  cryptographic keys and other parameters that influence the 
  security properties of the network.</t>
          <t>In order to recover from such a failure event, the reinitialized JRC can trigger the renegotiation of the OSCORE security context through the procedure described in  
<xref target="RFC8613" section="B.2" sectionFormat="of" format="default"/>.
Aware of the failure event, the reinitialized JRC responds to the first 
Join Request of each pledge it is managing with a 4.01 (Unauthorized) 
error and a random nonce.
The pledge verifies the error response and then initiates the CoJP join exchange using a new OSCORE security context derived from an ID Context consisting of the concatenation of two nonces, one that it received from the JRC and the other that the pledge generates locally.
After verifying the Join Request with the new ID Context and the 
derived OSCORE security context, the JRC should consequently map 
the new ID Context to the previously used pledge identifier.
How the JRC handles this mapping is out of scope of this document.</t>
          <t>The use of the procedure specified in 
<xref target="RFC8613" section="B.2" sectionFormat="of" format="default"/> 
is <bcp14>RECOMMENDED</bcp14> in order to handle the failure events or 
any other event that may lead to the loss of mutable security-context parameters.
The length of nonces exchanged using this procedure <bcp14>MUST</bcp14> be at least 8 bytes.</t>
          <t>The procedure requires both the pledge and the JRC 
to have good sources of randomness.
While this is typically not an issue at the JRC side, the constrained 
device hosting the pledge may pose limitations in this regard.
If the procedure outlined in 
<xref target="RFC8613" section="B.2" sectionFormat="of" format="default"/> 
is not supported by the pledge, the network administrator <bcp14>MUST</bcp14> 
reprovision the concerned devices with freshly generated parameters 
through out-of-band means.</t>

</section>
      </section>
      <section anchor="cbor_objects" numbered="true" toc="default">
        <name>CoJP Objects</name>
        <t>This section specifies the structure of CoJP CBOR objects 
that may be carried as the payload of CoJP messages.
Some of these objects may be received both as part of the 
CoJP join exchange when the device operates as a (CoJP) pledge or 
as part of the parameter update exchange when the device operates 
as a joined (6LBR) node.</t>

<section anchor="join_request_object" numbered="true" toc="default">
          <name>Join Request Object</name>
          <t>The Join_Request structure is built on a CBOR map object.</t>
          <t>The set of parameters that can appear in a Join_Request object is summarized below.
The labels can be found in the "Constrained Join Protocol (CoJP) Parameters" registry, 
<xref target="iana_cojp_registry" format="default"/>.</t>
          <dl spacing="normal">
            <dt>role:</dt> 
            <dd>The identifier of the role that the pledge requests 
to play in the network once it joins, encoded as an unsigned integer.
Possible values are specified in <xref target="table_role_values" format="default"/>.
This parameter <bcp14>MAY</bcp14> be included.
If the parameter is omitted, the default value of 0, 
i.e., the role "6TiSCH Node", <bcp14>MUST</bcp14> be assumed.</dd>
            <dt>network identifier:</dt> 
            <dd>The identifier of the network, as discussed in 
<xref target="provisioning" format="default"/>, encoded as a CBOR byte string.
When present in the Join_Request, it hints to the JRC which network 
the pledge is requesting to join, enabling the JRC to manage multiple networks.
The pledge obtains the value of the network identifier from the received EB frames.
This parameter <bcp14>MUST</bcp14> be included in a Join_Request object 
regardless of the role parameter value.</dd>
            <dt>unsupported configuration:</dt> 
            <dd>The identifier of the parameters that are not supported by 
the implementation, encoded as an Unsupported_Configuration object described in 
<xref target="unsupported_configuration_object" format="default"/>.
This parameter <bcp14>MAY</bcp14> be included.
If a (6LBR) pledge previously attempted to join and received a valid 
Join Response message over OSCORE but failed to act on its payload 
(Configuration object), it <bcp14>SHOULD</bcp14> include this parameter 
to facilitate the recovery and debugging.</dd>
          </dl>
          <t><xref target="table_join_req_params" format="default"/> 
summarizes the parameters that may appear in a Join_Request object.</t>
          <table anchor="table_join_req_params" align="center">
            <name>Summary of Join_Request parameters.</name>
            <thead>
              <tr>
                <th>Name</th>
                <th>Label</th>
                <th>CBOR Type</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>role</td>
                <td>1</td>
                <td>unsigned integer</td>
              </tr>
              <tr>
                <td>network identifier</td>
                <td>5</td>
                <td>byte string</td>
              </tr>
              <tr>
                <td>unsupported configuration</td>
                <td>8</td>
                <td>array</td>
              </tr>
            </tbody>
          </table>
          <t>The CDDL fragment that represents the text above for the Join_Request follows:</t>
          <sourcecode type=""><![CDATA[
Join_Request = {
    ? 1 : uint,                       ; role
      5 : bstr,                       ; network identifier
    ? 8 : Unsupported_Configuration   ; unsupported configuration
}
]]></sourcecode>
          <table anchor="table_role_values" align="center">
            <name>Role values.</name>
            <thead>
              <tr>
                <th>Name</th>
                <th>Value</th>
                <th>Description</th>
                <th>Reference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>6TiSCH Node</td>
                <td>0</td>
                <td>The pledge requests to play the role of a regular 6TiSCH node, i.e., non-6LBR node.</td>
                <td>RFC 9031</td>
              </tr>
              <tr>
                <td>6LBR</td>
                <td>1</td>
                <td>The pledge requests to play the role of 6LoWPAN Border Router (6LBR).</td>
                <td>RFC 9031</td>
              </tr>
            </tbody>
          </table>

</section>
        <section anchor="configuration_object" numbered="true" toc="default">
          <name>Configuration Object</name>
          <t>The Configuration structure is built on a CBOR map object.
The set of parameters that can appear in a Configuration object is summarized below.
The labels can be found in "Constrained Join Protocol (CoJP) Parameters" registry, <xref target="iana_cojp_registry" format="default"/>.</t>
          <dl spacing="normal">
            <dt>link-layer key set:</dt> 
            <dd>An array encompassing a set of cryptographic keys 
and their identifiers that are currently in use in the network 
or that are scheduled to be used in the future.
The encoding of individual keys is described in <xref target="ll_keys" format="default"/>.
The link-layer key set parameter <bcp14>MAY</bcp14> be included in a Configuration object.
When present, the link-layer key set parameter <bcp14>MUST</bcp14> contain at least one key.
This parameter is also used to implement rekeying in the network.
The installation and use of keys differs for the 6LBR and 
other (regular) nodes, and this is explained in Sections <xref target="keychanging6lbr" format="counter"/> 
and <xref target="keychanging6lr" format="counter"/>.</dd>
            <dt>short identifier: </dt>
            <dd>A compact identifier assigned to the pledge.
The short identifier structure is described in <xref target="short_identifier" format="default"/>.
The short identifier parameter <bcp14>MAY</bcp14> be included in a Configuration object.</dd>
            <dt>JRC address:</dt> 
            <dd>The IPv6 address of the JRC, encoded as a byte string, with the length of 16 bytes.
If the length of the byte string is different from 16, the parameter <bcp14>MUST</bcp14> be discarded.
If the JRC is not co-located with the 6LBR and has a different IPv6 address than the 6LBR, 
this parameter <bcp14>MUST</bcp14> be included.
In the special case where the JRC is co-located with the 6LBR and 
has the same IPv6 address as the 6LBR, this parameter <bcp14>MAY</bcp14> be included.
If the JRC address parameter is not present in the Configuration object, 
this indicates that the JRC has the same IPv6 address as the 6LBR.
The joined node can then discover the IPv6 address of the JRC through network control traffic.
See <xref target="netreq" format="default"/>.</dd>
            <dt>blacklist:</dt>
            <dd>An array encompassing a list of pledge identifiers 
that are blacklisted by the JRC, with each pledge identifier encoded as a byte string.
The blacklist parameter <bcp14>MAY</bcp14> be included in a Configuration object.
When present, the array <bcp14>MUST</bcp14> contain zero or more byte strings encoding pledge identifiers.
The joined node <bcp14>MUST</bcp14> silently drop any link-layer frames 
originating from the pledge identifiers enclosed in the blacklist parameter.
When this parameter is received, its value <bcp14>MUST</bcp14> overwrite any previously set values.
This parameter allows the JRC to configure the node acting as a JP to filter out 
traffic from misconfigured or malicious pledges before their traffic is forwarded into the network.
If the JRC decides to remove a given pledge identifier from a blacklist, 
it omits the pledge identifier in the blacklist parameter value it sends next.
Since the blacklist parameter carries the pledge identifiers, privacy considerations apply.
See <xref target="privacy_considerations" format="default"/>.</dd>
            <dt>join rate:</dt> 
            <dd>The average data rate (in units of bytes/second) of join traffic 
forwarded into the network that should not be exceeded when a joined node operates 
as a JP, encoded as an unsigned integer.
The join rate parameter <bcp14>MAY</bcp14> be included in a Configuration object.
This parameter allows the JRC to configure different nodes in the network to 
operate as JP and to act in case of an attack by throttling the rate at which JP 
forwards unauthenticated traffic into the network.
When this parameter is present in a Configuration object, the value <bcp14>MUST</bcp14> 
be used to set the PROBING_RATE of CoAP at the joined node for communication with the JRC.
If this parameter is set to zero, a joined node <bcp14>MUST</bcp14> silently drop 
any join traffic coming from unauthenticated pledges.
If this parameter is omitted, the value of positive infinity <bcp14>SHOULD</bcp14> be assumed.
A node operating as a JP <bcp14>MAY</bcp14> use another mechanism that is out of scope 
of this specification to configure the PROBING_RATE of CoAP in the absence of a 
join rate parameter from the Configuration object.</dd>
          </dl>
          <t><xref target="table_configuration_params" format="default"/> 
summarizes the parameters that may appear in a Configuration object.</t>
          <table anchor="table_configuration_params" align="center">
            <name>Summary of Configuration parameters.</name>
            <thead>
              <tr>
                <th>Name</th>
                <th>Label</th>
                <th>CBOR Type</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>link-layer key set</td>
                <td>2</td>
                <td>array</td>
              </tr>
              <tr>
                <td>short identifier</td>
                <td>3</td>
                <td>array</td>
              </tr>
              <tr>
                <td>JRC address</td>
                <td>4</td>
                <td>byte string</td>
              </tr>
              <tr>
                <td>blacklist</td>
                <td>6</td>
                <td>array</td>
              </tr>
              <tr>
                <td>join rate</td>
                <td>7</td>
                <td>unsigned integer</td>
              </tr>
            </tbody>
          </table>
          <t>The CDDL fragment that represents the text above for the Configuration follows.
The structures Link_Layer_Key and Short_Identifier are specified in 
Sections <xref target="ll_keys" format="counter"/> and <xref target="short_identifier" format="counter"/>,
respectively.</t>
          <sourcecode type=""><![CDATA[
Configuration = {
    ? 2 : [ +Link_Layer_Key ],   ; link-layer key set
    ? 3 : Short_Identifier,      ; short identifier
    ? 4 : bstr,                  ; JRC address
    ? 6 : [ *bstr ],             ; blacklist
    ? 7 : uint                   ; join rate
}
]]></sourcecode>

          <table anchor="table_cojp_parameters_labels" align="center">
            <name>CoJP parameters map labels.</name>
            <thead>
              <tr>
                <th>Name</th>
                <th>Label</th>
                <th>CBOR type</th>
                <th>Description</th>
                <th>Reference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>role</td>
                <td>1</td>
                <td>unsigned integer</td>
                <td>Identifies the role parameter</td>
                <td>RFC 9031</td>
              </tr>
              <tr>
                <td>link-layer key set</td>
                <td>2</td>
                <td>array</td>
                <td>Identifies the array carrying one or more link-layer cryptographic keys</td>
                <td>RFC 9031</td>
              </tr>
              <tr>
                <td>short identifier</td>
                <td>3</td>
                <td>array</td>
                <td>Identifies the assigned short identifier</td>
                <td>RFC 9031</td>
              </tr>
              <tr>
                <td>JRC address</td>
                <td>4</td>
                <td>byte string</td>
                <td>Identifies the IPv6 address of the JRC</td>
                <td>RFC 9031</td>
              </tr>
              <tr>
                <td>network identifier</td>
                <td>5</td>
                <td>byte string</td>
                <td>Identifies the network identifier parameter</td>
                <td>RFC 9031</td>
              </tr>
              <tr>
                <td>blacklist</td>
                <td>6</td>
                <td>array</td>
                <td>Identifies the blacklist parameter</td>
                <td>RFC 9031</td>
              </tr>
              <tr>
                <td>join rate</td>
                <td>7</td>
                <td>unsigned integer</td>
                <td>Identifier the join rate parameter</td>
                <td>RFC 9031</td>
              </tr>
              <tr>
                <td>unsupported configuration</td>
                <td>8</td>
                <td>array</td>
                <td>Identifies the unsupported configuration parameter</td>
                <td>RFC 9031</td>
              </tr>
            </tbody>
          </table>

</section>
        <section anchor="ll_keys" numbered="true" toc="default">
          <name>Link-Layer Key</name>
          <t>The Link_Layer_Key structure encompasses the parameters needed to configure the link-layer security module:
    the key identifier;
    the value of the cryptographic key;
    the link-layer algorithm identifier and the security level and the frame types 
         with which it should be used for both outgoing and incoming security operations;
    and any additional information that may be needed to configure the key.</t>
          <t>For encoding compactness, the Link_Layer_Key object is not enclosed in a top-level CBOR object.
Rather, it is transported as a sequence of CBOR elements <xref target="RFC8742" format="default"/>, some being optional.</t>
          <t>The set of parameters that can appear in a Link_Layer_Key object is summarized below, in order:</t>
          <dl spacing="normal">
            <dt>key_id:</dt> 
            <dd>The identifier of the key, encoded as a CBOR unsigned integer.
This parameter <bcp14>MUST</bcp14> be included.
If the decoded CBOR unsigned integer value is larger than the maximum link-layer 
key identifier, the key is considered invalid.
If the key is considered invalid, the key <bcp14>MUST</bcp14> be discarded,
and the implementation <bcp14>MUST</bcp14> signal the error as specified in 
<xref target="cojp_error_handling" format="default"/>.</dd>
            <dt>key_usage:</dt>
            <dd>The identifier of the link-layer algorithm, security level, and 
link-layer frame types that can be used with the key, encoded as an integer.
This parameter <bcp14>MAY</bcp14> be included.
Possible values and the corresponding link-layer settings are specified in the
IANA "Constrained Join Protocol (CoJP) Key Usage" registry (<xref target="iana_cojp_key_usage_registry" format="default"/>).
If the parameter is omitted, the default value of 0 (6TiSCH-K1K2-ENC-MIC32) 
from <xref target="table_key_usage_values" format="default"/> <bcp14>MUST</bcp14> be assumed.
This default value has been chosen because it results in byte savings 
in the most constrained settings; its selection  does not imply a recommendation for its general usage.</dd>
            <dt>key_value:</dt> 
            <dd>The value of the cryptographic key, encoded as a byte string.
This parameter <bcp14>MUST</bcp14> be included.
If the length of the byte string is different than the corresponding key length 
for a given algorithm specified by the key_usage parameter, the key 
<bcp14>MUST</bcp14> be discarded, and the implementation <bcp14>MUST</bcp14> 
signal the error as specified in <xref target="cojp_error_handling" format="default"/>.</dd>
            <dt>key_addinfo:</dt> 
            <dd>Additional information needed to configure the link-layer key, 
encoded as a byte string.
This parameter <bcp14>MAY</bcp14> be included.
The processing of this parameter is dependent on the link-layer technology 
in use and a particular keying mode.</dd>
          </dl>
          <t>To be able to decode the keys that are present in the 
link-layer key set and to identify individual parameters of a single 
Link_Layer_Key object, the CBOR decoder needs to differentiate between elements based on the CBOR type.
For example, a uint that follows a byte string signals to the decoder that a new Link_Layer_Key object is being processed.</t>
          <t>The CDDL fragment for the Link_Layer_Key that 
represents the text above follows:</t>
          <sourcecode type=""><![CDATA[
Link_Layer_Key = (
      key_id             : uint,
    ? key_usage          : int,
      key_value          : bstr,
    ? key_addinfo        : bstr,
)
]]></sourcecode>

          <table anchor="table_key_usage_values" align="center">
            <name>Key Usage values.</name>
            <thead>
              <tr>
                <th>Name</th>
                <th>Value</th>
                <th>Algorithm</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>6TiSCH-K1K2-ENC-MIC32</td>
                <td>0</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-32 for EBs, ENC-MIC-32 for DATA and ACKNOWLEDGMENT.</td>
              </tr>
              <tr>
                <td>6TiSCH-K1K2-ENC-MIC64</td>
                <td>1</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-64 for EBs, ENC-MIC-64 for DATA and ACKNOWLEDGMENT.</td>
              </tr>
              <tr>
                <td>6TiSCH-K1K2-ENC-MIC128</td>
                <td>2</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-128 for EBs, ENC-MIC-128 for DATA and ACKNOWLEDGMENT.</td>
              </tr>
              <tr>
                <td>6TiSCH-K1K2-MIC32</td>
                <td>3</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-32 for EBs, DATA and ACKNOWLEDGMENT.</td>
              </tr>
              <tr>
                <td>6TiSCH-K1K2-MIC64</td>
                <td>4</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-64 for EBs, DATA and ACKNOWLEDGMENT.</td>
              </tr>
              <tr>
                <td>6TiSCH-K1K2-MIC128</td>
                <td>5</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-128 for EBs, DATA and ACKNOWLEDGMENT.</td>
              </tr>
              <tr>
                <td>6TiSCH-K1-MIC32</td>
                <td>6</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-32 for EBs.</td>
              </tr>
              <tr>
                <td>6TiSCH-K1-MIC64</td>
                <td>7</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-64 for EBs.</td>
              </tr>
              <tr>
                <td>6TiSCH-K1-MIC128</td>
                <td>8</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-128 for EBs.</td>
              </tr>
              <tr>
                <td>6TiSCH-K2-MIC32</td>
                <td>9</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-32 for DATA and ACKNOWLEDGMENT.</td>
              </tr>
              <tr>
                <td>6TiSCH-K2-MIC64</td>
                <td>10</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-64 for DATA and ACKNOWLEDGMENT.</td>
              </tr>
              <tr>
                <td>6TiSCH-K2-MIC128</td>
                <td>11</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use MIC-128 for DATA and ACKNOWLEDGMENT.</td>
              </tr>
              <tr>
                <td>6TiSCH-K2-ENC-MIC32</td>
                <td>12</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use ENC-MIC-32 for DATA and ACKNOWLEDGMENT.</td>
              </tr>
              <tr>
                <td>6TiSCH-K2-ENC-MIC64</td>
                <td>13</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use ENC-MIC-64 for DATA and ACKNOWLEDGMENT.</td>
              </tr>
              <tr>
                <td>6TiSCH-K2-ENC-MIC128</td>
                <td>14</td>
                <td>IEEE802154-AES-CCM-128</td>
                <td>Use ENC-MIC-128 for DATA and ACKNOWLEDGMENT.</td>
              </tr>
            </tbody>
          </table>

<section anchor="keychanging6lbr" numbered="true" toc="default">
            <name>Rekeying of 6LBRs</name>
            <t>When the 6LBR receives the Configuration object containing 
a link-layer key set, it <bcp14>MUST</bcp14> immediately install and start 
using the new keys for all outgoing traffic and 
remove any old keys it has installed from the previous key set 
after a delay of COJP_REKEYING_GUARD_TIME has passed. 
This mechanism is used by the JRC to force the 6LBR to start sending 
traffic with the new key.
The decision is made by the JRC when it has determined that the new key 
has been made available to all (or some overwhelming majority) of nodes.
Any node that the JRC has not yet reached at that point is either 
nonfunctional or in extended sleep such that it will not be reached.
To get the key update, such a node will need to go through the join process anew.</t>

</section>
          <section anchor="keychanging6lr" numbered="true" toc="default">
            <name>Rekeying of 6LNs</name>
            <t>When a regular 6LN receives the Configuration object 
with a link-layer key set, it <bcp14>MUST</bcp14> install the new keys.
The 6LN will use both the old and the new keys to decrypt and authenticate any incoming traffic that arrives based upon the key identifier in the packet.
It <bcp14>MUST</bcp14> continue to use the old keys for all outgoing 
traffic until it has detected that the network has switched to the new key set.</t>
            <t>The detection of the network switch is based 
upon the receipt of traffic secured with the new keys.
Upon the reception and the successful security processing of a link-layer 
frame secured with a key from the new key set, a 6LN <bcp14>MUST</bcp14> 
then switch to sending all outgoing traffic using the keys from the 
new set.
The 6LN <bcp14>MUST</bcp14> remove any keys it had installed 
from the previous key set after waiting COJP_REKEYING_GUARD_TIME since  
it started using the new key set.
</t>
            <t>Sending traffic with the new keys signals to other 
downstream nodes to switch to their new key, causing
a ripple of key updates around each 6LBR.</t>

</section>
          <section anchor="use-in-ieee-std-802154" numbered="true" toc="default">
            <name>Use in IEEE Std 802.15.4</name>
            <t>When Link_Layer_Key is used in the context of <xref target="IEEE802.15.4" format="default"/>, the following considerations apply.</t>
            <t>Signaling of different keying modes of <xref target="IEEE802.15.4" format="default"/> is done based on the parameter values present in a Link_Layer_Key object.
For instance, the value of the key_id parameter in combination with key_addinfo denotes which of the four Key ID modes of <xref target="IEEE802.15.4" format="default"/> is used and how.</t>
            <dl spacing="normal">
              <dt>Key ID Mode 0x00 (Implicit, pairwise):</dt>
<dd>The key_id parameter <bcp14>MUST</bcp14> be set to 0.
The key_addinfo parameter <bcp14>MUST</bcp14> be present.
The key_addinfo parameter <bcp14>MUST</bcp14> be set to the link-layer 
address(es) of a single peer with whom the key should be used.
Depending on the configuration of the network, key_addinfo may carry 
the peer's long link-layer address (i.e., pledge identifier), 
short link-layer address, or their concatenation with the long address being encoded first.
Which address type(s) is carried is determined from the length of the byte string.</dd>
              <dt>Key ID Mode 0x01 (Key Index):</dt>
<dd>The key_id parameter <bcp14>MUST</bcp14> be set to a value different from 0.
The key_addinfo parameter <bcp14>MUST NOT</bcp14> be present.</dd>
              <dt>Key ID Mode 0x02 (4-byte Explicit Key Source):</dt>
<dd>The key_id parameter <bcp14>MUST</bcp14> be set to a value different from 0.
The key_addinfo parameter <bcp14>MUST</bcp14> be present.
The key_addinfo parameter <bcp14>MUST</bcp14> be set to a byte string, exactly 4 bytes long.
The key_addinfo parameter carries the Key Source parameter used to configure 
<xref target="IEEE802.15.4" format="default"/>.</dd>
              <dt>Key ID Mode 0x03 (8-byte Explicit Key Source):</dt>
<dd>The key_id parameter <bcp14>MUST</bcp14> be set to a value different from 0.
The key_addinfo parameter <bcp14>MUST</bcp14> be present.
The key_addinfo parameter <bcp14>MUST</bcp14> be set to a byte string, exactly 8 bytes long.
The key_addinfo parameter carries the Key Source parameter used to configure 
<xref target="IEEE802.15.4" format="default"/>.</dd>
            </dl>
            <t>In all cases, the key_usage parameter determines how a 
particular key should be used with respect to incoming and outgoing security policies.</t>
            <t>For Key ID Modes 0x01 through 0x03, the key_id parameter 
sets the "secKeyIndex" parameter of <xref target="IEEE802.15.4" format="default"/> 
that is signaled in all outgoing frames secured with a given key.
The maximum value that key_id can have is 254.
The value of 255 is reserved in <xref target="IEEE802.15.4" format="default"/> and is therefore considered invalid.</t>
            <t>Key ID Mode 0x00 (Implicit, pairwise) enables the JRC to act as a trusted third party and assign pairwise keys between nodes in the network.
How the JRC learns about the network topology is out of scope of 
this specification, but it could be done through 6LBR-JRC signaling, for example.
Pairwise keys could also be derived through a key agreement protocol 
executed between the peers directly, where the authentication is based on 
the symmetric cryptographic material provided to both peers by the JRC.
Such a protocol is out of scope of this specification.</t>
            <t>Implementations <bcp14>MUST</bcp14> use different 
link-layer keys when using different authentication tag (MIC) lengths, 
as using the same key with different authentication tag lengths might be unsafe.
For example, this prohibits the usage of the same key for both MIC-32 and MIC-64 levels.
See Annex B.4.3 of <xref target="IEEE802.15.4" format="default"/> for more information.</t>

</section>
        </section>
        <section anchor="short_identifier" numbered="true" toc="default">
          <name>Short Identifier</name>
          <t>The Short_Identifier object represents an identifier assigned to the pledge.
It is encoded as a CBOR array object and contains, in order:</t>
          <dl spacing="normal">
            <dt>identifier:</dt> 
            <dd>The short identifier assigned to the pledge, encoded as a byte string.
This parameter <bcp14>MUST</bcp14> be included.
The identifier <bcp14>MUST</bcp14> be unique in the set of all identifiers assigned 
in a network that is managed by a JRC.
If the identifier is invalid, the decoder <bcp14>MUST</bcp14> silently 
ignore the Short_Identifier object.</dd>
            <dt>lease_time:</dt> 
            <dd>The validity of the identifier in hours after the reception 
of the CBOR object, encoded as a CBOR unsigned integer.
This parameter <bcp14>MAY</bcp14> be included.
The node <bcp14>MUST</bcp14> stop using the assigned short identifier after 
the expiry of the lease_time interval.
It is up to the JRC to renew the lease before the expiry of the previous interval.
The JRC updates the lease by executing the parameter update exchange with the node 
and including the Short_Identifier in the Configuration object, as described in 
<xref target="update" format="default"/>.
If the lease expires, then the node <bcp14>SHOULD</bcp14> initiate a new join exchange, 
as described in <xref target="join" format="default"/>.
If this parameter is omitted, then the value of positive infinity <bcp14>MUST</bcp14> 
be assumed, meaning that the identifier is valid for as long as the node participates 
in the network.</dd>
          </dl>
          <t>The CDDL fragment for the Short_Identifier that 
represents the text above follows:</t>
          <sourcecode type=""><![CDATA[
Short_Identifier = [
      identifier        : bstr,
    ? lease_time        : uint
]
]]></sourcecode>

<section anchor="use-in-ieee-std-802154-1" numbered="true" toc="default">
            <name>Use in IEEE Std 802.15.4</name>
            <t>When the Short_Identifier is used in the context of <xref target="IEEE802.15.4" format="default"/>, the following considerations apply.</t>
            <t>The identifier <bcp14>MUST</bcp14> be used to set the 
short address of the IEEE Std 802.15.4 module.
When operating in TSCH mode, the identifier <bcp14>MUST</bcp14> be unique in the set of all identifiers assigned in multiple networks that share link-layer key(s).
If the length of the byte string corresponding to the identifier 
parameter is different from 2, the identifier is considered invalid.
The values 0xfffe and 0xffff are reserved by <xref target="IEEE802.15.4" format="default"/>, 
and their use is considered invalid.</t>
            <t>The security properties offered by the 
<xref target="IEEE802.15.4" format="default"/> link-layer in TSCH mode are 
conditioned on the uniqueness requirement of the short identifier (i.e., short address).
The short address is one of the inputs in the construction of the nonce, which is used to protect link-layer frames.
If a misconfiguration occurs, and the same short address is assigned twice under the same link-layer key, the loss of security properties is imminent.
For this reason, practices where the pledge generates the short identifier locally are not safe and are likely to result in the loss of link-layer security properties.</t>
            <t>The JRC <bcp14>MUST</bcp14> ensure that at any 
given time there are never two of the same short identifiers being 
used under the same link-layer key.
If the lease_time parameter of a given Short_Identifier object is 
set to positive infinity, care needs to be taken that the corresponding 
identifier is not assigned to another node until the JRC is certain 
that it is no longer in use, potentially through out-of-band signaling.
If the lease_time parameter expires for any reason, the JRC should take 
into consideration potential ongoing transmissions by the joined node, 
which may be hanging in the queues, before assigning the same identifier 
to another node.</t>
            <t>Care needs to be taken on how the pledge (joined node) configures the expiration of the lease.
Since units of the lease_time parameter are in hours after the reception of the CBOR object, the pledge needs to convert the received time to the corresponding Absolute Slot Number in the network.
The joined node (pledge) <bcp14>MUST</bcp14> only use the 
Absolute Slot Number as the appropriate reference of time to determine whether the assigned short identifier is still valid.</t>

</section>
        </section>
        <section anchor="unsupported_configuration_object" numbered="true" toc="default">
          <name>Unsupported Configuration Object</name>
          <t>The Unsupported_Configuration object is encoded as a CBOR array, containing at least one Unsupported_Parameter object.
Each Unsupported_Parameter object is a sequence of CBOR elements without an enclosing top-level CBOR object for compactness.
The set of parameters that appear in an Unsupported_Parameter object is summarized below, in order:</t>
          <dl spacing="normal">
            <dt>code:</dt> 
            <dd>Indicates the capability of acting on the 
parameter signaled by parameter_label, encoded as an integer.
This parameter <bcp14>MUST</bcp14> be included.
Possible values of this parameter are specified in the 
IANA "Constrained Join Protocol (CoJP) Unsupported Configuration Codes" registry 
(<xref target="iana_cojp_unsupported_code_registry" format="default"/>).</dd>
            <dt>parameter_label:</dt> 
            <dd>Indicates the parameter.  This parameter 
<bcp14>MUST</bcp14> be included.  Possible values of this 
parameter are specified in the label column of the 
IANA "Constrained Join Protocol (CoJP) Parameters" registry" (<xref target="iana_cojp_registry" format="default"/>).</dd>
            <dt>parameter_addinfo:</dt> 
             <dd>Additional information about the parameter 
that cannot be acted upon.
This parameter <bcp14>MUST</bcp14> be included.
If the code is set to "Unsupported", parameter_addinfo gives 
additional information to the JRC.
If the parameter indicated by parameter_label cannot be acted upon 
regardless of its value, parameter_addinfo <bcp14>MUST</bcp14> 
be set to null, signaling to the JRC that it <bcp14>SHOULD NOT</bcp14> 
attempt to configure the parameter again.
If the pledge can act on the parameter, but cannot configure the 
setting indicated by the parameter value, the pledge can hint this 
to the JRC.
In this case, parameter_addinfo <bcp14>MUST</bcp14> be set to the 
value of the parameter that cannot be acted upon following the 
normative parameter structure specified in this document.
For example, it is possible to include the link-layer key set 
object, signaling that either a subset or the entire key set that 
 was received cannot be acted upon. 
In that case, the value of parameter_addinfo follows the 
link-layer key set structure defined in 
<xref target="configuration_object" format="default"/>.
If the code is set to "Malformed", parameter_addinfo <bcp14>MUST</bcp14> 
be set to null, signaling to the JRC that it <bcp14>SHOULD NOT</bcp14> 
attempt to configure the parameter again.</dd>
          </dl>
          <t>The CDDL fragment 
for the Unsupported_Configuration and Unsupported_Parameter objects 
that represents the text above 
follows:</t>
          <sourcecode type=""><![CDATA[
Unsupported_Configuration = [
       + parameter           : Unsupported_Parameter
]

Unsupported_Parameter = (
         code                : int,
         parameter_label     : int,
         parameter_addinfo   : nil / any
)
]]></sourcecode>

          <table anchor="table_unsupported_code_values" align="center">
            <name>Unsupported Configuration code values.</name>
            <thead>
              <tr>
                <th>Name</th>
                <th>Value</th>
                <th>Description</th>
                <th>Reference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Unsupported</td>
                <td>0</td>
                <td>The indicated setting is not supported by the networking stack implementation.</td>
                <td>RFC 9031</td>
              </tr>
              <tr>
                <td>Malformed</td>
                <td>1</td>
                <td>The indicated parameter value is malformed.</td>
                <td>RFC 9031</td>
              </tr>
            </tbody>
          </table>

</section>
      </section>
      <section anchor="recommended-settings" numbered="true" toc="default">
        <name>Recommended Settings</name>
        <t>This section gives <bcp14>RECOMMENDED</bcp14> values of CoJP settings.</t>
        <table align="center">
          <name>Recommended CoJP settings.</name>
          <thead>
            <tr>
              <th>Name</th>
              <th>Default Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>COJP_MAX_JOIN_ATTEMPTS</td>
              <td>4</td>
            </tr>
            <tr>
              <td>COJP_REKEYING_GUARD_TIME</td>
              <td>12 seconds</td>
            </tr>
          </tbody>
        </table>
        <t>The COJP_REKEYING_GUARD_TIME value <bcp14>SHOULD</bcp14> take into account possible retransmissions at the link layer due to imperfect wireless links.</t>

</section>
    </section>
    <section anchor="sec_considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>Since this document uses the pledge identifier to set 
the ID Context parameter of OSCORE, an important security requirement is 
that the pledge identifier is unique in the set of all pledge identifiers managed by a JRC.
The uniqueness of the pledge identifier ensures unique (key, nonce) pairs 
for the AEAD algorithm used by OSCORE.
It also allows the JRC to retrieve the correct security context 
upon the reception of a Join Request message.
The management of pledge identifiers is simplified if the globally 
unique EUI-64 is used, but this comes with privacy risks, as discussed 
in <xref target="privacy_considerations" format="default"/>.</t>
      <t>This document further mandates that the (6LBR) pledge and the JRC are provisioned with unique PSKs.
While the process of provisioning PSKs to all pledges can result in a substantial operational overhead, it is vital to do so for the security properties of the network.
The PSK is used to set the OSCORE Master Secret during security context derivation.
This derivation process results in OSCORE keys that are important for mutual authentication of the (6LBR) pledge and the JRC.
The resulting security context shared between the pledge (joined node) 
and the JRC is used for the purpose of joining and is long-lived in 
that it can be used throughout the lifetime of a joined node 
for parameter update exchanges.
Should an attacker come to know the PSK, then a man-in-the-middle attack is possible.</t>
      <t>Note that while OSCORE provides replay protection, it does not 
provide an indication of freshness in the presence of an attacker 
that can drop and/or reorder traffic.
Since the Join Request contains no randomness, and the 
sequence number is predictable, the JRC could in principle anticipate 
a Join Request from a particular pledge and pre-calculate the response.
In such a scenario, the JRC does not have to be alive at the time 
the request is received.
This could be relevant in the case when the JRC was temporarily compromised 
and control was subsequently regained by the legitimate owner.</t>
      <t>It is of utmost importance to avoid unsafe practices when generating and provisioning PSKs.
The use of a single PSK shared among a group of devices is a common pitfall that results in poor security.
In this case, the compromise of a single device is likely to lead to a compromise of the entire batch, with the attacker having the ability to impersonate a legitimate device and join the network, 
generate bogus data, and disturb the network operation.
Additionally, some vendors use methods such as scrambling or hashing  
device serial numbers or their EUI-64 identifiers to generate "unique" PSKs.
Without any secret information involved, the effort that the attacker needs to invest into breaking these unsafe derivation methods is quite low, resulting in the possible impersonation of any device from the batch, without even needing to compromise a single device.
The use of cryptographically secure random number generators to generate the PSK is <bcp14>RECOMMENDED</bcp14>, see <xref target="NIST800-90A" format="default"/> for different mechanisms using deterministic methods.</t>
      <t>The JP forwards the unauthenticated join traffic into the network.
A data cap on the JP prevents it from forwarding more traffic than the network can handle and enables throttling in case of an attack.
Note that this traffic can only be directed at the JRC so that the JRC needs to be prepared to handle such unsanitized inputs.
The data cap can be configured by the JRC by including a join rate parameter 
in the Join Response, and it is implemented through the CoAP's PROBING_RATE setting.
The use of a data cap at a JP forces attackers to use more than one JP if they wish to overwhelm the network.
Marking the join traffic packets with a nonzero DSCP allows the 
network to carry the traffic if it has capacity, but it encourages 
the network to drop the extra traffic rather than add bandwidth due to that traffic.</t>
      <t>The shared nature of the "minimal" cell used for the join traffic makes the network prone to a DoS attack by congesting the JP with bogus traffic.
Such an attacker is limited by its maximum transmit power.
The redundancy in the number of deployed JPs alleviates the issue 
and also gives the pledge the possibility to use the best available link for joining.
How a network node decides to become a JP is out of scope of this specification.</t>
      <t>At the beginning of the join process, the pledge has no 
means of verifying the content in the EB and has to accept it at "face value".
If the pledge tries to join an attacker's network, 
the Join Response message will either fail the security check or time out.
The pledge may implement a temporary blacklist in order to filter out 
undesired EBs and try to join using the next seemingly valid EB.
This blacklist alleviates the issue but is effectively limited by 
the node's available memory.
Note that this temporary blacklist is different from the one 
communicated as part of the CoJP Configuration object as it helps 
the pledge fight a DoS attack.
The bogus beacons prolong the join time of the pledge and so does the 
time spent in "minimal" duty cycle mode <xref target="RFC8180" format="default"/>.
The blacklist communicated as part of the CoJP Configuration object 
helps the JP fight a DoS attack by a malicious pledge.</t>
      <t>During the network lifetime, the JRC may at any time initiate a parameter update exchange with a joined node.
The Parameter Update message uses the same OSCORE security context 
as is used for the join exchange, except that the server and client 
roles are interchanged.
As a consequence, each Parameter Update message carries the well-known OSCORE Sender ID of the JRC.
A passive attacker may use the OSCORE Sender ID to identify the 
Parameter Update traffic if the link-layer protection does not provide confidentiality.
A countermeasure against such a traffic-analysis attack is to 
use encryption at the link layer.
Note that the join traffic does not undergo link-layer protection 
at the first hop, as the pledge is not yet in possession of cryptographic keys.
Similarly, EB traffic in the network is not encrypted.
This makes it easy for a passive attacker to identify these types of traffic.</t>

</section>
    <section anchor="privacy_considerations" numbered="true" toc="default">
      <name>Privacy Considerations</name>
      <t>The join solution specified in this document relies on the uniqueness of the pledge identifier in the set of all pledge identifiers managed by a JRC.
This identifier is transferred in the clear as an OSCORE 'kid context'.
The use of the globally unique EUI-64 as pledge identifier simplifies the management but comes with certain privacy risks.
The implications are thoroughly discussed in <xref target="RFC7721" format="default"/> 
and comprise correlation of activities over time, location tracking, address scanning, 
and device-specific vulnerability exploitation.
Since the join process occurs rarely compared to the network lifetime, long-term threats that arise from using EUI-64 as the pledge identifier are minimal.
However, after the join process completes, the use of EUI-64 
in the form of a Layer 2 or Layer 3 address extends the 
aforementioned privacy threats to the long term.</t>
      <t>As an optional mitigation technique, the Join Response message 
may contain a short address that is assigned by the JRC to the (6LBR) pledge.
The assigned short address <bcp14>SHOULD</bcp14> be uncorrelated with the long-term pledge identifier.
The short address is encrypted in the response.
Once the join process completes, the new node may use the short addresses for all further Layer 2 (and Layer 3) operations.
This reduces the privacy threats as the short Layer 2 address (visible even when the network is encrypted) does not disclose the manufacturer, as is the case of EUI-64.
However, an eavesdropper with access to the radio medium during the join process may be able to correlate the assigned short address with the extended address based on timing information with a non-negligible probability.
This probability decreases with an increasing number of pledges joining concurrently.</t>

</section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>

      <t>This document allocates a well-known name under 
the .arpa name space according to the rules given in <xref target="RFC3172" format="default"/> and <xref target="RFC6761" format="default"/>.
The name "6tisch.arpa" is requested.
No subdomains are expected, and addition of any such subdomains
requires the publication of an IETF Standards Track RFC.
No A, AAAA, or PTR record is requested.</t>

<section anchor="iana_cojp_registry" numbered="true" toc="default">
        <name>Constrained Join Protocol (CoJP) Parameters</name>

        <t>This section defines a subregistry within the 
"IPv6 Over the TSCH Mode of IEEE 802.15.4 (6TiSCH)" registry with the 
name "Constrained Join Protocol (CoJP) Parameters".</t>
        <t>The columns of the registry are:</t>
<dl>
        <dt>Name:</dt>
        <dd>This is a descriptive name that enables an easier reference to the item.
It is not used in the encoding. The name <bcp14>MUST</bcp14> be unique.</dd>
        <dt>Label:</dt>
        <dd>The value to be used to identify this parameter.
The label is an integer. The label <bcp14>MUST</bcp14> be unique.</dd>
        <dt>CBOR Type:</dt>
        <dd>This field contains the CBOR type for the field.</dd>
        <dt>Description:</dt>
        <dd>This field contains a brief description for the field. The description <bcp14>MUST</bcp14> be unique.</dd>
        <dt>Reference:</dt> 
        <dd>This field contains a pointer to the public specification for the field, if one exists.</dd>
</dl>

        <t>This registry is populated with the values 
in <xref target="table_cojp_parameters_labels" format="default"/>.</t>

        <t>The amending formula for this subregistry is: 
Different ranges of values use different registration policies <xref target="RFC8126" format="default"/>.
Integer values from -256 to 255 are designated as Standards Action.
Integer values from -65536 to -257 and from 256 to 65535 are designated as Specification Required.
Integer values greater than 65535 are designated as Expert Review.
Integer values less than -65536 are marked as Private Use.</t>
      </section>
      <section anchor="iana_cojp_key_usage_registry" numbered="true" toc="default">
        <name>Constrained Join Protocol (CoJP) Key Usage</name>
        <t>This section defines a subregistry within the 
"IPv6 Over the TSCH Mode of IEEE 802.15.4 (6TiSCH)" registry with the 
name "Constrained Join Protocol (CoJP) Key Usage".</t>
        <t>The columns of this registry are:</t>
<dl>
        <dt>Name:</dt>
        <dd>This is a descriptive name that enables easier reference to the item.
It is not used in the encoding. The name <bcp14>MUST</bcp14> be unique.</dd>
        <dt>Value:</dt>
        <dd>This is the value used to identify the key usage setting.
These values <bcp14>MUST</bcp14> be unique.  The value is an integer.</dd>
        <dt>Algorithm:</dt>
        <dd>This is a descriptive name of the link-layer algorithm in use and uniquely determines the key length.
The name is not used in the encoding. The algorithm <bcp14>MUST</bcp14> be unique.</dd>
        <dt>Description:</dt>
        <dd>This field contains a description of the key usage setting.
The field should describe in enough detail how the key is to be used with different frame types, specific for the link-layer technology in question. The description <bcp14>MUST</bcp14> be unique.</dd>
        <dt>Reference:</dt>
        <dd>This contains a pointer to the public specification for the field, if one exists.</dd>
</dl>
        <t>This registry is populated with the values in <xref target="table_key_usage_values" format="default"/>.</t>
        <t>The amending formula for this subregistry is: 
Different ranges of values use different registration policies <xref target="RFC8126" format="default"/>.
Integer values from -256 to 255 are designated as Standards Action.
Integer values from -65536 to -257 and from 256 to 65535 are designated as Specification Required.
Integer values greater than 65535 are designated as Expert Review.
Integer values less than -65536 are marked as Private Use.</t>
      </section>
      <section anchor="iana_cojp_unsupported_code_registry" numbered="true" toc="default">
        <name>Constrained Join Protocol (CoJP) Unsupported Configuration Codes</name>

        <t>This section defines a subregistry within the 
"IPv6 Over the TSCH Mode of IEEE 802.15.4 (6TiSCH)" registry with the 
name "Constrained Join Protocol (CoJP) Unsupported Configuration Codes".</t>
        <t>The columns of this registry are:</t>
<dl>
        <dt>Name:</dt>
        <dd>This is a descriptive name that enables easier reference to the item.
It is not used in the encoding.
The name <bcp14>MUST</bcp14> be unique.</dd>
        <dt>Value:</dt>
        <dd>This is the value used to identify the diagnostic code.
These values <bcp14>MUST</bcp14> be unique.
The value is an integer.</dd>
        <dt>Description:</dt>
        <dd>This is a descriptive human-readable name.
The description <bcp14>MUST</bcp14> be unique.
It is not used in the encoding.</dd>
        <dt>Reference:</dt>
        <dd>This contains a pointer to the public specification for the field, if one exists.</dd>
</dl>
        <t>This registry is to be populated with the values in <xref target="table_unsupported_code_values" format="default"/>.</t>

        <t>The amending formula for this subregistry is: 
Different ranges of values use different registration policies <xref target="RFC8126" format="default"/>.
Integer values from -256 to 255 are designated as Standards Action.
Integer values from -65536 to -257 and from 256 to 65535 are designated as Specification Required.
Integer values greater than 65535 are designated as Expert Review.
Integer values less than -65536 are marked as Private Use.
</t>

     </section>
    </section>
  </middle>

  <back>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7554.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8180.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8613.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7252.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8949.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8152.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2597.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3172.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>

     <reference anchor="IEEE802.15.4" target="https://ieeexplore.ieee.org/document/7460875">
        <front>
            <title>IEEE Standard for Low-Rate Wireless Networks</title>
            <author>
              <organization>IEEE</organization>
            </author>
            <date month="April" year="2016"/>
        </front>
        <seriesInfo name="IEEE Standard" value="802.15.4-2015"/>
        <seriesInfo name="DOI" value="10.1109/IEEESTD.2016.7460875"/>
     </reference>


        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8974.xml"/>

        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8505.xml"/>

<reference anchor="RFC9030" target="https://www.rfc-editor.org/info/rfc9030">
<front>
<title>An Architecture for IPv6 over the Time-Slotted Channel Hopping Mode of IEEE 802.15.4 (6TiSCH)</title>

<author initials="P" surname="Thubert" fullname="Pascal Thubert" role="editor">
    <organization/>
</author>

<date month="May" year="2021"/>

</front>
<seriesInfo name="RFC" value="9030"/>
<seriesInfo name="DOI" value="10.17487/RFC9030"/>
</reference>

        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8820.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8085.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5869.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6761.xml"/>
      </references>
      <references>

        <name>Informative References</name>

        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8610.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8742.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8480.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8615.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7721.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4944.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6550.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4231.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8415.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8990.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml"/>

        <reference anchor="NIST800-90A">
          <front>
            <title>Recommendation for Random Number Generation Using Deterministic Random Bit Generators</title>
            <author>
              <organization>National Institute of Standards and Technology</organization>
            </author>
            <date month="June" year="2015"/>
          </front>
          <seriesInfo name="DOI" value="10.6028/NIST.SP.800-90Ar1"/>
          <refcontent>Special Publication 800-90A, Revision 1</refcontent>
        </reference>
      </references>
    </references>

<section anchor="example" numbered="true" toc="default">
      <name>Example</name>
      <t><xref target="fig_example" format="default"/> illustrates a successful join protocol exchange.
The pledge instantiates the OSCORE context and derives the OSCORE keys and nonces from the PSK.
It uses the instantiated context to protect the Join Request addressed with
    a Proxy-Scheme option,
    the well-known host name of the JRC in the Uri-Host option, and
    it uses its EUI-64 as pledge identifier and OSCORE 'kid context'.
Triggered by the presence of a Proxy-Scheme option, the JP forwards the request to the JRC and sets the CoAP token to the internally needed state.
The JP learned the IPv6 address of the JRC when it acted as a pledge and joined the network.
Once the JRC receives the request, it looks up the correct context based on the 'kid context' parameter.
The OSCORE data authenticity verification ensures that the request has not been modified in transit.
In addition, replay protection is ensured through persistent handling of mutable context parameters.</t>
      <t>Once the JP receives the Join Response, it authenticates the state within the CoAP token before deciding where to forward.
The JP sets its internal state to that found in the token and 
forwards the Join Response to the correct pledge.
Note that the JP does not possess the key to decrypt the CoJP object (configuration) present in the payload.
At the pledge, the Join Response is matched to the Join Request 
and verified for replay protection using OSCORE processing rules.
In this example, the Join Response does not contain the IPv6 address 
of the JRC, hence the pledge understands that the JRC is co-located with the 6LBR.</t>
      <figure anchor="fig_example">
        <name>Example of a successful join protocol exchange. { ... } denotes authenticated encryption, &lt;Tag&gt; denotes the authentication tag.</name>
        <artwork align="center" name="" type="" alt=""><![CDATA[
  <-----E2E OSCORE------>
Client      Proxy     Server
Pledge       JP        JRC
  |          |          |
  |  Join    |          |            Code: 0.02 (POST)
  | Request  |          |           Token: -
  +--------->|          |    Proxy-Scheme: coap
  |          |          |        Uri-Host: 6tisch.arpa
  |          |          |          OSCORE: kid: -,
  |          |          |                  kid_context: EUI-64,
  |          |          |                  Partial IV: 1
  |          |          |         Payload: { Code: 0.02 (POST),
  |          |          |                    Uri-Path: "j",
  |          |          |                    join_request, <Tag> }
  |          |          |
  |          |  Join    |            Code: 0.02 (POST)
  |          | Request  |           Token: opaque state
  |          +--------->|          OSCORE: kid: -,
  |          |          |                  kid_context: EUI-64,
  |          |          |                  Partial IV: 1
  |          |          |         Payload: { Code: 0.02 (POST),
  |          |          |                    Uri-Path: "j",
  |          |          |                    join_request, <Tag> }
  |          |          |
  |          |          |
  |          |  Join    |            Code: 2.04 (Changed)
  |          | Response |           Token: opaque state
  |          |<---------+          OSCORE: -
  |          |          |         Payload: { Code: 2.04 (Changed),
  |          |          |                    configuration, <Tag> }
  |          |          |
  |          |          |
  |  Join    |          |            Code: 2.04 (Changed)
  | Response |          |           Token: -
  |<---------+          |          OSCORE: -
  |          |          |         Payload: { Code: 2.04 (Changed),
  |          |          |                    configuration, <Tag> }
  |          |          |
]]></artwork>
      </figure>
      <t>Where the join_request object is:</t>
      <sourcecode type=""><![CDATA[
join_request:
{
   5 : h'cafe' / PAN ID of the network pledge is attempting to join /
}
]]></sourcecode>
      <t>Since the role parameter is not present, the default role of "6TiSCH Node" is implied.</t>
      <t>The join_request object is converted to h'a10542cafe' with a size of 5 bytes.</t>
      <t>And the configuration object is the following:</t>
      <sourcecode type=""><![CDATA[
configuration:
{
   2 : [           / link-layer key set /
         1,        / key_id /
         h'e6bf4287c2d7618d6a9687445ffd33e6' / key_value /
       ],
   3 : [           / short identifier /
         h'af93'   / assigned short address /
       ]
}
]]></sourcecode>
      <t>Since the key_usage parameter is not present in the link-layer key set object, the default value of "6TiSCH-K1K2-ENC-MIC32" is implied.
Since the key_addinfo parameter is not present and key_id is 
different from 0, Key ID Mode 0x01 (Key Index) is implied.
Similarly, since the lease_time parameter is not present in the short identifier object, the default value of positive infinity is implied.</t>
      <t>The configuration object is converted to the following:</t>
      <t>h'a202820150e6bf4287c2d7618d6a9687445ffd33e6038142af93' with a size of 26 bytes.</t>

</section>
    <section anchor="lightweight" numbered="true" toc="default">
      <name>Lightweight Implementation Option</name>
      <t>In environments where optimizing the implementation footprint is important, it is possible to implement this specification without having the implementations of HKDF <xref target="RFC5869" format="default"/> and SHA <xref target="RFC4231" format="default"/> on constrained devices.
HKDF and SHA are used during the OSCORE security context derivation phase.
This derivation can also be done by the JRC or a provisioning device on behalf 
of the (6LBR) pledge during the provisioning phase.
In that case, the derived OSCORE security context parameters are 
written directly into the (6LBR) pledge, without requiring the PSK to 
be provisioned to the (6LBR) pledge.</t>
      <t>The use of HKDF to derive OSCORE security context parameters 
ensures that the resulting OSCORE keys have good security properties 
and are unique as long as the input varies for different pledges.
This specification ensures the uniqueness by mandating
    unique pledge identifiers
    and a unique PSK for each (6LBR) pledge.
From the AEAD nonce reuse viewpoint, having a unique pledge identifier is a sufficient condition.
However, as discussed in <xref target="sec_considerations" format="default"/>, the use of a single PSK shared among many devices is a common security pitfall.
The compromise of this shared PSK on a single device would lead to the compromise of the entire batch.
When using the implementation/deployment scheme outlined above, 
the PSK does not need to be written to individual pledges.
As a consequence, even if a shared PSK is used, the scheme offers a 
level of security comparable to the scenario in which each pledge 
is provisioned with a unique PSK.
In this case, there is still a latent risk of the shared PSK being 
compromised on the provisioning device, which would compromise all devices in the batch.</t>
    </section>

     <section anchor="acknowledgments" numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>The work on this document has been partially supported by the 
European Union's H2020 Programme for research, technological development and 
demonstration under grant agreements: No. 644852, project ARMOUR; 
No. 687884, project F-Interop and open-call project SPOTS; 
No. 732638, project Fed4FIRE+ and open-call project SODA.</t>
      <t>The following individuals provided input to this document (in alphabetic order):
<contact fullname="Christian Amsüss"/>,
<contact fullname="Tengfei Chang"/>,
<contact fullname="Roman Danyliw"/>,
<contact fullname="Linda Dunbar"/>,
<contact fullname="Vijay Gurbani"/>,
<contact fullname="Klaus Hartke"/>,
<contact fullname="Barry Leiba"/>,
<contact fullname="Benjamin Kaduk"/>,
<contact fullname="Tero Kivinen"/>,
<contact fullname="Mirja Kühlewind"/>,
<contact fullname="John Mattsson"/>,
<contact fullname="Hilarie Orman"/>,
<contact fullname="Alvaro Retana"/>,
<contact fullname="Adam Roach"/>,
<contact fullname="Jim Schaad"/>,
<contact fullname="Göran Selander"/>,
<contact fullname="Yasuyuki Tanaka"/>,
<contact fullname="Pascal Thubert"/>,
<contact fullname="William Vignat"/>,
<contact fullname="Xavier Vilajosana"/>,
<contact fullname="Éric Vyncke"/>, and
<contact fullname="Thomas Watteyne"/>.</t>
    </section>
 </back>

</rfc>
