<?xml version='1.0' encoding='utf-8'?>

<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<rfc
xmlns:xi="http://www.w3.org/2001/XInclude"
submissionType="IETF"
category="std"
consensus="true"
docName="draft-ietf-ntp-using-nts-for-ntp-28"
number="8915"
ipr="trust200902"
obsoletes=""
updates=""
xml:lang="en"
tocInclude="true"
tocDepth="3"
symRefs="true"
sortRefs="true"
version="3">

  <!-- xml2rfc v2v3 conversion 2.43.0 -->
  <front>
    <title abbrev="Network Time Security for NTP">Network Time Security for the Network Time
    Protocol</title>
    <seriesInfo name="RFC" value="8915"/>
    <author fullname="Daniel Fox Franke" initials="D." surname="Franke">
      <organization abbrev="Akamai">Akamai Technologies</organization>
      <address>
        <postal>
          <street>145 Broadway</street>
          <city>Cambridge</city>
          <region>MA</region>
          <code>02142</code>
          <country>United States of America</country>
        </postal>
        <email>dafranke@akamai.com</email>
      </address>
    </author>
    <author fullname="Dieter Sibold" initials="D." surname="Sibold">
      <organization abbrev="PTB">Physikalisch-Technische
      Bundesanstalt</organization>
      <address>
        <postal>
          <street>Bundesallee 100</street>
          <city>Braunschweig</city>
          <code>D-38116</code>
          <country>Germany</country>
        </postal>
        <phone>+49-(0)531-592-8462</phone>
        <email>dieter.sibold@ptb.de</email>
      </address>
    </author>
    <author fullname="Kristof Teichel" initials="K." surname="Teichel">
      <organization abbrev="PTB">Physikalisch-Technische
      Bundesanstalt</organization>
      <address>
        <postal>
          <street>Bundesallee 100</street>
          <city>Braunschweig</city>
          <code>D-38116</code>
          <country>Germany</country>
        </postal>
        <phone>+49-(0)531-592-4471</phone>
        <email>kristof.teichel@ptb.de</email>
        <uri/>
      </address>
    </author>
    <author fullname="Marcus Dansarie" initials="M." surname="Dansarie">
      <address>
        <postal>
          <country>Sweden</country>
        </postal>
        <email>marcus@dansarie.se</email>
        <uri>https://orcid.org/0000-0001-9246-0263</uri>
      </address>
    </author>
    <author fullname="Ragnar Sundblad" initials="R." surname="Sundblad">
      <organization>Netnod</organization>
      <address>
        <postal>
          <country>Sweden</country>
        </postal>
        <email>ragge@netnod.se</email>
      </address>
    </author>
    <date month="September" year="2020"/>
    <area>Internet Area</area>
    <workgroup>NTP Working Group</workgroup>
    <keyword>Integrity</keyword>
    <keyword>Authentication</keyword>
    <keyword>NTP</keyword>
    <keyword>Security</keyword>
    <abstract>
      <t>
        This memo specifies Network Time Security (NTS), a mechanism
        for using Transport Layer Security (TLS) and Authenticated
        Encryption with Associated Data (AEAD) to provide
        cryptographic security for the client-server mode of the
        Network Time Protocol (NTP).
      </t>
      <t>
        NTS is structured as a suite of two loosely coupled sub-protocols.
        The first (NTS Key Establishment (NTS-KE)) handles initial authentication and key
        establishment over TLS. The second (NTS Extension Fields for NTPv4) handles encryption and
        authentication during NTP time synchronization via extension fields in the
        NTP packets, and holds all required state only on the
        client via opaque cookies.
      </t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>
	This memo specifies Network Time Security (NTS), a
	cryptographic security mechanism for network time
	synchronization. A complete specification is provided for
	application of NTS to the client-server mode of the
        <xref target="RFC5905" format="default">Network Time Protocol (NTP)</xref>.
      </t>
      <section numbered="true" toc="default">
        <name>Objectives</name>
        <t>
	  The objectives of NTS are as follows:

        </t>
        <ul spacing="normal">
          <li>
        Identity: Through the use of a X.509 public key infrastructure,
        implementations can cryptographically establish the identity of
        the parties they are communicating with.
	    </li>
          <li>
	      Authentication: Implementations can cryptographically
	      verify that any time synchronization packets are
	      authentic, i.e., that they were produced by an
	      identified party and have not been modified in transit.
	    </li>
          <li>
	      Confidentiality: Although basic time synchronization
	      data is considered nonconfidential and sent in the
	      clear, NTS includes support for encrypting NTP extension
	      fields.
	    </li>
          <li>
	      Replay prevention: Client implementations can detect when
	      a received time synchronization packet is a replay of
	      a previous packet.
	    </li>
          <li>
	      Request-response consistency: Client implementations can
	      verify that a time synchronization packet received from
	      a server was sent in response to a particular request from
	      the client.
	    </li>
          <li>
	      Unlinkability: For mobile clients, NTS will not leak any
	      information additional to NTP which would permit a
	      passive adversary to determine that two packets sent
	      over different networks came from the same client.
	    </li>
          <li>
              Non-amplification: Implementations (especially server
              implementations) can avoid acting as distributed
              denial-of-service (DDoS) amplifiers by never responding to a
              request with a packet larger than the request packet.
	    </li>
          <li>
	      Scalability: Server implementations can serve large
	      numbers of clients without having to retain any
	      client-specific state.
	    </li>
          <li>
	      Performance: NTS must not significantly degrade the
	      quality of the time transfer. The encryption and
	      authentication used when actually transferring time
	      should be lightweight (see Section
              <xref target="RFC7384" section="5.7" sectionFormat="bare" format="default"/>
              of <xref target="RFC7384" format="default">RFC 7384</xref>).
	    </li>
        </ul>
      </section>
    <section numbered="true" toc="default">
      <name>Terms and Abbreviations</name>
      <dl newline="false" spacing="normal" indent="11">
        <dt>AEAD   </dt>
        <dd>
          <xref target="RFC5116" format="default">Authenticated Encryption
            with Associated Data</xref></dd>
        <dt>ALPN   </dt>
        <dd>
          <xref target="RFC7301" format="default">Application-Layer Protocol
            Negotiation</xref></dd>
        <dt>C2S    </dt>
        <dd>Client-to-server</dd>
        <dt>DoS    </dt>
        <dd>Denial-of-Service</dd>
        <dt>DDoS   </dt>
        <dd>Distributed Denial-of-Service</dd>
        <dt>EF     </dt>
        <dd>
          <xref target="RFC5905" format="default">Extension Field</xref></dd>
        <dt>HKDF   </dt>
        <dd>
          <xref target="RFC5869" format="default">Hashed Message
            Authentication Code-based Key Derivation Function</xref></dd>
        <dt>KoD    </dt>
        <dd>
          <xref target="RFC5905" format="default">Kiss-o'-Death</xref></dd>
        <dt>NTP    </dt>
        <dd>
          <xref target="RFC5905" format="default">Network Time Protocol
          </xref></dd>
        <dt>NTS    </dt>
        <dd>Network Time Security</dd>
        <dt>NTS NAK</dt>
        <dd>NTS negative-acknowledgment</dd>
        <dt>NTS-KE </dt>
        <dd>Network Time Security Key Establishment</dd>
        <dt>S2C    </dt>
        <dd>Server-to-client</dd>
        <dt>TLS    </dt>
        <dd>
          <xref target="RFC8446" format="default">Transport Layer
            Security</xref></dd>
      </dl>
    </section>


      <section anchor="sec-protocol-overview" numbered="true" toc="default">
        <name>Protocol Overview</name>
        <t>
          The Network Time Protocol includes many different operating modes to
          support various network topologies (see Section
          <xref target="RFC5905" section="3" sectionFormat="bare" format="default"/> of
          <xref target="RFC5905" format="default">RFC 5905</xref>). In addition to its best-known and
          most-widely-used client-server mode, it also includes modes for
          synchronization between symmetric peers, a control mode for server
          monitoring and administration, and a broadcast mode. These various
          modes have differing and partly contradictory requirements for
          security and performance. Symmetric and control modes demand mutual
          authentication and mutual replay protection. Additionally, for certain
          message types, the control mode may require confidentiality as well as
          authentication. Client-server mode places more stringent requirements
          on resource utilization than other modes because servers may have a
          vast number of clients and be unable to afford to maintain per-client
          state. However, client-server mode also has more relaxed security
          needs because only the client requires replay protection: it is
          harmless for stateless servers to process replayed packets. The
          security demands of symmetric and control modes, on the other hand,
          are in conflict with the resource-utilization demands of client-server
          mode: any scheme that provides replay protection inherently involves
          maintaining some state to keep track of which messages have already
          been seen.
        </t>
        <t>
          This memo specifies NTS exclusively for the client-server mode of NTP.
          To this end, NTS is structured as a suite of two protocols:

        </t>
        <ul empty="true" spacing="normal">
          <li>
              The "NTS Extension Fields for NTPv4" define a collection of NTP
              extension fields for cryptographically securing NTPv4 using
              previously established key material. They are suitable for
              securing client-server mode because the server can implement them
              without retaining per-client state. All state is kept by the
              client and provided to the server in the form of an encrypted
              cookie supplied with each request. On the other hand, the NTS
              Extension Fields are suitable <em>only</em> for client-server mode
              because only the client, and not the server, is protected from
              replay.
            </li>
          <li>
              The "NTS Key Establishment" protocol (NTS-KE) is a
              mechanism for establishing key material for use with the NTS
              Extension Fields for NTPv4. It uses TLS to establish keys, to provide
              the client with an initial supply of cookies, and to negotiate some
              additional protocol options. After this, the TLS channel
              is closed with no per-client state remaining on the server side.
            </li>
        </ul>
        <t>
          The typical protocol flow is as follows: The client connects to an
          NTS-KE server on the NTS TCP port and the two parties perform a TLS
          handshake. Via the TLS channel, the parties negotiate some additional
          protocol parameters, and the server sends the client a supply of
          cookies along with an address and port of an NTP server
          for which the cookies are valid. The parties use
          <xref target="RFC5705" format="default">TLS key export</xref> to extract key material,
          which will be used in the next phase of the protocol. This negotiation
          takes only a single round trip, after which the server closes the
          connection and discards all associated state. At this point, the NTS-KE
          phase of the protocol is complete. Ideally, the client never needs to
          connect to the NTS-KE server again.
        </t>
        <t>
          Time synchronization proceeds with the indicated NTP server.
          The client sends the server an NTP client
          packet that includes several extension fields. Included among these
          fields are a cookie (previously provided by the key establishment server)
          and an authentication tag, computed using key material extracted from
          the NTS-KE handshake.  The NTP server uses the cookie to recover this
          key material and send back an authenticated response. The response
          includes a fresh, encrypted cookie that the client then sends back in
          the clear in a subsequent request. This constant refreshing of cookies
          is necessary in order to achieve NTS's unlinkability goal.
        </t>
        <t>
          <xref target="protocol-overview" format="default"/> provides an overview of the
          high-level interaction between the client, the NTS-KE server, and the
          NTP server. Note that the cookies' data format and the exchange of
          secrets between NTS-KE and NTP servers are not part of this
          specification and are implementation dependent. However, a suggested
          format for NTS cookies is provided in
          <xref target="suggested-format-for-nts-cookies" format="default"/>.
        </t>
        <figure anchor="protocol-overview">
          <name>Overview of High-Level Interactions in NTS</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
                                                     +--------------+
                                                     |              |
                                                 +-> | NTP Server 1 |
                                                 |   |              |
                           Shared cookie         |   +--------------+
+---------------+      encryption parameters     |   +--------------+
|               |    (Implementation dependent)  |   |              |
| NTS-KE Server | <------------------------------+-> | NTP Server 2 |
|               |                                |   |              |
+---------------+                                |   +--------------+
       ^                                         |          .
       |                                         |          .
       | 1. Negotiate parameters,                |          .
       |    receive initial cookie               |   +--------------+
       |    supply, generate AEAD keys,          |   |              |
       |    and receive NTP server IP            +-> | NTP Server N |
       |    addresses using "NTS Key                 |              |
       |    Establishment" protocol.                 +--------------+
       |                                                    ^
       |                                                    |
       |             +----------+                           |
       |             |          |                           |
       +-----------> |  Client  | <-------------------------+
                     |          |  2. Perform authenticated
                     +----------+     time synchronization
                                      and generate new
                                      cookies using "NTS
                                      Extension Fields for
                                      NTPv4".
]]></artwork>
        </figure>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Requirements Language</name>
      <t>
        The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
        "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
        "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>",
        "<bcp14>NOT RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and
        "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as described in
        BCP&nbsp;14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when,
        and only when, they appear in all capitals, as shown here.
      </t>
    </section>
    <section anchor="tls-profile" numbered="true" toc="default">
      <name>TLS Profile for Network Time Security</name>
      <t>
        Network Time Security makes use of TLS for NTS key establishment.
      </t>
      <t>
        Since the NTS protocol is new as of this publication, no
        backward-compatibility concerns exist to justify using
        obsolete, insecure, or otherwise broken TLS features or
        versions. Implementations <bcp14>MUST</bcp14> conform with
        <xref target="RFC7525" format="default">RFC 7525</xref> or
        with a later revision of BCP 195.
      </t>
      <t>
        Implementations <bcp14>MUST NOT</bcp14> negotiate TLS versions earlier than 1.3
        <xref target="RFC8446" format="default"/> and <bcp14>MAY</bcp14> refuse to negotiate any TLS version
        that has been superseded by a later supported version.
      </t>
      <t>
        Use of the <xref target="RFC7301" format="default">Application-Layer Protocol
        Negotiation Extension</xref> is integral to NTS, and support for
        it is <bcp14>REQUIRED</bcp14> for interoperability.
      </t>
      <t>
        Implementations <bcp14>MUST</bcp14> follow the rules in <xref target="RFC5280" format="default">
        RFC 5280</xref> and <xref target="RFC6125" format="default">RFC 6125</xref> for the
        representation and verification of the application's service identity.
        When NTS-KE service discovery (out of scope for this document)
        produces one or more host names, use of the
        <xref target="RFC6125" format="default">DNS-ID identifier type</xref> is <bcp14>RECOMMENDED</bcp14>;
        specifications for service discovery mechanisms can provide additional
        guidance for certificate validation based on the results of
        discovery. <xref target="sec-cert-verification" format="default"/> of this memo
        discusses particular considerations for certificate verification in
        the context of NTS.
      </t>
    </section>
    <section anchor="nts-ke" numbered="true" toc="default">
      <name>The NTS Key Establishment Protocol</name>

      <t>
        The NTS key establishment protocol is conducted via TCP port 4460.
        The two endpoints carry out a TLS handshake in conformance with
        <xref target="tls-profile" format="default"/>, with the client offering (via an
        <xref target="RFC7301" format="default">ALPN extension</xref>), and the server accepting,
        an application-layer protocol of "ntske/1". Immediately
        following a successful handshake, the client <bcp14>SHALL</bcp14> send a single request
        as Application Data encapsulated in the TLS-protected channel. Then, the
        server <bcp14>SHALL</bcp14> send a single response. After sending their respective
        request and response, the client and server <bcp14>SHALL</bcp14> send TLS
        "close_notify" alerts in accordance with Section
        <xref target="RFC8446" section="6.1" sectionFormat="bare" format="default"/> of
        <xref target="RFC8446" format="default">RFC 8446</xref>.
      </t>
      <t>
        The client's request and the server's response each <bcp14>SHALL</bcp14> consist of a
        sequence of records formatted according to
        <xref target="ntske-record" format="default"/>. The request and a non-error response each
        <bcp14>SHALL</bcp14> include exactly one NTS Next Protocol Negotiation record. The
        sequence <bcp14>SHALL</bcp14> be terminated by a "End of Message" record. The
        requirement that all NTS-KE messages be terminated by an End of Message
        record makes them self-delimiting.
      </t>
      <t>
        Clients and servers <bcp14>MAY</bcp14> enforce length limits on requests and responses;
        however, servers <bcp14>MUST</bcp14> accept requests of at least 1024 octets, and
        clients <bcp14>SHOULD</bcp14> accept responses of at least 65536 octets.
      </t>
      <figure anchor="ntske-record">
        <name>NTS-KE Record Format</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|C|         Record Type         |          Body Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
.                                                               .
.                           Record Body                         .
.                                                               .
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
      </figure>
      <t>
        The fields of an NTS-KE record are defined as follows:
      </t>
      <dl newline="false" spacing="normal">
        <dt>C (Critical Bit):</dt> <dd>Determines the disposition of unrecognized Record
            Types. Implementations which receive a record with an unrecognized
            Record Type <bcp14>MUST</bcp14> ignore the record if the Critical Bit is 0 and <bcp14>MUST</bcp14>
            treat it as an error if the Critical Bit is 1 (see <xref target="nts-error" format="default"/>).
          </dd>
        <dt>Record Type Number:</dt> <dd>A 15-bit integer in network byte order. The
            semantics of Record Types 0-7 are specified in this memo.
            Additional type numbers <bcp14>SHALL</bcp14> be tracked through the IANA "Network
            Time Security Key Establishment Record Types" registry.
          </dd>
        <dt>Body Length:</dt> <dd>The length of the Record Body field, in octets, as a
            16-bit integer in network byte order. Record bodies <bcp14>MAY</bcp14> have any
            representable length and need not be aligned to a word boundary.
          </dd>
        <dt>Record Body:</dt> <dd>The syntax and semantics of this field <bcp14>SHALL</bcp14> be
           determined by the Record Type.
          </dd>
      </dl>
      <t>
        For clarity regarding bit-endianness: the Critical Bit is the
        most significant bit of the first octet. In the C programming language,
        given a network buffer
        'unsigned char b[]' containing an NTS-KE record, the critical bit is
        'b[0] &gt;&gt; 7' while the record type is
        '((b[0] &amp; 0x7f) &lt;&lt; 8) + b[1]'.
      </t>
      <t>
        Note that, although the Type-Length-Body format of an NTS-KE record is
        similar to that of an NTP extension field, the semantics of the length
        field differ. While the length subfield of an NTP extension field gives
        the length of the entire extension field including the type and length
        subfields, the length field of an NTS-KE record gives just the length
        of the body.
      </t>
      <t>
        <xref target="fig_NTSKeyEstablishment" format="default"/> provides a schematic overview of the
        key establishment. It displays the protocol steps to be performed by the NTS
        client and server and Record Types to be exchanged.
      </t>
      <figure anchor="fig_NTSKeyEstablishment">
        <name>NTS Key Establishment Messages</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
                +---------------------------------------+
                | - Verify client request message.      |
                | - Extract TLS key material.           |
                | - Generate KE response message.       |
                |   - Include Record Types:             |
                |       o NTS Next Protocol Negotiation |
                |       o AEAD Algorithm Negotiation    |
                |       o <NTPv4 Server Negotiation>    |
                |       o <NTPv4 Port Negotiation>      |
                |       o New Cookie for NTPv4          |
                |       o <New Cookie for NTPv4>        |
                |       o End of Message                |
                +-----------------+---------------------+
                                  |
                                  |
Server -----------+---------------+-----+----------------------->
                  ^                      \
                 /                        \
                /    TLS application       \
               /     data                   \
              /                              \
             /                                V
Client -----+---------------------------------+----------------->
            |                                 |
            |                                 |
            |                                 |
+-----------+----------------------+   +------+-----------------+
|- Generate KE request message.    |   |- Verify server response|
| - Include Record Types:          |   |  message.              |
|  o NTS Next Protocol Negotiation |   |- Extract cookie(s).    |
|  o AEAD Algorithm Negotiation    |   +------------------------+
|  o <NTPv4 Server Negotiation>    |
|  o <NTPv4 Port Negotiation>      |
|  o End of Message                |
+----------------------------------+
]]></artwork>
      </figure>
      <section numbered="true" toc="default">
        <name>NTS-KE Record Types</name>
        <t>The following NTS-KE Record Types are defined:</t>
        <section anchor="end-of-message" numbered="true" toc="default">
          <name>End of Message</name>
          <t>
            The End of Message record has a Record Type number of 0 and a
            zero-length body. It <bcp14>MUST</bcp14> occur exactly once as the final record of
            every NTS-KE request and response. The Critical Bit <bcp14>MUST</bcp14> be set.
          </t>
        </section>
        <section anchor="nts-next-protocol-negotiation" numbered="true" toc="default">
          <name>NTS Next Protocol Negotiation</name>
          <t>
            The NTS Next Protocol Negotiation record has a Record Type number
            of 1. It <bcp14>MUST</bcp14> occur exactly once in every NTS-KE request and
            response. Its body consists of a sequence of 16-bit unsigned
            integers in network byte order. Each integer represents a Protocol
            ID from the IANA "Network Time Security Next Protocols" registry
            (<xref target="iana-nts-next-protocols" format="default"/>). The
            Critical Bit <bcp14>MUST</bcp14> be set.
          </t>
          <t>

            The Protocol IDs listed in the client's NTS Next Protocol
            Negotiation record denote those protocols that the client wishes to
            speak using the key material established through this NTS-KE
            session. Protocol IDs listed in the NTS-KE server's response <bcp14>MUST</bcp14>
            comprise a subset of those listed in the request and
            denote those protocols that the NTP server is willing and
            able to speak using the key material established through
            this NTS-KE session. The client <bcp14>MAY</bcp14>
            proceed with one or more of them. The request <bcp14>MUST</bcp14> list at least one
            protocol, but the response <bcp14>MAY</bcp14> be empty.
          </t>
        </section>
        <section anchor="nts-error" numbered="true" toc="default">
          <name>Error</name>
          <t>
            The Error record has a Record Type number of 2. Its body is exactly
            two octets long, consisting of an unsigned 16-bit integer in network
            byte order, denoting an error code. The Critical Bit <bcp14>MUST</bcp14> be set.
          </t>
          <t>
            Clients <bcp14>MUST NOT</bcp14> include Error records in their request. If clients
            receive a server response that includes an Error record, they <bcp14>MUST</bcp14>
            discard any key material negotiated during the initial TLS exchange
            and <bcp14>MUST NOT</bcp14> proceed to the Next Protocol. Requirements for retry
            intervals are described in <xref target="nts-ke-retry" format="default"/>.
          </t>
          <t>
            The following error codes are defined:
          </t>
          <ul empty="true" spacing="normal">
            <li>
                Error code 0 means "Unrecognized Critical Record". The
                server <bcp14>MUST</bcp14> respond with this error code if the request included
                a record that the server did not understand and that had its
                Critical Bit set. The client <bcp14>SHOULD NOT</bcp14> retry its request
                without modification.
              </li>
            <li>
                Error code 1 means "Bad Request". The server <bcp14>MUST</bcp14>
                respond with this error if the request is not complete
                and syntactically well-formed, or, upon the expiration
                of an implementation-defined timeout, it has not yet
                received such a request. The client <bcp14>SHOULD NOT</bcp14> retry its
                request without modification.
              </li>
            <li>
                Error code 2 means "Internal Server Error". The server
                <bcp14>MUST</bcp14> respond with this error if it is unable to respond properly
                due to an internal condition. The client <bcp14>MAY</bcp14> retry its request.
              </li>
          </ul>
        </section>
        <section anchor="nts-warning" numbered="true" toc="default">
          <name>Warning</name>
          <t>
            The Warning record has a Record Type number of 3. Its body is
            exactly two octets long, consisting of an unsigned 16-bit integer in
            network byte order, denoting a warning code. The Critical Bit <bcp14>MUST</bcp14>
            be set.
          </t>
          <t>
            Clients <bcp14>MUST NOT</bcp14> include Warning records in their request. If
            clients receive a server response that includes a Warning record,
            they <bcp14>MAY</bcp14> discard any negotiated key material and abort without
            proceeding to the Next Protocol. Unrecognized warning codes <bcp14>MUST</bcp14> be
            treated as errors.
          </t>
          <t>
            This memo defines no warning codes.
          </t>
        </section>
        <section anchor="aead-algorithm-negotiation" numbered="true" toc="default">
          <name>AEAD Algorithm Negotiation</name>
          <t>
            The AEAD Algorithm Negotiation record has a Record Type number of 4.
            Its body consists of a sequence of unsigned 16-bit integers in
            network byte order, denoting Numeric Identifiers from the IANA
            <xref target="IANA-AEAD" format="default">"AEAD Algorithms" registry</xref>. The
            Critical Bit <bcp14>MAY</bcp14> be set.
          </t>
          <t>
            If the NTS Next Protocol Negotiation record offers Protocol ID 0
            (for NTPv4), then this record <bcp14>MUST</bcp14> be included exactly once. Other
            protocols <bcp14>MAY</bcp14> require it as well.
          </t>
          <t>
            When included in a request, this record denotes which AEAD
            algorithms the client is willing to use to secure the Next Protocol,
            in decreasing preference order. When included in a response, this
            record denotes which algorithm the server chooses to use. It is
            empty if the server supports none of the algorithms offered. In
            requests, the list <bcp14>MUST</bcp14> include at least one algorithm. In
            responses, it <bcp14>MUST</bcp14> include at most one. Honoring the client's
            preference order is <bcp14>OPTIONAL</bcp14>: servers may select among any of the
            client's offered choices, even if they are able to support some
            other algorithm that the client prefers more.
          </t>
          <t>
            Server implementations of
            <xref target="nts-extension-fields-for-ntpv4" format="default">NTS Extension Fields for NTPv4</xref>
            <bcp14>MUST</bcp14> support
            <xref target="RFC5297" format="default">AEAD_AES_SIV_CMAC_256</xref>
            (Numeric Identifier 15). That is, if the client includes AEAD_AES_SIV_CMAC_256 in its
            AEAD Algorithm Negotiation record, and the server accepts Protocol
            ID 0 (NTPv4) in its NTS Next Protocol Negotiation record, then the
            server's AEAD Algorithm Negotiation record <bcp14>MUST NOT</bcp14> be empty.
          </t>
        </section>
        <section anchor="new-cookie-for-ntpv4" numbered="true" toc="default">
          <name>New Cookie for NTPv4</name>
          <t>
            The New Cookie for NTPv4 record has a Record Type number of 5. The
            contents of its body <bcp14>SHALL</bcp14> be implementation-defined,
            and clients <bcp14>MUST NOT</bcp14> attempt to interpret them.
            See <xref target="suggested-format-for-nts-cookies" format="default"/> for a suggested
            construction.
          </t>
          <t>
            Clients <bcp14>MUST NOT</bcp14> send records of this type. Servers <bcp14>MUST</bcp14> send at
            least one record of this type, and <bcp14>SHOULD</bcp14> send eight of them, if the
            Next Protocol Negotiation response record contains Protocol ID 0
            (NTPv4) and the AEAD Algorithm Negotiation response record is not
            empty. The Critical Bit <bcp14>SHOULD NOT</bcp14> be set.
          </t>
        </section>
        <section anchor="ntp-server-negotiation" numbered="true" toc="default">
          <name>NTPv4 Server Negotiation</name>
          <t>
            The NTPv4 Server Negotiation record has a Record Type number of 6.
            Its body consists of an
            <xref target="RFC0020" format="default">ASCII-encoded</xref> string. The
            contents of the string <bcp14>SHALL</bcp14> be either an IPv4 address, an IPv6
            address, or a fully qualified domain name (FQDN). IPv4 addresses
            <bcp14>MUST</bcp14> be in dotted decimal notation. IPv6 addresses <bcp14>MUST</bcp14> conform to
            the "Text Representation of Addresses" as specified in
            <xref target="RFC4291" format="default">RFC 4291</xref> and <bcp14>MUST NOT</bcp14> include zone
            identifiers <xref target="RFC6874" format="default"/>. If a label contains at least
            one non-ASCII character, it is an internationalized domain name,
            and an A-LABEL <bcp14>MUST</bcp14> be used as defined in Section
            <xref target="RFC5890" section="2.3.2.1" sectionFormat="bare" format="default"/>
            of <xref target="RFC5890" format="default">RFC 5890</xref>.
            If the record contains a domain name, the recipient <bcp14>MUST</bcp14> treat it
            as a FQDN, e.g., by making sure it ends with a dot.
          </t>
          <t>
            When NTPv4 is negotiated as a Next Protocol and this
            record is sent by the server, the body specifies the
            hostname or IP address of the NTPv4 server with which the
            client should associate and that will accept the supplied
            cookies. If no record of this type is sent, the client
            <bcp14>SHALL</bcp14> interpret this as a directive to associate with an
            NTPv4 server at the same IP address as the NTS-KE server.
            Servers <bcp14>MUST NOT</bcp14> send more than one record of this type.
          </t>
          <t>
            When this record is sent by the client, it indicates that
            the client wishes to associate with the specified NTP
            server. The NTS-KE server <bcp14>MAY</bcp14> incorporate this request when
            deciding which NTPv4 Server Negotiation records to respond
            with, but honoring the client's preference is
            <bcp14>OPTIONAL</bcp14>. The client <bcp14>MUST NOT</bcp14> send more than one record of
            this type.
          </t>
          <t>
            If the client has sent a record of this type, the NTS-KE server
            <bcp14>SHOULD</bcp14> reply with the same record if it is valid and the server is
            able to supply cookies for it. If the client has not sent any
            record of this type, the NTS-KE server <bcp14>SHOULD</bcp14> respond with either
            an NTP server address in the same family as the NTS-KE session or
            a FQDN that can be resolved to an address in that family, if such
            alternatives are available.
          </t>
          <t>
            Servers <bcp14>MAY</bcp14> set the Critical Bit on records of this type;
            clients <bcp14>SHOULD NOT</bcp14>.
          </t>
        </section>
        <section anchor="ntp-port-negotiation" numbered="true" toc="default">
          <name>NTPv4 Port Negotiation</name>
          <t>
            The NTPv4 Port Negotiation record has a Record Type number
            of 7. Its body consists of a 16-bit unsigned integer in
            network byte order, denoting a UDP port number.
          </t>
          <t>
            When NTPv4 is negotiated as a Next Protocol, and this
            record is sent by the server, the body specifies the port
            number of the NTPv4 server with which the client should
            associate and that will accept the supplied cookies. If
            no record of this type is sent, the client <bcp14>SHALL</bcp14> assume
            a default of 123 (the registered port number for NTP).
          </t>
          <t>
            When this record is sent by the client in conjunction with
            a NTPv4 Server Negotiation record, it indicates that the
            client wishes to associate with the NTP server at the
            specified port. The NTS-KE server <bcp14>MAY</bcp14> incorporate this
            request when deciding what NTPv4 Server Negotiation and
            NTPv4 Port Negotiation records to respond with, but
            honoring the client's preference is <bcp14>OPTIONAL</bcp14>.
          </t>
          <t>
            Servers <bcp14>MAY</bcp14> set the Critical Bit on records of this type;
            clients <bcp14>SHOULD NOT</bcp14>.
          </t>
        </section>
      </section>
      <section anchor="nts-ke-retry" numbered="true" toc="default">
        <name>Retry Intervals</name>
        <t>
          A mechanism for not unnecessarily overloading the NTS-KE server is
          <bcp14>REQUIRED</bcp14> when retrying the key establishment process due to protocol,
          communication, or other errors. The exact workings of this will be
          dependent on the application and operational experience gathered over
          time. Until such experience is available, this memo provides the
          following suggestion.
        </t>
        <t>
          Clients <bcp14>SHOULD</bcp14> use exponential backoff, with an initial and minimum
          retry interval of 10 seconds, a maximum retry interval of 5 days, and
          a base of 1.5. Thus, the minimum interval in seconds, 't', for the nth
          retry is calculated with the following:
        </t>
        <ul empty="true" spacing="normal">
          <li>
              t = min(10 * 1.5<sup>n-1</sup>, 432000).
            </li>
        </ul>
        <t>
          Clients <bcp14>MUST NOT</bcp14> reset the retry interval until they have performed
          a successful key establishment with the NTS-KE server, followed by a
          successful use of the negotiated Next Protocol with the keys and data
          established during that transaction.
        </t>
      </section>
      <section anchor="key-extraction" numbered="true" toc="default">
        <name>Key Extraction (Generally)</name>
        <t>
          Following a successful run of the NTS-KE protocol, key material <bcp14>SHALL</bcp14>
          be extracted using <xref target="RFC5869" format="default">the HMAC-based
          Extract-and-Expand Key Derivation Function (HKDF)</xref> in
          accordance with Section <xref target="RFC8446" section="7.5" sectionFormat="bare" format="default"/>
          of <xref target="RFC8446" format="default">RFC 8446</xref>.

          Inputs to the exporter function are to be constructed in a manner
          specific to the negotiated Next Protocol. However, all protocols that
          utilize NTS-KE <bcp14>MUST</bcp14> conform to the following two rules:
        </t>
        <ul empty="true" spacing="normal">
          <li>
              The <xref target="RFC5705" format="default">disambiguating label string</xref> <bcp14>MUST</bcp14>
              be "EXPORTER-network-time-security".
            </li>
          <li>
              The <xref target="RFC5705" format="default">per-association context value</xref>
              <bcp14>MUST</bcp14> be provided and <bcp14>MUST</bcp14> begin with the two-octet Protocol ID
              that was negotiated as a Next Protocol.
            </li>
        </ul>
      </section>
    </section>
    <section anchor="nts-extension-fields-for-ntpv4" numbered="true" toc="default">
      <name>NTS Extension Fields for NTPv4</name>
      <section numbered="true" toc="default">
        <name>Key Extraction (for NTPv4)</name>
        <t>
          Following a successful run of the NTS-KE protocol wherein Protocol
          ID 0 (NTPv4) is selected as a Next Protocol, two AEAD keys <bcp14>SHALL</bcp14> be
          extracted: a client-to-server (C2S) key and a server-to-client (S2C)
          key. These keys <bcp14>SHALL</bcp14> be computed with the HKDF defined in
          Section <xref target="RFC8446" section="7.5" sectionFormat="bare" format="default"/>
          of <xref target="RFC8446" format="default">RFC 8446</xref> using the
          following inputs:
        </t>
        <ul empty="true" spacing="normal">
          <li>
              The <xref target="RFC5705" format="default">disambiguating label string</xref>
              <bcp14>SHALL</bcp14> be "EXPORTER-network-time-security".
            </li>
          <li>
            <t>
              The <xref target="RFC5705" format="default">per-association context value</xref>
              <bcp14>SHALL</bcp14> consist of the following five octets:
            </t>
            <ul spacing="normal">
              <li>
                  The first two octets <bcp14>SHALL</bcp14> be zero (the Protocol ID for
                  NTPv4).
                </li>
              <li>
                  The next two octets <bcp14>SHALL</bcp14> be the Numeric Identifier of the
                  negotiated AEAD algorithm in network byte order.
                </li>
              <li>
                  The final octet <bcp14>SHALL</bcp14> be 0x00 for the C2S key and 0x01 for the
                  S2C key.
                </li>
            </ul>
          </li>
        </ul>
        <t>
          Implementations wishing to derive additional keys for private or
          experimental use <bcp14>MUST NOT</bcp14> do so by extending the above-specified
          syntax for per-association context values. Instead, they <bcp14>SHOULD</bcp14> use
          their own disambiguating label string. Note that <xref target="RFC5705" format="default">RFC 5705</xref> provides that disambiguating label
          strings beginning with "EXPERIMENTAL" <bcp14>MAY</bcp14> be used without
          IANA registration.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Packet Structure Overview</name>
        <t>
          In general, an NTS-protected NTPv4 packet consists of the following:
        </t>
        <ul empty="true" spacing="normal">
          <li>
              The usual 48-octet NTP header, which is authenticated but not
              encrypted.
            </li>
          <li>
              Some extension fields, which are authenticated but not encrypted.
            </li>
          <li>
              An extension field that contains AEAD output (i.e., an
              authentication tag and possible ciphertext). The corresponding
              plaintext, if non-empty, consists of some extension fields that
              benefit from both encryption and authentication.
            </li>
          <li>
              Possibly, some additional extension fields that are neither
              encrypted nor authenticated. In general, these are discarded by the
              receiver.
            </li>
        </ul>
        <t>
          Always included among the authenticated or authenticated-and-encrypted
          extension fields are a cookie extension field and a unique identifier
          extension field, as described in <xref target="protocol-details" format="default"/>. The purpose of the
          cookie extension field is to enable the server to offload storage of
          session state onto the client. The purpose of the unique identifier
          extension field is to protect the client from replay attacks.
        </t>
      </section>
      <section anchor="unique-identifier-extension-field" numbered="true" toc="default">
        <name>The Unique Identifier Extension Field</name>
        <t>
          The Unique Identifier extension field provides the client with a
          cryptographically strong means of detecting replayed packets. It has a
          Field Type of 0x0104. When the extension field is included in a
          client packet (mode 3), its body <bcp14>SHALL</bcp14> consist of a string of octets
          generated by a <xref target="RFC4086" format="default">cryptographically secure random
          number generator</xref>. The string <bcp14>MUST</bcp14> be at least 32 octets
          long. When the extension field is included in a server packet
          (mode 4), its body <bcp14>SHALL</bcp14> contain the same octet string as was provided
          in the client packet to which the server is responding. All server
          packets generated by NTS-implementing servers in response to client
          packets containing this extension field <bcp14>MUST</bcp14> also contain this field
          with the same content as in the client's request. The field's use in
          modes other than client-server is not defined.
        </t>
        <t>
          This extension field <bcp14>MAY</bcp14> also be used standalone, without NTS, in
          which case it provides the client with a means of detecting spoofed
          packets from off-path attackers. Historically, NTP's origin timestamp
          field has played both these roles, but this
          is suboptimal for cryptographic purposes because it is only 64 bits long, and depending on
          implementation details, most of those bits may be predictable. In
          contrast, the Unique Identifier extension field enables a degree of
          unpredictability and collision resistance more consistent with
          cryptographic best practice.
        </t>
      </section>
      <section anchor="nts-cookie-extension-field" numbered="true" toc="default">
        <name>The NTS Cookie Extension Field</name>
        <t>
          The NTS Cookie extension field has a Field Type of 0x0204. Its
          purpose is to carry information that enables the server to recompute
          keys and other session state without having to store any per-client
          state. The contents of its body <bcp14>SHALL</bcp14> be implementation-defined, and
          clients <bcp14>MUST NOT</bcp14> attempt to interpret them.
          See <xref target="suggested-format-for-nts-cookies" format="default"/> for a suggested
          construction.  The NTS Cookie extension field <bcp14>MUST NOT</bcp14> be included in
          NTP packets whose mode is other than 3 (client) or 4 (server).
        </t>
      </section>
      <section anchor="nts-cookie-placeholder-extension-field" numbered="true" toc="default">
        <name>The NTS Cookie Placeholder Extension Field</name>
        <t>
          The NTS Cookie Placeholder extension field has a Field Type of
          0x0304.  When this extension field is included in a client packet
          (mode 3), it communicates to the server that the client wishes it to
          send additional cookies in its response. This extension field <bcp14>MUST NOT</bcp14>
          be included in NTP packets whose mode is other than 3.
        </t>
        <t>
          Whenever an NTS Cookie Placeholder extension field is present, it <bcp14>MUST</bcp14>
          be accompanied by an NTS Cookie extension field. The body length of
          the NTS Cookie Placeholder extension field <bcp14>MUST</bcp14> be the same as the
          body length of the NTS Cookie extension field. This length requirement
          serves to ensure that the response will not be larger than the
          request, in order to improve timekeeping precision and prevent DDoS
          amplification. The contents of the NTS Cookie Placeholder extension
          field's body <bcp14>SHOULD</bcp14> be all zeros and, aside from checking its length,
          <bcp14>MUST</bcp14> be ignored by the server.
        </t>
      </section>
      <section anchor="nts-aeef-extension-field" numbered="true" toc="default">
        <name>The NTS Authenticator and Encrypted Extension Fields Extension Field</name>
        <t>
          The NTS Authenticator and Encrypted Extension Fields extension field
          is the central cryptographic element of an NTS-protected NTP packet.
          Its Field Type is 0x0404. It <bcp14>SHALL</bcp14> be formatted according to
          <xref target="fig-aeef-field" format="default"/> and include the following fields:
        </t>
        <dl newline="false" spacing="normal">
          <dt>Nonce Length:</dt> <dd>Two octets in network byte order, giving the length
              of the Nonce field, excluding any padding, interpreted as an
              unsigned integer.
            </dd>
          <dt>Ciphertext Length:</dt> <dd>Two octets in network byte order, giving the
              length of the Ciphertext field, excluding any padding, interpreted
              as an unsigned integer.
            </dd>
          <dt>Nonce:</dt> <dd>A nonce as required by the negotiated AEAD algorithm. The
              end of the field is zero-padded to a word (four octets) boundary.
            </dd>
          <dt>Ciphertext:</dt> <dd>The output of the negotiated AEAD algorithm. The
              structure of this field is determined by the negotiated algorithm,
              but it typically contains an authentication tag in addition to the
              actual ciphertext. The end of the field is zero-padded to a word
              (four octets) boundary.
            </dd>
          <dt>Additional Padding:</dt> <dd>Clients that use a nonce length shorter than
              the maximum allowed by the negotiated AEAD algorithm may be required
              to include additional zero-padding. The necessary length of this
              field is specified below.
            </dd>
        </dl>
        <figure anchor="fig-aeef-field">
          <name>NTS Authenticator and Encrypted Extension Fields Extension Field Format</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Nonce Length         |      Ciphertext Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
.                                                               .
.          Nonce, including up to 3 octets padding              .
.                                                               .
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
.                                                               .
.        Ciphertext, including up to 3 octets padding           .
.                                                               .
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
.                                                               .
.                      Additional Padding                       .
.                                                               .
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>
        <t>
          The Ciphertext field <bcp14>SHALL</bcp14> be formed by providing the following inputs
          to the negotiated AEAD algorithm:
        </t>
        <dl newline="false" spacing="normal" indent="4">
          <dt>K:</dt> <dd>For packets sent from the client to the server, the C2S key
              <bcp14>SHALL</bcp14> be used. For packets sent from the server to the client, the
              S2C key <bcp14>SHALL</bcp14> be used.
            </dd>
          <dt>A:</dt> <dd>The associated data <bcp14>SHALL</bcp14> consist of the portion of the NTP
              packet beginning from the start of the NTP header and ending at
              the end of the last extension field that precedes the NTS
              Authenticator and Encrypted Extension Fields extension field.
            </dd>
          <dt>P:</dt> <dd>The plaintext <bcp14>SHALL</bcp14> consist of all (if any) NTP extension fields to
              be encrypted; if multiple extension fields are present, they <bcp14>SHALL</bcp14> be
              joined by concatenation. Each such field <bcp14>SHALL</bcp14> be formatted in
              accordance with <xref target="RFC7822" format="default">RFC 7822</xref>, except that, contrary to the RFC
              7822 requirement that fields have a minimum length of 16 or 28 octets,
              encrypted extension fields <bcp14>MAY</bcp14> be arbitrarily short (but still <bcp14>MUST</bcp14> be
              a multiple of 4 octets in length).
            </dd>
          <dt>N:</dt> <dd>The nonce <bcp14>SHALL</bcp14> be formed however required by the negotiated
              AEAD algorithm.
            </dd>
        </dl>
        <t>
          The purpose of the Additional Padding field is to ensure
          that servers can always choose a nonce whose length is
          adequate to ensure its uniqueness, even if the client
          chooses a shorter one, and still ensure that the overall
          length of the server's response packet does not exceed the
          length of the request. For mode 4 (server) packets, no
          Additional Padding field is ever required.  For mode 3
          (client) packets, the length of the Additional Padding field
          <bcp14>SHALL</bcp14> be computed as follows.  Let 'N_LEN' be the padded
          length of the Nonce field. Let 'N_MAX' be, as specified
          by <xref target="RFC5116" format="default">RFC 5116</xref>, the maximum
          permitted nonce length for the negotiated AEAD
          algorithm. Let 'N_REQ' be the lesser of 16 and N_MAX,
          rounded up to the nearest multiple of 4.  If N_LEN is
          greater than or equal to N_REQ, then no Additional Padding
          field is required. Otherwise, the Additional Padding field
          <bcp14>SHALL</bcp14> be at least N_REQ - N_LEN octets in length. Servers
          <bcp14>MUST</bcp14> enforce this requirement by discarding any packet that
          does not conform to it.
        </t>
        <t>
          Senders are always free to include more Additional Padding
          than mandated by the above paragraph. Theoretically, it
          could be necessary to do so in order to bring the extension
          field to the minimum length required by <xref target="RFC7822" format="default">RFC 7822</xref>. This should never happen in
          practice because any reasonable AEAD algorithm will have a nonce and
          an authenticator long enough to bring the extension field to
          its required length already.  Nonetheless, implementers are
          advised to explicitly handle this case and ensure that the
          extension field they emit is of legal length.
        </t>
        <t>
          The NTS Authenticator and Encrypted Extension Fields extension field
          <bcp14>MUST NOT</bcp14> be included in NTP packets whose mode is other than 3
          (client) or 4 (server).
        </t>
      </section>
      <section anchor="protocol-details" numbered="true" toc="default">
        <name>Protocol Details</name>
        <t>
          A client sending an NTS-protected request <bcp14>SHALL</bcp14> include the following
          extension fields as displayed in  <xref target="fig_NTSTimeSyncMessage" format="default"/>:
        </t>
        <ul empty="true" spacing="normal">
          <li>
              Exactly one Unique Identifier extension field that <bcp14>MUST</bcp14> be
              authenticated, <bcp14>MUST NOT</bcp14> be encrypted, and whose contents <bcp14>MUST</bcp14> be
              the output of a <xref target="RFC4086" format="default">cryptographically secure random number generator
              </xref>.
          </li>
          <li>
              Exactly one NTS Cookie extension field that <bcp14>MUST</bcp14> be authenticated
              and <bcp14>MUST NOT</bcp14> be encrypted. The cookie <bcp14>MUST</bcp14> be one which has been
              previously provided to the client, either from the key establishment
              server during the NTS-KE handshake or from the NTP server in
              response to a previous NTS-protected NTP request.
            </li>
          <li>
              Exactly one NTS Authenticator and Encrypted Extension Fields
              extension field, generated using an AEAD algorithm and C2S key
              established through NTS-KE.
            </li>
        </ul>
        <t>
          To protect the client's privacy, the client <bcp14>SHOULD</bcp14> avoid reusing
          a cookie. If the client does not have any cookies that it has not
          already sent, it <bcp14>SHOULD</bcp14> initiate a rerun of the NTS-KE protocol. The
          client <bcp14>MAY</bcp14> reuse cookies in order to prioritize resilience over
          unlinkability. Which of the two that should be prioritized in any
          particular case is dependent on the application and the user's
          preference. <xref target="Unlinkability" format="default"/> describes the privacy
          considerations of this in further detail.
        </t>
        <t>
          The client <bcp14>MAY</bcp14> include one or more NTS Cookie Placeholder extension
          fields that <bcp14>MUST</bcp14> be authenticated and <bcp14>MAY</bcp14> be encrypted. The number of
          NTS Cookie Placeholder extension fields that the client includes
          <bcp14>SHOULD</bcp14> be such that if the client includes N placeholders and the server
          sends back N+1 cookies, the number of unused cookies stored by the
          client will come to eight. The client <bcp14>SHOULD NOT</bcp14> include more than seven
          NTS Cookie Placeholder extension fields in a request. When both the
          client and server adhere to all cookie-management guidance provided in
          this memo, the number of placeholder extension fields will equal the
          number of dropped packets since the last successful volley.
        </t>
        <t>
          In rare circumstances, it may be necessary to include fewer
          NTS Cookie Placeholder extensions than recommended above in
          order to prevent datagram fragmentation. When cookies adhere
          to the format recommended in <xref target="suggested-format-for-nts-cookies" format="default"/> and the AEAD in
          use is the mandatory-to-implement AEAD_AES_SIV_CMAC_256,
          senders can include a cookie and seven placeholders and
          still have packet size fall comfortably below 1280 octets if
          no non-NTS-related extensions are used; 1280 octets is the
          minimum prescribed MTU for IPv6 and is generally safe
          for avoiding IPv4 fragmentation. Nonetheless,
          senders <bcp14>SHOULD</bcp14> include fewer cookies and placeholders than
          otherwise indicated if doing so is necessary to prevent
          fragmentation.
        </t>
        <figure anchor="fig_NTSTimeSyncMessage">
          <name>NTS-Protected NTP Time Synchronization Messages</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
                +---------------------------------------+
                | - Verify time request message.        |
                | - Generate time response message.     |
                |   - Included NTPv4 extension fields:  |
                |      o Unique Identifier EF           |
                |      o NTS Authentication and         |
                |        Encrypted Extension Fields EF  |
                |        - NTS Cookie EF                |
                |        - <NTS Cookie EF>              |
                | - Transmit time request packet.       |
                +-----------------+---------------------+
                                  |
                                  |
Server -----------+---------------+-----+----------------------->
                  ^                      \
                 /                        \
  Time request  /                          \   Time response
  (mode 3)     /                            \  (mode 4)
              /                              \
             /                                V
Client -----+---------------------------------+----------------->
            |                                 |
            |                                 |
            |                                 |
+-----------+-----------------------+   +-----+------------------+
|- Generate time request message.   |   |- Verify time response  |
| - Include NTPv4 Extension fields: |   |  message.              |
|    o Unique Identifier EF         |   |- Extract cookie(s).    |
|    o NTS Cookie EF                |   |- Time synchronization  |
|    o <NTS Cookie Placeholder EF>  |   |  processing.           |
|                                   |   +------------------------+
|- Generate AEAD tag of NTP message.|
|- Add NTS Authentication and       |
|  Encrypted Extension Fields EF.   |
|- Transmit time request packet.    |
+-----------------------------------+
]]></artwork>
        </figure>
        <t>
          The client <bcp14>MAY</bcp14> include additional (non-NTS-related) extension fields
          that <bcp14>MAY</bcp14> appear prior to the NTS Authenticator and Encrypted Extension
          Fields extension fields (therefore authenticated but not encrypted),
          within it (therefore encrypted and authenticated), or after it
          (therefore neither encrypted nor authenticated).
          The server <bcp14>MUST</bcp14> discard any unauthenticated extension
          fields. Future specifications of extension fields <bcp14>MAY</bcp14> provide
          exceptions to this rule.
        </t>
        <t>
          Upon receiving an NTS-protected request, the server <bcp14>SHALL</bcp14> (through some
          implementation-defined mechanism) use the cookie to recover the AEAD
          algorithm, C2S key, and S2C key associated with the request, and then
          use the C2S key to authenticate the packet and decrypt the ciphertext.
          If the cookie is valid and authentication and decryption succeed, the
          server <bcp14>SHALL</bcp14> include the following extension fields in its response:
        </t>
        <ul empty="true" spacing="normal">
          <li>
              Exactly one Unique Identifier extension field that <bcp14>MUST</bcp14> be
              authenticated, <bcp14>MUST NOT</bcp14> be encrypted, and whose contents <bcp14>SHALL</bcp14> echo
              those provided by the client.
            </li>
          <li>
              Exactly one NTS Authenticator and Encrypted Extension Fields
              extension field, generated using the AEAD algorithm and S2C key
              recovered from the cookie provided by the client.
            </li>
          <li>
              One or more NTS Cookie extension fields that <bcp14>MUST</bcp14> be authenticated
              and encrypted. The number of NTS Cookie extension fields included
              <bcp14>SHOULD</bcp14> be equal to, and <bcp14>MUST NOT</bcp14> exceed, one plus the number of
              valid NTS Cookie Placeholder extension fields included in the
              request. The cookies returned in those fields <bcp14>MUST</bcp14> be valid for use
              with the NTP server that sent them. They <bcp14>MAY</bcp14> be valid for other NTP
              servers as well, but there is no way for the server to indicate
              this.
            </li>
        </ul>
        <t>
          We emphasize the contrast that NTS Cookie extension fields <bcp14>MUST NOT</bcp14> be
          encrypted when sent from client to server but <bcp14>MUST</bcp14> be encrypted when
          sent from server to client. The former is necessary in order for the
          server to be able to recover the C2S and S2C keys, while the latter is
          necessary to satisfy the unlinkability goals discussed in <xref target="Unlinkability" format="default"/>. We emphasize also that "encrypted"
          means encapsulated within the NTS Authenticator and Encrypted
          Extensions extension field. While the body of an NTS Cookie extension
          field will generally consist of some sort of AEAD output (regardless of
          whether the recommendations of <xref target="suggested-format-for-nts-cookies" format="default"/> are precisely followed),
          this is not sufficient to make the extension field
          "encrypted".
        </t>
        <t>
          The server <bcp14>MAY</bcp14> include additional (non-NTS-related) extension fields
          that <bcp14>MAY</bcp14> appear prior to the NTS Authenticator and Encrypted Extension
          Fields extension field (therefore authenticated but not encrypted),
          within it (therefore encrypted and authenticated), or after it
          (therefore neither encrypted nor authenticated).
          The client <bcp14>MUST</bcp14> discard any unauthenticated extension fields.
          Future specifications of extension fields <bcp14>MAY</bcp14> provide exceptions to
          this rule.
        </t>
        <t>
          Upon receiving an NTS-protected response, the client <bcp14>MUST</bcp14> verify that
          the Unique Identifier matches that of an outstanding request, and that
          the packet is authentic under the S2C key associated with that
          request. If either of these checks fails, the packet <bcp14>MUST</bcp14> be discarded
          without further processing. In particular, the client <bcp14>MUST</bcp14> discard
          unprotected responses to NTS-protected requests.
        </t>
        <t>
          If the server is unable to validate the cookie or authenticate the
          request, it <bcp14>SHOULD</bcp14> respond with a Kiss-o'-Death (KoD) packet (see
          Section <xref target="RFC5905" section="7.4" sectionFormat="bare" format="default"/>
          of <xref target="RFC5905" format="default">RFC 5905</xref>) with kiss code
          "NTSN", meaning "NTS NAK" (NTS negative-acknowledgment).
          It <bcp14>MUST NOT</bcp14> include any NTS Cookie or NTS Authenticator and
          Encrypted Extension Fields extension fields.
        </t>
        <t>
          If the NTP server has previously responded with authentic NTS-protected
          NTP packets, the client <bcp14>MUST</bcp14> verify that
          any KoD packets received from the server contain the Unique Identifier
          extension field and that the Unique Identifier matches that of an
          outstanding request. If this check fails, the packet <bcp14>MUST</bcp14> be discarded
          without further processing. If this check passes, the client <bcp14>MUST</bcp14> comply
          with Section <xref target="RFC5905" section="7.4" sectionFormat="bare" format="default"/>
          of <xref target="RFC5905" format="default">RFC 5905</xref> where required.
        </t>
        <t>
          A client <bcp14>MAY</bcp14> automatically rerun the NTS-KE protocol upon forced
          disassociation from an NTP server. In that case, it <bcp14>MUST</bcp14> avoid quickly
          looping between the NTS-KE and NTP servers by rate limiting the
          retries. Requirements for retry intervals in NTS-KE are described in
          <xref target="nts-ke-retry" format="default"/>.
        </t>
        <t>
          Upon reception of the NTS NAK kiss code, the client <bcp14>SHOULD</bcp14> wait until
          the next poll for a valid NTS-protected response, and if none is
          received, initiate a fresh NTS-KE handshake to try to renegotiate new
          cookies, AEAD keys, and parameters. If the NTS-KE handshake succeeds,
          the client <bcp14>MUST</bcp14> discard all old cookies and parameters and use the new
          ones instead. As long as the NTS-KE handshake has not succeeded, the
          client <bcp14>SHOULD</bcp14> continue polling the NTP server using the cookies and
          parameters it has.
        </t>
        <t>
          To allow for NTP session restart when the NTS-KE server is unavailable
          and to reduce NTS-KE server load, the client <bcp14>SHOULD</bcp14> keep at least one
          unused but recent cookie, AEAD keys, negotiated AEAD algorithm, and
          other necessary parameters in persistent storage. This way, the client
          is able to resume the NTP session without performing renewed NTS-KE
          negotiation.
        </t>
      </section>
    </section>
    <section anchor="suggested-format-for-nts-cookies" numbered="true" toc="default">
      <name>Suggested Format for NTS Cookies</name>
      <t>
        This section is non-normative. It gives a suggested way for servers to
        construct NTS cookies. All normative requirements are stated in
        <xref target="new-cookie-for-ntpv4" format="default"/> and <xref target="nts-cookie-extension-field" format="default"/>.
      </t>
      <t>
        The role of cookies in NTS is closely analogous to that of session
        tickets in TLS. Accordingly, the thematic resemblance of this section to
        <xref target="RFC5077" format="default">RFC 5077</xref> is deliberate, and the reader
        should likewise take heed of its security considerations.
      </t>
      <t>
        Servers should select an AEAD algorithm that they will use to encrypt
        and authenticate cookies. The chosen algorithm should be one such as
        <xref target="RFC5297" format="default">AEAD_AES_SIV_CMAC_256</xref>, which resists
        accidental nonce reuse. It need not be the same as the one that was
        negotiated with the client. Servers should randomly generate and store a
        secret master AEAD key 'K'. Servers should additionally choose a non-secret,
        unique value 'I' as key identifier for 'K'.
      </t>
      <t>
        Servers should periodically (e.g., once daily) generate a new pair '(I,K)'
        and immediately switch to using these values for all newly-generated
        cookies. Following each such key rotation, servers should
        securely erase any previously generated keys that should now be expired.
        Servers should continue to accept any cookie generated using keys that
        they have not yet erased, even if those keys are no longer current.
        Erasing old keys provides for forward secrecy, limiting the scope of
        what old information can be stolen if a master key is somehow
        compromised. Holding on to a limited number of old keys allows clients
        to seamlessly transition from one generation to the next without having
        to perform a new NTS-KE handshake.
      </t>
      <t>
        The need to keep keys synchronized between NTS-KE and NTP servers as
        well as across load-balanced clusters can make automatic key rotation
        challenging. However, the task can be accomplished without the need for
        central key-management infrastructure by using a ratchet, i.e., making
        each new key a deterministic, cryptographically pseudorandom function
        of its predecessor. A recommended concrete implementation of this
        approach is to use <xref target="RFC5869" format="default">HKDF</xref> to derive new
        keys, using the key's predecessor as Input Keying Material and its key
        identifier as a salt.
      </t>
      <t>
        To form a cookie, servers should first form a plaintext 'P' consisting
        of the following fields:
      </t>
      <ul empty="true" spacing="normal">
        <li>The AEAD algorithm negotiated during NTS-KE.</li>
        <li>The S2C key.</li>
        <li>The C2S key.</li>
      </ul>
      <t>
        Servers should then generate a nonce 'N' uniformly at random, and form
        AEAD output 'C' by encrypting 'P' under key 'K' with nonce 'N' and no
        associated data.
      </t>
      <t>
        The cookie should consist of the tuple '(I,N,C)'.
      </t>
      <t>
        To verify and decrypt a cookie provided by the client, first parse it
        into its components 'I', 'N', and 'C'. Use 'I' to look up its decryption
        key 'K'. If the key whose identifier is 'I' has been erased or never
        existed, decryption fails; reply with an NTS NAK. Otherwise, attempt to
        decrypt and verify ciphertext 'C' using key 'K' and nonce 'N' with no
        associated data. If decryption or verification fails, reply with an NTS
        NAK. Otherwise, parse out the contents of the resulting plaintext 'P' to
        obtain the negotiated AEAD algorithm, S2C key, and C2S key.
      </t>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <section numbered="true" toc="default">
        <name>Service Name and Transport Protocol Port Number Registry</name>
        <t>
          IANA has allocated the following entry in the
          "Service Name and Transport Protocol
          Port Number Registry" <xref target="RFC6335" format="default"/>:
        </t>

        <dl newline="false" spacing="normal">
          <dt>Service Name:</dt>       <dd>ntske</dd>
          <dt>Port Number:</dt>        <dd>4460</dd>
          <dt>Transport Protocol:</dt> <dd>tcp</dd>
          <dt>Description:</dt>        <dd>Network Time Security Key Establishment</dd>
          <dt>Assignee:</dt>           <dd>IESG &lt;iesg@ietf.org&gt;</dd>
          <dt>Contact:</dt>            <dd>IETF Chair &lt;chair@ietf.org&gt;</dd>
	  <dt>Registration Date:</dt>  <dd>2020-04-07</dd>
          <dt>Reference:</dt>          <dd>RFC 8915</dd>
        </dl>
      </section>
      <section numbered="true" toc="default">
        <name>TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs Registry</name>
        <t>
          IANA has allocated the following entry in the
          "TLS Application-Layer Protocol Negotiation
            (ALPN) Protocol IDs" registry <xref target="RFC7301" format="default"/>:
        </t>
        <dl newline="false" spacing="normal">
          <dt>Protocol:</dt> <dd>Network Time Security Key Establishment, version 1</dd>
          <dt>Identification Sequence:</dt> <dd>0x6E 0x74 0x73 0x6B 0x65 0x2F 0x31 ("ntske/1")</dd>
          <dt>Reference:</dt><dd>RFC 8915, <xref target="nts-ke" format="default"/></dd>
        </dl>
      </section>
      <section numbered="true" toc="default">
        <name>TLS Exporter Labels Registry</name>
        <t>
          IANA has allocated the following entry in the
          <xref target="RFC5705" format="default">TLS Exporter Labels registry</xref>:
        </t>

        <table align="center">
          <thead>
            <tr>
              <th align="left">Value</th>
              <th align="left">DTLS-OK</th>
              <th align="left">Recommended</th>
              <th align="left">Reference</th>
              <th align="left">Note</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">EXPORTER-network-time-security</td>
              <td align="left">Y</td>
              <td align="left">Y</td>
              <td align="left">RFC 8915, <xref target="key-extraction" format="default"/></td>
              <td align="left"/>
            </tr>
          </tbody>
        </table>
      </section>
      <section numbered="true" toc="default">
        <name>NTP Kiss-o'-Death Codes Registry</name>
        <t>
          IANA has allocated the following entry in the
          "NTP Kiss-o'-Death Codes"
	  registry <xref target="RFC5905" format="default"/>:
        </t>
        <table align="center">
          <thead>
            <tr>
              <th align="left">Code</th>
              <th align="left">Meaning</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">NTSN</td>
              <td align="left">Network Time Security (NTS) negative-acknowledgment (NAK)</td>
              <td align="left">RFC 8915, <xref target="protocol-details" format="default"/></td>
            </tr>
          </tbody>
        </table>
      </section>
      <section numbered="true" toc="default">

        <name>NTP Extension Field Types Registry</name>
        <t>
          IANA has allocated the following entries in the
          "NTP Extension Field Types" registry <xref target="RFC5905" format="default"/>:
        </t>
        <table align="center">
          <thead>
            <tr>
              <th align="left">Field Type</th>
              <th align="left">Meaning</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0x0104</td>
              <td align="left">Unique Identifier</td>
              <td align="left">RFC 8915,
            <xref target="unique-identifier-extension-field" format="default"/></td>
            </tr>
            <tr>
              <td align="left">0x0204</td>
              <td align="left">NTS Cookie</td>
              <td align="left">RFC 8915, <xref target="nts-cookie-extension-field" format="default"/></td>
            </tr>
            <tr>
              <td align="left">0x0304</td>
              <td align="left">NTS Cookie Placeholder</td>
              <td align="left">RFC 8915,
            <xref target="nts-cookie-placeholder-extension-field" format="default"/></td>
            </tr>
            <tr>
              <td align="left">0x0404</td>
              <td align="left">NTS Authenticator and Encrypted Extension Fields</td>
              <td align="left">RFC 8915, <xref target="nts-aeef-extension-field" format="default"/></td>
            </tr>
          </tbody>
        </table>
      </section>
      <section numbered="true" toc="default">
        <name>Network Time Security Key Establishment Record Types Registry</name>
        <t>
          IANA has created a new registry entitled
          "Network Time Security Key Establishment Record Types".
          Entries have the following fields:
        </t>
        <dl newline="false" spacing="normal">
          <dt>Record Type Number (<bcp14>REQUIRED</bcp14>):</dt> <dd>An integer in the range
              0-32767 inclusive.
            </dd>
          <dt>Description (<bcp14>REQUIRED</bcp14>):</dt> <dd>A short text description of the purpose of
              the field.
            </dd>
          <dt>Reference (<bcp14>REQUIRED</bcp14>):</dt> <dd>A reference to a document specifying the
              semantics of the record.
            </dd>
        </dl>
        <t>
          The registration policy varies by Record Type Number, as follows:
        </t>
        <dl newline="false" spacing="normal">
          <dt>0-1023:</dt> <dd>IETF Review</dd>
          <dt>1024-16383:</dt> <dd>Specification Required</dd>
          <dt>16384-32767:</dt> <dd>Private or Experimental Use</dd>
        </dl>
        <t>
          The initial contents of this registry are as follows:
        </t>

        <table align="center">
          <thead>
            <tr>
              <th align="left">Record Type Number</th>
              <th align="left">Description</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0</td>
              <td align="left">End of Message</td>
              <td align="left">RFC 8915, <xref target="end-of-message" format="default"/></td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">NTS Next Protocol Negotiation</td>
              <td align="left">RFC 8915,
            <xref target="nts-next-protocol-negotiation" format="default"/></td>
            </tr>
            <tr>
              <td align="left">2</td>
              <td align="left">Error</td>
              <td align="left">RFC 8915, <xref target="nts-error" format="default"/></td>
            </tr>
            <tr>
              <td align="left">3</td>
              <td align="left">Warning</td>
              <td align="left">RFC 8915, <xref target="nts-warning" format="default"/></td>
            </tr>
            <tr>
              <td align="left">4</td>
              <td align="left">AEAD Algorithm Negotiation</td>
              <td align="left">RFC 8915, <xref target="aead-algorithm-negotiation" format="default"/></td>
            </tr>
            <tr>
              <td align="left">5</td>
              <td align="left">New Cookie for NTPv4</td>
              <td align="left">RFC 8915, <xref target="new-cookie-for-ntpv4" format="default"/></td>
            </tr>
            <tr>
              <td align="left">6</td>
              <td align="left">NTPv4 Server Negotiation</td>
              <td align="left">RFC 8915, <xref target="ntp-server-negotiation" format="default"/></td>
            </tr>
            <tr>
              <td align="left">7</td>
              <td align="left">NTPv4 Port Negotiation</td>
              <td align="left">RFC 8915, <xref target="ntp-port-negotiation" format="default"/></td>
            </tr>
            <tr>
              <td align="left">8-16383</td>
              <td align="left">Unassigned</td>
              <td align="left"/>
            </tr>
            <tr>
              <td align="left">16384-32767</td>
              <td align="left">Reserved for Private or Experimental Use</td>
              <td align="left">RFC 8915</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section numbered="true" anchor="iana-nts-next-protocols" toc="default">
        <name>Network Time Security Next Protocols Registry</name>
        <t>
          IANA has created a new registry entitled
          "Network Time Security Next Protocols". Entries have
          the following fields:
        </t>
        <dl newline="false" spacing="normal">
          <dt>Protocol ID (<bcp14>REQUIRED</bcp14>):</dt> <dd>An integer in the range 0-65535 inclusive,
              functioning as an identifier.
            </dd>
          <dt>Protocol Name (<bcp14>REQUIRED</bcp14>):</dt> <dd>A short text string naming the protocol
              being identified.
            </dd>
          <dt>Reference (<bcp14>REQUIRED</bcp14>):</dt> <dd> A reference to a relevant specification
              document.
            </dd>
        </dl>
        <t>
          The registration policy varies by Protocol ID, as follows:
        </t>
        <dl newline="false" spacing="normal">
          <dt>0-1023:</dt>      <dd>IETF Review</dd>
          <dt>1024-32767:</dt>  <dd>Specification Required</dd>
          <dt>32768-65535:</dt> <dd>Private or Experimental Use</dd>
        </dl>
        <t>
          The initial contents of this registry are as follows:
        </t>

        <table align="center">
          <thead>
            <tr>
              <th align="left">Protocol ID</th>
              <th align="left">Protocol Name</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0</td>
              <td align="left">Network Time Protocol version 4 (NTPv4)</td>
              <td align="left">RFC 8915</td>
            </tr>
            <tr>
              <td align="left">1-32767</td>
              <td align="left">Unassigned</td>
              <td align="left"/>
            </tr>
            <tr>
              <td align="left">32768-65535</td>
              <td align="left">Reserved for Private or Experimental Use</td>
              <td align="left">RFC 8915</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section numbered="true" toc="default">
        <name>Network Time Security Error and Warning Codes Registries</name>
        <t>
          IANA has created two new registries entitled
          "Network Time Security Error Codes" and
          "Network Time Security Warning Codes". Entries in each 
          have the following fields:
        </t>
        <dl newline="false" spacing="normal">
          <dt>Number (<bcp14>REQUIRED</bcp14>):</dt>      <dd>An integer in the range 0-65535 inclusive</dd>
          <dt>Description (<bcp14>REQUIRED</bcp14>):</dt> <dd>A short text description of the
              condition.</dd>
          <dt>Reference (<bcp14>REQUIRED</bcp14>):</dt>   <dd>A reference to a relevant specification
              document.</dd>
        </dl>
        <t>
          The registration policy varies by Number, as follows:
        </t>
        <dl newline="false" spacing="normal">
          <dt>0-1023:</dt>      <dd>IETF Review</dd>
          <dt>1024-32767:</dt>  <dd>Specification Required</dd>
          <dt>32768-65535:</dt> <dd>Private or Experimental Use</dd>
        </dl>
        <t>
          The initial contents of the "Network Time Security Error Codes" registry
          are as follows:
        </t>
        <table align="center">
          <thead>
            <tr>
              <th align="left">Number</th>
              <th align="left">Description</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0</td>
              <td align="left">Unrecognized Critical Record</td>
              <td align="left">RFC 8915, <xref target="nts-error" format="default"/></td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">Bad Request</td>
              <td align="left">RFC 8915, <xref target="nts-error" format="default"/></td>
            </tr>
            <tr>
              <td align="left">2</td>
              <td align="left">Internal Server Error</td>
              <td align="left">RFC 8915, <xref target="nts-error" format="default"/></td>
            </tr>
            <tr>
              <td align="left">3-32767</td>
              <td align="left">Unassigned</td>
              <td align="left"/>
            </tr>
            <tr>
              <td align="left">32768-65535</td>
              <td align="left">Reserved for Private or Experimental Use</td>
              <td align="left">RFC 8915</td>
            </tr>
          </tbody>
        </table>
        <t>
          The "Network Time Security Warning Codes" registry is
          initially empty except for the reserved range, i.e.:
        </t>
        <table align="center">
          <thead>
            <tr>
              <th align="left">Number</th>
              <th align="left">Description</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0-32767</td>
              <td align="left">Unassigned</td>
              <td align="left"/>
            </tr>
            <tr>
              <td align="left">32768-65535</td>
              <td align="left">Reserved for Private or Experimental Use</td>
              <td align="left">RFC 8915</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>

    <section numbered="true" toc="default">
      <name>Security Considerations</name>
      <section numbered="true" toc="default">
        <name>Protected Modes</name>
        <t>
          NTP provides many different operating modes in order to support different
          network topologies and to adapt to various requirements. This memo only
          specifies NTS for NTP modes 3 (client) and 4 (server) (see
          <xref target="sec-protocol-overview" format="default"/>). The best current practice for
          authenticating the other NTP modes is using the symmetric message
          authentication code feature as described in
          <xref target="RFC5905" format="default">RFC 5905</xref> and
          <xref target="RFC8573" format="default">RFC 8573</xref>.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Cookie Encryption Key Compromise</name>
        <t>
          If the suggested format
          for NTS cookies in <xref target="suggested-format-for-nts-cookies" format="default"/>
          of this document is used, an attacker who has gained
          access to the secret cookie encryption key 'K' can impersonate
          the NTP server, including generating new cookies.
          NTP and NTS-KE server operators <bcp14>SHOULD</bcp14> remove compromised keys as soon
          as the compromise is discovered. This will cause the NTP servers to
          respond with NTS NAK, thus forcing key renegotiation. Note that this
          measure does not protect against MITM attacks where the attacker has access
          to a compromised cookie encryption key. If another cookie scheme is used,
          there are likely similar considerations for that particular scheme.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Sensitivity to DDoS Attacks</name>
        <t>
          The introduction of NTS brings with it the introduction of asymmetric
          cryptography to NTP. Asymmetric cryptography is necessary for initial
          server authentication and AEAD key extraction. Asymmetric
          cryptosystems are generally orders of magnitude slower than their
          symmetric counterparts. This makes it much harder to build systems
          that can serve requests at a rate corresponding to the full line speed
          of the network connection. This, in turn, opens up a new possibility
          for DDoS attacks on NTP services.
        </t>
        <t>
          The main protection against these attacks in NTS lies in that the use
          of asymmetric cryptosystems is only necessary in the initial NTS-KE
          phase of the protocol. Since the protocol design enables separation of
          the NTS-KE and NTP servers, a successful DDoS attack on an NTS-KE
          server separated from the NTP service it supports will not affect NTP
          users that have already performed initial authentication, AEAD key
          extraction, and cookie exchange.
        </t>
        <t>
          NTS users should also consider that they are not fully protected
          against DoS attacks by on-path adversaries. In addition to dropping
          packets and attacks such as those described in
          <xref target="DelayAttack" format="default"/>, an on-path attacker can send spoofed
          Kiss-o'-Death replies, which are not authenticated, in response to NTP
          requests. This could result in significantly increased load on the
          NTS-KE server. Implementers have to weigh the user's need for
          unlinkability against the added resilience that comes with cookie
          reuse in cases of NTS-KE server unavailability.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Avoiding DDoS Amplification</name>
        <t>
          Certain nonstandard and/or deprecated features of the Network Time
          Protocol enable clients to send a request to a server that causes the
          server to send a response much larger than the request. Servers that
          enable these features can be abused in order to amplify traffic volume
          in DDoS attacks by sending them a request with a spoofed source IP address.
          In recent years, attacks of this nature have become an endemic nuisance.
        </t>
        <t>
          NTS is designed to avoid contributing any further to this problem by
          ensuring that NTS-related extension fields included in server
          responses will be the same size as the NTS-related extension fields
          sent by the client. In particular, this is why the client is required
          to send a separate and appropriately padded-out NTS Cookie Placeholder
          extension field for every cookie it wants to get back, rather than
          being permitted simply to specify a desired quantity.
        </t>
        <t>
          Due to the <xref target="RFC7822" format="default">RFC 7822</xref> requirement that
          extensions be padded and aligned to four-octet boundaries, response
          size may still in some cases exceed request size by up to three
          octets. This is sufficiently inconsequential that we have declined to
          address it.
        </t>
      </section>
      <section anchor="sec-cert-verification" numbered="true" toc="default">
        <name>Initial Verification of Server Certificates</name>
        <t>
          NTS's security goals are undermined if the client fails to verify that
          the X.509 certificate chain presented by the NTS-KE server is valid
          and rooted in a trusted certificate authority. <xref target="RFC5280" format="default">RFC 5280</xref> and <xref target="RFC6125" format="default"> RFC
          6125</xref> specify how such verification is to be performed in
          general. However, the expectation that the client does not yet have a
          correctly-set system clock at the time of certificate verification
          presents difficulties with verifying that the certificate is within
          its validity period, i.e., that the current time lies between the
          times specified in the certificate's notBefore and notAfter fields. It
          may be operationally necessary in some cases for a client to accept a
          certificate that appears to be expired or not yet valid. While there
          is no perfect solution to this problem, there are several mitigations
          the client can implement to make it more difficult for an adversary to
          successfully present an expired certificate:
        </t>
        <ul empty="true" spacing="normal">
          <li>
              Check whether the system time is in fact unreliable. On systems
              with the ntp_adjtime() system call, a return code other than
              TIME_ERROR indicates that some trusted software has already set
              the time and certificates can be strictly validated.
            </li>
          <li>
              Allow the system administrator to specify that certificates should
              <em>always</em> be strictly validated. Such a configuration is
              appropriate on systems that have a battery-backed clock or that
              can reasonably prompt the user to manually set an
              approximately correct time if it appears to be needed.
            </li>
          <li>
              Once the clock has been synchronized, periodically write the
              current system time to persistent storage. Do not accept any
              certificate whose notAfter field is earlier than the last recorded
              time.
            </li>
          <li>
              NTP time replies are expected to be consistent with the NTS-KE TLS
              certificate validity period, i.e. time replies received immediately after
              an NTS-KE handshake are expected to lie within the certificate validity
              period.
              Implementations are recommended to check that this is the case.
              Performing a new NTS-KE handshake based solely on the fact that the
              certificate used by the NTS-KE server in a previous handshake has expired
              is normally not necessary.
              Clients that still wish to do this must take care not to cause an
              inadvertent denial-of-service attack on the NTS-KE server, for example by
              picking a random time in the week preceding certificate expiry to perform
              the new handshake.
            </li>
          <li>
              Use multiple time sources. The ability to pass off an expired
              certificate is only useful to an adversary who has compromised the
              corresponding private key. If the adversary has compromised only a
              minority of servers, NTP's selection algorithm (Section
              <xref target="RFC5905" section="11.2.1" sectionFormat="bare" format="default"/>
              of <xref target="RFC5905" format="default">RFC 5905</xref>) will protect the
              client from accepting bad time from the adversary-controlled
              servers.
            </li>
        </ul>
      </section>
      <section anchor="DelayAttack" numbered="true" toc="default">
        <name>Delay Attacks</name>
        <t>
          In a packet delay attack, an adversary with the ability to act as a
          man-in-the-middle delays time synchronization packets between client
          and server asymmetrically <xref target="RFC7384" format="default"/>. Since NTP's
          formula for computing time offset relies on the assumption that
          network latency is roughly symmetrical, this leads to the client to
          compute an inaccurate value <xref target="Mizrahi" format="default"/>. The delay attack
          does not reorder or modify the content of the exchanged
          synchronization packets. Therefore, cryptographic means do not provide
          a feasible way to mitigate this attack. However, the maximum error
          that an adversary can introduce is bounded by half of the round-trip
          delay.
        </t>
        <t>
          <xref target="RFC5905" format="default">RFC 5905</xref> specifies a parameter called
          MAXDIST, which denotes the maximum round-trip latency (including not
          only the immediate round trip between client and server, but the whole
          distance back to the reference clock as reported in the Root Delay
          field) that a client will tolerate before concluding that the server
          is unsuitable for synchronization. The standard value for MAXDIST is
          one second, although some implementations use larger values. Whatever
          value a client chooses, the maximum error that can be introduced by a
          delay attack is MAXDIST/2.
        </t>
        <t>
          Usage of multiple time sources, or multiple network paths to a given
          time source <xref target="Shpiner" format="default"/>, may also serve to mitigate delay
          attacks if the adversary is in control of only some of the paths.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>NTS Stripping</name>
        <t>
          Implementers must be aware of the possibility of "NTS stripping"
          attacks, where an attacker attempts to trick clients into reverting to plain
          NTP. Naive client implementations might, for example, revert
          automatically to plain NTP if the NTS-KE handshake fails. A man-in-the-middle
          attacker can easily cause this to happen. Even clients that already
          hold valid cookies can be vulnerable, since an attacker can force a
          client to repeat the NTS-KE handshake by sending faked NTP mode 4
          replies with the NTS NAK kiss code. Forcing a client to repeat the
          NTS-KE handshake can also be the first step in more advanced attacks.
        </t>
        <t>
          For the reasons described here, implementations <bcp14>SHOULD NOT</bcp14> revert
          from NTS-protected to unprotected NTP with any server without
          explicit user action.
        </t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Privacy Considerations</name>
      <section anchor="Unlinkability" numbered="true" toc="default">
        <name>Unlinkability</name>
        <t>Unlinkability prevents a device from being tracked when it changes
        network addresses (e.g., because said device moved between different
        networks). In other words, unlinkability thwarts an attacker that
        seeks to link a new network address used by a device with a network
        address that it was formerly using because of recognizable data that
        the device persistently sends as part of an NTS-secured NTP
        association. This is the justification for continually supplying the
        client with fresh cookies, so that a cookie never represents
        recognizable data in the sense outlined above. </t>
        <t>NTS's unlinkability objective is merely to not leak any additional
        data that could be used to link a device's network address. NTS does
        not rectify legacy linkability issues that are already present in NTP.
        Thus, a client that requires unlinkability must also minimize
        information transmitted in a client query (mode 3) packet as described
        in the document <xref target="I-D.ietf-ntp-data-minimization" format="default">
        NTP Client Data Minimization</xref>.
        </t>
        <t>The unlinkability objective only holds for time synchronization
        traffic, as opposed to key establishment traffic. This implies that it
        cannot be guaranteed for devices that function not only as time
        clients, but also as time servers (because the latter can be externally
        triggered to send linkable data, such as the TLS certificate).</t>
        <t>It should also be noted that it could be possible to link devices
        that operate as time servers from their time synchronization traffic,
        using information exposed in (mode 4) server response packets (e.g.
        reference ID, reference time, stratum, poll).  Also, devices that
        respond to NTP control queries could be linked using the information
        revealed by control queries. </t>
        <t>Note that the unlinkability objective does not prevent a client device
        from being tracked by its time servers.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Confidentiality</name>
        <t>
	  NTS does not protect the confidentiality of information in
	  NTP's header fields. When clients implement
    <xref target="I-D.ietf-ntp-data-minimization" format="default">
    NTP Client Data Minimization</xref>, client packet
	  headers do not contain any information that the client
	  could conceivably wish to keep secret: one field is random,
	  and all others are fixed. Information in server packet
	  headers is likewise public: the origin timestamp is copied
	  from the client's (random) transmit timestamp, and all other
	  fields are set the same regardless of the identity of the
	  client making the request.
        </t>
        <t>
	  Future extension fields could hypothetically contain
	  sensitive information, in which case NTS provides a
	  mechanism for encrypting them.
        </t>
      </section>
    </section>
  </middle>
  <back>

<displayreference target="I-D.ietf-ntp-data-minimization" to="NTP-DATA-MIN"/>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>

        <reference anchor="IANA-AEAD" target="https://www.iana.org/assignments/aead-parameters/">
          <front>
            <title>
            Authenticated Encryption with Associated Data (AEAD) Parameters
            </title>
            <author>
              <organization>IANA</organization>
            </author>
          </front>
        </reference>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0020.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4291.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5116.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5297.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5705.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5869.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5890.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5905.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6125.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6335.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6874.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7301.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7525.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7822.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
      </references>
      <references>
        <name>Informative References</name>

        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.draft-ietf-ntp-data-minimization.xml"/>

        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4086.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5077.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7384.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8573.xml"/>

        <reference anchor="Mizrahi" target="">
          <front>
            <title>A game theoretic analysis of delay attacks against time
          synchronization protocols</title>
            <author fullname="Tal Mizrahi" initials="T" surname="Mizrahi">
              <organization/>
            </author>
            <date day="" month="September" year="2012"/>
          </front>
            <seriesInfo name="DOI" value="10.1109/ISPCS.2012.6336612"/>
          <refcontent>2012 IEEE International Symposium on Precision Clock Synchronization
                      for Measurement, Control and Communication Proceedings, pp. 1-6</refcontent>
        </reference>

        <reference anchor="Shpiner">
          <front>
            <title>Multi-path Time Protocols</title>
            <author fullname="Alexander Shpiner" initials="A" surname="Shpiner">
              <organization/>
            </author>
            <author fullname="Yoram Revah" initials="Y" surname="Revah">
              <organization/>
            </author>
            <author fullname="Tal Mizrahi" initials="T" surname="Mizrahi">
              <organization/>
            </author>
            <date month="September" year="2013"/>
          </front>
            <seriesInfo name="DOI" value="10.1109/ISPCS.2013.6644754"/>
          <refcontent>2013 IEEE International Symposium on Precision Clock Synchronization
                      for Measurement, Control and Communication (ISPCS) Proceedings, pp. 1-6</refcontent>
        </reference>
      </references>
    </references>

    <section anchor="Acknowledgments" numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>The authors would like to thank <contact fullname="Richard Barnes"/>,
      <contact fullname="Steven Bellovin"/>, <contact fullname="Scott Fluhrer"/>,
      <contact fullname="Patrik Fältström"/>,
      <contact fullname="Sharon Goldberg"/>, <contact fullname="Russ Housley"/>,
      <contact fullname="Benjamin Kaduk"/>, <contact fullname="Suresh Krishnan"/>,
      <contact fullname="Mirja Kühlewind"/>, <contact fullname="Martin Langer"/>,
      <contact fullname="Barry Leiba"/>, <contact fullname="Miroslav Lichvar"/>,
      <contact fullname="Aanchal Malhotra"/>, <contact fullname="Danny Mayer"/>,
      <contact fullname="Dave Mills"/>, <contact fullname="Sandra Murphy"/>,
      <contact fullname="Hal Murray"/>, <contact fullname="Karen O'Donoghue"/>,
      <contact fullname="Eric K. Rescorla"/>, <contact fullname="Kurt Roeckx"/>,
      <contact fullname="Stephen Roettger"/>, <contact fullname="Dan Romascanu"/>,
      <contact fullname="Kyle Rose"/>, <contact fullname="Rich Salz"/>,
      <contact fullname="Brian Sniffen"/>, <contact fullname="Susan Sons"/>,
      <contact fullname="Douglas Stebila"/>, <contact fullname="Harlan Stenn"/>,
      <contact fullname="Joachim Strömbergsson"/>,
      <contact fullname="Martin Thomson"/>, <contact fullname="Éric Vyncke"/>,
      <contact fullname="Richard Welty"/>, <contact fullname="Christer Weinigel"/>, and
      <contact fullname="Magnus Westerlund"/> for contributions to this document
      and comments on the design of NTS.</t>
    </section>
  </back>
</rfc>
