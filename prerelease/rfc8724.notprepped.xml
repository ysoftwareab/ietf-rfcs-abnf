<?xml version='1.0' encoding='UTF-8'?>
<!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.3 -->
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?rfc symrefs="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902"
docName="draft-ietf-lpwan-ipv6-static-context-hc-24" 
number="8724" category="std" obsoletes="" updates=""
submissionType="IETF" consensus='true' xml:lang="en" symRefs="true"
sortRefs="true" tocInclude="true" version="3" >
  <!-- xml2rfc v2v3 conversion 2.38.0 -->
  <front>


    <title abbrev="LPWAN SCHC">SCHC: Generic Framework for Static Context Header Compression and Fragmentation</title>
    <seriesInfo name="RFC" value="8724"/>
    <author initials="A." surname="Minaburo" fullname="Ana Minaburo">
      <organization>Acklio</organization>
      <address>
        <postal>
          <street>1137A avenue des Champs Blancs</street>
          <city>35510 Cesson-Sevigne Cedex</city>
          <country>France</country>
        </postal>
        <email>ana@ackl.io</email>
      </address>
    </author>
    <author initials="L." surname="Toutain" fullname="Laurent Toutain">
      <organization>IMT Atlantique</organization>
      <address>
        <postal>
          <street>2 rue de la Chataigneraie</street>
          <street>CS 17607</street>
          <city>35576 Cesson-Sevigne Cedex</city>
          <country>France</country>
        </postal>
        <email>Laurent.Toutain@imt-atlantique.fr</email>
      </address>
    </author>
    <author initials="C." surname="Gomez" fullname="Carles Gomez">
      <organization>Universitat Politecnica de Catalunya</organization>
      <address>
        <postal>
          <street>C/Esteve Terradas, 7</street>
          <street>08860 Castelldefels</street>
          <country>Spain</country>
        </postal>
        <email>carlesgo@entel.upc.edu</email>
      </address>
    </author>
    <author initials="D." surname="Barthel" fullname="Dominique Barthel">
      <organization>Orange Labs</organization>
      <address>
        <postal>
          <street>28 chemin du Vieux Chene</street>
          <street>38243 Meylan</street>
          <country>France</country>
        </postal>
        <email>dominique.barthel@orange.com</email>
      </address>
    </author>
    <author initials="JC." surname="Zuniga" fullname="Juan Carlos Zuniga">
      <organization>SIGFOX</organization>
      <address>
        <postal>
          <street>425 rue Jean Rostand</street>
          <street>31670 Labege</street>
          <country>France</country>
        </postal>
        <email>JuanCarlos.Zuniga@sigfox.com</email>
      </address>
    </author>
    <date year="2020" month="April"/>
    <workgroup>lpwan Working Group</workgroup>


<keyword>header compression</keyword>
<keyword>compression</keyword>
<keyword>fragmentation</keyword>
<keyword>static context</keyword>
<keyword>rule-based</keyword>
<keyword>LPWAN</keyword>
<keyword>LPWANs</keyword>
<keyword>low power</keyword>
<keyword>low-power</keyword>
<keyword>6LoWPAN</keyword>
<keyword>6lo</keyword>
<keyword>LoWPAN</keyword>
<keyword>LoWPANs</keyword>
<keyword>LLN</keyword>
<keyword>LLNs</keyword>
<keyword>LTN</keyword>
<keyword>LTE</keyword>
<keyword>LTE-M</keyword>
<keyword>Sigfox</keyword>
<keyword>LoRaWAN</keyword>
<keyword>NB-IOT</keyword>
<keyword>5G</keyword>
<keyword>IoT</keyword>
<keyword>Internet of Things</keyword>
<keyword>adaptation layer</keyword>
<keyword>UDP</keyword>
<keyword>IPv6</keyword>
<keyword>WSN</keyword>
<keyword>sensor network</keyword>
<keyword>wireless sensor network</keyword>
<keyword>802.15.4</keyword>
<keyword>constrained network</keyword>
<keyword>constrained node</keyword>
<keyword>constrained-node network</keyword>

    <abstract>
      <t>This document defines the Static Context Header Compression
      and fragmentation (SCHC) framework, which provides both a header compression
      mechanism and an optional fragmentation mechanism. SCHC has been
      designed with Low-Power Wide Area Networks (LPWANs) in mind.</t>

      <t>SCHC compression is based on a common static context stored both in the LPWAN device and in the network infrastructure side. This document defines a generic header compression mechanism and its application to compress IPv6/UDP headers.</t>
      <t>This document also specifies an optional fragmentation and
      reassembly mechanism. It can be used to support the IPv6 MTU
      requirement over the LPWAN technologies. Fragmentation is needed
      for IPv6 datagrams that, after SCHC compression or when such
      compression was not possible, still exceed the Layer 2 maximum payload size.</t>
      <t>The SCHC header compression and fragmentation mechanisms are independent of the specific LPWAN technology over which they are used. This document defines generic functionalities and offers flexibility with regard to parameter settings and mechanism choices.
This document standardizes the exchange over the LPWAN between two SCHC entities.
Settings and choices specific to a technology or a product are expected to be grouped into profiles, which are specified in other documents.
Data models for the context and profiles are out of scope.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="Introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>This document defines the Static Context Header Compression and fragmentation (SCHC) framework, which provides both a header compression mechanism and an optional fragmentation mechanism. SCHC has been designed with Low-Power Wide Area Networks (LPWANs) in mind.</t>
      <t>LPWAN technologies impose some strict limitations on traffic. For instance, devices sleep most of the time and may only receive data during short periods of time after transmission, in order to preserve battery.
LPWAN technologies are also characterized by a greatly reduced data unit and/or payload size (see <xref target="RFC8376" format="default"/>).</t>
      <t>Header compression is needed for efficient Internet connectivity to a node within an LPWAN. The following properties of LPWANs can be exploited to get an efficient header compression:</t>
      <ul spacing="normal">
        <li>The network topology is star-oriented, which means that all packets between the same source-destination pair follow the same path. For the needs of this document, the architecture can simply be described as Devices (Dev) exchanging information with LPWAN Application Servers (Apps) through a Network Gateway (NGW).</li>
        <li>Because devices embed built-in applications, the traffic flows to be compressed are known in advance. Indeed, new applications are less frequently installed in an LPWAN device than they are in a general-purpose computer or smartphone.</li>
      </ul>
      <t>SCHC compression uses a Context (a set of Rules) in which information about header fields is stored. This Context is static: the values of the header fields and the actions to do compression/decompression do not change over time. This avoids the need for complex resynchronization mechanisms.
Indeed, a return path may be more restricted/expensive, or may
sometimes be completely unavailable <xref target="RFC8376" format="default"/>.
A compression protocol that relies on feedback is not compatible with the characteristics of such LPWANs.</t>
      <t>In most cases, a small Rule identifier is enough to represent the full IPv6/UDP headers. The SCHC header compression mechanism is independent of the specific LPWAN technology over which it is used.</t>
      <t>Furthermore, some LPWAN technologies do not provide a fragmentation functionality; to support the IPv6 MTU requirement of 1280 bytes <xref target="RFC8200" format="default"/>, they require a fragmentation protocol at the adaptation layer below IPv6.
Accordingly, this document defines an optional fragmentation/reassembly mechanism to help LPWAN technologies support the IPv6 MTU requirement.</t>
      <t>This document defines generic functionality and offers flexibility with regard to parameter settings
and mechanism choices. Technology-specific settings are expected to be grouped into Profiles specified in other documents.</t>
    </section>
    
    <section anchor="requirements-notation" numbered="true" toc="default">
      <name>Requirements Notation</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
    </section>
    <section anchor="LPWAN-Archi" numbered="true" toc="default">
      <name>LPWAN Architecture</name>
      <t>LPWAN architectures are similar among them, but each LPWAN technology names architecture elements differently.
In this document, we use terminology from <xref target="RFC8376" format="default"/>,
which identifies the following entities in a typical LPWAN
      (see <xref target="Fig-LPWANarchi" format="default"/>):</t>

      <ul spacing="normal">
      <li>Devices (Dev) are the end-devices or hosts (e.g., sensors, actuators, etc.). There can be a very high density of devices per Radio Gateway.</li>
      <li>The Radio Gateway (RGW) is the endpoint of the constrained link.</li>
      <li>The Network Gateway (NGW) is the interconnection node between the Radio Gateway and the Internet.</li>
      <li>The Application Server (App) is the endpoint of the application-level protocol on the Internet side.</li></ul>
      <figure anchor="Fig-LPWANarchi">
        <name>LPWAN Architecture (Simplified from That Shown in RFC 8376)</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 ()   ()   ()       |
  ()  () () ()     / \       +---------+
() () () () () () /   \======|    ^    |             +-----------+
 ()  ()   ()     |           | <--|--> |             |Application|
()  ()  ()  ()  / \==========|    v    |=============|   Server  |
  ()  ()  ()   /   \         +---------+             +-----------+
 Dev            RGWs             NGW                      App]]></artwork>
      </figure>
    </section>
    <section anchor="Term" numbered="true" toc="default">
      <name>Terminology</name>
      <t>This section defines terminology and abbreviations used in this document.
It extends the terminology of <xref target="RFC8376" format="default"/>.</t>
      <t>The SCHC acronym is pronounced like "sheek" in English (or "chic" in French). Therefore, this document writes "a SCHC Packet" instead of "an SCHC Packet".</t>
      <dl spacing="normal" indent="9">

	
        <dt>App:</dt><dd>LPWAN Application Server, as defined by <xref target="RFC8376" format="default"/>. It runs an application sending/receiving packets to/from the Dev.</dd>
        <dt>AppIID:</dt><dd>Application Interface Identifier. The IID that
	identifies the App interface.</dd>
        <dt>Compression Residue:</dt><dd>The bits that remain to be sent (beyond the RuleID itself) after applying the SCHC compression.</dd>
        <dt>Context:</dt><dd>A set of Rules used to compress/decompress headers, or to fragment/reassemble a packet.</dd>
        <dt>Dev:</dt><dd>Device, as defined by <xref target="RFC8376" format="default"/>.</dd>
        <dt>DevIID:</dt><dd>Device Interface Identifier. The IID that identifies the Dev interface.</dd>
        <dt>Downlink:</dt><dd>From the App to the Dev.</dd>
        <dt>IID:</dt><dd>Interface Identifier. See the IPv6 addressing architecture <xref target="RFC7136" format="default"/>.</dd>
        <dt>L2:</dt><dd>Layer 2. The immediate lower layer that SCHC interfaces with, for example an underlying LPWAN technology. It does not necessarily correspond to the OSI model definition of Layer 2.</dd>
        <dt>L2 Word:</dt><dd>This is the minimum subdivision of payload data that the L2 will carry. In most L2 technologies, the L2 Word is an octet.
In bit-oriented radio technologies, the L2 Word might be a single bit.
The L2 Word size is assumed to be constant over time for each device.</dd>
	
        <dt>Padding:</dt><dd>Extra bits that may be appended by SCHC to a data unit that it passes down to L2 for transmission.
SCHC itself operates on bits, not bytes, and does not have any alignment prerequisite. See <xref target="Padding" format="default"/>.</dd>
        <dt>Profile:</dt><dd>SCHC offers variations in the way it is operated, with a number of parameters listed in <xref target="SCHCParams" format="default"/>.
A Profile indicates a particular setting of all these parameters.
Both ends of a SCHC communication must be provisioned with the same Profile information and with the same set of Rules before the communication starts,
so that there is no ambiguity in how they expect to communicate.</dd>
        <dt>Rule:</dt><dd>Part of the Context that describes how a packet is compressed/decompressed or fragmented/reassembled.</dd>
        <dt>RuleID:</dt><dd>Rule Identifier.  An identifier for a Rule.</dd>
        <dt>SCHC:</dt><dd>Static Context Header Compression and fragmentation (SCHC), a generic framework.</dd>
        <dt>SCHC C/D:</dt><dd>SCHC Compressor/Decompressor, or SCHC Compression/Decompression. The SCHC entity or mechanism used on both sides, at the Dev and at the network, to achieve compression/decompression of headers.</dd>
        <dt>SCHC F/R:</dt><dd>SCHC Fragmenter/Reassembler or SCHC Fragmentation/Reassembly. The SCHC entity or mechanism used on both sides, at the Dev and at the network, to achieve fragmentation/reassembly of SCHC Packets.</dd>
        <dt>SCHC Packet:</dt><dd>A packet (e.g., an IPv6 packet) whose header has been compressed as per the header compression mechanism defined in this document. If the header compression process is unable to actually compress the packet header, the packet with the uncompressed header is still called a SCHC Packet (in this case, a RuleID is used to indicate that the packet header has not been compressed). See <xref target="SCHComp" format="default"/> for more details.</dd>
        <dt>Uplink:</dt><dd>From the Dev to the App.</dd>
      </dl>
      <t>Additional terminology for the optional SCHC F/R is found in <xref target="FragTools" format="default"/>.</t>
      <t>Additional terminology for SCHC C/D is found in <xref target="schc-cd-rules" format="default"/>.</t>
    </section>
    <section anchor="Overview" numbered="true" toc="default">
      <name>SCHC Overview</name>
      <t>SCHC can be characterized as an adaptation layer between an upper layer (for example, IPv6) and an underlying layer (for example, an LPWAN technology).
SCHC comprises two sublayers (i.e., the Compression sublayer and the Fragmentation sublayer), as shown in <xref target="Fig-IntroLayers" format="default"/>.</t>
      <figure anchor="Fig-IntroLayers">
        <name>Example of Protocol Stack Comprising IPv6, SCHC, and an LPWAN Technology</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
             +----------------+
             |      IPv6      |
          +- +----------------+            
          |  |   Compression  |  
    SCHC <   +----------------+   
          |  |  Fragmentation |
          +- +----------------+         
             |LPWAN technology|
             +----------------+]]></artwork>
      </figure>
      <t>Before an upper layer packet (e.g., an IPv6 packet) is transmitted to the underlying layer, header compression is first attempted. The resulting packet is called a "SCHC Packet", whether or not any compression is performed.
If needed by the underlying layer, the optional SCHC fragmentation <bcp14>MAY</bcp14> be applied to the SCHC Packet.
The inverse operations take place at the receiver. This process is illustrated in <xref target="Fig-Operations" format="default"/>.</t>
      <figure anchor="Fig-Operations">
        <name>SCHC Operations at the Sender and the Receiver</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
A packet (e.g., an IPv6 packet)
         |                                           ^
         v                                           |
+------------------+                      +--------------------+
| SCHC Compression |                      | SCHC Decompression |
+------------------+                      +--------------------+
         |                                           ^
         |   If no fragmentation (*)                 |
         +-------------- SCHC Packet  -------------->|
         |                                           |
         v                                           |
+--------------------+                       +-----------------+
| SCHC Fragmentation |                       | SCHC Reassembly |
+--------------------+                       +-----------------+
      |     ^                                     |     ^
      |     |                                     |     |
      |     +---------- SCHC ACK (+) -------------+     |
      |                                                 |
      +-------------- SCHC Fragments -------------------+

        Sender                                    Receiver

*: the decision not to use SCHC fragmentation is left to each Profile
+: optional, depends on Fragmentation mode]]></artwork>
      </figure>
      <section anchor="schc-packet-format" numbered="true" toc="default">
        <name>SCHC Packet Format</name>
        <t>The SCHC Packet is composed of the Compressed Header followed by the payload from the original packet (see <xref target="Fig-SCHCpckt" format="default"/>).
The Compressed Header itself is composed of the RuleID and a Compression Residue, which is the output of compressing the packet header with the Rule identified by that RuleID (see <xref target="SCHComp" format="default"/>).
The Compression Residue may be empty. Both the RuleID and the Compression Residue potentially have a variable size, and are not necessarily a multiple of bytes in size.</t>
        <figure anchor="Fig-SCHCpckt">
          <name>SCHC Packet</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
|------- Compressed Header -------|
+---------------------------------+--------------------+ 
|  RuleID  |  Compression Residue |      Payload       |
+---------------------------------+--------------------+]]></artwork>
        </figure>
      </section>
      <section anchor="FunctionalMapping" numbered="true" toc="default">
        <name>Functional Mapping</name>
        <t><xref target="Fig-archi" format="default"/> maps the
	functional elements of <xref target="Fig-Operations"
	format="default"/> onto the LPWAN architecture elements of
	<xref target="Fig-LPWANarchi" format="default"/>.</t>

	
        <figure anchor="Fig-archi">
          <name>Architectural Mapping</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
        Dev                                               App
+----------------+                               +----+ +----+ +----+
| App1 App2 App3 |                               |App1| |App2| |App3|
|                |                               |    | |    | |    |
|       UDP      |                               |UDP | |UDP | |UDP |
|      IPv6      |                               |IPv6| |IPv6| |IPv6|
|                |                               |    | |    | |    |
|SCHC C/D and F/R|                               |    | |    | |    |
+--------+-------+                               +----+ +----+ +----+
         |  +---+     +---+    +----+    +----+    .      .      .
         +~ |RGW| === |NGW| == |SCHC| == |SCHC|..... Internet ....
            +---+     +---+    |F/R |    |C/D |
                               +----+    +----+]]></artwork>
        </figure>
        <t>SCHC C/D and SCHC F/R are located on both sides of the LPWAN transmission, hereafter called the "Dev side" and the "Network Infrastructure side".</t>
        <t>The operation in the Uplink direction is as follows. The Device application uses IPv6 or IPv6/UDP protocols. Before sending the packets, the Dev compresses their headers using SCHC C/D;
if the SCHC Packet resulting from the compression needs to be fragmented by SCHC, SCHC F/R is performed (see <xref target="Frag" format="default"/>).
The resulting SCHC Fragments are sent to an LPWAN Radio Gateway (RGW), which forwards them to a Network Gateway (NGW).
The NGW sends the data to a SCHC F/R for reassembly (if needed) and then to the SCHC C/D for decompression.
After decompression, the packet can be sent over the Internet
to one or several Apps.</t>
        <t>The SCHC F/R and SCHC C/D on the Network Infrastructure side can
	be part of the NGW or located in the Internet as long as a
	tunnel is established between them and the NGW.

	
For some LPWAN technologies, it may be suitable to locate the SCHC F/R
functionality nearer the NGW, in order to better deal with time constraints of such technologies.</t>
        <t>The SCHC C/Ds on both sides <bcp14>MUST</bcp14> share the same set of Rules.
So <bcp14>MUST</bcp14> the SCHC F/Rs on both sides.</t>
        <t>The operation in the Downlink direction is similar to that in the Uplink direction, only reversing the order in which the architecture elements are traversed.</t>
      </section>
    </section>
    <section anchor="RuleID" numbered="true" toc="default">
      <name>RuleID</name>
      <t>RuleIDs identify the Rules used for compression/decompression or
for fragmentation/reassembly.</t>
      <t>The scope of the RuleID of a compression/decompression Rule is the link between the SCHC C/D in a given Dev and the corresponding SCHC C/D in the Network Infrastructure side.
The scope of the RuleID of a fragmentation/reassembly Rule is the link between the SCHC F/R in a given Dev and the corresponding SCHC F/R in the Network Infrastructure side.
If such a link is bidirectional, the scope includes both directions.</t>
      <t>The RuleIDs are therefore specific to the Context related to one Dev. Hence, multiple Dev instances, which refer to different Contexts, <bcp14>MAY</bcp14> reuse the same RuleID for different Rules.
      On the Network Infrastructure side, in order to identify the correct Rule to be applied to Uplink traffic, the SCHC C/D or SCHC F/R needs to associate the RuleID with the Dev identifier.
      Similarly, for Downlink traffic, the SCHC C/D or SCHC F/R on the Network Infrastructure side first needs to identify the destination Dev before looking for the appropriate Rule (and associated RuleID) in the Context of that Dev.</t>
      <t>Inside their scopes, Rules for compression/decompression and Rules for fragmentation/reassembly share the same RuleID space.</t>
      <t>The size of the RuleIDs is not specified in this document,
      as it is implementation-specific and can vary according to the
      LPWAN technology and the number of Rules, among other things. It is defined in Profiles.</t>
      <t>The RuleIDs are used:</t>
      <ul spacing="normal">
        <li>
          <t>For SCHC C/D, to identify the Rule that is used to compress a packet header.  </t>
          <ul spacing="normal">
            <li>At least one RuleID <bcp14>MUST</bcp14> be allocated to tagging packets for which SCHC compression was not possible (i.e., no matching compression Rule was found).</li>
          </ul>
        </li>
        <li>
          <t>In SCHC F/R, to identify the specific mode and settings of fragmentation/reassembly for one direction of data traffic (Uplink or Downlink).  </t>
          <ul spacing="normal">
            <li>When SCHC F/R is used for both communication directions, at least two RuleID values are needed for fragmentation/reassembly: one per direction of data traffic.
This is because fragmentation/reassembly may entail control messages flowing in the reverse direction compared to data traffic.</li>
          </ul>
        </li>
      </ul>
    </section>
    <section anchor="SCHComp" numbered="true" toc="default">
      <name>Compression/Decompression</name>
      <t>Compression with SCHC
is based on using a set of Rules, which constitutes the Context of SCHC C/D, to compress or
      decompress headers. SCHC avoids Context synchronization traffic,
      which consumes considerable bandwidth in other header
      compression mechanisms such as RObust Header Compression (RoHC)
      <xref target="RFC5795" format="default"/>. Since the content of
      packets is highly predictable in LPWANs, static Contexts
      can be stored beforehand. The Contexts <bcp14>MUST</bcp14> be
      stored at both ends, and they can be learned by a provisioning
      protocol, by out-of-band means, or by pre-provisioning. The way the Contexts are provisioned is out of the scope of this document.</t>
      <section anchor="schc-cd-rules" numbered="true" toc="default">
        <name>SCHC C/D Rules</name>
        <t>The main idea of the SCHC compression scheme is to transmit the RuleID to the other end instead of sending known field values. This RuleID identifies a Rule that matches the original packet values. Hence, when a value is known by both ends, it is only necessary to send the corresponding RuleID over the LPWAN.
The manner by which Rules are generated is out of the scope of this document. The Rules <bcp14>MAY</bcp14> be changed at run-time, but the mechanism is out of scope of this document.</t>
        <t>The SCHC C/D Context is a set of Rules.
See <xref target="Fig-ctxt" format="default"/> for a high-level, abstract representation of the Context.
The formal specification of the representation of the Rules is outside the scope of this document.</t>
        <t>Each Rule itself contains a list of Field Descriptors composed of a Field Identifier (FID), a Field Length (FL), a Field Position (FP), a Direction Indicator (DI), a Target Value (TV), a Matching Operator (MO), and a Compression/Decompression Action (CDA).</t>
        <figure anchor="Fig-ctxt">
          <name>A SCHC C/D Context</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  /-----------------------------------------------------------------\
  |                         Rule N                                  |
 /-----------------------------------------------------------------\|
 |                       Rule i                                    ||
/-----------------------------------------------------------------\||
|  (FID)            Rule 1                                        |||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||...    |..|..|..|   ...      | ...             | ...           ||||
|+-------+--+--+--+------------+-----------------+---------------+||/
||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|||
|+-------+--+--+--+------------+-----------------+---------------+|/
|                                                                 |
\-----------------------------------------------------------------/]]></artwork>
        </figure>
        <t>A Rule does not describe how the compressor parses a packet header to find and identify each field (e.g., the IPv6 Source Address, the UDP Destination Port, or a CoAP URI path option).
It is assumed that there is a protocol parser alongside SCHC that is able to identify
all the fields encountered in the headers to be compressed,
and to label them with a Field ID.
Rules only describe the compression/decompression behavior for each header field, after it has been identified.</t>
        <t>In a Rule, the Field Descriptors are listed in the order in which the fields appear in the packet header.
The Field Descriptors describe the header fields with the following entries:</t>
        <ul spacing="normal">
          <li>Field Identifier (FID) designates a protocol and field (e.g., UDP Destination Port), unambiguously among all protocols that a SCHC compressor processes. In the presence of protocol nesting, the Field ID also identifies the nesting.</li>
          <li>Field Length (FL) represents the length of the original field. It can be either a fixed value (in bits) if the length is known when the Rule is created or a type if the length is variable. The length of a header field is defined by its own protocol specification (e.g., IPv6 or UDP). If the length is variable, the type defines the process to compute the length and its unit (bits, bytes...).</li>
          <li>Field Position (FP): most often, a field only occurs once in a packet header.
However, some fields may occur multiple times. An example is the uri-path of CoAP.
FP indicates which occurrence this Field Descriptor applies to.
The default value is 1.
The value 1 designates the first occurrence.
The value 0 is special. It means "don't care", see <xref target="PProcessing" format="default"/>.</li>
          <li>
            <t>A Direction Indicator (DI) indicates the packet direction(s) this Field Descriptor applies to. It allows for asymmetric processing, using the same Rule. Three values are possible:  </t>
            <dl spacing="normal" newline="false">  
              <dt>Up:</dt><dd>this Field Descriptor is only applicable to packets traveling Uplink.</dd>
              <dt>Dw:</dt><dd>this Field Descriptor is only applicable to packets traveling Downlink.</dd>
              <dt>Bi:</dt><dd>this Field Descriptor is applicable to packets traveling Uplink or Downlink.</dd>
            </dl>
          </li>
          <li>Target Value (TV) is the value used to match against the packet header field. The Target Value can be a scalar value of any type (integer, strings, etc.) or a more complex structure (array, list, etc.). The types and representations are out of scope for this document.</li>
          <li>Matching Operator (MO) is the operator used to match the field value and the Target Value. The Matching Operator may require some parameters. The set of MOs defined in this document can be found in <xref target="chap-MO" format="default"/>.</li>
          <li>Compression/Decompression Action (CDA) describes the pair of actions that are performed at the compressor to compress a header field and at the decompressor to recover the original value of the header field. Some CDAs might use parameter values for their operation. The set of CDAs defined in this document can be found in <xref target="chap-CDA" format="default"/>.</li>
        </ul>
      </section>

      <section anchor="PProcessing" numbered="true" toc="default">
        <name>Packet Processing</name>
        <t>The compression/decompression process follows several phases:</t>
        <dl spacing="normal">


            <dt>Compression Rule selection:</dt><dd><t>the general idea is to browse the Rule set to find a Rule that has a matching
Field Descriptor (given the DI and FP) for all and only those header fields that appear in the packet being compressed.
The detailed algorithm is the following: </t>
            <ul spacing="normal">
              <li>The first step is to check the FIDs.
If any header field of the packet being examined cannot be matched with a Field Descriptor with the correct FID, the Rule <bcp14>MUST</bcp14> be disregarded.
If any Field Descriptor in the Rule has a FID that cannot be matched to one of the header fields of the packet being examined, the Rule <bcp14>MUST</bcp14> be disregarded.</li>
              <li>The next step is to match the Field Descriptors by their direction, using the DI. If any field of the packet header cannot be matched with a Field Descriptor with the correct FID and DI, the Rule <bcp14>MUST</bcp14> be disregarded.</li>
              <li>
                <t>Then, the Field Descriptors are further selected according to FP. If any field of the packet header cannot be matched with a Field Descriptor with the correct FID, DI and FP, the Rule <bcp14>MUST</bcp14> be disregarded.      </t>
                <t>
The value 0 for FP means "don't care", i.e., the comparison of this Field Descriptor's FP with
the position of the field of the packet header being compressed
returns True, whatever that position.  FP=0 can be useful to build compression Rules for protocol headers in which
some fields order is irrelevant. An example could be uri-queries in CoAP.
Care needs to be exercised when writing Rules containing FP=0 values.
Indeed, it may result in decompressed packets having fields ordered differently compared to the original packet.</t>
              </li>
              <li>
                <t>Once each header field has been associated with a Field Descriptor with matching FID, DI, and FP, each packet field's value is then compared to the corresponding TV stored in the Rule for that specific field, using the MO.
If every field in the packet header satisfies the corresponding MOs of a Rule (i.e., all MO results are True), that Rule is valid for use to compress the header.
Otherwise, the Rule <bcp14>MUST</bcp14> be disregarded.      </t>
                <t>
This specification does not prevent multiple Rules from matching the above steps and, therefore, being valid for use.
Which Rule to use among multiple valid Rules is left to the implementation.
As long as the same Rule set is installed at both ends, this degree of freedom does not constitute an interoperability issue.</t>
              </li>
              <li>If no valid compression Rule is found, then the packet <bcp14>MUST</bcp14> be sent uncompressed
using the RuleID dedicated to this purpose (see <xref target="RuleID" format="default"/>).
The entire packet header is the Compression Residue (see <xref target="Fig-SCHCpckt" format="default"/>).
Sending an uncompressed header is likely to require SCHC F/R.</li>
            </ul></dd>
          
          <dt>Compression:</dt><dd>if a valid Rule is found, each field of the header is compressed according to the CDAs of the Rule.
The fields are compressed in the order that the Field Descriptors appear in the Rule.
The compression of each field results in a residue, which may be empty.
The Compression Residue for the packet header is the concatenation of the non-empty residues for each field of the header, in the order the Field Descriptors appear in the Rule.
The order in which the Field Descriptors appear in the Rule is therefore semantically important.</dd>
        </dl>
        <figure anchor="Fig-CompRes">
          <name>Compression Residue Structure</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    |------------------- Compression Residue -------------------|
    +-----------------+-----------------+-----+-----------------+
    | field 1 residue | field 2 residue | ... | field N residue |
    +-----------------+-----------------+-----+-----------------+]]></artwork>
        </figure>
        <dl spacing="normal">
          <dt>Sending:</dt><dd>The RuleID is sent to the other end jointly with the Compression Residue (which could be empty) or the uncompressed header, and directly followed by the payload (see <xref target="Fig-SCHCpckt" format="default"/>).
The way the RuleID is sent will be specified in the Profile and is out of the scope of the present document.
For example, it could be included in an L2 header or sent as part of the L2 payload.</dd>
          
            <dt>Decompression:</dt><dd><t>when decompressing, on the Network Infrastructure side, the SCHC C/D needs to find the correct Rule based on the L2 address of the Dev.&nbsp; On the Dev side, only the RuleID is needed to identify the correct Rule since the Dev typically only holds Rules that apply to itself.  </t>
            <t>
This Rule describes the compressed header format. From this, the decompressor determines the order of the residues, the fixed-size or variable-size nature of each residue (see <xref target="var-length-field" format="default"/>),
and the size of the fixed-size residues.  </t>
            <t>
Therefore, from the received compressed header, it can retrieve all the residue values and associate them to the corresponding header fields.  </t>
            <t>
For each field in the header, the receiver applies the CDA action associated with that field in order to reconstruct the original header field value. The CDA application order can be different from the order in which the fields are listed in the Rule. In particular, Compute-* <bcp14>MUST</bcp14> be applied after the application of the CDAs of all the fields it computes on.</t>
          </dd>
        </dl>
      </section>
      <section anchor="chap-MO" numbered="true" toc="default">
        <name>Matching Operators</name>
        <t>MOs are functions used at the compression side of SCHC C/D. They are not typed and can be applied to integer, string or any other data type. The result of the operation can either be True or False. The following MOs are defined:</t>
        <dl spacing="normal">
          <dt>equal:</dt><dd>The match result is True if the field value in the packet matches the TV.</dd>
          <dt>ignore:</dt><dd>No matching is attempted between the
	  field value in the packet and the TV in the Rule. The result
	  is always True.</dd>

	  
          <dt>MSB(x):</dt><dd>A match is obtained if the most significant (leftmost) x bits of the packet header field value are equal to the TV in the Rule. The x parameter of the MSB MO indicates how many bits are involved in the comparison. If the FL is described as variable, the x parameter must be a multiple of the FL unit. For example, x must be multiple of 8 if the unit of the variable length is bytes.</dd>
          <dt>match-mapping:</dt><dd>With match-mapping, TV is a list of values. Each value of the list is identified by an index. Compression is achieved by sending the index instead of the original header field value. This operator matches if the header field value is equal to one of the values in the target list.</dd>
        </dl>
      </section>
      <section anchor="chap-CDA" numbered="true" toc="default">
        <name>Compression/Decompression Actions (CDA)</name>
        <t>The CDA specifies the actions taken during the compression of header fields and the inverse action taken by the decompressor to restore the original value.
        The CDAs defined by this document are described in detail in <xref target="NotSentCDA" format="default"/> to <xref target="compute-" format="default"/>.
        They are summarized in <xref target="Fig-function" format="default"/>.</t>
        <table anchor="Fig-function" align="center">
          <name>Compression and Decompression Actions</name>
          <thead>
            <tr>
              <th align="left">Action</th>
              <th align="left">Compression</th>
              <th align="left">Decompression</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">not-sent</td>
              <td align="left">elided</td>
              <td align="left">use TV stored in Rule</td>
            </tr>
            <tr>
              <td align="left">value-sent</td>
              <td align="left">send</td>
              <td align="left">use received value</td>
            </tr>
            <tr>
              <td align="left">mapping-sent</td>
              <td align="left">send index</td>
              <td align="left">retrieve value from TV list</td>
            </tr>
            <tr>
              <td align="left">LSB</td>
              <td align="left">send least significant bits (LSB)</td>
              <td align="left">concatenate TV and received value</td>
            </tr>
            <tr>
              <td align="left">compute-*</td>
              <td align="left">elided</td>
              <td align="left">recompute at decompressor</td>
            </tr>
            <tr>
              <td align="left">DevIID</td>
              <td align="left">elided</td>
              <td align="left">build IID from L2 Dev addr</td>
            </tr>
            <tr>
              <td align="left">AppIID</td>
              <td align="left">elided</td>
              <td align="left">build IID from L2 App addr</td>
            </tr>
          </tbody>
        </table>
        <t>The first column shows the action's name. The second and third columns show the compression and decompression behaviors for each action.</t>
        <section anchor="fixed-length-field" numbered="true" toc="default">
          <name>Processing Fixed-Length Fields</name>
          <t>If the field is identified in the Field Descriptor as being of fixed length, then applying the CDA to compress this field results in a fixed amount of bits.
The residue for that field is simply the bits resulting from applying the CDA to the field.
This value may be empty (e.g., not-sent CDA), in which case the field residue is absent from the Compression Residue.</t>
          <figure anchor="Fig-FieldResFixLength">
            <name>Fixed-Size Field Residue Structure</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
|- field residue -|
+-----------------+
|      value      |
+-----------------+]]></artwork>
          </figure>
        </section>
        <section anchor="var-length-field" numbered="true" toc="default">
          <name>Processing Variable-Length Fields</name>
          <t>If the field is identified in the Field Descriptor as being of variable length,
then applying the CDA to compress this field may result in a value of fixed size
(e.g., not-sent or mapping-sent)
or of variable size (e.g., value-sent or LSB).
In the latter case, the residue for that field is the bits that result from applying the CDA to the field, preceded with the size of the value.
The most significant bit of the size is stored to the left (leftmost bit of the residue field).</t>
          <figure anchor="Fig-FieldResVarLength">
            <name>Variable-Size Field Residue Structure</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
|--- field residue ---|
+-------+-------------+
|  size |    value    |
+-------+-------------+]]></artwork>
          </figure>
          <t>The size (using the unit defined in the FL) is encoded on 4, 12, or 28 bits as follows:</t>
          <ul spacing="normal">
            <li>If the size is between 0 and 14, it is encoded as a 4-bit unsigned integer.</li>
            <li>Sizes between 15 and 254 are encoded as 0b1111 followed by the 8-bit unsigned integer.</li>
            <li>Larger sizes are encoded as 0xfff followed by the 16-bit unsigned integer.</li>
          </ul>
          <t>If the field is identified in the Field Descriptor as being of variable length and this field is not present in the packet header being compressed, size 0 <bcp14>MUST</bcp14> be sent to denote its absence.</t>
        </section>
        <section anchor="NotSentCDA" numbered="true" toc="default">
          <name>Not-Sent CDA</name>
          <t>The not-sent action can be used when the field value is
	  specified in a Rule and, therefore, known by both the
	  Compressor and the Decompressor. This action
	  <bcp14>SHOULD</bcp14> be used with the "equal" MO. If MO is
	  "ignore", there is a risk of having a decompressed field
	  value that is different from the original field that was compressed.</t>
          <t>The compressor does not send any residue for a field on which not-sent compression is applied.</t>
          <t>The decompressor restores the field value with the TV stored in the matched Rule identified by the received RuleID.</t>
        </section>
        <section anchor="value-sent-cda" numbered="true" toc="default">
          <name>Value-Sent CDA</name>
          <t>The value-sent action can be used when the field value is not known by both the Compressor and the Decompressor. The field is sent in its entirety, using the same bit order as in the original packet header.</t>
          <t>If this action is performed on a variable-length field, the size of the residue value (using the units defined in FL) <bcp14>MUST</bcp14> be sent as described in <xref target="var-length-field" format="default"/>.</t>
          <t>This action is generally used with the "ignore" MO.</t>
        </section>
        <section anchor="mapping-sent-cda" numbered="true" toc="default">
          <name>Mapping-Sent CDA</name>
          <t>The mapping-sent action is used to send an index (the index into the TV list of values) instead of the original value. This action is used together with the "match-mapping" MO.</t>
          <t>On the compressor side, the match-mapping MO searches the TV for a match with the header field value. The mapping-sent CDA then sends the corresponding index as the field residue.
The most significant bit of the index is stored to the left (leftmost bit of the residue field).</t>
          <t>On the decompressor side, the CDA uses the received index to restore the field value by looking up the list in the TV.</t>
          <t>The number of bits sent is the minimal size for coding all the possible indices.</t>
          <t>The first element in the list <bcp14>MUST</bcp14> be represented by index value 0, and successive elements in the list <bcp14>MUST</bcp14> have indices incremented by 1.</t>
        </section>
        <section anchor="lsb-cda" numbered="true" toc="default">
          <name>LSB CDA</name>
          <t>The LSB action is used together with the "MSB(x)" MO to avoid sending the most significant part of the packet field if that part is already known by the receiving end.</t>
          <t>The compressor sends the LSBs as the field residue value.
The number of bits sent is the original header field length minus the length specified in the MSB(x) MO.
The bits appear in the residue in the same bit order as in the original packet header.</t>
          <t>The decompressor concatenates the x most significant bits
	  of the TV and the received residue value.</t>
          <t>If this action is performed on a variable-length field, the size of the residue value (using the units defined in FL) <bcp14>MUST</bcp14> be sent as described in <xref target="var-length-field" format="default"/>.</t>
        </section>
        <section anchor="deviid-appiid-cda" numbered="true" toc="default">
          <name>DevIID, AppIID CDA</name>
          <t>These actions are used to process the DevIID and AppIID of the IPv6 addresses, respectively. AppIID CDA is less common since most current LPWAN technologies frames contain a single L2 address, which is the Dev's address.</t>
          <t>The DevIID value <bcp14>MAY</bcp14> be computed from the Dev ID present in the L2 header, or from some other stable identifier. The computation is specific to each Profile and <bcp14>MAY</bcp14> depend on the Dev ID size.</t>
          <t>In the Downlink direction, at the compressor, the DevIID CDA may be used to generate the L2 addresses on the LPWAN, based on the packet's Destination Address.</t>
        </section>
        <section anchor="compute-" numbered="true" toc="default">
          <name>Compute-*</name>
          <t>Some fields can be elided at the compressor and recomputed locally at the decompressor.</t>
          <t>Because the field is uniquely identified by its FID (e.g., IPv6 length), the relevant protocol specification unambiguously defines the algorithm for such computation.</t>
          <t>An example of a field that knows how to recompute itself is IPv6 length.</t>
        </section>
      </section>
    </section>
    <section anchor="Frag" numbered="true" toc="default">
      <name>Fragmentation/Reassembly</name>
      <section anchor="overview" numbered="true" toc="default">
        <name>Overview</name>
        <t>In LPWAN technologies, the L2 MTU typically ranges from tens to hundreds of bytes.
Some of these technologies do not have an internal fragmentation/reassembly mechanism.</t>
        <t>The optional SCHC F/R functionality enables such LPWAN technologies to comply with the IPv6 MTU requirement of 1280 bytes <xref target="RFC8200" format="default"/>.
It is <bcp14>OPTIONAL</bcp14> to implement per this specification, but Profiles may specify that it is <bcp14>REQUIRED</bcp14>.</t>
        <t>This specification includes several SCHC F/R modes, which allow for a range of reliability options such as optional SCHC Fragment retransmission.
More modes may be defined in the future.</t>
        <t>The same SCHC F/R mode <bcp14>MUST</bcp14> be used for all SCHC Fragments of a given SCHC Packet.
This document does not specify which mode(s) must be implemented and used over a specific LPWAN technology. That information will be given in Profiles.</t>
        <t>SCHC allows transmitting non-fragmented SCHC Packet concurrently with fragmented SCHC Packets.
In addition, SCHC F/R provides protocol elements that allow transmitting several fragmented SCHC Packets concurrently, i.e., interleaving the transmission of fragments from different fragmented SCHC Packets.
A Profile <bcp14>MAY</bcp14> restrict the latter behavior.</t>
        <t>The L2 Word size (see <xref target="Term" format="default"/>) determines the encoding of some messages.
SCHC F/R usually generates SCHC Fragments and SCHC ACKs that are multiples of L2 Words.</t>
      </section>
      <section anchor="FragTools" numbered="true" toc="default">
        <name>SCHC F/R Protocol Elements</name>
        <t>This subsection describes the different elements that are used to enable the SCHC F/R functionality defined in this document.
These elements include the SCHC F/R messages, tiles, windows, bitmaps, counters, timers, and header fields.</t>
        <t>The elements are described here in a generic manner. Their application to each SCHC F/R mode is found in <xref target="FragModes" format="default"/>.</t>
        <section anchor="messages" numbered="true" toc="default">
          <name>Messages</name>
          <t>SCHC F/R defines the following messages:</t>
          <dl spacing="normal">
            <dt>SCHC Fragment:</dt><dd>A message that carries part of a SCHC Packet from the sender to the receiver.</dd>
            <dt>SCHC ACK:</dt><dd>An acknowledgement for fragmentation, by the receiver to the sender.
This message is used to indicate whether or not the reception of pieces of,
or the whole of, the fragmented SCHC Packet was successful.</dd>
            <dt>SCHC ACK REQ:</dt><dd>A request by the sender for a SCHC ACK from the receiver.</dd>
            <dt>SCHC Sender-Abort:</dt><dd>A message by the sender telling the receiver that it has aborted the transmission of a fragmented SCHC Packet.</dd>
            <dt>SCHC Receiver-Abort:</dt><dd>A message by the receiver to tell the sender to abort the transmission of a fragmented SCHC Packet.</dd>
          </dl>
          <t>The format of these messages is provided in <xref target="Fragfor" format="default"/>.</t>
        </section>
        <section anchor="OtherTools" numbered="true" toc="default">
          <name>Tiles, Windows, Bitmaps, Timers, Counters</name>
          <section anchor="tiles" numbered="true" toc="default">
            <name>Tiles</name>
            <t>The SCHC Packet is fragmented into pieces, hereafter called "tiles".
The tiles <bcp14>MUST</bcp14> be non-empty and pairwise disjoint.
Their union <bcp14>MUST</bcp14> be equal to the SCHC Packet.</t>
            <t>See <xref target="Fig-TilesExample" format="default"/> for an example.</t>
            <figure anchor="Fig-TilesExample">
              <name>SCHC Packet Fragmented in Tiles</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[
                                SCHC Packet
        +----+--+-----+---+----+-+---+-----+...-----+----+---+------+
Tiles   |    |  |     |   |    | |   |     |        |    |   |      |
        +----+--+-----+---+----+-+---+-----+...-----+----+---+------+]]></artwork>
            </figure>
            <t>Modes (see <xref target="FragModes" format="default"/>) <bcp14>MAY</bcp14> place additional constraints on tile sizes.</t>
            <t>Each SCHC Fragment message carries at least one tile in its Payload, if the Payload field is present.</t>
          </section>
          <section anchor="Windows" numbered="true" toc="default">
            <name>Windows</name>
            <t>Some SCHC F/R modes may handle successive tiles in groups, called windows.</t>
            <t>If windows are used:</t>
            <ul spacing="normal">
              <li>all the windows of a SCHC Packet, except the last one, <bcp14>MUST</bcp14> contain the same number of tiles.
This number is WINDOW_SIZE.</li>
              <li>WINDOW_SIZE <bcp14>MUST</bcp14> be specified in a Profile.</li>
              <li>the windows are numbered.</li>
              <li>their numbers <bcp14>MUST</bcp14> increment by 1 from 0 upward, from the start of the SCHC Packet to its end.</li>
              <li>the last window <bcp14>MUST</bcp14> contain WINDOW_SIZE tiles or less.</li>
              <li>tiles are numbered within each window.</li>
              <li>the tile indices <bcp14>MUST</bcp14> decrement by 1 from WINDOW_SIZE - 1 downward, looking from the start of the SCHC Packet toward its end.</li>
              <li>therefore, each tile of a SCHC Packet is uniquely identified by a window number and a tile index within this window.</li>
            </ul>
            <t>See <xref target="Fig-WindowsExample" format="default"/> for an example.</t>
            <figure anchor="Fig-WindowsExample">
              <name>SCHC Packet Fragmented in Tiles Grouped in 29 Windows, with WINDOW_SIZE = 5</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[
        +---------------------------------------------...-----------+
        |                       SCHC Packet                         |
        +---------------------------------------------...-----------+

Tile#   | 4 | 3 | 2 | 1 | 0 | 4 | 3 | 2 | 1 | 0 | 4 |     | 0 | 4 |3|
Window# |-------- 0 --------|-------- 1 --------|- 2  ... 27 -|- 28-|]]></artwork>
            </figure>
            <t><xref target="MultWinSizes" format="default"/> discusses the benefits of selecting one among multiple window sizes depending on the size of the SCHC Packet to be fragmented.</t>
            <t>When windows are used:</t>
            <ul spacing="normal">
              <li>Bitmaps (see <xref target="Bitmap" format="default"/>) <bcp14>MAY</bcp14> be sent back by the receiver to the sender in a SCHC ACK message.</li>
              <li>A Bitmap corresponds to exactly one Window.</li>
            </ul>
          </section>
          <section anchor="Bitmap" numbered="true" toc="default">
            <name>Bitmaps</name>
            <t>Each bit in the Bitmap for a window corresponds to a tile in the window.
Therefore, each Bitmap has WINDOW_SIZE bits.
The bit at the leftmost position corresponds to the tile numbered WINDOW_SIZE - 1.
Consecutive bits, going right, correspond to sequentially decreasing tile indices.
In Bitmaps for windows that are not the last one of a SCHC Packet,
the bit at the rightmost position corresponds to the tile numbered 0.
In the Bitmap for the last window,
the bit at the rightmost position corresponds either to the tile numbered 0 or to a tile that is sent/received as "the last one of the SCHC Packet" without explicitly stating its number (see <xref target="LastFrag" format="default"/>).</t>
            <t>At the receiver:</t>
            <ul spacing="normal">
              <li>a bit set to 1 in the Bitmap indicates that a tile associated with that bit position has been correctly received for that window.</li>
              <li>a bit set to 0 in the Bitmap indicates that there has been no tile correctly received, associated with that bit position, for that window.
Possible reasons include that the tile was not sent at all, not received, or received with errors.</li>
            </ul>
          </section>
          <section anchor="MiscTools" numbered="true" toc="default">
            <name>Timers and Counters</name>
            <t>Some SCHC F/R modes can use the following timers and counters:</t>
            <dl spacing="normal">
              <dt>Inactivity Timer:</dt><dd>a SCHC Fragment receiver uses this timer to abort waiting for a SCHC F/R message.</dd>
              <dt>Retransmission Timer:</dt><dd>a SCHC Fragment sender uses this timer to abort waiting for an expected SCHC ACK.</dd>
              <dt>Attempts:</dt><dd>this counter counts the requests for SCHC ACKs, up to MAX_ACK_REQUESTS.</dd>
            </dl>
          </section>
        </section>
        <section anchor="IntegrityChecking" numbered="true" toc="default">
          <name>Integrity Checking</name>
          <t>The integrity of the fragmentation-reassembly process of a SCHC Packet <bcp14>MUST</bcp14> be checked at the receive end.
A Profile <bcp14>MUST</bcp14> specify how integrity checking is performed.</t>
          <t>It is <bcp14>RECOMMENDED</bcp14> that integrity checking be performed by computing a Reassembly Check Sequence (RCS)
based on the SCHC Packet at the sender side
and transmitting it to the receiver for comparison with the RCS locally computed after reassembly.</t>
          <t>The RCS supports UDP checksum elision by SCHC C/D (see <xref target="UDPchecksum" format="default"/>).</t>
          <t>The CRC32 polynomial 0xEDB88320 (i.e., the reversed polynomial representation, which is
used in the Ethernet standard <xref target="ETHERNET" format="default"/>) is <bcp14>RECOMMENDED</bcp14> as the default algorithm for computing the
RCS.</t>
          <t>The RCS <bcp14>MUST</bcp14> be computed on the full SCHC Packet concatenated with the padding bits, if any, of the SCHC Fragment carrying the last tile.
The rationale is that the SCHC reassembler has no way of knowing the boundary between the last tile and the padding bits.
Indeed, this requires decompressing the SCHC Packet, which is out of the scope of the SCHC reassembler.</t>
          <t>The concatenation of the complete SCHC Packet and any padding bits, if present, of the last SCHC Fragment does not
generally constitute an integer number of bytes.
CRC libraries are usually byte oriented.
It is <bcp14>RECOMMENDED</bcp14> that the concatenation of the
complete SCHC Packet and any last fragment padding bits be zero-extended to the next byte boundary and
that the RCS be computed on that byte array.</t>
        </section>
        <section anchor="HeaderFields" numbered="true" toc="default">
          <name>Header Fields</name>
          <t>The SCHC F/R messages contain the following fields (see the formats in <xref target="Fragfor" format="default"/>):</t>
          <dl spacing="normal">
            
              <dt>RuleID:</dt><dd><t>this field is present in all the SCHC F/R messages. The Rule identifies:</t>
              <ul spacing="normal">
                <li>that a SCHC F/R message is being carried, as opposed to an unfragmented SCHC Packet,</li>
                <li>which SCHC F/R mode is used,</li>
                <li>in case this mode uses windows, what the value of
		WINDOW_SIZE is, and</li>
                <li>what other optional fields are present and what the field sizes are.</li>
              </ul>
              <t>
The Rule tells apart a non-fragmented SCHC Packet from SCHC Fragments.
It will also tell apart SCHC Fragments of fragmented SCHC Packets that use different SCHC F/R modes or different parameters.
Therefore, interleaved transmission of these is possible.  </t>
              <t>
All SCHC F/R messages pertaining to the same SCHC Packet <bcp14>MUST</bcp14> bear the same RuleID.</t>
            </dd>
            
              <dt>Datagram Tag (DTag):</dt><dd><t>This field allows differentiating SCHC F/R messages belonging to different SCHC Packets
that may be using the same RuleID simultaneously.
Hence, it allows interleaving fragments of a new SCHC Packet with fragments of a previous SCHC Packet under the same RuleID.  </t>
              <t>
The size of the DTag field (called "T", in bits) is defined by each Profile for each RuleID.
When T is 0, the DTag field does not appear in the SCHC F/R messages and the DTag value is defined as 0.  </t>
              <t>
When T is 0, there can be no more than one fragmented SCHC Packet in transit for each fragmentation RuleID.  </t>
              <t>
	      If T is not 0, DTag:  </t>

	      
              <ul spacing="normal">
                <li><bcp14>MUST</bcp14> be set to the same value for all the SCHC F/R messages related to the same fragmented SCHC Packet, and</li>
                <li><bcp14>MUST</bcp14> be set to different values for SCHC F/R messages related to different SCHC Packets that are being fragmented under the same RuleID and whose transmission may overlap.</li>
              </ul>
            </dd>
            
              <dt>W:</dt><dd><t>The W field is optional. It is only present if windows are used.
Its presence and size (called "M", in bits) is defined by each SCHC F/R mode and each Profile for each RuleID.  </t>
              <t>
This field carries information pertaining to the window a SCHC F/R message relates to.
If present, W <bcp14>MUST</bcp14> carry the same value for all the SCHC F/R messages related to the same window.
Depending on the mode and Profile, W may carry the full window number, or just the LSB or any other partial representation of the window number.</t>
            </dd>
            
              <dt>Fragment Compressed Number (FCN):</dt><dd><t>The FCN field is present in the SCHC Fragment Header.
Its size (called "N", in bits) is defined by each Profile for each RuleID.  </t>
              <t>
This field conveys information about the progress in the sequence of tiles being transmitted by SCHC Fragment messages.
For example, it can contain a partial, efficient representation of a larger-sized tile index.
The description of the exact use of the FCN field is left to each SCHC F/R mode.
However, two values are reserved for special purposes. They help control the SCHC F/R process:  </t>
              <ul spacing="normal">
                <li>The FCN value with all the bits equal to 1 (called "All-1") signals that the very last tile of a SCHC Packet has been transmitted.
By extension, if windows are used, the last window of a packet is called the "All-1" window.</li>
                <li>If windows are used, the FCN value with all the bits equal to 0 (called "All-0") signals
the last tile of a window that is not the last one of the SCHC packet.
By extension, such a window is called an "All-0 window".</li>
              </ul>
            </dd>
            
              <dt>Reassembly Check Sequence (RCS):</dt><dd><t>This field only appears in the All-1 SCHC Fragments.
Its size (called "U", in bits) is defined by each Profile for each RuleID.  </t>
              <t>
See <xref target="IntegrityChecking" format="default"/> for the RCS default size, default polynomial and details on RCS computation.</t>
            </dd>
            
              <dt>C (integrity Check):</dt><dd><t>C is a 1-bit field.
This field is used in the SCHC ACK message to report on the reassembled SCHC Packet integrity check (see <xref target="IntegrityChecking" format="default"/>).  </t>
              <t>
A value of 1 tells that the integrity check was performed and is successful.
A value of 0 tells that the integrity check was not performed or that it was a failure.</t>
            </dd>
            
              <dt>Compressed Bitmap:</dt><dd><t>The Compressed Bitmap is used together with windows and Bitmaps (see <xref target="Bitmap" format="default"/>).
Its presence and size is defined for each SCHC F/R mode for each RuleID.  </t>
              <t>
This field appears in the SCHC ACK message to report on the receiver Bitmap (see <xref target="BitmapTrunc" format="default"/>).</t>
            </dd>
          </dl>
        </section>
      </section>
      <section anchor="Fragfor" numbered="true" toc="default">
        <name>SCHC F/R Message Formats</name>
        <t>This section defines the SCHC Fragment formats, the SCHC ACK format, the SCHC ACK REQ format and the SCHC Abort formats.</t>
        <section anchor="schc-fragment-format" numbered="true" toc="default">
          <name>SCHC Fragment Format</name>
          <t>A SCHC Fragment conforms to the general format shown in <xref target="Fig-FragFormat" format="default"/>.
It comprises a SCHC Fragment Header and a SCHC Fragment Payload.
The SCHC Fragment Payload carries one or several tile(s).</t>
          <figure anchor="Fig-FragFormat">
            <name>SCHC Fragment General Format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
+-----------------+-----------------------+~~~~~~~~~~~~~~~~~~~~~
| Fragment Header | Fragment Payload      | padding (as needed)
+-----------------+-----------------------+~~~~~~~~~~~~~~~~~~~~~]]></artwork>
          </figure>


	  
          <section anchor="NotLastFrag" numbered="true" toc="default">
            <name>Regular SCHC Fragment</name>
            <t>The Regular SCHC Fragment format is shown in <xref target="Fig-NotLastFrag" format="default"/>.
Regular SCHC Fragments are generally used to carry tiles that are not the last one of a SCHC Packet.
The DTag field and the W field are <bcp14>OPTIONAL</bcp14>, their presence is specified by each mode and Profile.</t>
            <figure anchor="Fig-NotLastFrag">
              <name>Detailed Header Format for Regular SCHC Fragments</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[
|-- SCHC Fragment Header ----|
         |-- T --|-M-|-- N --|
+-- ... -+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~
| RuleID | DTag  | W |  FCN  | Fragment Payload | padding (as needed)
+-- ... -+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~]]></artwork>
            </figure>
            <t>The FCN field <bcp14>MUST NOT</bcp14> contain all bits set to 1.</t>
            <t>Profiles <bcp14>MUST</bcp14> ensure that
a SCHC Fragment with FCN equal to 0 (called an "All-0 SCHC Fragment") is distinguishable by size,
even in the presence of padding,
from a SCHC ACK REQ message (see <xref target="ACKREQ" format="default"/>) with the same RuleID value and with the same T, M, and N values.
This condition is met if the Payload is at least the size of an L2 Word.
This condition is also met if the SCHC Fragment Header is a multiple of L2 Words.</t>
          </section>
          <section anchor="LastFrag" numbered="true" toc="default">
            <name>All-1 SCHC Fragment</name>
            <t>The All-1 SCHC Fragment format is shown in <xref target="Fig-LastFrag" format="default"/>.
The sender uses the All-1 SCHC Fragment format for the message that completes the emission of a fragmented SCHC Packet.
The DTag field, the W field, the RCS field and the Payload are <bcp14>OPTIONAL</bcp14>, their presence is specified by each mode and Profile.
At least one of RCS field or Fragment Payload <bcp14>MUST</bcp14> be present.
The FCN field is all ones.</t>
            <figure anchor="Fig-LastFrag">
              <name>Detailed Header Format for the All-1 SCHC Fragment</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[
|------- SCHC Fragment Header -------|
         |-- T --|-M-|-- N --|-- U --|
+-- ... -+- ... -+---+- ... -+- ... -+-----...-----+~~~~~~~~~~~~~~~~~
| RuleID | DTag  | W | 11..1 |  RCS  | FragPayload | pad. (as needed)
+-- ... -+- ... -+---+- ... -+- ... -+-----...-----+~~~~~~~~~~~~~~~~~
                       (FCN)]]></artwork>
            </figure>
            <t>Profiles <bcp14>MUST</bcp14> ensure that
an All-1 SCHC Fragment message is distinguishable by size,
even in the presence of padding,
from a SCHC Sender-Abort message (see <xref target="SenderAbort" format="default"/>) with the same RuleID value and with the same T, M, and N values.
This condition is met if the RCS is present and is at least the size of an L2 Word
or if the Payload is present and is at least the size an L2 Word.
This condition is also met if the SCHC Sender-Abort Header is a multiple of L2 Words.</t>
          </section>
        </section>
        <section anchor="ACK" numbered="true" toc="default">
          <name>SCHC ACK Format</name>
          <t>The SCHC ACK message is shown in <xref target="Fig-ACK-Format" format="default"/>.
The DTag field and the W field are <bcp14>OPTIONAL</bcp14>, their presence is specified by each mode and Profile.
The Compressed Bitmap field <bcp14>MUST</bcp14> be present in SCHC F/R modes that use windows and <bcp14>MUST NOT</bcp14> be present in other modes.</t>
          <figure anchor="Fig-ACK-Format">
            <name>Format of the SCHC ACK Message</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
|--- SCHC ACK Header ----|
         |-- T --|-M-| 1 |
+-- ... -+- ... -+---+---+~~~~~~~~~~~~~~~~~~
| RuleID |  DTag | W |C=1| padding as needed                (success)
+-- ... -+- ... -+---+---+~~~~~~~~~~~~~~~~~~

+-- ... -+- ... -+---+---+------ ... ------+~~~~~~~~~~~~~~~
| RuleID |  DTag | W |C=0|Compressed Bitmap| pad. as needed (failure)
+-- ... -+- ... -+---+---+------ ... ------+~~~~~~~~~~~~~~~]]></artwork>
          </figure>
          <t>The SCHC ACK Header contains a C bit (see <xref target="HeaderFields" format="default"/>).</t>
          <t>If the C bit is set to 1 (integrity check successful),
no Bitmap is carried.</t>
          <t>If the C bit is set to 0 (integrity check not performed or failed) and if windows are used,
a Compressed Bitmap for the window referred to by the W field is transmitted
as specified in <xref target="BitmapTrunc" format="default"/>.</t>
          <section anchor="BitmapTrunc" numbered="true" toc="default">
            <name>Bitmap Compression</name>
            <t>For transmission, the Compressed Bitmap in the SCHC ACK message is defined by the following algorithm (see <xref target="Fig-Localbitmap" format="default"/> for a follow-along example):</t>
            <ul spacing="normal">
              <li>Build a temporary SCHC ACK message that contains the Header followed by the original Bitmap
 (see <xref target="Bitmap" format="default"/> for a description of Bitmaps).</li>
              <li>Position scissors at the end of the Bitmap, after
	      its last bit.</li>

              <li>While the bit on the left of the scissors is 1 and belongs to the Bitmap, keep moving left, then stop.</li>
              <li>Then, while the scissors are not on an L2 Word boundary of the SCHC ACK message and there is a Bitmap bit on the right of the scissors, keep moving right, then stop.</li>
              <li>At this point, cut and drop off any bits to the right of the scissors.</li>
            </ul>
            <t>When one or more bits have effectively been dropped off as a result of the above algorithm, the SCHC ACK message is a multiple of L2 Words; no padding bits will be appended.</t>
            <t>Because the SCHC Fragment sender knows the size of the original Bitmap, it can reconstruct the original Bitmap from the Compressed Bitmap received in the SCHC ACK message.</t>
            <t><xref target="Fig-Localbitmap" format="default"/> shows an example where L2 Words are actually bytes and where the original Bitmap contains 17 bits, the last 15 of which are all set to 1.</t>
            <figure anchor="Fig-Localbitmap">
              <name>SCHC ACK Header Plus Uncompressed Bitmap</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[
|--- SCHC ACK Header ----|--------      Bitmap     --------|
         |-- T --|-M-| 1 |
+-- ... -+- ... -+---+---+---------------------------------+
| RuleID |  DTag | W |C=0|1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1|
+-- ... -+- ... -+---+---+---------------------------------+
       next L2 Word boundary ->|]]></artwork>
            </figure>
            <t><xref target="Fig-transmittedbitmap" format="default"/> shows that the last 14 bits are not sent.</t>
            <figure anchor="Fig-transmittedbitmap">
              <name>Resulting SCHC ACK Message with Compressed Bitmap</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[
|--- SCHC ACK Header ----|CpBmp|
         |-- T --|-M-| 1 |
+-- ... -+- ... -+---+---+-----+
| RuleID |  DTag | W |C=0|1 0 1|
+-- ... -+- ... -+---+---+-----+
       next L2 Word boundary ->|]]></artwork>
            </figure>
            <t><xref target="Fig-Bitmap-Win" format="default"/> shows an example of a SCHC ACK with tile indices ranging from 6 down to 0, where the Bitmap indicates that the second and the fourth tile of the window have not been correctly received.</t>
            <figure anchor="Fig-Bitmap-Win">
              <name>Example of a SCHC ACK Message, Missing Tiles</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[
|--- SCHC ACK Header ----|--- Bitmap --|
         |-- T --|-M-| 1 |6 5 4 3 2 1 0| (tile #)
+--------+-------+---+---+-------------+
| RuleID |  DTag | W |C=0|1 0 1 0 1 1 1|     uncompressed Bitmap
+--------+-------+---+---+-------------+
   next L2 Word boundary ->|<-- L2 Word --->|

+--------+-------+---+---+-------------+~~~~+
| RuleID |  DTag | W |C=0|1 0 1 0 1 1 1|pad.| transmitted SCHC ACK
+--------+-------+---+---+-------------+~~~~+
   next L2 Word boundary ->|<-- L2 Word --->|]]></artwork>
            </figure>
            <t><xref target="Fig-Bitmap-lastWin" format="default"/> shows an example of a SCHC ACK with tile indices ranging from 6 down to 0, where integrity check has not been performed or has failed and the Bitmap indicates that there is no missing tile in that window.</t>
            <figure anchor="Fig-Bitmap-lastWin">
              <name>Example of a SCHC ACK Message, No Missing Tile</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[
|--- SCHC ACK Header ----|--- Bitmap --|
         |-- T --|-M-| 1 |6 5 4 3 2 1 0| (tile #)
+--------+-------+---+---+-------------+
| RuleID |  DTag | W |C=0|1 1 1 1 1 1 1|  with uncompressed Bitmap
+--------+-------+---+---+-------------+
   next L2 Word boundary ->|

+-- ... -+- ... -+---+---+-+
| RuleID |  DTag | W |C=0|1|                  transmitted SCHC ACK
+-- ... -+- ... -+---+---+-+
   next L2 Word boundary ->|]]></artwork>
            </figure>
          </section>
        </section>
        <section anchor="ACKREQ" numbered="true" toc="default">
          <name>SCHC ACK REQ Format</name>
          <t>The SCHC ACK REQ is used by a sender to request a SCHC ACK from the receiver.
Its format is shown in <xref target="Fig-ACKREQ" format="default"/>.
The DTag field and the W field are <bcp14>OPTIONAL</bcp14>, their presence is specified by each mode and Profile.
The FCN field is all zero.</t>
          <figure anchor="Fig-ACKREQ">
            <name>SCHC ACK REQ Format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
|--- SCHC ACK REQ Header ----|
         |-- T --|-M-|-- N --|
+-- ... -+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~
| RuleID | DTag  | W |  0..0 | padding (as needed)      (no payload)
+-- ... -+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~]]></artwork>
          </figure>
        </section>
        <section anchor="SenderAbort" numbered="true" toc="default">
          <name>SCHC Sender-Abort Format</name>
          <t>When a SCHC Fragment sender needs to abort an ongoing fragmented SCHC Packet transmission, it sends a SCHC Sender-Abort message to the SCHC Fragment receiver.</t>
          <t>The SCHC Sender-Abort format is shown in <xref target="Fig-SenderAbort" format="default"/>.
The DTag field and the W field are <bcp14>OPTIONAL</bcp14>, their presence is specified by each mode and Profile.
The FCN field is all ones.</t>
          <figure anchor="Fig-SenderAbort">
            <name>SCHC Sender-Abort Format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
|--- Sender-Abort Header ----|
         |-- T --|-M-|-- N --|
+-- ... -+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~
| RuleID | DTag  | W | 11..1 | padding (as needed)
+-- ... -+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~]]></artwork>
          </figure>
          <t>If the W field is present:</t>
          <ul spacing="normal">
            <li>the fragment sender <bcp14>MUST</bcp14> set it to all ones.
Other values are RESERVED.</li>
            <li>the fragment receiver <bcp14>MUST</bcp14> check its value.
If the value is different from all ones, the message <bcp14>MUST</bcp14> be ignored.</li>
          </ul>
          <t>The SCHC Sender-Abort <bcp14>MUST NOT</bcp14> be acknowledged.</t>
        </section>
        <section anchor="schc-receiver-abort-format" numbered="true" toc="default">
          <name>SCHC Receiver-Abort Format</name>
          <t>When a SCHC Fragment receiver needs to abort an ongoing fragmented SCHC Packet transmission, it transmits a SCHC Receiver-Abort message to the SCHC Fragment sender.</t>
          <t>The SCHC Receiver-Abort format is shown in <xref target="Fig-ReceiverAbort" format="default"/>.
The DTag field and the W field are <bcp14>OPTIONAL</bcp14>, their presence is specified by each mode and Profile.</t>
          <figure anchor="Fig-ReceiverAbort">
            <name>SCHC Receiver-Abort Format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
|-- Receiver-Abort Header ---|
           |--- T ---|-M-| 1 |
+--- ... --+-- ... --+---+---+-+-+-+-+-+-+-+-+-+-+-+
|  RuleID  |   DTag  | W |C=1| 1..1|      1..1     |
+--- ... --+-- ... --+---+---+-+-+-+-+-+-+-+-+-+-+-+
           next L2 Word boundary ->|<-- L2 Word -->|]]></artwork>
          </figure>
          <t>If the W field is present:</t>
          <ul spacing="normal">
            <li>the fragment receiver <bcp14>MUST</bcp14> set it to all ones.
Other values are RESERVED.</li>
            <li>if the value is different from all ones, the fragment sender <bcp14>MUST</bcp14> ignore the message.</li>
          </ul>
          <t>The SCHC Receiver-Abort has the same header as a SCHC ACK message.
The bits that follow the SCHC Receiver-Abort Header <bcp14>MUST</bcp14> be as follows:</t>
          <ul spacing="normal">
            <li>if the Header does not end at an L2 Word boundary, append bits set to 1 as needed to reach the next L2 Word boundary.</li>
            <li>append exactly one more L2 Word with bits all set to ones.</li>
          </ul>
          <t>Such a bit pattern never occurs in a legitimate SCHC ACK. This is how the fragment sender recognizes a SCHC Receiver-Abort.</t>
          <t>The SCHC Receiver-Abort <bcp14>MUST NOT</bcp14> be acknowledged.</t>
        </section>
      </section>
      <section anchor="FragModes" numbered="true" toc="default">
        <name>SCHC F/R Modes</name>
        <t>This specification includes several SCHC F/R modes that:</t>
        <ul spacing="normal">
          <li>allow for a range of reliability options, such as optional SCHC Fragment retransmission.</li>
          <li>support various LPWAN characteristics, such as links with variable MTU or unidirectional links.</li>
        </ul>
        <t>More modes may be defined in the future.</t>
        <t><xref target="FragExamples" format="default"/> provides examples of fragmentation sessions based on the modes described hereafter.</t>
        <t><xref target="FSM" format="default"/> provides examples of Finite State Machines implementing the SCHC F/R modes described hereafter.</t>
        <section anchor="No-ACK-subsection" numbered="true" toc="default">
          <name>No-ACK Mode</name>
          <t>The No-ACK mode has been designed under the assumption that data unit out-of-sequence delivery does not occur between the entity performing fragmentation and the entity performing reassembly.
This mode supports L2 technologies that have a variable MTU.</t>
          <t>In No-ACK mode, there is no communication from the fragment receiver to the fragment sender.
The sender transmits all the SCHC Fragments without expecting any acknowledgement.
Therefore, No-ACK does not require bidirectional links: unidirectional links are just fine.</t>
          <t>In No-ACK mode, only the All-1 SCHC Fragment is padded as needed. The other SCHC Fragments are intrinsically aligned to L2 Words.</t>
          <t>The tile sizes are not required to be uniform.
Windows are not used.
The Retransmission Timer is not used.
The Attempts counter is not used.</t>
          <t>Each Profile <bcp14>MUST</bcp14> specify which RuleID value(s) corresponds to SCHC F/R messages operating in this mode.</t>
          <t>The W field <bcp14>MUST NOT</bcp14> be present in the SCHC F/R messages.
SCHC ACK <bcp14>MUST NOT</bcp14> be sent.
SCHC ACK REQ <bcp14>MUST NOT</bcp14> be sent.
SCHC Sender-Abort <bcp14>MAY</bcp14> be sent.
SCHC Receiver-Abort <bcp14>MUST NOT</bcp14> be sent.</t>
          <t>The value of N (size of the FCN field) is <bcp14>RECOMMENDED</bcp14> to be 1.</t>
          <t>Each Profile, for each RuleID value, <bcp14>MUST</bcp14> define:</t>
          <ul spacing="normal">
            <li>the size of the DTag field,</li>
            <li>the size and algorithm for the RCS field, and</li>
            <li>the expiration time of the Inactivity Timer.</li>
          </ul>
          <t>Each Profile, for each RuleID value, <bcp14>MAY</bcp14> define</t>
          <ul spacing="normal">
            <li>a value of N different from the recommended one, and</li>
            <li>the meaning of values sent in the FCN field, for values different from the All-1 value.</li>
          </ul>
          <t>For each active pair of RuleID and DTag values, the receiver <bcp14>MUST</bcp14> maintain an Inactivity Timer.
If the receiver is under-resourced to do this, it <bcp14>MUST</bcp14> silently drop the related messages.</t>
          <section anchor="sender-behavior" numbered="true" toc="default">
            <name>Sender Behavior</name>
            <t>At the beginning of the fragmentation of a new SCHC Packet, the fragment sender <bcp14>MUST</bcp14> select a RuleID and DTag value pair for this SCHC Packet.</t>
            <t>Each SCHC Fragment <bcp14>MUST</bcp14> contain exactly one tile in its Payload.
The tile <bcp14>MUST</bcp14> be at least the size of an L2 Word.
The sender <bcp14>MUST</bcp14> transmit the SCHC Fragments messages in the order that the tiles appear in the SCHC Packet.
Except for the last tile of a SCHC Packet, each tile <bcp14>MUST</bcp14> be of a size
that complements the SCHC Fragment Header so
that the SCHC Fragment is a multiple of L2 Words without the need for padding bits.
Except for the last one, the SCHC Fragments <bcp14>MUST</bcp14> use the Regular SCHC Fragment format specified in <xref target="NotLastFrag" format="default"/>.
The SCHC Fragment that carries the last tile <bcp14>MUST</bcp14> be an All-1 SCHC Fragment, described in <xref target="LastFrag" format="default"/>.</t>
            <t>The sender <bcp14>MAY</bcp14> transmit a SCHC Sender-Abort.</t>
            <t><xref target="Fig-NoACKModeSnd" format="default"/> shows an example of a corresponding state machine.</t>
          </section>
          <section anchor="receiver-behavior" numbered="true" toc="default">
            <name>Receiver Behavior</name>
            <t>Upon receiving each Regular SCHC Fragment:</t>
            <ul spacing="normal">
              <li>the receiver <bcp14>MUST</bcp14> reset the Inactivity Timer.</li>
              <li>the receiver assembles the payloads of the SCHC Fragments.</li>
            </ul>
            <t>On receiving an All-1 SCHC Fragment:</t>
            <ul spacing="normal">
              <li>the receiver <bcp14>MUST</bcp14> append the All-1 SCHC Fragment Payload and the padding bits to the
previously received SCHC Fragment Payloads for this SCHC Packet.</li>
              <li>the receiver <bcp14>MUST</bcp14> perform the integrity check.</li>
              <li>if integrity checking fails,
  the receiver <bcp14>MUST</bcp14> drop the reassembled SCHC Packet.</li>
              <li>the reassembly operation concludes.</li>
            </ul>
            <t>On expiration of the Inactivity Timer,
the receiver <bcp14>MUST</bcp14> drop the SCHC Packet being reassembled.</t>
            <t>On receiving a SCHC Sender-Abort,
the receiver <bcp14>MAY</bcp14> drop the SCHC Packet being reassembled.</t>
            <t><xref target="Fig-NoACKModeRcv" format="default"/> shows an example of a corresponding state machine.</t>
          </section>
        </section>
        <section anchor="ACK-Always-subsection" numbered="true" toc="default">
          <name>ACK-Always Mode</name>
          <t>The ACK-Always mode has been designed under the following assumptions:</t>
          <ul spacing="normal">
            <li>Data unit out-of-sequence delivery does not occur between the entity performing fragmentation and the entity performing reassembly,</li>
            <li>The L2 MTU value does not change while the fragments of a SCHC Packet are being transmitted, and</li>
            <li>There is a feedback path from the reassembler to the fragmenter.
See <xref target="AsymLinks" format="default"/> for a discussion on using ACK-Always mode on quasi-bidirectional links.</li>
          </ul>
          <t>In ACK-Always mode, windows are used.
An acknowledgement, positive or negative, is transmitted by the fragment receiver to the fragment sender at the end of the transmission of each window of SCHC Fragments.</t>
          <t>The tiles are not required to be of uniform size. In ACK-Always mode, only the All-1 SCHC Fragment is padded as needed. The other SCHC Fragments are intrinsically aligned to L2 Words.</t>
          <t>Briefly, the algorithm is as follows: after a first blind transmission of all the tiles of a window, the fragment sender iterates retransmitting the tiles that are reported missing until the fragment receiver reports that all the tiles belonging to the window have been correctly received or until too many attempts were made.
The fragment sender only advances to the next window of tiles when it has ascertained that all the tiles belonging to the current window have been fully and correctly received. This results in a per-window lock-step behavior between the sender and the receiver.</t>
          <t>Each Profile <bcp14>MUST</bcp14> specify which RuleID value(s) correspond to SCHC F/R messages operating in this mode.</t>
          <t>The W field <bcp14>MUST</bcp14> be present and its size M <bcp14>MUST</bcp14> be 1 bit.</t>
          <t>Each Profile, for each RuleID value, <bcp14>MUST</bcp14> define:</t>
          <ul spacing="normal">
            <li>the value of N,</li>
            <li>the value of WINDOW_SIZE, which <bcp14>MUST</bcp14> be strictly less than 2^N,</li>
            <li>the size and algorithm for the RCS field,</li>
            <li>the value of T,</li>
            <li>the value of MAX_ACK_REQUESTS,</li>
            <li>the expiration time of the Retransmission Timer, and</li>
            <li>the expiration time of the Inactivity Timer.</li>
          </ul>
          <t>For each active pair of RuleID and DTag values, the sender <bcp14>MUST</bcp14> maintain:</t>
          <ul spacing="normal">
            <li>one Attempts counter</li>
            <li>one Retransmission Timer</li>
          </ul>
          <t>For each active pair of RuleID and DTag values, the receiver <bcp14>MUST</bcp14> maintain</t>
          <ul spacing="normal">
            <li>one Inactivity Timer, and</li>
            <li>one Attempts counter.</li>
          </ul>
          <section anchor="sender-behavior-1" numbered="true" toc="default">
            <name>Sender Behavior</name>
            <t>At the beginning of the fragmentation of a new SCHC Packet, the fragment sender <bcp14>MUST</bcp14> select a RuleID and DTag value pair for this SCHC Packet.</t>
            <t>Each SCHC Fragment <bcp14>MUST</bcp14> contain exactly one tile in its Payload.
All tiles with the index 0, as well as the last tile, <bcp14>MUST</bcp14> be at least the size of an L2 Word.</t>
            <t>In all SCHC Fragment messages, the W field <bcp14>MUST</bcp14> be filled with the LSB of the window number that the sender is currently processing.</t>
            <t>For a SCHC Fragment that carries a tile other than the last one of the SCHC Packet:</t>
            <ul spacing="normal">
              <li>the Fragment <bcp14>MUST</bcp14> be of the Regular type specified in <xref target="NotLastFrag" format="default"/>.</li>
              <li>the FCN field <bcp14>MUST</bcp14> contain the tile index.</li>
              <li>each tile <bcp14>MUST</bcp14> be of a size
that complements the SCHC Fragment Header so
that the SCHC Fragment is a multiple of L2 Words without the need for padding bits.</li>
            </ul>
            <t>The SCHC Fragment that carries the last tile <bcp14>MUST</bcp14> be an All-1 SCHC Fragment, described in <xref target="LastFrag" format="default"/>.</t>
            <t>The fragment sender <bcp14>MUST</bcp14> start by transmitting the window numbered 0.</t>
            <t>All message receptions being discussed in the rest of this section are to be understood as
"matching the RuleID and DTag pair being processed", even if not spelled out, for brevity.</t>
            <t>The sender starts by a "blind transmission" phase, in which it <bcp14>MUST</bcp14> transmit all the tiles composing the window, in decreasing tile index order.</t>
            <t>Then, it enters a "retransmission phase" in which
it <bcp14>MUST</bcp14> initialize an Attempts counter to 0,
it <bcp14>MUST</bcp14> start a Retransmission Timer
and it <bcp14>MUST</bcp14> await a SCHC ACK. </t>
            <ul spacing="normal">
              <li>
                <t>Then, upon receiving a SCHC ACK:</t>
                <ul spacing="normal">
                  <li>if the SCHC ACK indicates that some tiles are missing at the receiver, then
the sender <bcp14>MUST</bcp14> transmit all the tiles that have been reported missing,
it <bcp14>MUST</bcp14> increment Attempts,
it <bcp14>MUST</bcp14> reset the Retransmission Timer,
and <bcp14>MUST</bcp14> await the next SCHC ACK.</li>
                  <li>if the current window is not the last one and the SCHC ACK indicates that all tiles were correctly received,
the sender <bcp14>MUST</bcp14> stop the Retransmission Timer,
it <bcp14>MUST</bcp14> advance to the next fragmentation window,
and it <bcp14>MUST</bcp14> start a blind transmission phase as described above.</li>
                  <li>if the current window is the last one and the SCHC ACK indicates that more tiles were received than the sender sent,
the fragment sender <bcp14>MUST</bcp14> send a SCHC Sender-Abort,
and it <bcp14>MAY</bcp14> exit with an error condition.</li>
                  <li>if the current window is the last one and the
		  SCHC ACK indicates that all tiles were correctly
		  received, yet the integrity check was a failure,
the fragment sender <bcp14>MUST</bcp14> send a SCHC Sender-Abort,
and it <bcp14>MAY</bcp14> exit with an error condition.</li>
                  <li>if the current window is the last one and the SCHC ACK indicates that integrity checking was successful,
the sender exits successfully.</li>
                </ul>
              </li>
              <li>
                <t>on Retransmission Timer expiration:  </t>
                <ul spacing="normal">
                  <li>if Attempts is strictly less that MAX_ACK_REQUESTS,
the fragment sender <bcp14>MUST</bcp14> send a SCHC ACK REQ
and <bcp14>MUST</bcp14> increment the Attempts counter.</li>
                  <li>otherwise,
the fragment sender <bcp14>MUST</bcp14> send a SCHC Sender-Abort,
and it <bcp14>MAY</bcp14> exit with an error condition.</li>
                </ul>
              </li>
            </ul>
            <t>At any time:</t>
            <ul spacing="normal">
              <li>on receiving a SCHC Receiver-Abort, the fragment sender <bcp14>MAY</bcp14> exit with an error condition.</li>
              <li>on receiving a SCHC ACK that bears a W value different from the W value that it currently uses, the fragment sender <bcp14>MUST</bcp14> silently discard and ignore that SCHC ACK.</li>
            </ul>
            <t><xref target="Fig-ACKAlwaysSnd" format="default"/> shows an example of a corresponding state machine.</t>
          </section>
          <section anchor="receiver-behavior-1" numbered="true" toc="default">
            <name>Receiver Behavior</name>
            <t>On receiving a SCHC Fragment with a RuleID and DTag pair not being processed at that time:</t>
            <ul spacing="normal">
              <li>the receiver <bcp14>SHOULD</bcp14> check if the DTag value has not recently been used for that RuleID value,
thereby ensuring that the received SCHC Fragment is not a remnant of a prior fragmented SCHC Packet transmission.
The initial value of the Inactivity Timer is the <bcp14>RECOMMENDED</bcp14> lifetime for the DTag value at the receiver.
If the SCHC Fragment is determined to be such a remnant, the receiver <bcp14>MAY</bcp14> silently ignore it and discard it.</li>
              <li>the receiver <bcp14>MUST</bcp14> start a process to assemble a new SCHC Packet with that RuleID and DTag value pair.</li>
              <li>the receiver <bcp14>MUST</bcp14> start an Inactivity Timer for that RuleID and DTag pair.
It <bcp14>MUST</bcp14> initialize an Attempts counter to 0 for that RuleID and DTag pair.
It <bcp14>MUST</bcp14> initialize a window counter to 0.
If the receiver is under-resourced to do this, it <bcp14>MUST</bcp14> respond to the sender with a SCHC Receiver-Abort.</li>
            </ul>
            <t>In the rest of this section, "local W bit" means the least significant bit of the window counter of the receiver.</t>
            <t>On reception of any SCHC F/R message for the RuleID and DTag pair being processed, the receiver <bcp14>MUST</bcp14> reset the Inactivity Timer pertaining to that RuleID and DTag pair.</t>
            <t>All message receptions being discussed in the rest of this section are to be understood as
"matching the RuleID and DTag pair being processed", even if not spelled out, for brevity.</t>
            <t>The receiver <bcp14>MUST</bcp14> first initialize an empty Bitmap for the first window then
enter an "acceptance phase", in which:</t>
            <ul spacing="normal">
              <li>on receiving a SCHC Fragment or a SCHC ACK REQ, either one having the W bit different from the local W bit,
the receiver <bcp14>MUST</bcp14> silently ignore and discard that message.</li>
              <li>on receiving a SCHC ACK REQ with the W bit equal to the local W bit,
the receiver <bcp14>MUST</bcp14> send a SCHC ACK for this window.</li>
              <li>
                <t>on receiving a SCHC Fragment with the W bit equal to the local W bit,
the receiver <bcp14>MUST</bcp14> assemble the received tile based on the window counter and on the FCN field in the SCHC Fragment,
and it <bcp14>MUST</bcp14> update the Bitmap.
                </t>
                <ul spacing="normal">
                  <li>if the SCHC Fragment received is an All-0 SCHC Fragment,
the current window is determined to be a not-last window,
the receiver <bcp14>MUST</bcp14> send a SCHC ACK for this window
and it <bcp14>MUST</bcp14> enter the "retransmission phase" for this window.</li>
<li>

  
                    <t>if the SCHC Fragment received is an All-1 SCHC Fragment,
the current window is determined to be the last window,
the padding bits of the All-1 SCHC Fragment <bcp14>MUST</bcp14> be assembled after the received tile,
the receiver <bcp14>MUST</bcp14> perform the integrity check
and it <bcp14>MUST</bcp14> send a SCHC ACK for this window. Then:      </t>
                    <ul spacing="normal">
                      <li>If the integrity check indicates that the full SCHC Packet has been correctly reassembled,
the receiver <bcp14>MUST</bcp14> enter the "clean-up phase" for this window.</li>
                      <li>If the integrity check indicates that the full SCHC Packet has not been correctly reassembled,
the receiver enters the "retransmission phase" for this window.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
            <t>In the "retransmission phase":</t>
            <ul spacing="normal">
              <li>
                <t>if the window is a not-last window:</t>
                <ul spacing="normal">
                  <li>on receiving a SCHC Fragment that is not All-0 or All-1 and that has a W bit different from the local W bit,
the receiver <bcp14>MUST</bcp14> increment its window counter and allocate a fresh Bitmap,
it <bcp14>MUST</bcp14> assemble the tile received and update the Bitmap,
and it <bcp14>MUST</bcp14> enter the "acceptance phase" for that new window.</li>
                  <li>on receiving a SCHC ACK REQ with a W bit different from the local W bit,
the receiver <bcp14>MUST</bcp14> increment its window counter and allocate a fresh Bitmap,
it <bcp14>MUST</bcp14> send a SCHC ACK for that new window,
and it <bcp14>MUST</bcp14> enter the "acceptance phase" for that new window.</li>
                  <li>on receiving a SCHC All-0 Fragment with a W bit different from the local W bit,
the receiver <bcp14>MUST</bcp14> increment its window counter and allocate a fresh Bitmap,
it <bcp14>MUST</bcp14> assemble the tile received and update the Bitmap,
it <bcp14>MUST</bcp14> send a SCHC ACK for that new window,
and it <bcp14>MUST</bcp14> stay in the "retransmission phase" for that new window.</li>
                  <li>
                    <t>on receiving a SCHC All-1 Fragment with a W bit different from the local W bit,
the receiver <bcp14>MUST</bcp14> increment its window counter and allocate a fresh Bitmap;
it <bcp14>MUST</bcp14> assemble the tile received,
including the padding bits;
it <bcp14>MUST</bcp14> update the Bitmap and perform the integrity check;
it <bcp14>MUST</bcp14> send a SCHC ACK for the new window,
which is determined to be the last window. Then:</t>
                    <ul spacing="normal">
                      <li>If the integrity check indicates that the full SCHC Packet has been correctly reassembled,
the receiver <bcp14>MUST</bcp14> enter the "clean-up phase" for that new window.</li>
                      <li>If the integrity check indicates that the full SCHC Packet has not been correctly reassembled,
the receiver enters the "retransmission phase" for that new window.</li>
                    </ul>
                  </li>
                  <li>
                    <t>on receiving a SCHC Fragment with a W bit equal to the local W bit:</t>
                    <ul spacing="normal">
                      <li>if the SCHC Fragment received is an All-1 SCHC Fragment,
the receiver <bcp14>MUST</bcp14> silently ignore it and discard it.</li>
                      <li>otherwise,
the receiver <bcp14>MUST</bcp14> assemble the tile received and update the Bitmap.
If the Bitmap becomes fully populated with 1's or if the SCHC Fragment is an All-0,
the receiver <bcp14>MUST</bcp14> send a SCHC ACK for this window.</li>
                    </ul>
                  </li>
                  <li>on receiving a SCHC ACK REQ with the W bit equal to the local W bit,
the receiver <bcp14>MUST</bcp14> send a SCHC ACK for this window.</li>
                </ul>
              </li>
              <li>
                <t>if the window is the last window:</t>
                <ul spacing="normal">
                  <li>on receiving a SCHC Fragment or a SCHC ACK REQ, either one having a W bit different from the local W bit,
the receiver <bcp14>MUST</bcp14> silently ignore and discard that message.</li>
                  <li>on receiving a SCHC ACK REQ with the W bit equal to the local W bit,
the receiver <bcp14>MUST</bcp14> send a SCHC ACK for this window.</li>
                  <li>
                    <t>on receiving a SCHC Fragment with a W bit equal to the local W bit:</t>
                    <ul spacing="normal">
                      <li>if the SCHC Fragment received is an All-0 SCHC Fragment,
the receiver <bcp14>MUST</bcp14> silently ignore it and discard it.</li>
                      <li>
                        <t>otherwise, the receiver <bcp14>MUST</bcp14> update the Bitmap,
and it <bcp14>MUST</bcp14> assemble the tile received.
If the SCHC Fragment received is an All-1 SCHC Fragment,
the receiver <bcp14>MUST</bcp14> assemble the padding bits of the All-1 SCHC Fragment after the received tile,
it <bcp14>MUST</bcp14> perform the integrity check and:</t>
                        <ul spacing="normal">
                          <li>if the integrity check indicates that the full SCHC Packet has been correctly reassembled,
the receiver <bcp14>MUST</bcp14> send a SCHC ACK
and it enters the "clean-up phase".</li>
                          <li>
                            <t>if the integrity check indicates that the full SCHC Packet has not been correctly reassembled:
                            </t>
                            <ul spacing="normal">
                              <li>if the SCHC Fragment received was an All-1 SCHC Fragment, the receiver <bcp14>MUST</bcp14> send a SCHC ACK for this window.</li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
            <t>In the "clean-up phase":</t>
            <ul spacing="normal">
              <li>On receiving an All-1 SCHC Fragment or a SCHC ACK REQ, either one having the W bit equal to the local W bit, the receiver <bcp14>MUST</bcp14> send a SCHC ACK.</li>
              <li>Any other SCHC Fragment received <bcp14>MUST</bcp14> be silently ignored and discarded.</li>
            </ul>
            <t>At any time,
on sending a SCHC ACK,
the receiver <bcp14>MUST</bcp14> increment the Attempts counter.</t>
            <t>At any time,
on incrementing its window counter,
the receiver <bcp14>MUST</bcp14> reset the Attempts counter.</t>
            <t>At any time,
on expiration of the Inactivity Timer,
on receiving a SCHC Sender-Abort or
when Attempts reaches MAX_ACK_REQUESTS,
the receiver <bcp14>MUST</bcp14> send a SCHC Receiver-Abort,
and it <bcp14>MAY</bcp14> exit the receive process for that SCHC Packet.</t>
            <t><xref target="Fig-ACKAlwaysRcv" format="default"/> shows an example of a corresponding state machine.</t>
          </section>
        </section>
        <section anchor="ACK-on-Error-subsection" numbered="true" toc="default">
          <name>ACK-on-Error Mode</name>
          <t>The ACK-on-Error mode supports L2 technologies that have variable MTU and out-of-order delivery.
It requires an L2 that provides a feedback path from the reassembler to the fragmenter.
See <xref target="AsymLinks" format="default"/> for a discussion on using ACK-on-Error mode on quasi-bidirectional links.</t>
          <t>In ACK-on-Error mode, windows are used.</t>
          <t>All tiles except the last one and the penultimate one <bcp14>MUST</bcp14> be of equal size, hereafter called "regular".
The size of the last tile <bcp14>MUST</bcp14> be smaller than or equal to the regular tile size.
Regarding the penultimate tile, a Profile <bcp14>MUST</bcp14> pick one of the following two options:</t>
          <ul spacing="normal">
            <li>The penultimate tile size <bcp14>MUST</bcp14> be the
	    regular tile size, or</li>
            <li>the penultimate tile size <bcp14>MUST</bcp14> be either the regular tile size or the regular tile size minus one L2 Word.</li>
          </ul>
          <t>A SCHC Fragment message carries one or several contiguous tiles, which may span multiple windows.
A SCHC ACK reports on the reception of exactly one window of tiles.</t>
          <t>See <xref target="Fig-TilesACKonError" format="default"/> for an example.</t>
          <figure anchor="Fig-TilesACKonError">
            <name>SCHC Packet Fragmented in Tiles, ACK-on-Error Mode</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
        +---------------------------------------------...-----------+
        |                       SCHC Packet                         |
        +---------------------------------------------...-----------+

Tile#   | 4 | 3 | 2 | 1 | 0 | 4 | 3 | 2 | 1 | 0 | 4 |     | 0 | 4 |3|
Window# |-------- 0 --------|-------- 1 --------|- 2  ... 27 -|- 28-|


SCHC Fragment msg   |-----------|]]></artwork>
          </figure>
          <t>The W field is wide enough that it unambiguously represents an absolute window number.
The fragment receiver sends SCHC ACKs to the fragment sender about windows for which tiles are missing.
No SCHC ACK is sent by the fragment receiver for windows that it knows have been fully received.</t>
          <t>The fragment sender retransmits SCHC Fragments for tiles that are reported missing.
It can advance to next windows even before it has ascertained that all tiles belonging to previous windows have been correctly received,
and it can still later retransmit SCHC Fragments with tiles belonging to previous windows.
Therefore, the sender and the receiver may operate in a decoupled fashion.
The fragmented SCHC Packet transmission concludes when:</t>
          <ul spacing="normal">
            <li>integrity checking shows that the fragmented SCHC Packet has been correctly reassembled at the receive end,
and this information has been conveyed back to the sender, or</li>
            <li>too many retransmission attempts were made, or</li>
            <li>the receiver determines that the transmission of this fragmented SCHC Packet has been inactive for too long.</li>
          </ul>
          <t>Each Profile <bcp14>MUST</bcp14> specify which RuleID value(s) corresponds to SCHC F/R messages operating in this mode.</t>
          <t>The W field <bcp14>MUST</bcp14> be present in the SCHC F/R messages.</t>
          <t>Each Profile, for each RuleID value, <bcp14>MUST</bcp14> define:</t>
          <ul spacing="normal">
            <li>the tile size (a tile does not need to be multiple of an L2 Word, but it <bcp14>MUST</bcp14> be at least the size of an L2 Word),</li>
            <li>the value of M,</li>
            <li>the value of N,</li>
            <li>the value of WINDOW_SIZE, which <bcp14>MUST</bcp14> be strictly less than 2^N,</li>
            <li>the size and algorithm for the RCS field,</li>
            <li>the value of T,</li>
            <li>the value of MAX_ACK_REQUESTS,</li>
            <li>the expiration time of the Retransmission Timer,</li>
            <li>the expiration time of the Inactivity Timer,</li>
            <li>if the last tile is carried in a Regular SCHC Fragment or an All-1 SCHC Fragment (see <xref target="ACK-on-Error-sender" format="default"/>), and</li>
            <li>if the penultimate tile <bcp14>MAY</bcp14> be one L2 Word smaller than the regular tile size. In this case, the regular tile size <bcp14>MUST</bcp14> be at least twice the L2 Word size.</li>
          </ul>
          <t>For each active pair of RuleID and DTag values, the sender <bcp14>MUST</bcp14> maintain:</t>
          <ul spacing="normal">
            <li>one Attempts counter, and</li>
            <li>one Retransmission Timer.</li>
          </ul>
          <t>For each active pair of RuleID and DTag values, the receiver <bcp14>MUST</bcp14> maintain:</t>
          <ul spacing="normal">
            <li>one Inactivity Timer, and</li>
            <li>one Attempts counter.</li>
          </ul>
          <section anchor="ACK-on-Error-sender" numbered="true" toc="default">
            <name>Sender Behavior</name>
            <t>At the beginning of the fragmentation of a new SCHC Packet:</t>
            <ul spacing="normal">
              <li>the fragment sender <bcp14>MUST</bcp14> select a RuleID and DTag value pair for this SCHC Packet.
A Rule <bcp14>MUST NOT</bcp14> be selected if the values of M and WINDOW_SIZE for that Rule are such that the SCHC Packet cannot be fragmented in (2^M) * WINDOW_SIZE tiles or less.</li>
              <li>the fragment sender <bcp14>MUST</bcp14> initialize the Attempts counter to 0 for that RuleID and DTag value pair.</li>
            </ul>
            <t>A Regular SCHC Fragment message carries in its payload one or more tiles.
If more than one tile is carried in one Regular SCHC Fragment:</t>
            <ul spacing="normal">
              <li>the selected tiles <bcp14>MUST</bcp14> be contiguous in the original SCHC Packet, and</li>
              <li>they <bcp14>MUST</bcp14> be placed in the SCHC Fragment Payload adjacent to one another, in the order they appear in the SCHC Packet, from the start of the SCHC Packet toward its end.</li>
            </ul>
            <t>Tiles that are not the last one <bcp14>MUST</bcp14> be sent in Regular SCHC Fragments specified in <xref target="NotLastFrag" format="default"/>.
The FCN field <bcp14>MUST</bcp14> contain the tile index of the first tile sent in that SCHC Fragment.</t>
            <t>In a Regular SCHC Fragment message, the sender <bcp14>MUST</bcp14> fill the W field with the window number of the first tile sent in that SCHC Fragment.</t>
            <t>A Profile <bcp14>MUST</bcp14> define if the last tile of a SCHC Packet is sent:</t>
            <ul spacing="normal">
              <li>in a Regular SCHC Fragment, alone or as part of a multi-tiles Payload,</li>
              <li>alone in an All-1 SCHC Fragment, or</li>
              <li>with any of the above two methods.</li>
            </ul>
            <t>In an All-1 SCHC Fragment message, the sender <bcp14>MUST</bcp14> fill the W field with the window number of the last tile of the SCHC Packet.</t>
            <t>The fragment sender <bcp14>MUST</bcp14> send SCHC Fragments such that, all together, they contain all the tiles of the fragmented SCHC Packet.</t>
            <t>The fragment sender <bcp14>MUST</bcp14> send at least one All-1 SCHC Fragment.</t>
            <t>In doing the two items above, the sender <bcp14>MUST</bcp14> ascertain that the receiver will not receive the last tile through both a Regular SCHC Fragment and an All-1 SCHC Fragment.</t>
            <t>The fragment sender <bcp14>MUST</bcp14> listen for SCHC ACK messages after having sent:</t>
            <ul spacing="normal">
              <li>an All-1 SCHC Fragment, or</li>
              <li>a SCHC ACK REQ.</li>
            </ul>
            <t>A Profile <bcp14>MAY</bcp14> specify other times at which the fragment sender <bcp14>MUST</bcp14> listen for SCHC ACK messages.
For example, this could be after sending a complete window of tiles.</t>
            <t>Each time a fragment sender sends an All-1 SCHC Fragment or a SCHC ACK REQ:</t>
            <ul spacing="normal">
              <li>it <bcp14>MUST</bcp14> increment the Attempts counter, and</li>
              <li>it <bcp14>MUST</bcp14> reset the Retransmission Timer.</li>
            </ul>
            <t>On Retransmission Timer expiration:</t>
            <ul spacing="normal">
              <li>if the Attempts counter is strictly less than MAX_ACK_REQUESTS,
the fragment sender <bcp14>MUST</bcp14> send
either the All-1 SCHC Fragment or
a SCHC ACK REQ with the W field corresponding to the last window,</li>
              <li>otherwise, the fragment sender <bcp14>MUST</bcp14> send a SCHC Sender-Abort, and
it <bcp14>MAY</bcp14> exit with an error condition.</li>
            </ul>
            <t>All message receptions being discussed in the rest of this section are to be understood as
"matching the RuleID and DTag pair being processed", even if not spelled out, for brevity.</t>
            <t>On receiving a SCHC ACK:</t>
            <ul spacing="normal">
              <li>
                <t>if the W field in the SCHC ACK corresponds to the last window of the SCHC Packet:</t>
                <ul spacing="normal">
                  <li>if the C bit is set, the sender <bcp14>MAY</bcp14> exit successfully.</li>
                  <li>
                    <t>otherwise:      </t>
                    <ul spacing="normal">
                      <li>
                        <t>if the Profile mandates that the last tile be sent in an All-1 SCHC Fragment:</t>
                        <ul spacing="normal">
                          <li>
                            <t>if the SCHC ACK shows no missing tile at the receiver, the sender:</t>
                            <ul spacing="normal">
                              <li><bcp14>MUST</bcp14> send a SCHC Sender-Abort, and</li>
                              <li><bcp14>MAY</bcp14> exit with an error condition.</li>
                            </ul>
                          </li>
                          <li>
                            <t>otherwise:</t>
                            <ul spacing="normal">
                              <li>the fragment sender <bcp14>MUST</bcp14> send SCHC Fragment messages containing all the tiles that are reported missing in the SCHC ACK.</li>
                              <li>if the last of these SCHC Fragment messages is not an All-1 SCHC Fragment,
then the fragment sender <bcp14>MUST</bcp14> in addition send after it a SCHC ACK REQ with the W field corresponding to the last window.</li>
                              <li>in doing the two items above, the sender <bcp14>MUST</bcp14> ascertain that the receiver will not receive the last tile through both a Regular SCHC Fragment and an All-1 SCHC Fragment.</li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                      <li>
                        <t>otherwise:</t>
                        <ul spacing="normal">
                          <li>if the SCHC ACK shows no missing tile at the receiver, the sender
<bcp14>MUST</bcp14> send the All-1 SCHC Fragment</li>
                          <li>
                            <t>otherwise:</t>
                            <ul spacing="normal">
                              <li>the fragment sender <bcp14>MUST</bcp14> send SCHC Fragment messages containing all the tiles that are reported missing in the SCHC ACK.</li>
                              <li>the fragment sender <bcp14>MUST</bcp14> then send
either the All-1 SCHC Fragment or
a SCHC ACK REQ with the W field corresponding to the last window.</li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <t>otherwise, the fragment sender:</t>
                <ul spacing="normal">
                  <li><bcp14>MUST</bcp14> send SCHC Fragment messages containing the tiles that are reported missing in the SCHC ACK.</li>
                  <li>then, it <bcp14>MAY</bcp14> send a SCHC ACK REQ with the W field corresponding to the last window.</li>
                </ul>
              </li>
            </ul>
            <t>See <xref target="Fig-ACKonerrorSnd" format="default"/> for one among several possible examples of a Finite State Machine implementing a sender behavior obeying this specification.</t>
          </section>
          <section anchor="ACK-on-Error-receiver" numbered="true" toc="default">
            <name>Receiver Behavior</name>
            <t>On receiving a SCHC Fragment with a RuleID and DTag pair not being processed at that time:</t>
            <ul spacing="normal">
              <li>the receiver <bcp14>SHOULD</bcp14> check if the DTag value has not recently been used for that RuleID value,
thereby ensuring that the received SCHC Fragment is not a remnant of a prior fragmented SCHC Packet transmission.
The initial value of the Inactivity Timer is the <bcp14>RECOMMENDED</bcp14> lifetime for the DTag value at the receiver.
If the SCHC Fragment is determined to be such a remnant, the receiver <bcp14>MAY</bcp14> silently ignore it and discard it.</li>
              <li>the receiver <bcp14>MUST</bcp14> start a process to assemble a new SCHC Packet with that RuleID and DTag value pair.
The receiver <bcp14>MUST</bcp14> start an Inactivity Timer for that RuleID and DTag value pair.
It <bcp14>MUST</bcp14> initialize an Attempts counter to 0 for that RuleID and DTag value pair.
If the receiver is under-resourced to do this, it <bcp14>MUST</bcp14> respond to the sender with a SCHC Receiver-Abort.</li>
            </ul>
            <t>On reception of any SCHC F/R message for the RuleID and DTag pair being processed, the receiver <bcp14>MUST</bcp14> reset the Inactivity Timer pertaining to that RuleID and DTag pair.</t>
            <t>All message receptions being discussed in the rest of this section are to be understood as
"matching the RuleID and DTag pair being processed", even if not spelled out, for brevity.</t>
            <t>On receiving a SCHC Fragment message,
the receiver determines what tiles were received, based on the payload length and on the W and FCN fields of the SCHC Fragment.</t>
            <ul spacing="normal">
              <li>if the FCN is All-1, if a Payload is present, the full SCHC Fragment Payload <bcp14>MUST</bcp14> be assembled including the padding bits.
This is because the size of the last tile is not known by the receiver;
therefore, padding bits are indistinguishable from the tile data bits, at this stage.
They will be removed by the SCHC C/D sublayer.
If the size of the SCHC Fragment Payload exceeds or equals
the size of one regular tile plus the size of an L2 Word, this <bcp14>SHOULD</bcp14> raise an error flag.</li>
              <li>
                <t>otherwise, tiles <bcp14>MUST</bcp14> be assembled based on the a priori known tile size.
                </t>
                <ul spacing="normal">
                  <li>If allowed by the Profile, the end of the payload <bcp14>MAY</bcp14> contain the last tile, which may be shorter. Padding bits are indistinguishable from the tile data bits, at this stage.</li>
                  <li>The payload may contain the penultimate tile that, if allowed by the Profile, <bcp14>MAY</bcp14> be exactly one L2 Word shorter than the regular tile size.</li>
                  <li>
                    <t>Otherwise, padding bits <bcp14>MUST</bcp14> be discarded.
This is possible because:</t>
                    <ul spacing="normal">
                      <li>the size of the tiles is known a priori,</li>
                      <li>tiles are larger than an L2 Word, and</li>
                      <li>padding bits are always strictly less than an L2 Word.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
            <t>On receiving a SCHC ACK REQ or an All-1 SCHC Fragment:</t>
            <ul spacing="normal">
              <li>if the receiver knows of any windows with missing tiles for the packet being reassembled, it
<bcp14>MUST</bcp14> return a SCHC ACK for the lowest-numbered such window:</li>
              <li>
                <t>otherwise:
                </t>
                <ul spacing="normal">
                  <li>if it has received at least one tile, it <bcp14>MUST</bcp14> return a SCHC ACK for the highest-numbered window it currently has tiles for,</li>
                  <li>otherwise, it <bcp14>MUST</bcp14> return a SCHC ACK for window numbered 0.</li>
                </ul>
              </li>
            </ul>
            <t>A Profile <bcp14>MAY</bcp14> specify other times and circumstances at which
a receiver sends a SCHC ACK,
and which window the SCHC ACK reports about in these circumstances.</t>
            <t>Upon sending a SCHC ACK, the receiver <bcp14>MUST</bcp14> increase the Attempts counter.</t>
            <t>After receiving an All-1 SCHC Fragment,
a receiver <bcp14>MUST</bcp14> check the integrity of the reassembled SCHC Packet at least every time
it prepares for sending a SCHC ACK for the last window.</t>
            <t>Upon receiving a SCHC Sender-Abort,
the receiver <bcp14>MAY</bcp14> exit with an error condition.</t>
            <t>Upon expiration of the Inactivity Timer,
the receiver <bcp14>MUST</bcp14> send a SCHC Receiver-Abort,
and it <bcp14>MAY</bcp14> exit with an error condition.</t>
            <t>On the Attempts counter exceeding MAX_ACK_REQUESTS,
the receiver <bcp14>MUST</bcp14> send a SCHC Receiver-Abort,
and it <bcp14>MAY</bcp14> exit with an error condition.</t>
            <t>Reassembly of the SCHC Packet concludes when:</t>
            <ul spacing="normal">
              <li>a Sender-Abort has been received, or</li>
              <li>the Inactivity Timer has expired, or</li>
              <li>the Attempts counter has exceeded MAX_ACK_REQUESTS, or</li>
              <li>at least an All-1 SCHC Fragment has been received and integrity checking of the reassembled SCHC Packet is successful.</li>
            </ul>

	    
            <t>See <xref target="Fig-ACKonerrorRcv" format="default"/> for one among several possible examples of a Finite State Machine implementing a receiver behavior obeying this specification. The example provided is meant to match the sender Finite State Machine of <xref target="Fig-ACKonerrorSnd" format="default"/>.</t>
          </section>
        </section>
      </section>
    </section>
    <section anchor="Padding" numbered="true" toc="default">
      <name>Padding Management</name>
      <t>SCHC C/D and SCHC F/R operate on bits, not bytes. SCHC itself does not have any alignment prerequisite.
The size of SCHC Packets can be any number of bits.</t>
      <t>If the L2 constrains the payload to align to coarser boundaries (for example, bytes),
the SCHC messages <bcp14>MUST</bcp14> be padded.
When padding occurs, the number of appended bits <bcp14>MUST</bcp14> be strictly less than the L2 Word size.</t>
      <t>If a SCHC Packet is sent unfragmented (see <xref target="Fig-Operations-Pad" format="default"/>), it is padded as needed for transmission.</t>
      <t>If a SCHC Packet needs to be fragmented for transmission, it is not padded in itself. Only the SCHC F/R messages are padded as needed for transmission.
Some SCHC F/R messages are intrinsically aligned to L2 Words.</t>
      <figure anchor="Fig-Operations-Pad">
        <name>SCHC Operations, Including Padding as Needed</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
A packet (e.g., an IPv6 packet)
         |                                           ^ (padding bits
         v                                           |       dropped)
+------------------+                      +--------------------+
| SCHC Compression |                      | SCHC Decompression |
+------------------+                      +--------------------+
         |                                           ^
         |   If no fragmentation,                    |
         +---- SCHC Packet + padding as needed ----->|
         |                                           | (integrity
         v                                           |  checked)
+--------------------+                       +-----------------+
| SCHC Fragmentation |                       | SCHC Reassembly |
+--------------------+                       +-----------------+
     |       ^                                   |       ^
     |       |                                   |       |
     |       +--- SCHC ACK + padding as needed --+       |
     |                                                   |
     +------- SCHC Fragments + padding as needed---------+

        Sender                                    Receiver]]></artwork>
      </figure>
      <t>Each Profile <bcp14>MUST</bcp14> specify the size of the L2 Word.
The L2 Word might actually be a single bit, in which case no padding will take place at all.</t>
      <t>A Profile <bcp14>MUST</bcp14> define the value of the padding bits if the L2 Word is wider than a single bit. The <bcp14>RECOMMENDED</bcp14> value is 0.</t>
    </section>
    <section anchor="schc-compression-for-ipv6-and-udp-headers" numbered="true" toc="default">
      <name>SCHC Compression for IPv6 and UDP Headers</name>
      <t>This section lists the IPv6 and UDP header fields and describes how they can be compressed.
An example of a set of Rules for UDP/IPv6 header compression is provided in <xref target="compressIPv6" format="default"/>.</t>
      <section anchor="ipv6-version-field" numbered="true" toc="default">
        <name>IPv6 Version Field</name>
        <t>The IPv6 version field is labeled by the protocol parser as being the "version" field of the IPv6 protocol.
Therefore, it only exists for IPv6 packets.
In the Rule, TV is set to 6, MO to "ignore"
and CDA to "not-sent".</t>
      </section>
      <section anchor="ipv6-traffic-class-field" numbered="true" toc="default">
        <name>IPv6 Traffic Class Field</name>

        <t>If the Diffserv field does not vary and is known by both sides, the Field Descriptor in the Rule <bcp14>SHOULD</bcp14> contain a TV with
this well-known value, an "equal" MO, and a "not-sent" CDA.</t>
        <t>Otherwise (e.g., ECN bits are to be transmitted), two possibilities can be considered depending on the variability of the value:</t>
        <ul spacing="normal">
          <li>One possibility is to not compress the field and send the original value. In the Rule, TV is not set to any particular value, MO is set to "ignore", and CDA is set to "value-sent".</li>
          <li>
            <t>If some upper bits in the field are constant and known, a better option is to only send the LSBs. In the Rule, TV is set to a value with the stable known upper part, MO is set to MSB(x), and CDA to LSB.  </t>
            <t>
ECN functionality depends on both bits of the ECN field, which
are the 2 LSBs of this field; hence, sending only a single
LSB of this field is <bcp14>NOT RECOMMENDED</bcp14>.</t>
          </li>
        </ul>
      </section>
      <section anchor="flow-label-field" numbered="true" toc="default">
        <name>Flow Label Field</name>
        <t>If the flow label is not set, i.e., its value is zero, the Field Descriptor in the Rule <bcp14>SHOULD</bcp14> contain a TV set to zero, an "equal" MO, and a "not-sent" CDA.</t>
        <t>If the flow label is set to a pseudorandom value according to <xref target="RFC6437" format="default"/>, in the Rule, TV is not set to any particular value, MO is set to "ignore", and CDA is set to "value-sent".</t>
        <t>If the flow label is set according to some prior agreement, i.e., by a flow state establishment method as allowed by <xref target="RFC6437" format="default"/>,
the Field Descriptor in the Rule <bcp14>SHOULD</bcp14> contain a TV with this agreed-upon value, an "equal" MO, and a "not-sent" CDA.</t>
      </section>
      <section anchor="payload-length-field" numbered="true" toc="default">
        <name>Payload Length Field</name>
        <t>This field can be elided for the transmission on the LPWAN. The SCHC C/D recomputes the original payload length value. In the Field Descriptor, TV is not set, MO is set to "ignore", and CDA is "compute-*".</t>
      </section>
      <section anchor="next-header-field" numbered="true" toc="default">
        <name>Next Header Field</name>
        <t>If the Next Header field does not vary and is known by both sides, the Field Descriptor in the Rule <bcp14>SHOULD</bcp14> contain a TV with
this Next Header value, the MO <bcp14>SHOULD</bcp14> be "equal", and the CDA <bcp14>SHOULD</bcp14> be "not-sent".</t>
        <t>Otherwise, TV is not set in the Field Descriptor, MO is set to "ignore", and CDA is set to "value-sent". Alternatively, a matching-list <bcp14>MAY</bcp14> also be used.</t>
      </section>
      <section anchor="hop-limit-field" numbered="true" toc="default">
        <name>Hop Limit Field</name>
        <t>The field behavior for this field is different for Uplink and Downlink.
In Uplink, since there is no IP forwarding between the Dev and the SCHC C/D, the value is relatively constant.
On the other hand, the Downlink value depends on Internet routing and can change more frequently.
The DI can be used to distinguish both directions:</t>
        <ul spacing="normal">
          <li>in an Up Field Descriptor, elide the field: the TV is set to the known constant value, the MO is set to "equal" and the CDA is set to "not-sent".</li>
          <li>in a Dw Field Descriptor, the Hop Limit is elided for transmission and forced to 1 at the receiver, by setting TV to 1, MO to "ignore" and CDA to "not-sent". This prevents any further forwarding.</li>
        </ul>
      </section>
      <section anchor="ipv6-addresses-fields" numbered="true" toc="default">
        <name>IPv6 Addresses Fields</name>
        <t>As in 6LoWPAN <xref target="RFC4944" format="default"/>, IPv6 addresses are split into two 64-bit-long fields; one for the prefix and one for the Interface Identifier (IID). These fields <bcp14>SHOULD</bcp14> be compressed. To allow for a single Rule being used for both directions, these values are identified by their role (Dev or App) and not by their position in the header (source or destination).</t>
        <section anchor="ipv6-source-and-destination-prefixes" numbered="true" toc="default">
          <name>IPv6 Source and Destination Prefixes</name>
          <t>Both ends <bcp14>MUST</bcp14> be configured with the appropriate prefixes. For a specific flow, the source and destination prefixes can be unique and stored in the Context.
In that case, the TV for the
source and destination prefixes contain the values, the MO is set to "equal" and the CDA is set to "not-sent".</t>
          <t>If the Rule is intended to compress packets with different prefix values, match-mapping <bcp14>SHOULD</bcp14> be used. The different prefixes are listed in the TV, the MO is set to "match-mapping" and the CDA is set to "mapping-sent". See <xref target="Fig-fields" format="default"/>.</t>
          <t>Otherwise, the TV is not set, the MO is set to "ignore", and the CDA is set to "value-sent".</t>
        </section>
        <section anchor="ipv6-source-and-destination-iid" numbered="true" toc="default">
          <name>IPv6 Source and Destination IID</name>
          <t>If the Dev or App IID are based on an L2 address, then the IID can be reconstructed with information coming from the L2 header. In that case, the TV is not set, the MO is set to "ignore" and the CDA is set to "DevIID" or "AppIID".
On LPWAN technologies where the frames carry a single identifier (corresponding to the Dev), AppIID cannot be used.</t>
          <t>As described in <xref target="RFC8065" format="default"/>, it may be undesirable to build the Dev IPv6 IID out of the Dev address. Another static value is used instead.
In that case, the TV contains the static value, the MO operator is set to "equal" and the CDA is set to "not-sent".</t>
          <t>If several IIDs are possible, then the TV contains the list of possible IIDs, the MO is set to "match-mapping" and the CDA is set to "mapping-sent".</t>
          <t>It may also happen that the IID variability only expresses itself on a few bytes. In that case, the TV is set to the stable part of the IID, the MO is set to "MSB" and the CDA is set to "LSB".</t>
          <t>Finally, the IID can be sent in its entirety on the L2. In that case, the TV is not set, the MO is set to "ignore", and the CDA is set to "value-sent".</t>
        </section>
      </section>
      <section anchor="ipv6-extension-headers" numbered="true" toc="default">
        <name>IPv6 Extension Headers</name>
        <t>This document does not provide recommendations on how to compress IPv6 extension headers.</t>
      </section>
      <section anchor="udp-source-and-destination-ports" numbered="true" toc="default">
        <name>UDP Source and Destination Ports</name>
        <t>To allow for a single Rule being used for both directions, the UDP port values are identified by their role (Dev or App) and not by their position in the header (source or destination). The SCHC C/D <bcp14>MUST</bcp14> be aware of the traffic direction (Uplink, Downlink) to select the appropriate field. The following Rules apply for Dev and App port numbers.</t>
        <t>If both ends know the port number, it can be elided. The TV
	contains the port number, the MO is set to "equal", and the CDA is set to "not-sent".</t>
        <t>If the port variation is on few bits, the TV contains the stable part of the port number, the MO is set to "MSB", and the CDA is set to "LSB".</t>
        <t>If some well-known values are used,  the TV can contain the list of these values, the MO is set to "match-mapping", and the CDA is set to "mapping-sent".</t>
        <t>Otherwise, the port numbers are sent over the L2. The TV is not set, the MO is set to "ignore" and the CDA is set to "value-sent".</t>
      </section>
      <section anchor="udp-length-field" numbered="true" toc="default">
        <name>UDP Length Field</name>
        <t>The parser MUST NOT label this field unless the UDP Length value
matches the Payload Length value from the IPv6 header.
The TV is not set, the MO is set to "ignore", and the CDA is set to
"compute-*".</t>
      </section>
      <section anchor="UDPchecksum" numbered="true" toc="default">
        <name>UDP Checksum Field</name>
        <t>The UDP checksum operation is mandatory with IPv6 for most
packets, but there are exceptions <xref target="RFC8200" format="default"/>.</t>
        <t>For instance, protocols that use UDP as a tunnel encapsulation may
enable zero-checksum mode for a specific port (or set of ports) for
sending and/or receiving. <xref target="RFC8200" format="default"/> requires any node
implementing zero-checksum mode to follow the requirements specified
in "Applicability Statement for the Use of IPv6 UDP Datagrams with
Zero Checksums" <xref target="RFC6936" format="default"/>.</t>
        <t>6LoWPAN Header Compression <xref target="RFC6282" format="default"/> also specifies that a UDP
checksum can be elided by the compressor and recomputed by the decompressor when an upper
layer guarantees the integrity of the UDP payload and pseudo-header.
A specific example of this is
when a message integrity check protects the compressed message
between the compressor that elides the UDP checksum and the decompressor
that computes it,
with a strength that is identical or better to
the UDP checksum.</t>
        <t>Similarly, a SCHC compressor <bcp14>MAY</bcp14>
elide the UDP checksum when another layer guarantees at least equal
integrity protection for the UDP payload and the pseudo-header.
In this case, the TV is not set, the MO is set to "ignore", and the CDA is set to "compute-*".</t>
        <t>In particular, when SCHC fragmentation is used, a fragmentation RCS
of 2 bytes or more provides equal or better protection than the UDP
checksum; in that case, if the compressor is collocated with the
fragmentation point and the decompressor is collocated with the
packet reassembly point,
and if the SCHC Packet is fragmented even when it would fit unfragmented in the L2 MTU,
then the compressor <bcp14>MAY</bcp14> verify and then elide the UDP checksum.
Whether and when the UDP Checksum is elided is to be specified in the
Profile.</t>
        <t>Since the compression happens before the fragmentation, implementers
should understand the risks when dealing with unprotected data below
the transport layer and take special care when manipulating that data.</t>
        <t>In other cases, the checksum <bcp14>SHOULD</bcp14> be explicitly sent. The TV is not set, the MO is set to "ignore" and the CDA is set to "value-sent".</t>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This document has no IANA actions.</t>
    </section>
    <section anchor="SecConsiderations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>As explained in <xref target="Overview" format="default"/>, SCHC is expected to be implemented on top of LPWAN technologies,
which are expected to implement security measures.</t>
      <t>In this section, we analyze the potential security threats that could be introduced
into an LPWAN by adding the SCHC functionalities.</t>
      <section anchor="security-considerations-for-schc-compressiondecompression" numbered="true" toc="default">
        <name>Security Considerations for SCHC Compression/Decompression</name>
        <section anchor="forged-schc-packet" numbered="true" toc="default">
          <name>Forged SCHC Packet</name>
          <t>Let's assume that an attacker is able to send a forged SCHC Packet to a SCHC decompressor.</t>
          <t>Let's first consider the case where the RuleID contained in that forged SCHC Packet does not correspond to a Rule allocated in the Rule table.
An implementation should detect that the RuleID is invalid and should silently drop the offending SCHC Packet.</t>
          <t>Let's now consider that the RuleID corresponds to a Rule in the table. With the CDAs defined in this document, the reconstructed packet is, at most, a constant number of bits bigger than the SCHC Packet that was received.
This assumes that the compute-* decompression actions produce a bounded number of bits, irrespective of the incoming SCHC Packet. This property is true for IPv6 Length, UDP Length, and UDP Checksum, for which the compute-* CDA is recommended by this document.</t>
          <t>As a consequence, SCHC decompression does not amplify attacks, beyond adding a bounded number of bits to the SCHC Packet received. This bound is determined by the Rule stored in the receiving device.</t>
          <t>As a general safety measure, a SCHC decompressor should never reconstruct a packet larger than MAX_PACKET_SIZE (defined in a Profile, with 1500 bytes as generic default).</t>
        </section>
        <section anchor="compressed-packet-size-as-a-side-channel-to-guess-a-secret-token" numbered="true" toc="default">
          <name>Compressed Packet Size as a Side Channel to Guess a Secret Token</name>
          <t>Some packet compression methods are known to be susceptible to attacks, such as BREACH and CRIME.
The attack involves injecting arbitrary data into the packet and observing the resulting compressed packet size. The observed size potentially reflects correlation between the arbitrary data and some content that was meant to remain secret, such as a security token, thereby allowing the attacker to get at the secret.</t>
          <t>By contrast, SCHC compression takes place header field by header field,
with the SCHC Packet being a mere concatenation of the compression residues of each of the individual field.
Any correlation between header fields does not result in a change in the SCHC Packet size compressed under the same Rule.</t>
          <t>If SCHC C/D is used to compress packets that include a secret information field, such as a token,
the Rule set should be designed so that the size of the compression residue for the field to remain secret
is the same irrespective of the value of the secret information.
This is achieved by, e.g., sending this field in extenso with the "ignore" MO and the "value-sent" CDA.
This recommendation is disputable if it is ascertained that the Rule set itself will remain secret.</t>
        </section>
        <section anchor="decompressed-packet-different-from-the-original-packet" numbered="true" toc="default">
          <name>Decompressed Packet Different from the Original Packet</name>
          <t>As explained in <xref target="PProcessing" format="default"/>, using FPs with value 0 in Field Descriptors in a Rule may result in header fields
appearing in the decompressed packet in an order different from that in the original packet.
Likewise, as stated in <xref target="NotSentCDA" format="default"/>, using an "ignore" MO together with a "not-sent" CDA will
result in the header field taking the TV value, which is likely to be different from the original value.</t>
          <t>Depending on the protocol, the order of header fields in
	  the packet may or may not be functionally significant.</t>
          <t>Furthermore, if the packet is protected by a checksum or a similar integrity protection mechanism,
and if the checksum is transmitted instead of being recomputed as part of the decompression,
these situations may result in the packet being considered corrupt and dropped.</t>
        </section>
      </section>
      <section anchor="security-considerations-for-schc-fragmentationreassembly" numbered="true" toc="default">
        <name>Security Considerations for SCHC Fragmentation/Reassembly</name>
        <section anchor="buffer-reservation-attack" numbered="true" toc="default">
          <name>Buffer Reservation Attack</name>
          <t>Let's assume that an attacker is able to send a forged SCHC Fragment to a SCHC reassembler.</t>
          <t>A node can perform a buffer reservation attack: the receiver will reserve buffer space for the SCHC Packet. If the implementation has only one buffer, other incoming fragmented SCHC Packets will be dropped while the reassembly buffer is occupied during the reassembly timeout. Once that timeout expires, the attacker can repeat the same procedure, and iterate, thus, creating a denial-of-service attack.
An implementation may have multiple reassembly buffers. The cost to mount this attack is linear with the number of buffers at the target node.
Better, the cost for an attacker can be increased if individual
fragments of multiple SCHC Packets can be stored in the reassembly
buffer. The finer grained the reassembly buffer (down to the smallest tile size), the higher the cost of the attack.
If buffer overload does occur, a smart receiver could selectively discard SCHC Packets being reassembled based on the sender behavior, which may help identify which SCHC Fragments have been sent by the attacker.
Another mild countermeasure is for the target to abort the fragmentation/reassembly session as early as it detects a non-identical SCHC Fragment duplicate, anticipating for an eventual corrupt SCHC Packet, so as to save the sender the hassle of sending the rest of the fragments for this SCHC Packet.</t>
        </section>
        <section anchor="corrupt-fragment-attack" numbered="true" toc="default">
          <name>Corrupt Fragment Attack</name>
          <t>Let's assume that an attacker is able to send a forged SCHC Fragment to a SCHC reassembler.
The malicious node is additionally assumed to be able to hear an incoming communication destined to the target node.</t>
          <t>It can then send a forged SCHC Fragment that looks like it belongs to a SCHC Packet already being reassembled at the target node.
This can cause the SCHC Packet to be considered corrupt and to be dropped by the receiver.
The amplification happens here by a single spoofed SCHC Fragment rendering a full sequence of legitimate SCHC Fragments useless.
If the target uses ACK-Always or ACK-on-Error mode, such a malicious node can also interfere with
the acknowledgement and repetition algorithm of SCHC F/R.
A single spoofed ACK, with all Bitmap bits set to 0, will trigger the repetition of WINDOW_SIZE tiles. This protocol loop amplification depletes the energy source of the target node and consumes the channel bandwidth.
Similarly, a spoofed ACK REQ will trigger the sending of a SCHC ACK,
which may be much larger than the ACK REQ if WINDOW_SIZE is large.
These consequences should be borne in mind when defining profiles for SCHC over specific LPWAN technologies.</t>
        </section>
        <section anchor="fragmentation-as-a-way-to-bypass-network-inspection" numbered="true" toc="default">
          <name>Fragmentation as a Way to Bypass Network Inspection</name>
          <t>Fragmentation is known for potentially allowing one to force through a Network Inspection device (e.g., firewall) packets that would be rejected if unfragmented.
This involves sending overlapping fragments to rewrite fields whose initial value led the Network Inspection device to allow the flow to go through.</t>
          <t>SCHC F/R is expected to be used over one LPWAN link, where no Network Inspection device is expected to sit.
As described in <xref target="FunctionalMapping" format="default"/>, even if the SCHC F/R on the Network Infrastructure side is located
in the Internet, a tunnel is to be established between it and the NGW.</t>
        </section>
        <section anchor="privacy-issues-associated-with-schc-header-fields" numbered="true" toc="default">
          <name>Privacy Issues Associated with SCHC Header Fields</name>
          <t>SCHC F/R allocates a DTag value to fragments belonging to the same SCHC Packet.
Concerns were raised that, if DTag is a wide counter that is incremented in a predictable fashion for each new fragmented SCHC Packet,
it might lead to a privacy issue, such as enabling tracking of a device across LPWANs.</t>
          <t>However, SCHC F/R is expected to be used over exactly one LPWAN link.
As described in <xref target="FunctionalMapping" format="default"/>, even if the SCHC F/R on the Network Infrastructure side is located
in the Internet, a tunnel is to be established between it and the NGW.
Therefore, assuming the tunnel provides confidentiality, neither the DTag field nor any other SCHC-introduced field is visible over the Internet.</t>
        </section>
      </section>
    </section>

  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6936.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8376.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4944.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5795.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6282.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6437.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7136.xml"/>
        <xi:include
	    href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8065.xml"/>

<reference anchor="ETHERNET" target="https://ieeexplore.ieee.org/document/6419735" quoteTitle="true" derivedAnchor="IEEE-802.3-2012">
<front>
<title>IEEE Standard for Ethernet</title>
<seriesInfo name="DOI" value="10.1109/IEEESTD.2012.6419735"/>
<seriesInfo name="IEEE Standard" value="802.3-2012"/>
<author>
<organization showOnFrontPage="true">IEEE</organization>
</author>
<date month="December" year="2012"/>
</front>
</reference>
	
    
      </references>
    </references>
    <section anchor="compressIPv6" numbered="true" toc="default">
      <name>Compression Examples</name>


      <t>This section gives some scenarios of the compression mechanism for IPv6/UDP. The goal is to illustrate the behavior of SCHC.</t>
      <t>The mechanisms defined in this document can be applied to a Dev that embeds some applications running over CoAP. In this example, three flows are considered. The first flow is for the device management based
on CoAP using Link Local IPv6 addresses and UDP ports 123 and 124 for
Dev and App, respectively. The second flow is a CoAP server for measurements done by the Dev (using ports 5683) and Global IPv6 Address prefixes alpha::IID/64 to beta::1/64.
The last flow is for legacy applications using different ports numbers, the destination IPv6 address prefix is gamma::1/64.</t>
      <t><xref target="FigStack" format="default"/> presents the protocol stack. IPv6 and UDP are represented with dotted lines since these protocols are compressed on the radio link.</t>
      <figure anchor="FigStack">
        <name>Simplified Protocol Stack for LP-WAN</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 Management   Data
+----------+---------+---------+
|   CoAP   |  CoAP   | legacy  |
+----||----+---||----+---||----+
.   UDP    .  UDP    |   UDP   |
................................
.   IPv6   .  IPv6   .  IPv6   .
+------------------------------+
|    SCHC Header compression   |
|      and fragmentation       |
+------------------------------+
|      LPWAN L2 technologies   |
+------------------------------+
         Dev or NGW]]></artwork>
      </figure>



      <figure anchor="Fig-fields">
        <name>Context Rules - Rule 0 and Rule 1</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Rule 0
  Special RuleID used to tag an uncompressed UDP/IPV6 packet.

Rule 1
 +----------------+--+--+--+---------+--------+------------++------+
 |       FID      |FL|FP|DI|    TV   |   MO   |     CDA    || Sent |
 |                |  |  |  |         |        |            ||[bits]|
 +----------------+--+--+--+---------+---------------------++------+
 |IPv6 Version    |4 |1 |Bi|6        | ignore | not-sent   ||      |
 |IPv6 Diffserv   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | compute-*  ||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |
 |IPv6 DevPrefix  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |
 |IPv6 DevIID     |64|1 |Bi|         | ignore | DevIID     ||      |
 |IPv6 AppPrefix  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |
 |IPv6 AppIID     |64|1 |Bi|::1      | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DevPort     |16|1 |Bi|123      | equal  | not-sent   ||      |
 |UDP AppPort     |16|1 |Bi|124      | equal  | not-sent   ||      |
 |UDP Length      |16|1 |Bi|         | ignore | compute-*  ||      |
 |UDP checksum    |16|1 |Bi|         | ignore | compute-*  ||      |
 +================+==+==+==+=========+========+============++======+]]></artwork>
      </figure>
     
      <figure anchor="Fig-fields1">
        <name>Context Rules - Rule 2</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 Rule 2
 +----------------+--+--+--+---------+--------+------------++------+
 |       FID      |FL|FP|DI|    TV   |   MO   |     CDA    || Sent |
 |                |  |  |  |         |        |            ||[bits]|
 +----------------+--+--+--+---------+--------+------------++------+
 |IPv6 Version    |4 |1 |Bi|6        | ignore | not-sent   ||      |
 |IPv6 Diffserv   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | compute-*  ||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |
 |IPv6 DevPrefix  |64|1 |Bi|[alpha/64, match- |mapping-sent||   1  |
 |                |  |  |  |fe80::/64] mapping|            ||      |
 |IPv6 DevIID     |64|1 |Bi|         | ignore | DevIID     ||      |
 |IPv6 AppPrefix  |64|1 |Bi|[beta/64,| match- |mapping-sent||   2  |
 |                |  |  |  |alpha/64,| mapping|            ||      |
 |                |  |  |  |fe80::64]|        |            ||      |
 |IPv6 AppIID     |64|1 |Bi|::1000   | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DevPort     |16|1 |Bi|5683     | equal  | not-sent   ||      |
 |UDP AppPort     |16|1 |Bi|5683     | equal  | not-sent   ||      |
 |UDP Length      |16|1 |Bi|         | ignore | compute-*  ||      |
 |UDP checksum    |16|1 |Bi|         | ignore | compute-*  ||      |
 +================+==+==+==+=========+========+============++======+]]></artwork>
      </figure>

      <figure anchor="Fig-fields2">
        <name>Context Rules - Rule 3</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 Rule 3
 +----------------+--+--+--+---------+--------+------------++------+
 |       FID      |FL|FP|DI|    TV   |   MO   |     CDA    || Sent |
 |                |  |  |  |         |        |            ||[bits]|
 +----------------+--+--+--+---------+--------+------------++------+
 |IPv6 Version    |4 |1 |Bi|6        | ignore | not-sent   ||      |
 |IPv6 Diffserv   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | compute-*  ||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Up|255      | ignore | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Dw|         | ignore | value-sent ||   8  |
 |IPv6 DevPrefix  |64|1 |Bi|alpha/64 | equal  | not-sent   ||      |
 |IPv6 DevIID     |64|1 |Bi|         | ignore | DevIID     ||      |
 |IPv6 AppPrefix  |64|1 |Bi|gamma/64 | equal  | not-sent   ||      |
 |IPv6 AppIID     |64|1 |Bi|::1000   | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DevPort     |16|1 |Bi|8720     | MSB(12)| LSB        ||   4  |
 |UDP AppPort     |16|1 |Bi|8720     | MSB(12)| LSB        ||   4  |
 |UDP Length      |16|1 |Bi|         | ignore | compute-*  ||      |
 |UDP checksum    |16|1 |Bi|         | ignore | compute-*  ||      |
 +================+==+==+==+=========+========+============++======+]]></artwork>
      </figure>
      <t>Figures <xref target="Fig-fields" format="counter"/> to <xref target="Fig-fields2" format="counter"/> describe an example of a Rule set.</t>
      <t>In this example, 0 was chosen as the special RuleID that tags packets that cannot be compressed with any compression Rule.</t>
      <t>All the fields described in Rules 1-3 are present in the IPv6 and UDP headers. The DevIID value is inferred from the L2 header.</t>
      <t>Rules 2-3 use global addresses. The way the Dev learns the prefix is not in the scope of the document.</t>
      <t>Rule 3 compresses each port number to 4 bits.</t>
    </section>
    <section anchor="FragExamples" numbered="true" toc="default">
      <name>Fragmentation Examples</name>
      <t>This section provides examples for the various fragment reliability modes specified in this document.
In the drawings, Bitmaps are shown in their uncompressed form.</t>
      <t><xref target="Fig-Example-Unreliable" format="default"/> illustrates the transmission in No-ACK mode of a SCHC Packet that needs 11 SCHC Fragments. FCN is 1 bit wide.</t>
      <figure anchor="Fig-Example-Unreliable">
        <name>No-ACK Mode, 11 SCHC Fragments</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
        Sender               Receiver
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-----FCN=1 + RCS --->| Integrity check: success
        (End)]]></artwork>
      </figure>
      <t>In the following examples, N (the size of the FCN field) is 3 bits. The All-1 FCN value is therefore 7.</t>
      <t><xref target="Fig-Example-Win-NoLoss-NACK" format="default"/> illustrates the transmission in ACK-on-Error mode of a SCHC Packet fragmented in 11 tiles, with one tile per SCHC Fragment, WINDOW_SIZE=7 and no lost SCHC Fragment.</t>
      <figure anchor="Fig-Example-Win-NoLoss-NACK">
        <name>ACK-on-Error Mode, 11 Tiles, One Tile per SCHC Fragment, No Lost SCHC Fragment</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
        Sender               Receiver
          |-----W=0, FCN=6----->|
          |-----W=0, FCN=5----->|
          |-----W=0, FCN=4----->|
          |-----W=0, FCN=3----->|
          |-----W=0, FCN=2----->|
          |-----W=0, FCN=1----->|
          |-----W=0, FCN=0----->|
      (no ACK)
          |-----W=1, FCN=6----->|
          |-----W=1, FCN=5----->|
          |-----W=1, FCN=4----->|
          |--W=1, FCN=7 + RCS-->| Integrity check: success
          |<-- ACK, W=1, C=1 ---| C=1
        (End)]]></artwork>
      </figure>
      <t><xref target="Fig-Example-Rel-Window-NACK-Loss" format="default"/> illustrates the transmission in ACK-on-Error mode of a SCHC Packet fragmented in 11 tiles, with one tile per SCHC Fragment, WINDOW_SIZE=7, and three lost SCHC Fragments.</t>
      <figure anchor="Fig-Example-Rel-Window-NACK-Loss">
        <name>ACK-on-Error Mode, 11 Tiles, One Tile per SCHC Fragment, Lost SCHC Fragments</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
        Sender               Receiver
          |-----W=0, FCN=6----->|
          |-----W=0, FCN=5----->|
          |-----W=0, FCN=4--X-->|
          |-----W=0, FCN=3----->|
          |-----W=0, FCN=2--X-->|
          |-----W=0, FCN=1----->|
          |-----W=0, FCN=0----->|        6543210
          |<-- ACK, W=0, C=0 ---| Bitmap:1101011
          |-----W=0, FCN=4----->|
          |-----W=0, FCN=2----->|   
      (no ACK)     
          |-----W=1, FCN=6----->|
          |-----W=1, FCN=5----->|
          |-----W=1, FCN=4--X-->|
          |- W=1, FCN=7 + RCS ->| Integrity check: failure
          |<-- ACK, W=1, C=0 ---| C=0, Bitmap:1100001
          |-----W=1, FCN=4----->| Integrity check: success
          |<-- ACK, W=1, C=1 ---| C=1
        (End)]]></artwork>
      </figure>
      <t><xref target="Figure-Example-ACK-on-Error-VarMTU" format="default"/> shows an example of a transmission in ACK-on-Error mode of a SCHC Packet fragmented in
73 tiles, with N=5, WINDOW_SIZE=28, M=2, and three lost SCHC Fragments.</t>
      <figure anchor="Figure-Example-ACK-on-Error-VarMTU">
        <name>ACK-on-Error Mode, Variable MTU</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   Sender               Receiver
    |-----W=0, FCN=27----->| 4 tiles sent
    |-----W=0, FCN=23----->| 4 tiles sent
    |-----W=0, FCN=19----->| 4 tiles sent
    |-----W=0, FCN=15--X-->| 4 tiles sent (not received)
    |-----W=0, FCN=11----->| 4 tiles sent
    |-----W=0, FCN=7 ----->| 4 tiles sent
    |-----W=0, FCN=3 ----->| 4 tiles sent
    |-----W=1, FCN=27----->| 4 tiles sent
    |-----W=1, FCN=23----->| 4 tiles sent
    |-----W=1, FCN=19----->| 4 tiles sent
    |-----W=1, FCN=15----->| 4 tiles sent
    |-----W=1, FCN=11----->| 4 tiles sent
    |-----W=1, FCN=7 ----->| 4 tiles sent
    |-----W=1, FCN=3 --X-->| 4 tiles sent (not received)
    |-----W=2, FCN=27----->| 4 tiles sent
    |-----W=2, FCN=23----->| 4 tiles sent
^   |-----W=2, FCN=19----->| 1 tile sent
|   |-----W=2, FCN=18----->| 1 tile sent
|   |-----W=2, FCN=17----->| 1 tile sent
    |-----W=2, FCN=16----->| 1 tile sent
s   |-----W=2, FCN=15----->| 1 tile sent
m   |-----W=2, FCN=14----->| 1 tile sent
a   |-----W=2, FCN=13--X-->| 1 tile sent (not received)
l   |-----W=2, FCN=12----->| 1 tile sent
l   |---W=2, FCN=31 + RCS->| Integrity check: failure
e   |<--- ACK, W=0, C=0 ---| C=0, Bitmap:1111111111110000111111111111
r   |-----W=0, FCN=15----->| 1 tile sent
    |-----W=0, FCN=14----->| 1 tile sent
L   |-----W=0, FCN=13----->| 1 tile sent
2   |-----W=0, FCN=12----->| 1 tile sent
    |<--- ACK, W=1, C=0 ---| C=0, Bitmap:1111111111111111111111110000
M   |-----W=1, FCN=3 ----->| 1 tile sent
T   |-----W=1, FCN=2 ----->| 1 tile sent
U   |-----W=1, FCN=1 ----->| 1 tile sent
    |-----W=1, FCN=0 ----->| 1 tile sent
|   |<--- ACK, W=2, C=0 ---| C=0, Bitmap:1111111111111101000000000001
|   |-----W=2, FCN=13----->| Integrity check: success
V   |<--- ACK, W=2, C=1 ---| C=1
  (End)]]></artwork>
      </figure>
      <t>In this example, the L2 MTU becomes reduced just before sending the "W=2, FCN=19" fragment, leaving space for only one tile in each forthcoming SCHC Fragment.
Before retransmissions, the 73 tiles are carried by a total of 25 SCHC Fragments, the last nine being of smaller size.</t>
      <t>Note: other sequences of events (e.g., regarding when ACKs are sent by the Receiver) are also allowed by this specification. Profiles may restrict this flexibility.</t>
      <t><xref target="Fig-Example-Rel-Window-ACK-NoLoss" format="default"/> illustrates the transmission in ACK-Always mode of a SCHC Packet fragmented in 11 tiles, with one tile per SCHC Fragment, with N=3, WINDOW_SIZE=7, and no loss.</t>
      <figure anchor="Fig-Example-Rel-Window-ACK-NoLoss">
        <name>ACK-Always Mode, 11 Tiles, One Tile per SCHC Fragment, No Loss</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
        Sender               Receiver
          |-----W=0, FCN=6----->|
          |-----W=0, FCN=5----->|
          |-----W=0, FCN=4----->|
          |-----W=0, FCN=3----->|
          |-----W=0, FCN=2----->|
          |-----W=0, FCN=1----->|
          |-----W=0, FCN=0----->|
          |<-- ACK, W=0, C=0 ---| Bitmap:1111111
          |-----W=1, FCN=6----->|
          |-----W=1, FCN=5----->|   
          |-----W=1, FCN=4----->|
          |--W=1, FCN=7 + RCS-->| Integrity check: success
          |<-- ACK, W=1, C=1 ---| C=1
        (End)]]></artwork>
      </figure>
      <t><xref target="Fig-Example-Rel-Window-ACK-Loss" format="default"/> illustrates the transmission in ACK-Always mode of a SCHC Packet fragmented in 11 tiles, with one tile per SCHC Fragment, N=3, WINDOW_SIZE=7 and three lost SCHC Fragments.</t>
      <figure anchor="Fig-Example-Rel-Window-ACK-Loss">
        <name>ACK-Always Mode, 11 Tiles, One Tile per SCHC Fragment, Three Lost SCHC Fragments</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
        Sender               Receiver
          |-----W=0, FCN=6----->|
          |-----W=0, FCN=5----->|
          |-----W=0, FCN=4--X-->|
          |-----W=0, FCN=3----->|
          |-----W=0, FCN=2--X-->|
          |-----W=0, FCN=1----->|
          |-----W=0, FCN=0----->|        6543210
          |<-- ACK, W=0, C=0 ---| Bitmap:1101011
          |-----W=0, FCN=4----->|
          |-----W=0, FCN=2----->|
          |<-- ACK, W=0, C=0 ---| Bitmap:1111111
          |-----W=1, FCN=6----->|
          |-----W=1, FCN=5----->|
          |-----W=1, FCN=4--X-->|
          |--W=1, FCN=7 + RCS-->| Integrity check: failure
          |<-- ACK, W=1, C=0 ---| C=0, Bitmap:11000001
          |-----W=1, FCN=4----->| Integrity check: success
          |<-- ACK, W=1, C=1 ---| C=1
        (End)]]></artwork>
      </figure>
      <t><xref target="Fig-Example-Rel-Window-ACK-Loss-Last-A" format="default"/> illustrates the transmission in ACK-Always mode of a SCHC Packet fragmented in six tiles,
with one tile per SCHC Fragment, N=3, WINDOW_SIZE=7, three lost SCHC Fragments, and only one retry needed to recover each lost SCHC Fragment.</t>
      <figure anchor="Fig-Example-Rel-Window-ACK-Loss-Last-A">
        <name>ACK-Always Mode, Six Tiles, One Tile per SCHC Fragment, Three Lost SCHC Fragments</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
          Sender                Receiver
             |-----W=0, FCN=6----->|
             |-----W=0, FCN=5----->|
             |-----W=0, FCN=4--X-->|
             |-----W=0, FCN=3--X-->|
             |-----W=0, FCN=2--X-->|
             |--W=0, FCN=7 + RCS-->| Integrity check: failure
             |<-- ACK, W=0, C=0 ---| C=0, Bitmap:1100001
             |-----W=0, FCN=4----->| Integrity check: failure
             |-----W=0, FCN=3----->| Integrity check: failure
             |-----W=0, FCN=2----->| Integrity check: success
             |<-- ACK, W=0, C=1 ---| C=1
           (End)]]></artwork>
      </figure>
      <t><xref target="Fig-Example-Rel-Window-ACK-Loss-Last-B" format="default"/> illustrates the transmission in ACK-Always mode of a SCHC Packet fragmented in six tiles,
with one tile per SCHC Fragment, N=3, WINDOW_SIZE=7, three lost SCHC Fragments, and the second SCHC ACK lost.</t>
      <figure anchor="Fig-Example-Rel-Window-ACK-Loss-Last-B">
        <name>ACK-Always Mode, Six Tiles, One Tile per SCHC Fragment, SCHC ACK Loss</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
          Sender                Receiver
             |-----W=0, FCN=6----->|
             |-----W=0, FCN=5----->|
             |-----W=0, FCN=4--X-->|
             |-----W=0, FCN=3--X-->|
             |-----W=0, FCN=2--X-->|
             |--W=0, FCN=7 + RCS-->| Integrity check: failure
             |<-- ACK, W=0, C=0 ---| C=0, Bitmap:1100001
             |-----W=0, FCN=4----->| Integrity check: failure
             |-----W=0, FCN=3----->| Integrity check: failure
             |-----W=0, FCN=2----->| Integrity check: success
             |<-X-ACK, W=0, C=1 ---| C=1
    timeout  |                     |
             |--- W=0, ACK REQ --->| ACK REQ
             |<-- ACK, W=0, C=1 ---| C=1
           (End)]]></artwork>
      </figure>
      <t><xref target="Fig-Example-Rel-Window-ACK-Loss-Last-C" format="default"/> illustrates the transmission in ACK-Always mode of a SCHC Packet fragmented in six tiles,
with N=3, WINDOW_SIZE=7, with three lost SCHC Fragments, and one retransmitted SCHC Fragment lost again.</t>
      <figure anchor="Fig-Example-Rel-Window-ACK-Loss-Last-C">
        <name>ACK-Always Mode, Six Tiles, Retransmitted SCHC Fragment Lost Again</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
           Sender                Receiver
             |-----W=0, FCN=6----->|
             |-----W=0, FCN=5----->|
             |-----W=0, FCN=4--X-->|
             |-----W=0, FCN=3--X-->|
             |-----W=0, FCN=2--X-->|
             |--W=0, FCN=7 + RCS-->| Integrity check: failure
             |<-- ACK, W=0, C=0 ---| C=0, Bitmap:1100001
             |-----W=0, FCN=4----->| Integrity check: failure
             |-----W=0, FCN=3----->| Integrity check: failure
             |-----W=0, FCN=2--X-->|
      timeout|                     |
             |--- W=0, ACK REQ --->| ACK REQ
             |<-- ACK, W=0, C=0 ---| C=0, Bitmap: 1111101
             |-----W=0, FCN=2----->| Integrity check: success
             |<-- ACK, W=0, C=1 ---| C=1
           (End)]]></artwork>
      </figure>
      <t><xref target="Fig-Example-MaxWindFCN" format="default"/> illustrates the transmission in ACK-Always mode of a SCHC Packet fragmented in 28 tiles,
with one tile per SCHC Fragment, N=5, WINDOW_SIZE=24, and two lost SCHC Fragments.</t>
      <figure anchor="Fig-Example-MaxWindFCN">
        <name>ACK-Always Mode, 28 Tiles, One Tile per SCHC Fragment, Lost SCHC Fragments</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
      Sender               Receiver
        |-----W=0, FCN=23----->|
        |-----W=0, FCN=22----->|
        |-----W=0, FCN=21--X-->|
        |-----W=0, FCN=20----->|
        |-----W=0, FCN=19----->|
        |-----W=0, FCN=18----->|
        |-----W=0, FCN=17----->|
        |-----W=0, FCN=16----->|
        |-----W=0, FCN=15----->|
        |-----W=0, FCN=14----->|
        |-----W=0, FCN=13----->|
        |-----W=0, FCN=12----->|
        |-----W=0, FCN=11----->|
        |-----W=0, FCN=10--X-->|
        |-----W=0, FCN=9 ----->|
        |-----W=0, FCN=8 ----->|
        |-----W=0, FCN=7 ----->|
        |-----W=0, FCN=6 ----->|
        |-----W=0, FCN=5 ----->|
        |-----W=0, FCN=4 ----->|
        |-----W=0, FCN=3 ----->|
        |-----W=0, FCN=2 ----->|
        |-----W=0, FCN=1 ----->|
        |-----W=0, FCN=0 ----->|
        |                      |
        |<--- ACK, W=0, C=0 ---| Bitmap:110111111111101111111111
        |-----W=0, FCN=21----->|
        |-----W=0, FCN=10----->|
        |<--- ACK, W=0, C=0 ---| Bitmap:111111111111111111111111
        |-----W=1, FCN=23----->|
        |-----W=1, FCN=22----->|
        |-----W=1, FCN=21----->|
        |--W=1, FCN=31 + RCS-->| Integrity check: success
        |<--- ACK, W=1, C=1 ---| C=1
      (End)]]></artwork>
      </figure>
    </section>
    <section anchor="FSM" numbered="true" toc="default">
      <name>Fragmentation State Machines</name>
      <t>The fragmentation state machines of the sender and the receiver, one for each of the different reliability modes, are described in the following figures:</t>
      <figure anchor="Fig-NoACKModeSnd">
        <name>Sender State Machine for the No-ACK Mode</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
             +===========+
+------------+  Init     |                                      
|  FCN=0     +===========+                                      
|  No Window                                       
|  No Bitmap                                                      
|                   +-------+           
|          +========+==+    | More Fragments                 
|          |           | <--+ ~~~~~~~~~~~~~~~~~~~~                          
+--------> |   Send    |      send Fragment (FCN=0)                            
           +===+=======+                                                                      
               |  last fragment
               |  ~~~~~~~~~~~~                               
               |  FCN = 1                               
               v  send fragment+RCS
           +============+                                             
           |    END     |                                             
           +============+]]></artwork>
      </figure>
      <figure anchor="Fig-NoACKModeRcv">
        <name>Receiver State Machine for the No-ACK Mode</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
                      +------+ Not All-1
           +==========+=+    | ~~~~~~~~~~~~~~~~~~~
           |            + <--+ set Inactivity Timer
           |  RCV Frag  +-------+
           +=+===+======+       |All-1 &
   All-1 &   |   |              |RCS correct
 RCS wrong   |   |Inactivity    |
             |   |Timer Exp.    |
             v   |              |
  +==========++  |              v
  |   Error   |<-+     +========+==+
  +===========+        |    END    |
                       +===========+]]></artwork>
      </figure>
      <figure anchor="Fig-ACKAlwaysSnd">
        <name>Sender State Machine for the ACK-Always Mode</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
              +=======+  
              | INIT  |       FCN!=0 & more frags
              |       |       ~~~~~~~~~~~~~~~~~~~~~~
              +======++  +--+ send Window + frag(FCN)
                 W=0 |   |  | FCN-
  Clear lcl_bm       |   |  v set lcl_bm
       FCN=max value |  ++==+========+
                     +> |            |
+---------------------> |    SEND    |
|                       +==+===+=====+
|      FCN==0 & more frags |   | last frag
|    ~~~~~~~~~~~~~~~~~~~~~ |   | ~~~~~~~~~~~~~~~
|               set lcl_bm |   | set lcl_bm
|   send wnd + frag(all-0) |   | send wnd+frag(all-1)+RCS
|       set Retrans_Timer  |   | set Retrans_Timer
|                          |   |
|Recv_wnd == wnd &         |   |  
|lcl_bm==recv_bm &         |   |  +----------------------+
|more frag                 |   |  | lcl_bm!=rcv-bm       |
|~~~~~~~~~~~~~~~~~~~~~~    |   |  | ~~~~~~~~~            |
|Stop Retrans_Timer        |   |  | Attempt++            v
|clear lcl_bm              v   v  |                +=====+=+
|window=next_window   +====+===+==+===+            |Resend |
+---------------------+               |            |Missing|
                 +----+     Wait      |            |Frag   |
not expected wnd |    |    Bitmap     |            +=======+
~~~~~~~~~~~~~~~~ +--->+               ++Retrans_Timer Exp  |          
    discard frag      +==+=+===+=+==+=+| ~~~~~~~~~~~~~~~~~ |
                         | |   | ^  ^  |reSend(empty)All-* |   
                         | |   | |  |  |Set Retrans_Timer  |
                         | |   | |  +--+Attempt++          |
  C_bit==1 &             | |   | +-------------------------+
Recv_window==window &    | |   |   all missing frags sent
             no more frag| |   |   ~~~~~~~~~~~~~~~~~~~~~~
 ~~~~~~~~~~~~~~~~~~~~~~~~| |   |   Set Retrans_Timer 
       Stop Retrans_Timer| |   |    
 +=============+         | |   |
 |     END     +<--------+ |   |
 +=============+           |   | Attempt > MAX_ACK_REQUESTS
            All-1 Window & |   | ~~~~~~~~~~~~~~~~~~
               C_bit ==0 & |   v Send Abort
          lcl_bm==recv_bm  | +=+===========+
              ~~~~~~~~~~~~ +>|    ERROR    |
                Send Abort   +=============+]]></artwork>
      </figure>
      <figure anchor="Fig-ACKAlwaysRcv">
        <name>Receiver State Machine for the ACK-Always Mode</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 Not All- & w=expected +---+   +---+w = Not expected
 ~~~~~~~~~~~~~~~~~~~~~ |   |   |   |~~~~~~~~~~~~~~~~
 Set lcl_bm(FCN)       |   v   v   |discard
                      ++===+===+===+=+      
+---------------------+     Rcv      +--->* ABORT
|  +------------------+   Window     |
|  |                  +=====+==+=====+  
|  |       All-0 & w=expect |  ^ w =next & not-All
|  |     ~~~~~~~~~~~~~~~~~~ |  |~~~~~~~~~~~~~~~~~~~~~
|  |    set lcl_bm(FCN)     |  |expected = next window
|  |      send lcl_bm       |  |Clear lcl_bm
|  |                        |  |    
|  | w=expected & not-All   |  |
|  | ~~~~~~~~~~~~~~~~~~     |  |
|  |     set lcl_bm(FCN)+-+ |  | +--+ w=next & All-0
|  |     if lcl_bm full | | |  | |  | ~~~~~~~~~~~~~~~
|  |     send lcl_bm    | | |  | |  | expected = nxt wnd
|  |                    v | v  | |  | Clear lcl_bm
|  |w=expected& All-1 +=+=+=+==+=++ | set lcl_bm(FCN)
|  |  ~~~~~~~~~~~  +->+    Wait   +<+ send lcl_bm
|  |    discard    +--|    Next   |   
|  | All-0  +---------+  Window   +--->* ABORT  
|  | ~~~~~  +-------->+========+=++        
|  | snd lcl_bm  All-1 & w=next| |  All-1 & w=nxt
|  |                & RCS wrong| |  & RCS right
|  |          ~~~~~~~~~~~~~~~~~| | ~~~~~~~~~~~~~~~~~~
|  |            set lcl_bm(FCN)| |set lcl_bm(FCN)
|  |                send lcl_bm| |send lcl_bm
|  |                           | +----------------------+
|  |All-1 & w=expected         |                        |
|  |& RCS wrong                v   +---+ w=expected &   |
|  |~~~~~~~~~~~~~~~~~~~~  +====+=====+ | RCS wrong      |
|  |set lcl_bm(FCN)       |          +<+ ~~~~~~~~~~~~~~ |
|  |send lcl_bm           | Wait End |   set lcl_bm(FCN)|
|  +--------------------->+          +--->* ABORT       |
|                         +===+====+=+-+ All-1&RCS wrong|
|                             |    ^   | ~~~~~~~~~~~~~~~|
|      w=expected & RCS right |    +---+   send lcl_bm  |
|      ~~~~~~~~~~~~~~~~~~~~~~ |                         |
|       set lcl_bm(FCN)       | +-+ Not All-1           |
|        send lcl_bm          | | | ~~~~~~~~~           |
|                             | | |  discard            |
|All-1&w=expected & RCS right | | |                     |
|~~~~~~~~~~~~~~~~~~~~~~~~~~~~ v | v +----+All-1         |
|set lcl_bm(FCN)            +=+=+=+=+==+ |~~~~~~~~~     |
|send lcl_bm                |          +<+Send lcl_bm   |
+-------------------------->+    END   |                |
                            +==========+<---------------+

       --->* ABORT

       In any state
          on receiving a SCHC ACK REQ
             Send a SCHC ACK for the current window]]></artwork>
      </figure>
      <figure anchor="Fig-ACKonerrorSnd">
        <name>Sender State Machine for the ACK-on-Error Mode</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
                  +=======+
                  |       |
                  | INIT  |
                  |       |       FCN!=0 & more frags
                  +======++       ~~~~~~~~~~~~~~~~~~~~~~
     Frag RuleID trigger |   +--+ Send cur_W + frag(FCN);
     ~~~~~~~~~~~~~~~~~~~ |   |  | FCN--;
  cur_W=0; FCN=max_value;|   |  | set [cur_W, cur_Bmp]
    clear [cur_W, Bmp_n];|   |  v
          clear rcv_Bmp  |  ++==+==========+       **BACK_TO_SEND
                         +->+              |   cur_W==rcv_W &
      **BACK_TO_SEND        |     SEND     |   [cur_W,Bmp_n]==rcv_Bmp
+-------------------------->+              |   & more frags
|  +----------------------->+              |   ~~~~~~~~~~~~
|  |                        ++==+==========+   cur_W++;
|  |      FCN==0 & more frags|  |last frag     clear [cur_W, Bmp_n]
|  |  ~~~~~~~~~~~~~~~~~~~~~~~|  |~~~~~~~~~
|  |        set cur_Bmp;     |  |set [cur_W, Bmp_n];
|  |send cur_W + frag(All-0);|  |send cur_W + frag(All-1)+RCS;
|  |        set Retrans_Timer|  |set Retrans_Timer
|  |                         |  | +---------------------------------+
|  |                         |  | |cur_W ==                         |
|  |Retrans_Timer expires &  |  | |   rcv_W & [cur_W,Bmp_n]!=rcv_Bmp|
|  |more Frags               |  | |  ~~~~~~~~~~~~~~~~~~~            |
|  |~~~~~~~~~~~~~~~~~~~~     |  | |  Attempts++; W=cur_W            |
|  |stop Retrans_Timer;      |  | | +--------+           rcv_W==Wn &|
|  |[cur_W,Bmp_n]==cur_Bmp;  v  v | |        v   [Wn,Bmp_n]!=rcv_Bmp|
|  |cur_W++            +=====+==+=+=+==+   +=+=========+ ~~~~~~~~~~~|
|  +-------------------+               |   | Resend    | Attempts++;|
+----------------------+   Wait x ACK  |   | Missing   |       W=Wn |
+--------------------->+               |   | Frags(W)  +<-----------+
|         rcv_W==Wn &+-+               |   +======+====+
| [Wn,Bmp_n]!=rcv_Bmp| ++=+===+===+==+=+          |
|      ~~~~~~~~~~~~~~|  ^ |   |   |  ^            |
|        send (cur_W,+--+ |   |   |  +------------+
|        ALL-0-empty)     |   |   |     all missing frag sent(W)
|                         |   |   |     ~~~~~~~~~~~~~~~~~
|  Retrans_Timer expires &|   |   |     set Retrans_Timer
|            No more Frags|   |   |
|           ~~~~~~~~~~~~~~|   |   |
|      stop Retrans_Timer;|   |   |
|(re)send frag(All-1)+RCS |   |   |
+-------------------------+   |   |
                 cur_W==rcv_W&|   |
       [cur_W,Bmp_n]==rcv_Bmp&|   | Attempts > MAX_ACK_REQUESTS
  No more Frags & RCS flag==OK|   | ~~~~~~~~~~
            ~~~~~~~~~~~~~~~~~~|   | send Abort
 +=========+stop Retrans_Timer|   |  +===========+
 |   END   +<-----------------+   +->+   ERROR   |
 +=========+                         +===========+]]></artwork>
      </figure>
      <t>This is an example only. It is not normative.
The specification in <xref target="ACK-on-Error-sender" format="default"/> allows for sequences of operations different from the one shown here.</t>
      <artwork name="" type="" align="left" alt=""><![CDATA[
                 +=======+        New frag RuleID received
                 |       |        ~~~~~~~~~~~~~
                 | INIT  +-------+cur_W=0;clear([cur_W,Bmp_n]);
                 +=======+       |sync=0
                                 |
    Not All* & rcv_W==cur_W+---+ | +--+
      ~~~~~~~~~~~~~~~~~~~~ |   | | | (E)
      set[cur_W,Bmp_n(FCN)]|   v v v  |
                          ++===+=+=+==+=+
   +----------------------+             +--+ All-0&Full[cur_W,Bmp_n]
   |           ABORT *<---+  Rcv Window |  | ~~~~~~~~~~
   |  +-------------------+             +<-+ cur_W++;set Inact_timer;
   |  |                +->+=+=+=+=+=+===+    clear [cur_W,Bmp_n]
   |  | All-0 empty(Wn)|    | | | ^ ^
   |  | ~~~~~~~~~~~~~~ +----+ | | | |rcv_W==cur_W & sync==0;
   |  | sendACK([Wn,Bmp_n])   | | | |& Full([cur_W,Bmp_n])
   |  |                       | | | |& All* || last_miss_frag
   |  |                       | | | |~~~~~~~~~~~~~~~~~~~~~~
   |  |    All* & rcv_W==cur_W|(C)| |sendACK([cur_W,Bmp_n]);
   |  |              & sync==0| | | |cur_W++; clear([cur_W,Bmp_n])
   |  |&no_full([cur_W,Bmp_n])| |(E)|
   |  |      ~~~~~~~~~~~~~~~~ | | | |              +========+
   |  | sendACK([cur_W,Bmp_n])| | | |              | Error/ |
   |  |                       | | | |   +----+     | Abort  |
   |  |                       v v | |   |    |     +===+====+
   |  |                   +===+=+=+=+===+=+ (D)        ^
   |  |                +--+    Wait x     |  |         |
   |  | All-0 empty(Wn)+->| Missing Frags |<-+         |
   |  | ~~~~~~~~~~~~~~    +=============+=+            |
   |  | sendACK([Wn,Bmp_n])             +--------------+
   |  |                                       *ABORT
   v  v
  (A)(B)
                                   (D) All* || last_miss_frag
    (C) All* & sync>0                  & rcv_W!=cur_W & sync>0
        ~~~~~~~~~~~~                   & Full([rcv_W,Bmp_n])
        Wn=oldest[not full(W)];        ~~~~~~~~~~~~~~~~~~~~
        sendACK([Wn,Bmp_n])            Wn=oldest[not full(W)];
                                       sendACK([Wn,Bmp_n]);sync--

                             ABORT-->* Uplink Only &
                                       Inact_Timer expires
    (E) Not All* & rcv_W!=cur_W        || Attempts > MAX_ACK_REQUESTS
        ~~~~~~~~~~~~~~~~~~~~           ~~~~~~~~~~~~~~~~~~~~~
        sync++; cur_W=rcv_W;           send Abort
        set[cur_W,Bmp_n(FCN)]]]></artwork>
      <figure anchor="Fig-ACKonerrorRcv">
        <name>Receiver State Machine for the ACK-on-Error Mode</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
  (A)(B)
   |  |
   |  | All-1 & rcv_W==cur_W & RCS!=OK        All-0 empty(Wn)
   |  | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~     +-+  ~~~~~~~~~~
   |  | sendACK([cur_W,Bmp_n],C=0)       | v  sendACK([Wn,Bmp_n])
   |  |                      +===========+=++
   |  +--------------------->+   Wait End   +-+
   |                         +=====+=+====+=+ | All-1
   |     rcv_W==cur_W & RCS==OK    | |    ^   | & rcv_W==cur_W
   |     ~~~~~~~~~~~~~~~~~~~~~~    | |    +---+ & RCS!=OK
   |  sendACK([cur_W,Bmp_n],C=1)   | |          ~~~~~~~~~~~~~~~~~~~
   |                               | | sendACK([cur_W,Bmp_n],C=0);
   |                               | |          Attempts++
   |All-1 & Full([cur_W,Bmp_n])    | |
   |& RCS==OK & sync==0            | +-->* ABORT
   |~~~~~~~~~~~~~~~~~~~            v
   |sendACK([cur_W,Bmp_n],C=1)   +=+=========+
   +---------------------------->+    END    |
                                 +===========+]]></artwork>
      </figure>
    </section>
    <section anchor="SCHCParams" numbered="true" toc="default">
      <name>SCHC Parameters</name>
      <t>This section lists the information that needs to be provided in the LPWAN technology-specific documents.</t>
      <ul spacing="normal">
        <li>Most common uses cases, deployment scenarios.</li>
        <li>Mapping of the SCHC architectural elements onto the LPWAN architecture.</li>
        <li>Assessment of LPWAN integrity checking.</li>
        <li>Various potential channel conditions for the technology and the corresponding recommended use of SCHC C/D and SCHC F/R.</li>
      </ul>
      <t>This section lists the parameters that need to be defined in the Profile.</t>
      <ul spacing="normal">
        <li>RuleID numbering scheme, fixed-size or variable-size RuleIDs, number of Rules, the way the RuleID is transmitted.</li>
        <li>maximum packet size that should ever be reconstructed by SCHC decompression (MAX_PACKET_SIZE). See <xref target="SecConsiderations" format="default"/>.</li>
        <li>Padding: size of the L2 Word (for most LPWAN technologies, this would be a byte; for some technologies, a bit).</li>
        <li>
          <t>Decision to use SCHC fragmentation mechanism or not. If yes, the document must describe:  </t>
          <ul spacing="normal">
            <li>reliability mode(s) used, in which cases (e.g., based on link channel condition).</li>
            <li>RuleID values assigned to each mode in use.</li>
            <li>presence and number of bits for DTag (T) for each RuleID value, lifetime of DTag at the receiver.</li>
            <li>support for interleaved packet transmission, to what extent.</li>
            <li>WINDOW_SIZE, for modes that use windows.</li>
            <li>number of bits for W (M) for each RuleID value, for modes that use windows.</li>
            <li>number of bits for FCN (N) for each RuleID value, meaning of the FCN values.</li>
            <li>what makes an All-0 SCHC Fragment and a SCHC ACK REQ distinguishable (see <xref target="NotLastFrag" format="default"/>).</li>
            <li>what makes an All-1 SCHC Fragment and a SCHC Sender-Abort distinguishable (see <xref target="LastFrag" format="default"/>).</li>
            <li>for RuleIDs that use ACK-on-Error mode: when the last tile of a SCHC Packet is to be sent in a Regular SCHC Fragment, alone in an All-1 SCHC Fragment or with any of these two methods.</li>
            <li>for RuleIDs that use ACK-on-Error mode: if the penultimate tile of a SCHC Packet is of the regular size only or if it can also be one L2 Word shorter.</li>
            <li>for RuleIDs that use ACK-on-Error mode: times at which the sender must listen for SCHC ACKs.</li>
            <li>size of RCS and algorithm for its computation, for each RuleID, if different from the default CRC32. Byte fill-up with zeroes or other mechanism, to be specified. Support for UDP checksum elision.</li>
            <li>Retransmission Timer duration for each RuleID value, if applicable to the SCHC F/R mode.</li>
            <li>Inactivity Timer duration for each RuleID value, if applicable to the SCHC F/R mode.</li>
            <li>MAX_ACK_REQUESTS value for each RuleID value, if applicable to the SCHC F/R mode.</li>
          </ul>
        </li>
        <li>if L2 Word is wider than a bit and SCHC fragmentation is used, value of the padding bits (0 or 1).</li>
      </ul>
      <t>A Profile may define a delay to be added after each SCHC message transmission for compliance with local regulations or other constraints imposed by the applications.</t>
      <ul spacing="normal">
        <li>In some LPWAN technologies, as part of energy-saving techniques,
Downlink transmission is only possible immediately after an Uplink transmission.
In order to avoid potentially high delay in the Downlink transmission of a fragmented SCHC Packet,
the SCHC Fragment receiver may perform an Uplink transmission as soon as possible after reception of a SCHC
Fragment that is not the last one.
Such Uplink transmission may be triggered by the L2 (e.g., an L2 ACK sent in response to a SCHC Fragment encapsulated
in a L2 PDU that requires an L2 ACK) or it may be triggered from an upper layer. See <xref target="AsymLinks" format="default"/>.</li>
        <li>
          <t>the following parameters need to be addressed in documents other than this one but not necessarily in
the LPWAN technology-specific documents:  </t>
          <ul spacing="normal">
            <li>The way the Contexts are provisioned.</li>
            <li>The way the Rules are generated.</li>
          </ul>
        </li>
      </ul>
    </section>
    <section anchor="MultWinSizes" numbered="true" toc="default">
      <name>Supporting Multiple Window Sizes for Fragmentation</name>
      <t>For ACK-Always or ACK-on-Error, implementers may opt to support a single window size or multiple window sizes.  The latter, when feasible, may provide performance optimizations.  For example, a large WINDOW_SIZE should be used for packets that need to be split into a large number of tiles. However, when the number of tiles required to carry a packet is low, a smaller WINDOW_SIZE and, thus, a shorter Bitmap, may be sufficient to provide reception status on all tiles. If multiple window sizes are supported, the RuleID signals what WINDOW_SIZE is in use for a specific packet transmission.</t>
    </section>
    <section anchor="AsymLinks" numbered="true" toc="default">
      <name>ACK-Always and ACK-on-Error on Quasi-Bidirectional Links</name>
      <t>The ACK-Always and ACK-on-Error modes of SCHC F/R are bidirectional protocols:
they require a feedback path from the reassembler to the fragmenter.</t>
      <t>Some LPWAN technologies provide quasi-bidirectional connectivity,
whereby a Downlink transmission from the Network Infrastructure can only take place
right after an Uplink transmission by the Dev.</t>
      <t>When using SCHC F/R to send fragmented SCHC Packets Downlink over these quasi-bidirectional links,
the following situation may arise: if an Uplink SCHC ACK is lost,
the SCHC ACK REQ message by the sender could be stuck indefinitely in the Downlink queue
at the Network Infrastructure, waiting for a transmission opportunity.</t>
      <t>There are many ways by which this deadlock can be avoided.
The Dev application might be sending recurring Uplink messages such as keep-alive,
or the Dev application stack might be sending other recurring Uplink messages as part of its operation.
However, these are out of the control of this generic SCHC specification.</t>
      <t>In order to cope with quasi-bidirectional links, a SCHC-over-foo specification may want to amend
the SCHC F/R specification to add a timer-based retransmission of the SCHC ACK.
Below is an example of the suggested behavior for ACK-Always mode.
Because it is an example, <xref target="RFC2119" format="default"/> language is deliberately not used here.</t>
      <t>For Downlink transmission of a fragmented SCHC Packet in ACK-Always mode, the SCHC Fragment receiver may support timer-based SCHC ACK retransmission. In this mechanism, the SCHC Fragment receiver initializes and starts a timer (the UplinkACK Timer) after the transmission of a SCHC ACK, except when the SCHC ACK is sent in response to the last SCHC Fragment of a packet (All-1 fragment). In the latter case, the SCHC Fragment receiver does not start a timer after transmission of the SCHC ACK.</t>
      <t>If, after transmission of a SCHC ACK that is not an All-1 fragment, and before expiration of the corresponding UplinkACK timer, the SCHC Fragment receiver receives a SCHC Fragment that belongs to the current window (e.g., a missing SCHC Fragment from the current window) or to the next window, the UplinkACK timer for the SCHC ACK is stopped. However, if the UplinkACK timer expires, the SCHC ACK is resent and the UplinkACK timer is reinitialized and restarted.</t>
      <t>The default initial value for the UplinkACK Timer, as well as the maximum number of retries for a specific SCHC ACK, denoted MAX_ACK_REQUESTS, is to be defined in a Profile.
The initial value of the UplinkACK timer is expected to be greater than that of the Retransmission timer,
in order to make sure that a (buffered) SCHC Fragment to be retransmitted finds an opportunity for that transmission.
One exception to this recommendation is the special case of the All-1 SCHC Fragment transmission.</t>
      <t>When the SCHC Fragment sender transmits the All-1 SCHC Fragment,
it starts its Retransmission Timer with a large timeout value (e.g., several times that of the initial UplinkACK Timer).
If a SCHC ACK is received before expiration of this timer,
the SCHC Fragment sender retransmits any lost SCHC Fragments as reported by the SCHC ACK,
or if the SCHC ACK confirms successful reception of all SCHC Fragments of the last window,
the transmission of the fragmented SCHC Packet is considered complete.
If the timer expires, and no SCHC ACK has been received since the start of the timer,
the SCHC Fragment sender assumes that the All-1 SCHC Fragment has been successfully received
(and possibly, the last SCHC ACK has been lost: this mechanism assumes that the Retransmission Timer for the All-1 SCHC Fragment is long enough to allow several SCHC ACK retries if the All-1 SCHC Fragment has not been received by the SCHC Fragment receiver, and it also assumes that it is unlikely that several ACKs become all lost).</t>
</section>


    <section anchor="acknowledgements" numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t>Thanks to (in alphabetical order)
<contact fullname="Sergio Aguilar Romero"/>,
<contact fullname="David Black"/>,
<contact fullname="Carsten Bormann"/>,
<contact fullname="Deborah Brungard"/>,
<contact fullname="Brian Carpenter"/>,
<contact fullname="Philippe Clavier"/>,
<contact fullname="Alissa Cooper"/>,
<contact fullname="Roman Danyliw"/>,
<contact fullname="Daniel Ducuara Beltran"/>,
<contact fullname="Diego Dujovne"/>,
<contact fullname="Eduardo Ingles Sanchez"/>,
<contact fullname="Rahul Jadhav"/>,
<contact fullname="Benjamin Kaduk"/>,
<contact fullname="Arunprabhu Kandasamy"/>,
<contact fullname="Suresh Krishnan"/>,
<contact fullname="Mirja Kuehlewind"/>,
<contact fullname="Barry Leiba"/>,
<contact fullname="Sergio Lopez Bernal"/>,
<contact fullname="Antoni Markovski"/>,
<contact fullname="Alexey Melnikov"/>,
<contact fullname="Georgios Papadopoulos"/>,
<contact fullname="Alexander Pelov"/>,
<contact fullname="Charles Perkins"/>,
<contact fullname="Edgar Ramos"/>,
<contact fullname="Alvaro Retana"/>,
<contact fullname="Adam Roach"/>,
<contact fullname="Shoichi Sakane"/>,
<contact fullname="Joseph Salowey"/>,
<contact fullname="Pascal Thubert"/>,
and <contact fullname="Eric Vyncke"/>
for useful design considerations, reviews and comments.</t>
      <t><contact fullname="Carles Gomez"/> has been funded in part by the Spanish Government (Ministerio de Educacion, Cultura y Deporte) through the Jose
Castillejo grant CAS15/00336 and by the ERDF and the Spanish Government through project TEC2016-79988-P.  Part of his contribution to this work has been carried out during his stay as a visiting scholar at the Computer Laboratory of the University of Cambridge.</t>
    </section>
  </back>



</rfc>
