<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902"
     submissionType="IETF" category="bcp" consensus="true"
     docName="draft-ietf-dnsop-no-response-issue-23" number="8906"
     obsoletes="" updates="" xml:lang="en" symRefs="true" sortRefs="true"
     tocInclude="true" version="3"> 

  <!-- xml2rfc v2v3 conversion 2.44.0 -->
  <front>
    <title abbrev="Failure to Communicate">
      A Common Operational Problem in DNS Servers: Failure to Communicate
    </title>
    <seriesInfo name="RFC" value="8906"/>
    <seriesInfo name="BCP" value="231"/>
    <author initials="M." surname="Andrews" fullname="M. Andrews">
      <organization abbrev="ISC">Internet Systems Consortium</organization>
      <address>
        <postal>
          <street>PO Box 360</street>
          <city>Newmarket</city>
          <region>NH</region>
          <code>03857</code>
          <country>United States of America</country>
        </postal>
        <email>marka@isc.org</email>
      </address>
    </author>
    <author initials="R." surname="Bellis" fullname="Ray Bellis">
      <organization abbrev="ISC">Internet Systems Consortium</organization>
      <address>
        <postal>
          <street>PO Box 360</street>
          <city>Newmarket</city>
          <region>NH</region>
          <code>03857</code>
          <country>United States of America</country>
        </postal>
        <email>ray@isc.org</email>
      </address>
    </author>
    <date year="2020" month="September"/>


    <abstract>
      <t>
        The DNS is a query/response protocol.  Failing to respond
        to queries, or responding incorrectly, causes both immediate
        operational problems and long-term problems with protocol
        development.
      </t>
      <t>
        This document identifies a number of common kinds of queries
        to which some servers either fail to respond or respond
        incorrectly.  This document also suggests procedures for
        zone operators to apply to identify and remediate the problem.
      </t>
      <t>
        The document does not look at the DNS data itself, just the
        structure of the responses.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" numbered="true" toc="default">
      <name>Introduction</name>
      <t>The DNS <xref target="RFC1034" format="default"/> <xref
      target="RFC1035" format="default"/> is a query/response protocol.
      Failing to respond to queries or responding incorrectly causes both
      immediate operational problems and long-term problems with protocol
      development.</t> 
      <t>
        Failure to respond to a query is indistinguishable from
        packet loss without doing an analysis of query-response
        patterns.  Additionally, failure to respond results in
        unnecessary queries being made by DNS clients and
        introduces delays to the resolution process.
      </t>
      <t>
        Due to the inability to distinguish between packet loss and
        nameservers or middleboxes dropping Extension Mechanisms for DNS
	(EDNS) <xref target="RFC6891" format="default"/> 
        queries, packet loss is sometimes misclassified as lack of EDNS
        support, which can lead to DNSSEC validation failures.
      </t>
      <t>
        The existence of servers that fail to respond to queries
        results in developers being hesitant to deploy new standards.
        Such servers need to be identified and remediated.
      </t>
      <t>
        The DNS has response codes that cover almost any conceivable
        query response.  A nameserver should be able to respond to
        any conceivable query using them.  There should be no need
        to drop queries because a nameserver does not understand
        them.
      </t>
      <t>
        Unless a nameserver is under attack, it should respond to
        all DNS requests directed to it.  When a nameserver is under
        attack, it may wish to drop packets.  A common attack is to
        use a nameserver as an amplifier by sending spoofed packets.
        This is done because response packets are bigger than the
        queries and large amplification factors are available, especially
        if EDNS is supported.  Limiting the rate of responses is
        reasonable when this is occurring, and the client should
        retry.  However, this only works if legitimate clients are
        not being forced to guess whether or not EDNS queries are accepted.  As long as there is still a pool of servers that don't
        respond to EDNS requests, clients have no way to know if
        the lack of response is due to packet loss, EDNS packets
        not being supported, or rate limiting due to the server being
        under attack.  Misclassification of server behaviour is
        unavoidable when rate limiting is used until the population
        of servers that fail to respond to well-formed queries
        drops to near zero.
      </t>
      <t>
        Nameservers should respond to queries even if the queried
        name is not for any name the server is configured to answer
        for.  Misconfigured nameservers are a common occurrence in the
        DNS, and receiving queries for zones that the server is not
        configured for is not necessarily an indication that the
        server is under attack.  Parent zone operators are advised
        to regularly check that the delegating NS records are
        consistent with those of the delegated zone and to correct
        them when they are not (<xref target="RFC1034" sectionFormat="of" section="4.2.2"/>,
        Paragraph 3).
	Doing this regularly should reduce the instances
        of broken delegations.
      </t>
      <t>
        This document does not try to identify all possible errors
        nor does it supply an exhaustive list of tests.
      </t>
    </section>
    <section anchor="consequences" numbered="true" toc="default">
      <name>Consequences</name>
      <t>
        Failure to follow the guidance in relevant DNS RFCs has multiple adverse
        consequences.  Some are caused directly by the non-compliant
        behaviour and others as a result of workarounds forced on
        recursive servers.  Addressing known issues now will reduce
        future interoperability issues as the DNS protocol continues
        to evolve and clients make use of newly introduced DNS
        features.  In particular, the base DNS specification
        <xref target="RFC1034" format="default"/> <xref target="RFC1035" format="default"/> and the
        EDNS specification <xref target="RFC6891" format="default"/>, when implemented,
        need to be followed.
      </t>
      <t>
        Some examples of known consequences include the following:
      </t>
      <ul spacing="normal">
        <li>
            The AD (Authenticated Data) bit in a response
            cannot be trusted to mean anything, as some servers
            incorrectly copy the flag bit from the request to the
            response <xref target="RFC1035" format="default"/> <xref
	    target="RFC4035" format="default"/>. 
            The use of the AD bit in requests is defined in
            <xref target="RFC6840" format="default"/>.
          </li>
        <li>
            Widespread non-response to EDNS queries has led to
            recursive servers having to assume that EDNS is not
            supported and that fallback to plain DNS is required,
            potentially causing DNSSEC validation failures.
          </li>
        <li>
            Widespread non-response to EDNS options requires
            recursive servers to decide whether to probe
            to see if it is the specific EDNS option or the use of
            EDNS in general that is causing the non-response.  In
            the limited amount of time required to resolve a query
            before the client times out, this is not possible.
          </li>
        <li>
            Incorrectly returning FORMERR to an EDNS option being
            present leads to the recursive server not being able
            to determine if the server is just broken in the handling
            of the EDNS option or if it doesn't support EDNS at all.
          </li>
        <li>
            Mishandling of unknown query types has contributed
            to the abandonment of the transition of the SPF type.
          </li>
        <li>
            Mishandling of unknown query types has slowed up the
            development of DNS-Based Authentication of Named Entities (DANE)
	    and resulted in additional rules 
            being specified to reduce the probability of interacting
            with a broken server when making TLSA queries.
          </li>
      </ul>
      <t>
        The consequences of servers not following the RFCs will
        only grow if measures are not put in place to remove non-compliant
	servers from the ecosystem.  Working around issues 
        due to non-compliance with RFCs is not sustainable.
      </t>
      <t>
        Most (if not all) of these consequences could have been
        avoided if action had been taken to remove non-compliant
        servers as soon as people were aware of them, i.e., to actively
        seek out broken implementations and servers and inform their
        developers and operators that they need to fix their servers.
      </t>
    </section>
    <section anchor="query-kinds" numbered="true" toc="default">
      <name>Common Kinds of Queries That Result in No or Bad Responses</name>
      <t>
        This section is broken down into Basic DNS requests and EDNS requests.
      </t>
      <section numbered="true" toc="default">
        <name>Basic DNS Queries</name>
        <section anchor="existence" numbered="true" toc="default">
          <name>Zone Existence</name>
          <t>
            If a zone is delegated to a server, that server should
            respond to a SOA query for that zone with an SOA record.
            Failing to respond at all is always incorrect, regardless
            of the configuration of the server.  Responding with
            anything other than an SOA record in the answer section
            indicates a bad delegation.
          </t>
        </section>
        <section anchor="unknown" numbered="true" toc="default">
          <name>Unknown/Unsupported Type Queries</name>
          <t>
            Some servers fail to respond to unknown or unsupported
            types.  If a server receives a query for a type that
            it doesn't recognise, or doesn't implement, it is
            expected to return the appropriate response as if it
            did recognise the type but does not have any data for
            that type, i.e., either NOERROR or NXDOMAIN.  The exceptions
            to this are queries for Meta-RR types, which may return
            NOTIMP.
          </t>
        </section>
        <section anchor="dns-flags" numbered="true" toc="default">
          <name>DNS Flags</name>
          <t>
            Some servers fail to respond to DNS queries with various
            DNS flags set, regardless of whether they are defined or
            still reserved.  At the time of writing, there are servers
            that fail to respond to queries with the AD flag set to 1
            and servers that fail to respond to queries with the last
            reserved flag set.
          </t>
          <t>Servers should respond to such queries.  If the server does not
	  know the meaning of a flag, it must not copy it to the response
	  (<xref target="RFC1035" sectionFormat="of" section="4.1.1"/>). If
	  the server does not understand the meaning of a request, it should
	  reply with a FORMERR response with unknown flags set to zero.</t> 
          <section anchor="recursion" numbered="true" toc="default">
            <name>Recursive Queries</name>
            <t>
              A non-recursive server is supposed to respond to recursive
              queries as if the Recursion Desired (RD) bit is not set <xref
	      target="RFC1034" format="default"/>. 
            </t>
          </section>
        </section>
        <section anchor="opcode" numbered="true" toc="default">
          <name>Unknown DNS Opcodes</name>
          <t>
            The use of previously undefined opcodes is to be expected.
            Since the DNS was first defined, two new opcodes have been
            added, UPDATE and NOTIFY.
          </t>
          <t>
            NOTIMP is the expected rcode to an unknown or unimplemented
            opcode.
          </t><aside>
          <t>
            NOTE: while new opcodes will most probably use the current
            layout structure for the rest of the message, there is no
            requirement that anything other than the DNS header match.
          </t></aside>
        </section>
        <section anchor="tcp" numbered="true" toc="default">
          <name>TCP Queries</name>
          <t>
            All DNS servers are supposed to respond to queries over
            TCP <xref target="RFC7766" format="default"/>.  While firewalls should not
            block TCP connection attempts, those that do should
            cleanly terminate the connection by sending TCP RESET
            or sending ICMP/ICMPv6 Administratively Prohibited
            messages. Dropping TCP connections introduces excessive
            delays to the resolution process.
          </t>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>EDNS Queries</name>
        <t>
           EDNS queries are specified in <xref target="RFC6891" format="default"/>.
        </t>
        <section anchor="edns-independent" numbered="true" toc="default">
          <name>EDNS Queries: Version Independent</name>
          <t>
            Identifying servers that fail to respond to EDNS queries
            can be done by first confirming that the server responds
            to regular DNS queries, followed by a series of otherwise
            identical queries using EDNS, then making the original
            query again.  A series of EDNS queries is needed, as at
            least one DNS implementation responds to the first EDNS
            query with FORMERR but fails to respond to subsequent
            queries from the same address for a period until a
            regular DNS query is made.  The EDNS query should specify
            a UDP buffer size of 512 bytes to avoid false classification
            of not supporting EDNS due to response packet size.
          </t>
          <t>
            If the server responds to the first and last queries
            but fails to respond to most or all of the EDNS queries,
            it is probably faulty.  The test should be repeated a
            number of times to eliminate the likelihood of a false
            positive due to packet loss.
          </t>
          <t>
            Firewalls may also block larger EDNS responses, but there
            is no easy way to check authoritative servers to see
            if the firewall is misconfigured.
          </t>
        </section>
        <section anchor="edns-specific" numbered="true" toc="default">
          <name>EDNS Queries: Version Specific</name>
          <t>
            Some servers respond correctly to EDNS version 0 queries
            but fail to respond to EDNS queries with version numbers
            that are higher than zero.  Servers should respond with
            BADVERS to EDNS queries with version numbers that they
            do not support.
          </t>
          <t>
            Some servers respond correctly to EDNS version 0 queries
            but fail to set QR=1 when responding to EDNS versions
            they do not support.  Such responses may be discarded
            as invalid (as QR is not 1) or treated as requests (when the
            source port of the original request was port 53).
          </t>
        </section>
        <section anchor="edns-options" numbered="true" toc="default">
          <name>EDNS Options</name>
          <t>
            Some servers fail to respond to EDNS queries with EDNS
            options set.  The original EDNS specification left this
            behaviour undefined <xref target="RFC2671" format="default"/>, but the
            correct behaviour was clarified in <xref target="RFC6891" format="default"/>.
            Unknown EDNS options are supposed to be ignored by the server.
          </t>
        </section>
        <section anchor="edns-flags" numbered="true" toc="default">
          <name>EDNS Flags</name>
          <t>
            Some servers fail to respond to EDNS queries with EDNS
            flags set.  Servers should ignore EDNS flags they do not
            understand and must not add them to the response <xref target="RFC6891" format="default"/>.
          </t>
        </section>
        <section anchor="truncated-edns" numbered="true" toc="default">
          <name>Truncated EDNS Responses</name>
          <t>
            Some EDNS-aware servers fail to include an OPT record when a
            truncated response is sent.  An OPT record is supposed to be
            included in a truncated response <xref target="RFC6891" format="default"/>.
          </t>
          <t>
            Some EDNS-aware servers fail to honour the advertised EDNS
            UDP buffer size and send oversized responses
            <xref target="RFC6891" format="default"/>.  Servers must send UDP responses
            no larger than the advertised EDNS UDP buffer size.
          </t>
        </section>
        <section anchor="dobit" numbered="true" toc="default">
          <name>DO=1 Handling</name>
          <t>
            Some nameservers incorrectly only return an EDNS response
            when the DNSSEC OK (DO) bit <xref target="RFC3225" format="default"/> is 1 in the
            query.  Servers that support EDNS should always respond to
            EDNS requests with EDNS responses.
          </t>
          <t>
            Some nameservers fail to copy the DO bit to the response
            despite clearly supporting DNSSEC by returning an RRSIG
            records to EDNS queries with DO=1.  Nameservers that support
            DNSSEC are expected to copy the DO bit from the request to
            the response.
          </t>
        </section>
        <section anchor="tcp-edns" numbered="true" toc="default">
          <name>EDNS over TCP</name>
          <t>
            Some EDNS-aware servers incorrectly limit the TCP response
            sizes to the advertised UDP response size.  This breaks DNS
            resolution to clients where the response sizes exceed the
            advertised UDP response size despite the server and the client
            being capable of sending and receiving larger TCP responses,
            respectively.  It effectively defeats setting TC=1 in UDP
            responses.
          </t>
        </section>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Firewalls and Load Balancers</name>
      <t>
        Firewalls and load balancers can affect the externally
        visible behaviour of a nameserver.  Tests for conformance
        should to be done from outside of any firewall so that the
        system is tested as a whole.
      </t>
      <t>
        Firewalls and load balancers should not drop DNS packets
        that they don't understand.  They should either pass
        the packets or generate an appropriate error response.
      </t>
      <t>
        Requests for unknown query types are normal client behaviour
        and should not be construed as an attack.  Nameservers have
        always been expected to be able to handle such queries.
      </t>
      <t>
        Requests for unknown query classes are normal client behaviour
        and should not be construed as an attack.  Nameservers have
        always been expected to be able to handle such queries.
      </t>
      <t>
        Requests with unknown opcodes are normal client behaviour
        and should not be construed as an attack.  Nameservers have
        always been expected to be able to handle such queries.
      </t>
      <t>Requests with unassigned flags set (DNS or EDNS) are expected client
      behaviour and should not be construed as an attack. The behaviour for
      unassigned flags is to ignore them in the request and to not set them in
      the response.  Dropping DNS/EDNS packets with unassigned flags makes it
      difficult to deploy extensions that make use of them due to the need to
      reconfigure and update firewalls.</t> 
      <t>
        Requests with unknown EDNS options are expected client
        behaviour and should not be construed as an attack.  The
        correct behaviour for unknown EDNS options is to ignore
        their presence when constructing a reply.
      </t>
      <t>
        Requests with unknown EDNS versions are expected client
        behaviour and should not be construed as an attack.  The
        correct behaviour for unknown EDNS versions is to return
        BADVERS along with the highest EDNS version the server
        supports.  Dropping EDNS packets breaks EDNS version
        negotiation.
      </t>
      <t>
        Firewalls should not assume that there will only be a single
        response message to a request.  There have been proposals
        to use EDNS to signal that multiple DNS messages be returned
        rather than a single UDP message that is fragmented at the
        IP layer.
      </t>
      <t>
        DNS, and EDNS in particular, are designed to allow clients to
        be able to use new features against older servers without
        having to validate every option.  Indiscriminate blocking
        of messages breaks that design.
      </t>
      <t>
        However, there may be times when a nameserver mishandles
        messages with a particular flag, EDNS option, EDNS version
        field, opcode, type or class field, or combination thereof
        to the point where the integrity of the nameserver is
        compromised.  Firewalls should offer the ability to selectively
        reject messages using an appropriately constructed response
        based on all these fields while awaiting a fix from the
        nameserver vendor.  Returning FORMERR or REFUSED are two
        potential error codes to return.
      </t>
    </section>
    <section anchor="scrubbing" numbered="true" toc="default">
      <name>Packet Scrubbing Services</name>
      <t>
        Packet scrubbing services are used to filter out undesired traffic,
        including but not limited to denial-of-service traffic.  This is
        often done using heuristic analysis of the traffic.
      </t>
      <t>
        Packet scrubbing services can affect the externally visible behaviour
        of a nameserver in a similar way to firewalls.  If an operator
        uses a packet scrubbing service, they should check that legitimate
        queries are not being blocked.
      </t>
      <t>
        Packet scrubbing services, unlike firewalls, are also turned on
        and off in response to denial-of-service attacks.  One needs
        to take care when choosing a scrubbing service.
      </t>
      <t>
        Ideally, operators should run these tests against a packet scrubbing
        service to ensure that these tests are not seen as attack
        vectors.
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>Whole Answer Caches</name>
      <t>
        Whole answer caches take a previously constructed answer
        and return it to a subsequent query for the same question.
        However, they can return the wrong response if they do not
        take all of the relevant attributes of the query into account.
      </t>
      <t>
        In addition to the standard tuple of &lt;qname,qtype,qclass&gt;,
        a non-exhaustive set of attributes that must be considered
        include: RD, AD, CD, OPT record, DO, EDNS buffer size, EDNS
        version, EDNS options, and transport.
      </t>
    </section>
    <section anchor="response" numbered="true" toc="default">
      <name>Response Code Selection</name>
      <t>
        Choosing the correct response code when responding to DNS
        queries is important.  Response codes should be chosen
        considering how clients will handle them.
      </t>
      <t>
        For unimplemented opcodes, NOTIMP is the expected response code.
        Note: newly implemented opcodes may change the message format by
        extending the header, changing the structure of the records,
        etc.  Servers are not expected to be able to parse these
        and should respond with a response code of NOTIMP rather
        than FORMERR (which would be expected if there was a parse error
        with a known opcode).
      </t>
      <t>
        For unimplemented type codes, and in the absence of other
        errors, the only valid response is NOERROR if the qname
        exists and NXDOMAIN otherwise.  

	For Meta-RRs, NOTIMP may be returned instead.
      </t>
      <t>If a zone cannot be loaded because it contains unimplemented type
      codes that are not encoded as unknown record types according to <xref
      target="RFC3597" format="default"/>, then the expected response is
      SERVFAIL, as the whole zone should be rejected (<xref target="RFC1035"
      sectionFormat="of" section="5.2"></xref>).  If a zone loads, then <xref
      target="RFC1034" sectionFormat="of" section="4.3.2"></xref> applies.</t> 
      <t>
        If the server supports EDNS and receives a query with an
        unsupported EDNS version, the correct response is BADVERS
        <xref target="RFC6891" format="default"/>.
      </t>
      <t>
        If the server does not support EDNS at all, FORMERR is
        the expected error code.  That said, a minimal EDNS
        server implementation requires parsing the OPT records
        and responding with an empty OPT record in the additional
        section in most cases.  There is no need to interpret any
        EDNS options present in the request, as unsupported EDNS
        options are expected to be ignored <xref target="RFC6891" format="default"/>.
        Additionally, EDNS flags can be ignored.  The only part of the
        OPT record that needs to be examined is the version field
        to determine if BADVERS needs to be sent or not.
      </t>
    </section>
    <section anchor="testing" numbered="true" toc="default">
      <name>Testing</name>
      <t>
        Testing is divided into two sections:  "Basic DNS", which all
        servers should meet, and "Extended DNS", which should be met
        by all servers that support EDNS (a server is deemed to
        support EDNS if it gives a valid EDNS response to any EDNS
        query).  If a server does not support EDNS, it should still
        respond to all the tests, albeit with error responses.
      </t>
      <t>
        These tests query for records at the apex of a zone that the
        server is nominally configured to serve.  All tests should
        use the same zone.
      </t>
      <t>
        It is advisable to run all of the tests below in parallel
        so as to minimise the delays due to multiple timeouts when
        the servers do not respond.  There are 16 queries directed
        to each nameserver (assuming no packet loss) testing different
        aspects of Basic DNS and Extended DNS.
      </t>
      <t>
        The tests below use dig from BIND 9.11.0 <xref target="ISC" format="default"/>.
        Replace $zone with the name of the zone being used for testing.
        Replace $server with the name or address of the server being tested.
      </t>
      <t>
        When testing, recursive servers set RD=1 and choose a zone
        name that is known to exist and is not being served by the
        recursive server.  The root zone (".") is often a good
        candidate, as it is DNSSEC signed.  RD=1, rather than RD=0,
        should be present in the responses for all test involving 
        the opcode QUERY.  Non-authoritative answers (AA=0) are
        expected when talking to a recursive server.  AD=1 is only
        expected if the server is validating responses and
        one or both AD=1 or DO=1 is set in the request, otherwise
        AD=0 is expected.
      </t>
      <section anchor="testing-basic" numbered="true" toc="default">
        <name>Testing: Basic DNS</name>
        <t>
          This first set of tests cover Basic DNS server behaviour
          and all servers should pass these tests.
        </t>
        <section numbered="true" toc="default">
          <name>Is the server configured for the zone?</name>
          <t>
            Ask for the SOA record of the configured zone.  This
            query is made with no DNS flag bits set and without
            EDNS.
          </t>
          <t>
            We expect the SOA record for the zone to be returned
            in the answer section, the rcode to be set to NOERROR, and
            the Authoritative Answer (AA) and Query/Response (QR) bits to be
	    set in the header; the Recursion Available (RA) bits may also be
	    set <xref target="RFC1034" format="default"/>.  We 
	    do not expect an OPT record to be returned <xref target="RFC6891"
	    format="default"/>.</t> 
          <t keepWithNext="true">
                Verify the server is configured for the zone:
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +noedns +noad +norec soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
              ]]></sourcecode>
        </section>
        <section numbered="true" toc="default">
          <name>Testing Unknown Types</name>
          <t>

	    
            Identifying servers that fail to respond to unknown or
            unsupported types can be done by making an initial DNS
            query for an A record, making a number of queries for an
            unallocated type, then making a query for an A record
            again.  IANA maintains a registry of allocated types <xref
	    target="IANA-DNS"/>.
          </t>
          <t>
            If the server responds to the first and last queries but
            fails to respond to the queries for the unallocated type,
            it is probably faulty.  The test should be repeated a
            number of times to eliminate the likelihood of a false
            positive due to packet loss.
          </t>
          <t>
            Ask for the TYPE1000 RRset at the configured zone's
            name.  This query is made with no DNS flag bits set and
            without EDNS.  TYPE1000 has been chosen for this purpose,
            as IANA is unlikely to allocate this type in the near
            future and it is not in a range reserved for private
            use <xref target="RFC6895" format="default"/>.  Any unallocated type code
            could be chosen for this test.
          </t>
          <t>
            We expect no records to be returned in the answer
            section, the rcode to be set to NOERROR, and the AA and
            QR bits to be set in the header; RA may also be set
            <xref target="RFC1034" format="default"/>.  We do not expect an OPT record
            to be returned <xref target="RFC6891" format="default"/>.
          </t>
          <t keepWithNext="true">
                Check that queries for an unknown type work:
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +noedns +noad +norec type1000 $zone @$server

expect: status: NOERROR
expect: an empty answer section.
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
              ]]></sourcecode>
        </section>
        <section numbered="true" toc="default">
          <name>Testing Header Bits</name>
          <section numbered="true" toc="default">
            <name>Testing CD=1 Queries</name>
            <t>
              Ask for the SOA record of the configured zone.
              This query is made with only the CD DNS flag bit set,
              with all other DNS bits clear, and without EDNS.
            </t>
            <t>
              We expect the SOA record for the zone to be returned
              in the answer section, the rcode to be set to NOERROR,
              and the AA and QR bits to be set in the header.  We
              do not expect an OPT record to be returned.
            </t>
            <t>
              If the server supports DNSSEC, CD should be set in
              the response <xref target="RFC4035" format="default"/>; otherwise, CD
              should be clear <xref target="RFC1034" format="default"/>.
            </t>
            <t keepWithNext="true">
                  Check that queries with CD=1 work:
            </t>
            <sourcecode name="" type=""><![CDATA[
dig +noedns +noad +norec +cd soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
                ]]></sourcecode>
          </section>
          <section numbered="true" toc="default">
            <name>Testing AD=1 Queries</name>
            <t>Ask for the SOA record of the configured zone.  This query is
	    made with only the AD DNS flag bit set, with all other DNS bits clear,
	    and without EDNS.</t> 
            <t>
              We expect the SOA record for the zone to be returned
              in the answer section, the rcode to be set to NOERROR,
              and the AA and QR bits to be set in the header.  We
              do not expect an OPT record to be returned.  The
              purpose of this query is to detect blocking of queries
              with the AD bit present, not the specific value of
              AD in the response.
            </t>
            <t keepWithNext="true">
                  Check that queries with AD=1 work:
            </t>
            <sourcecode name="" type=""><![CDATA[
dig +noedns +norec +ad soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: the OPT record to NOT be present
                ]]></sourcecode>
            <t keepWithPrevious="true">
                  AD use in queries is defined in <xref target="RFC6840" format="default"/>.
            </t>
          </section>
          <section numbered="true" toc="default">
            <name>Testing Reserved Bit</name>
            <t>
              Ask for the SOA record of the configured zone.  This
              query is made with only the final reserved DNS flag
              bit set, with all other DNS bits clear, and without EDNS.
            </t>
            <t>
              We expect the SOA record for the zone to be returned
              in the answer section, the rcode to be set to NOERROR,
              and the AA and QR bits to be set in the header; RA
              may be set.  The final reserved bit must not be set
              <xref target="RFC1034" format="default"/>.  We do not expect an OPT
              record to be returned <xref target="RFC6891" format="default"/>.
            </t>
            <t keepWithNext="true">
                  Check that queries with the last unassigned DNS
                  header flag work and that the flag bit is not
                  copied to the response:
            </t>
            <sourcecode name="" type="" ><![CDATA[
dig +noedns +noad +norec +zflag soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: MBZ to NOT be in the response (see below)
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
                ]]></sourcecode>
            <t keepWithPrevious="true"> MBZ (Must Be Zero) is a dig-specific
	    indication that the flag bit has been incorrectly copied.  See
	    <xref target="RFC1035" sectionFormat="of" section="4.1.1"/>:</t>
<dl newline="false">
<dt>"Z</dt>
<dd>Reserved for future use.  Must be zero in all queries and responses."</dd> 
</dl>

 
          </section>
          <section numbered="true" toc="default">
            <name>Testing Recursive Queries</name>
            <t>
              Ask for the SOA record of the configured zone.  This
              query is made with only the RD DNS flag bit set and
              without EDNS.
            </t>
            <t>
              We expect the SOA record for the zone to be returned
              in the answer section, the rcode to be set to NOERROR, and
              the AA, QR and RD bits to be set in the header; RA
              may also be set <xref target="RFC1034" format="default"/>.  We do not
              expect an OPT record to be returned <xref target="RFC6891" format="default"/>.
            </t>
            <t keepWithNext="true">
                  Check that recursive queries work:
            </t>
            <sourcecode name="" type=""><![CDATA[
dig +noedns +noad +rec soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: flag: aa to be present
expect: flag: rd to be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
                ]]></sourcecode>
          </section>
        </section>
        <section numbered="true" toc="default">
          <name>Testing Unknown Opcodes</name>
          <t>
            Construct a DNS message that consists of only a DNS
            header with opcode set to 15 (currently not allocated),
            no DNS header bits set, and empty question, answer,
            authority, and additional sections. </t>
          <t keepWithNext="true">
                Check that new opcodes are handled:
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +noedns +noad +opcode=15 +norec +header-only @$server

expect: status: NOTIMP
expect: opcode: 15
expect: all sections to be empty
expect: flag: aa to NOT be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
              ]]></sourcecode>
        </section>
        <section numbered="true" toc="default">
          <name>Testing TCP</name>
          <t>
            Whether a server accepts TCP connections can be tested
            by first checking that it responds to UDP queries to
            confirm that it is up and operating, then attempting the
            same query over TCP.  An additional query should be made
            over UDP if the TCP connection attempt fails to confirm
            that the server under test is still operating.
          </t>
          <t>
            Ask for the SOA record of the configured zone.  This
            query is made with no DNS flag bits set and without
            EDNS.  This query is to be sent using TCP.
          </t>
          <t>
            We expect the SOA record for the zone to be returned
            in the answer section, the rcode to be set to NOERROR, and
            the AA and QR bits to be set in the header; RA may
            also be set <xref target="RFC1034" format="default"/>.  We do not expect
            an OPT record to be returned <xref target="RFC6891" format="default"/>.
          </t>
          <t keepWithNext="true">
                Check that TCP queries work:
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +noedns +noad +norec +tcp soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
              ]]></sourcecode>
          <t keepWithPrevious="true">
                The requirement that TCP be supported is defined
                in <xref target="RFC7766" format="default"/>.
          </t>
        </section>
      </section>
      <section anchor="testing-edns" numbered="true" toc="default">
        <name>Testing: Extended DNS</name>
        <t>
          The next set of tests cover various aspects of EDNS
          behaviour.  If any of these tests succeed (indicating
          at least some EDNS support), then all of them should
          succeed.  There are servers that support EDNS but fail
          to handle plain EDNS queries correctly, so a plain EDNS
          query is not a good indicator of lack of EDNS support.
        </t>
        <section numbered="true" toc="default">
          <name>Testing Minimal EDNS</name>
          <t>
            Ask for the SOA record of the configured zone.  This
            query is made with no DNS flag bits set.  EDNS version
            0 is used without any EDNS options or EDNS flags set.
          </t>
          <t>
            We expect the SOA record for the zone to be returned
            in the answer section, the rcode to be set to NOERROR, and
            the AA and QR bits to be set in the header; RA may
            also be set <xref target="RFC1034" format="default"/>.  We expect
            an OPT record to be returned.  There should be no EDNS
            flags present in the response.  The EDNS version field
            should be 0, and there should be no EDNS options present
            <xref target="RFC6891" format="default"/>.
          </t>
          <t keepWithNext="true">
                Check that plain EDNS queries work:
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +nocookie +edns=0 +noad +norec soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: an OPT record to be present in the additional section
expect: EDNS Version 0 in response
expect: flag: aa to be present
expect: flag: ad to NOT be present
              ]]></sourcecode>
          <t keepWithPrevious="true">
                +nocookie disables sending an EDNS COOKIE option, which
                is otherwise enabled by default in BIND 9.11.0 (and
                later).
          </t>
        </section>
        <section numbered="true" toc="default">
          <name>Testing EDNS Version Negotiation</name>
          <t>
            Ask for the SOA record of a zone the server is nominally
            configured to serve.  This query is made with no DNS flag
            bits set.  EDNS version 1 is used without any EDNS options
            or EDNS flags set.
          </t>
          <t>
            We expect the SOA record for the zone to NOT be returned
            in the answer section with the extended rcode set to
            BADVERS and the QR bit to be set in the header; RA
            may also be set <xref target="RFC1034" format="default"/>.  We expect
            an OPT record to be returned.  There should be no EDNS
            flags present in the response.  The EDNS version field
            should be 0 in the response, as no other EDNS version
            has as yet been specified <xref target="RFC6891" format="default"/>.
          </t>
          <t keepWithNext="true">
                Check that EDNS version 1 queries work (EDNS supported):
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +nocookie +edns=1 +noednsneg +noad +norec soa $zone @$server

expect: status: BADVERS
expect: the SOA record to NOT be present in the answer section
expect: an OPT record to be present in the additional section
expect: EDNS Version 0 in response
expect: flag: aa to NOT be present
expect: flag: ad to NOT be present
              ]]></sourcecode>
          <t keepWithPrevious="true">
                +noednsneg has been set, as dig supports EDNS version
                negotiation, and we want to see only the response to the
                initial EDNS version 1 query.
          </t>
        </section>
        <section numbered="true" toc="default">
          <name>Testing Unknown EDNS Options</name>
          <t>
            Ask for the SOA record of the configured zone.  This
            query is made with no DNS flag bits set.  EDNS version
            0 is used without any EDNS flags.  An EDNS option is
            present with a value that has not yet been assigned by
            IANA.  We have picked an unassigned code of 100 for
            the example below.  Any unassigned EDNS option code
            could have been chosen for this test.
          </t>
          <t>
            We expect the SOA record for the zone to be returned
            in the answer section, the rcode to be set to NOERROR, and
            the AA and QR bits to be set in the header; RA may
            also be set <xref target="RFC1034" format="default"/>.  We expect
            an OPT record to be returned.  There should be no EDNS
            flags present in the response.  The EDNS version field
            should be 0, as EDNS versions other than 0 are yet to
            be specified, and there should be no EDNS options present,
            as unknown EDNS options are supposed to be ignored by the
            server (<xref target="RFC6891" sectionFormat="of" section="6.1.1"/>).
          </t>
          <t keepWithNext="true">
                Check that EDNS queries with an unknown option work (EDNS supported):
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +nocookie +edns=0 +noad +norec +ednsopt=100 soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: an OPT record to be present in the additional section
expect: OPT=100 to NOT be present
expect: EDNS Version 0 in response
expect: flag: aa to be present
expect: flag: ad to NOT be present
              ]]></sourcecode>
        </section>
        <section numbered="true" toc="default">
          <name>Testing Unknown EDNS Flags</name>
          <t>
            Ask for the SOA record of the configured zone.  This
            query is made with no DNS flag bits set.  EDNS version
            0 is used without any EDNS options.  An unassigned EDNS
            flag bit is set (0x40 in this case).
          </t>
          <t>
            We expect the SOA record for the zone to be returned
            in the answer section, the rcode to be set to NOERROR, and
            the AA and QR bits to be set in the header; RA may
            also be set <xref target="RFC1034" format="default"/>.  We expect
            an OPT record to be returned.  There should be no EDNS
            flags present in the response, as unknown EDNS flags are
            supposed to be ignored.  The EDNS version field
            should be 0, and there should be no EDNS options present
            <xref target="RFC6891" format="default"/>.
          </t>
          <t keepWithNext="true">
                Check that EDNS queries with unknown flags work (EDNS supported):
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +nocookie +edns=0 +noad +norec +ednsflags=0x40 soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: an OPT record to be present in the additional section
expect: MBZ not to be present
expect: EDNS Version 0 in response
expect: flag: aa to be present
expect: flag: ad to NOT be present
              ]]></sourcecode>
          <t keepWithPrevious="true">
                MBZ (Must Be Zero) is a dig-specific indication that
                a flag bit has been incorrectly copied, as per
                <xref target="RFC6891" sectionFormat="of" section="6.1.4"/>.
          </t>
        </section>
        <section numbered="true" toc="default">
          <name>Testing EDNS Version Negotiation with Unknown EDNS Flags</name>
          <t>
            Ask for the SOA record of the configured zone.  This
            query is made with no DNS flag bits set.  EDNS version
            1 is used without any EDNS options.  An unassigned EDNS
            flag bit is set (0x40 in this case).
          </t>
          <t>
            We expect the SOA record for the zone to NOT be returned
            in the answer section with the extended rcode set to
            BADVERS and the QR bit to be set in the header; RA
            may also be set <xref target="RFC1034" format="default"/>.  We expect
            an OPT record to be returned.  There should be no EDNS
            flags present in the response, as unknown EDNS flags are
            supposed to be ignored.  The EDNS version field should
            be 0, as EDNS versions other than 0 are yet to be
            specified, and there should be no EDNS options present
            <xref target="RFC6891" format="default"/>.
          </t>
          <t keepWithNext="true">
                Check that EDNS version 1 queries with unknown flags work (EDNS supported):
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +nocookie +edns=1 +noednsneg +noad +norec +ednsflags=0x40 soa \
    $zone @$server

expect: status: BADVERS
expect: SOA record to NOT be present
expect: an OPT record to be present in the additional section
expect: MBZ not to be present
expect: EDNS Version 0 in response
expect: flag: aa to NOT be present
expect: flag: ad to NOT be present
              ]]></sourcecode>
        </section>
        <section numbered="true" toc="default">
          <name>Testing EDNS Version Negotiation with Unknown EDNS Options</name>
          <t>
            Ask for the SOA record of the configured zone.  This
            query is made with no DNS flag bits set.  EDNS version
            1 is used.  An unknown EDNS option is present.  We have
            picked an unassigned code of 100 for the example below.
            Any unassigned EDNS option code could have been chosen for
            this test.
          </t>
          <t>
            We expect the SOA record for the zone to NOT be returned
            in the answer section with the extended rcode set to
            BADVERS and the QR bit to be set in the header; RA
            may also be set <xref target="RFC1034" format="default"/>.  We expect
            an OPT record to be returned.  There should be no EDNS
            flags present in the response.  The EDNS version field
            should be 0, as EDNS versions other than 0 are yet
            to be specified, and there should be no EDNS options
            present <xref target="RFC6891" format="default"/>.
          </t>
          <t keepWithNext="true">
                Check that EDNS version 1 queries with unknown options work (EDNS supported):
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +nocookie +edns=1 +noednsneg +noad +norec +ednsopt=100 soa \
    $zone @$server

expect: status: BADVERS
expect: SOA record to NOT be present
expect: an OPT record to be present in the additional section
expect: OPT=100 to NOT be present
expect: EDNS Version 0 in response
expect: flag: aa to NOT be present
expect: flag: ad to NOT be present
              ]]></sourcecode>
        </section>
        <section numbered="true" toc="default">
          <name>Testing Truncated Responses</name>
          <t>
            Ask for the DNSKEY records of the configured zone, which
            must be a DNSSEC signed zone.  This query is made with
            no DNS flag bits set.  EDNS version 0 is used without
            any EDNS options.  The only EDNS flag set is DO.  The
            EDNS UDP buffer size is set to 512.  The intention of
            this query is to elicit a truncated response from the
            server.  Most signed DNSKEY responses are bigger than
            512 bytes.  This test will not give a valid result if
            the zone is not signed.
          </t>
          <t>We expect a response, the rcode to be set to NOERROR, and the AA
	  and QR bits to be set. AD may be set in the response if the server
	  supports DNSSEC; otherwise it should be clear; TC and RA may also be
	  set <xref target="RFC1035" format="default"/> <xref target="RFC4035"
	  format="default"/>.  We expect an OPT record to be present in the
	  response.  There should be no EDNS flags other than DO present in
	  the response.  The EDNS version field should be 0, and there should
	  be no EDNS options present <xref target="RFC6891"
	  format="default"/>.</t> 
          <t>
            If TC is not set, it is not possible to confirm that the
            server correctly adds the OPT record to the truncated
            responses or not.
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +norec +dnssec +bufsize=512 +ignore dnskey $zone @$server
expect: NOERROR
expect: OPT record with version set to 0
              ]]></sourcecode>
        </section>
        <section numbered="true" toc="default">
          <name>Testing DO=1 Handling</name>
          <t>
            Ask for the SOA record of the configured zone, which
            does not need to be DNSSEC signed.  This query is made
            with no DNS flag bits set.  EDNS version 0 is used
            without any EDNS options.  The only EDNS flag set is
            DO.
          </t>
          <t>We expect the SOA record for the zone to be returned in the
	  answer section, the rcode to be set to NOERROR, and the AA and QR
	  bits to be set in the response. AD may be set in the response if the
	  server supports DNSSEC, otherwise it should be clear; RA may also be
	  set <xref target="RFC1034" format="default"/>.  We expect an OPT
	  record to be returned.  There should be no EDNS flags other than DO
	  present in the response, which should be present if the server
	  supports DNSSEC.  The EDNS version field should be 0, and there
	  should be no EDNS options present <xref target="RFC6891"
	  format="default"/>.</t> 
          <t keepWithNext="true">
                Check that DO=1 queries work (EDNS supported):
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +nocookie +edns=0 +noad +norec +dnssec soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: an OPT record to be present in the additional section
expect: DO=1 to be present if an RRSIG is in the response
expect: EDNS Version 0 in response
expect: flag: aa to be present
              ]]></sourcecode>
        </section>
        <section numbered="true" toc="default">
          <name>Testing EDNS Version Negotiation with DO=1</name>
          <t>
            Ask for the SOA record of the configured zone, which does
            not need to be DNSSEC signed.  This query is made with no
            DNS flag bits set.  EDNS version 1 is used without any EDNS
            options.  The only EDNS flag set is DO.
          </t>
          <t>We expect the SOA record for the zone NOT to be returned in the answer
section, the extended rcode to be set to BADVERS, and the QR bit to be set in
the header; RA may also be set <xref target="RFC1034"
	  format="default"/>.  
	  
	  We expect an OPT record to be returned.  There
	  should be no EDNS flags other than DO present in the response, which
	  should be there if the server supports DNSSEC.  The EDNS version
	  field should be 0, and there should be no EDNS options present <xref
	  target="RFC6891" format="default"/>.</t> 
          <t keepWithNext="true">
                Check that EDNS version 1, DO=1 queries work (EDNS supported):
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +nocookie +edns=1 +noednsneg +noad +norec +dnssec soa \
    $zone @$server

expect: status: BADVERS
expect: SOA record to NOT be present
expect: an OPT record to be present in the additional section
expect: DO=1 to be present if the EDNS version 0 DNSSEC query test
        returned DO=1
expect: EDNS Version 0 in response
expect: flag: aa to NOT be present
              ]]></sourcecode>
        </section>
        <section numbered="true" toc="default">
          <name>Testing with Multiple Defined EDNS Options</name>
          <t>Ask for the SOA record of the configured zone.  This query is
	  made with no DNS flag bits set.  EDNS version 0 is used.  A number
	  of defined EDNS options are present (NSID <xref target="RFC5001"
	  format="default"/>, DNS COOKIE <xref target="RFC7873"
	  format="default"/>, EDNS Client Subnet <xref target="RFC7871"
	  format="default"/>, and EDNS Expire <xref target="RFC7314"
	  format="default"/>).</t> 
          <t>
            We expect the SOA record for the zone to be returned
            in the answer section, the rcode to be set to NOERROR, and
            the AA and QR bits to be set in the header; RA may
            also be set <xref target="RFC1034" format="default"/>.  We expect an OPT
            record to be returned.  There should be no EDNS flags
            present in the response.  The EDNS version field should
            be 0.  Any of the requested EDNS options supported
            by the server and permitted server configuration may
            be returned <xref target="RFC6891" format="default"/>.
          </t>
          <t keepWithNext="true">
                Check that EDNS queries with multiple defined EDNS options work:
          </t>
          <sourcecode name="" type=""><![CDATA[
dig +edns=0 +noad +norec +cookie +nsid +expire +subnet=0.0.0.0/0 \
    soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: an OPT record to be present in the additional section
expect: EDNS Version 0 in response
expect: flag: aa to be present
expect: flag: ad to NOT be present
              ]]></sourcecode>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>When EDNS Is Not Supported</name>
        <t>
          If EDNS is not supported by the nameserver, we expect a
          response to each of the above queries.  That response may
          be a FORMERR error response, or the OPT record may just
          be ignored.
        </t>
        <t>
          Some nameservers only return an EDNS response when a
          particular EDNS option or flag (e.g., DO=1) is present in
          the request. This behaviour is not compliant behaviour
          and may hide other incorrect behaviour from the above
          tests.  Retesting with the triggering option/flag
          present will expose this misbehaviour.
        </t>
      </section>
    </section>
    <section anchor="remediation" numbered="true" toc="default">
      <name>Remediation</name>
      <t>
        Nameserver operators are generally expected to test their
        own infrastructure for compliance to standards. The above
        tests should be run when new systems are brought online
        and should be repeated periodically to ensure continued
        interoperability.
      </t>
      <t>
        Domain registrants who do not maintain their own DNS
        infrastructure are entitled to a DNS service that conforms
        to standards and interoperates well.  Registrants who become
        aware that their DNS operator does not have a well-maintained
        or compliant infrastructure should insist that their service
        provider correct issues and switch providers if they do
        not.
      </t>
      <t>
        In the event that an operator experiences problems due to
        the behaviour of nameservers outside their control, the
        above tests will help in narrowing down the precise issue(s),
        which can then be reported to the relevant party.
      </t>
      <t>
        If contact information for the operator of a misbehaving
        nameserver is not already known, the following methods of
        communication could be considered:

      </t>
      <ul spacing="normal">
        <li>
            the RNAME of the zone authoritative for the name of the
            misbehaving server
          </li>
        <li>
            the RNAME of zones for which the offending server is
            authoritative
          </li>
        <li>
            administrative or technical contacts listed in the
            registration information for the parent domain of the
            name of the misbehaving server or for zones for which
            the nameserver is authoritative
          </li>
        <li>
            the registrar or registry for such zones
          </li>
        <li>
            DNS-specific, operational fora (e.g., mailing lists)
          </li>
      </ul>
      <t>
        Operators of parent zones may wish to regularly test the
        authoritative nameservers of their child zones.  However,
        parent operators can have widely varying capabilities in
        terms of notification or remediation depending on whether
        they have a direct relationship with the child operator.
        Many Top-Level Domain (TLD) registries, for example, cannot directly contact
        their registrants and may instead need to communicate through
        the relevant registrar.  In such cases, it may be most
        efficient for registrars to take on the responsibility for
        testing the nameservers of their registrants, since they
        have a direct relationship.
      </t>
      <t>
        When notification is not effective at correcting problems
        with a misbehaving nameserver, parent operators can choose
        to remove NS record sets (and glue records below) that refer
        to the faulty server until the servers are fixed.  This should
        only be done as a last resort and with due consideration, as
        removal of a delegation can have unanticipated side effects.
        For example, other parts of the DNS tree may depend on names
        below the removed zone cut, and the parent operator may find
        themselves responsible for causing new DNS failures to occur.
      </t>
    </section>
    <section anchor="seccon" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>
        Testing protocol compliance can potentially result in false
        reports of attempts to attack services from Intrusion Detection
        Services and firewalls.  All of the tests are well-formed
        (though not necessarily common) DNS queries.  None of the tests
        listed above should cause any harm to a protocol-compliant
        server.
      </t>
      <t>
        Relaxing firewall settings to ensure EDNS compliance could
        potentially expose a critical implementation flaw in the
        nameserver.  Nameservers should be tested for conformance
        before relaxing firewall settings.
      </t>
      <t>
        When removing delegations for non-compliant servers, there
        can be a knock-on effect on other zones that require these
        zones to be operational for the nameservers addresses to be
        resolved.
      </t>
    </section>
    <section anchor="iana" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This document has no IANA actions.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3225.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4035.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6840.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6895.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6891.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7766.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2671.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3597.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5001.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7314.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7871.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7873.xml"/>

        <reference anchor="ISC" target="https://www.isc.org/">
          <front>
            <title>Internet Systems Consortuim</title>
            <author/>
            <date/>
          </front>
        </reference>

<reference anchor="IANA-DNS"
           target="https://www.iana.org/assignments/dns-parameters/">
  <front>
    <title>Domain Name System (DNS) Parameters</title>
    <author><organization>IANA</organization></author>
  </front>
</reference>
	
      </references>
    </references>
    <section numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t>The contributions of <contact fullname="Matthew Pounsett"/> and
      <contact fullname="Tim Wicinski"/> are gratefully acknowledged.</t> 
    </section>
  </back>
</rfc>
