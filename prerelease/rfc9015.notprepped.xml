<?xml version="1.0" encoding="UTF-8"?>
<!-- updated by Chris 09/15/20 -->

<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude"
     docName="draft-ietf-bess-nsh-bgp-control-plane-18" number="9015"
     ipr="trust200902" obsoletes="" updates="" submissionType="IETF"
     category="std" consensus="true" xml:lang="en" tocInclude="true"
     tocDepth="3" symRefs="true" sortRefs="true" version="3">

  <!-- xml2rfc v2v3 conversion 3.1.1 -->
  <front>
    <title abbrev="BGP for NSH SFC">BGP Control Plane for the Network Service Header in Service Function Chaining</title>
    <seriesInfo name="RFC" value="9015"/>
    <author fullname="Adrian Farrel" initials="A." surname="Farrel">
      <organization>Old Dog Consulting</organization>
      <address>
        <email>adrian@olddog.co.uk</email>
      </address>
    </author>
    <author fullname="John Drake" initials="J." surname="Drake">
      <organization>Juniper Networks</organization>
      <address>
        <email>jdrake@juniper.net</email>
      </address>
    </author>
    <author fullname="Eric Rosen" initials="E." surname="Rosen">
      <organization>Juniper Networks</organization>
      <address>
        <email>erosen52@gmail.com</email>
      </address>
    </author>
    <author fullname="Jim Uttaro" initials="J." surname="Uttaro">
      <organization>AT&amp;T</organization>
      <address>
        <email>ju1738@att.com</email>
      </address>
    </author>
    <author fullname="Luay Jalil" initials="L" surname="Jalil">
      <organization>Verizon</organization>
      <address>
        <email>luay.jalil@verizon.com</email>
      </address>
    </author>
    <date year="2021" month="June" />
    <area>Routing</area>
    <workgroup>BESS Working Group</workgroup>
    <keyword>Service Function Chaining</keyword>
    <keyword>Service Function Chain</keyword>
    <keyword>Network Service Header</keyword>
    <keyword>Service Function</keyword>
    <keyword>Service Function Forwarder</keyword>
    <keyword>Service Function Path</keyword>
    <keyword>Service Function Path Route</keyword>
    <keyword>Service Function Instance</keyword>
    <keyword>Service Function Instance Route</keyword>
    <keyword>Service Function Type</keyword>
    <keyword>Control Plane</keyword>
    <abstract>
      <t>This document describes the use of BGP as a control plane for networks that support
         service function chaining.  The document introduces a new BGP address family
         called the "Service Function Chain (SFC) Address Family Identifier / Subsequent Address Family Identifier" (SFC
         AFI/SAFI) with two Route Types.  One Route Type is originated by a node to advertise
         that it hosts a particular instance of a specified service function.  This Route Type
         also provides "instructions" on how to send a packet to the hosting node in a way that
         indicates that the service function has to be applied to the packet.  The other Route
         Type is used by a controller to advertise the paths of "chains" of service functions
         and give a unique designator to each such path so that they can be used in
         conjunction with the Network Service Header (NSH) defined in RFC 8300.</t>
      <t>This document adopts the service function chaining architecture described in RFC 7665.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>As described in <xref target="RFC7498" format="default"/>, the delivery of end-to-end services can
       require a packet to pass through a series of Service Functions (SFs) --
       e.g., WAN and
       application accelerators, Deep Packet Inspection (DPI) engines, firewalls, TCP
       optimizers, and server load balancers -- in a specified order; this is termed
       "service function chaining".  There are a number of issues associated with
       deploying and maintaining service function chaining in production networks, which are
       described below.</t>
      <t>Historically, if a packet needed to travel through a particular service chain, the
       nodes hosting the service functions of that chain were placed in the network topology
       in such a way that the packet could not reach its ultimate destination without first
       passing through all the service functions in the proper order.  This need to place the
       service functions at particular topological locations limited the ability to adapt a
       service function chain to changes in network topology (e.g., link or node failures),
       network utilization, or offered service load.  These topological restrictions on where
       the service functions could be placed raised the following issues:

      </t>
      <ol spacing="normal" type="1"><li>The process of configuring or modifying a service function chain is operationally
            complex and may require changes to the network topology.</li>
        <li>Alternate or redundant service functions may need to be co-located with the
            primary service functions.</li>
        <li>When there is more than one path between source and destination, forwarding may be
            asymmetric, and it may be difficult to support bidirectional service function chains
            using simple routing methodologies and protocols without adding mechanisms for traffic
            steering or traffic engineering.</li>
      </ol>
      <t>In order to address these issues, the service function chaining architecture describes service function chains
       that are built in their own overlay network (the service function overlay network),
       coexisting with other overlay networks, over a common underlay network
       <xref target="RFC7665" format="default"/>.  A service function chain is a sequence of service functions
       through which packet flows that satisfy specified criteria will pass.</t>
      <t>This document describes the use of BGP as a control plane for networks that support service function chaining.  The document introduces a new BGP address family
       called the "Service Function Chain (SFC) Address Family Identifier / Subsequent Address Family Identifier"
       (SFC AFI/SAFI) with two Route Types.  One Route Type is originated by a
       node to advertise that it hosts a particular instance of a specified service function.
       This Route Type also provides "instructions" on how to send a packet to the hosting
       node in a way that indicates that the service function has to be applied to the packet.
       The other Route Type is used by a controller (a centralized network component responsible
       for planning and coordinating service function chaining within the network) to advertise
       the paths of "chains" of service functions and give a unique designator to each such
       path so that they can be used in conjunction with the Network Service Header (NSH)
       <xref target="RFC8300" format="default"/>.</t>
      <t>This document adopts the service function chaining architecture described in <xref target="RFC7665" format="default"/>.</t>
      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
         "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and
         "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as described in BCP
         14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when, and only when,
         they appear in all capitals, as shown here.</t>
      </section>
      <section anchor="terms" numbered="true" toc="default">
        <name>Terminology</name>
        <t>This document uses the following terms from <xref target="RFC7665" format="default"/>:
        </t>
        <ul spacing="normal">
          <li>Bidirectional Service Function Chain</li>
          <li>Classifier</li>
          <li>Service Function (SF)</li>
          <li>Service Function Chain (SFC)</li>
          <li>Service Function Forwarder (SFF)</li>
          <li>Service Function Instance (SFI)</li>
          <li>Service Function Path (SFP)</li>
          <li>SFC branching</li>
        </ul>
        <t>Additionally, this document uses the following terms from <xref target="RFC8300" format="default"/>:
        </t>
        <ul spacing="normal">
          <li>Network Service Header (NSH)</li>
          <li>Service Index (SI)</li>
          <li>Service Path Identifier (SPI)</li>
        </ul>
        <t>This document introduces the following terms:
        </t>
        <dl>
          <dt>Service Function Instance Route (SFIR):</dt><dd>A new BGP Route Type advertised by the
                node that hosts an SFI to describe the SFI and to announce the way to forward a
                packet to the node through the underlay network.</dd>
          <dt>Service Function Overlay Network:</dt><dd>The logical network comprised of classifiers,
                SFFs, and SFIs that are connected by paths or tunnels through underlay transport
                networks.</dd>
          <dt>Service Function Path Route (SFPR):</dt><dd>A new BGP Route Type originated by controllers to
                advertise the details of each SFP.</dd>
          <dt>Service Function Type (SFT):</dt><dd>An indication of the function and features of an SFI.</dd>
        </dl>
      </section>
    </section>
    <section anchor="overview" numbered="true" toc="default">
      <name>Overview</name>
      <t>This section provides an overview of service function chaining in general and the control
       plane defined in this document.  After reading this section, readers may find it helpful to
       look through <xref target="example" format="default"/> for some simple worked examples.</t>
      <section anchor="funcover" numbered="true" toc="default">
        <name>Overview of Service Function Chaining</name>
        <t>In <xref target="RFC8300" format="default"/>, a Service Function Chain (SFC) is an ordered list of
         Service Functions (SFs).  A Service Function Path (SFP) is an indication of which instances
         of SFs are acceptable to be traversed in an instantiation of an SFC in a service function
         overlay network.  The Service Path Identifier (SPI) is a 24-bit number that identifies
         a specific SFP, and a Service Index (SI) is an 8-bit number that identifies a specific point
         in that path.  In the context of a particular SFP (identified by an SPI), an SI represents a
         particular service function and indicates the order of that SF in the SFP.</t>
        <t>Within the context of a specific SFP, an SI references a set of one or more SFs.  Each of those SFs
         may be supported by one or more Service Function Instances (SFIs).  Thus, an SI may represent a choice
         of SFIs of one or more service function types.  By deploying multiple SFIs for a single SF, one
         can provide load balancing and redundancy.</t>
        <t>A special functional element, called a "classifier", is located at each ingress point to a service
         function overlay network.  It assigns the packets of a given packet flow to a specific SFP.  This may be done by comparing specific fields in a packet's header with
         local policy, which may be customer/network/service specific.  The classifier picks an SFP and
         sets the SPI accordingly; it then sets the SI to the value of the SI for the first hop in the
         SFP, and then prepends a Network Service Header (NSH) <xref target="RFC8300" format="default"/>
         containing the assigned SPI/SI to that packet.  Note that the classifier and the node that
         hosts the first SF in an SFP need not be located at the same
         point in the service function overlay network.</t>
        <t>Note that the presence of the NSH can make it difficult for nodes in the underlay network
         to locate the fields in the original packet that would normally be
	 used to constrain equal-cost multipath (ECMP) forwarding.  Therefore,
	 it is recommended that the node prepending the
         NSH also provide some form of entropy indicator that can be used in the underlay network.  How
         this indicator is generated and supplied, and how an SFF generates a new entropy indicator
         when it forwards a packet to the next SFF, are out of the scope of this document.</t>
        <t>The Service Function Forwarder (SFF) receives a packet from the previous node in an SFP, removes the packet's link layer or tunnel encapsulation, and hands the
         packet and the NSH to the SFI for processing.  The SFI has no knowledge
         of the SFP.</t>
        <t>When the SFF receives the packet and the NSH back from the SFI, it must select the next SFI
         along the path using the SPI and SI in the NSH and potentially choosing between multiple SFIs
         (possibly of different SFTs), as described in <xref target="selection" format="default"/>.  In
         the normal case, the SPI remains unchanged, and the SI will have been decremented to indicate the
         next SF along the path.  But other possibilities exist if the SF makes other changes to the NSH
         through a process of reclassification:
        </t>
        <ul spacing="normal">
          <li>
            <t>The SI in the NSH may indicate:
            </t>
            <ul spacing="normal">
              <li>A previous SF in the path; this is known as "looping" (see
	      <xref target="looping" format="default"/>).</li>
              <li>An SF further down the path; this is known as "jumping"
	      (again see <xref target="looping" format="default"/>).</li>
            </ul>
          </li>
          <li>The SPI and the SI may point to an SF on a different SFP; this is known as "branching" (see
               <xref target="looping" format="default"/>).</li>
        </ul>
        <t>Such modifications are limited to within the same service function overlay network.  That is, an
         SPI is known within the scope of service function overlay network.  Furthermore, the new SI value
         is interpreted in the context of the SFP identified by the SPI.</t>
        <t>As described in <xref target="RFC8300" format="default"/>, an SPI that is unknown or not valid is treated as an error, and
         the SFF drops the packet; such errors should be logged, and such logs are subject to rate limits.</t>
        <t>Also, as described in <xref target="RFC8300" format="default"/>, an SFF receiving an SI that is unknown in the
         context of the SPI can reduce the value to the next meaningful SI value in the SFP indicated by
         the SPI.  If no such value exists, or if the SFF does not support reducing the SI, the SFF drops the
         packet and should log the event; such logs are also subject to rate limits.</t>
        <t>The SFF then selects an SFI that provides the SF denoted by the SPI/SI and forwards the packet
         to the SFF that supports that SFI.</t>
        <t><xref target="RFC8300" format="default"/> makes it clear that the intended scope is for use within a single
         provider's operational domain.</t>
        <t>This document adopts the service function chaining architecture described in <xref target="RFC7665" format="default"/> and adds a
         control plane to support the functions, as described in <xref target="ctrlover" format="default"/>.  An essential
         component of this solution is the controller.  This is a network component responsible for
         planning SFPs within the network.  It gathers information about the availability of SFIs and SFFs,
         instructs the control plane about the SFPs to be programmed, and instructs the classifiers how
         to assign traffic flows to individual SFPs.</t>
      </section>
      <section anchor="ctrlover" numbered="true" toc="default">
        <name>Control Plane Overview</name>
        <t>To accomplish the function described in <xref target="funcover" format="default"/>, this document
         introduces the Service Function Type (SFT), which is the category of SF that is supported
         by an SFF (such as "firewall").  An IANA registry of service function types is introduced
         in <xref target="SFTreg" format="default"/> and is consistent with types used in other work, such as
         <xref target="I-D.dawra-idr-bgp-ls-sr-service-segments" format="default"/>.  An SFF may support SFs of
         multiple different SFTs, and it may support multiple SFIs of each SF.</t>
        <t>The registry of SFT values (see <xref target="SFTreg"/>) is split into three ranges with assignment
         policies per <xref target="RFC8126" format="default"/>:
        </t>
        <ul spacing="normal">
          <li>The special-purpose SFT values range is assigned through Standards Action.
               Values in that range are used for special SFC operations and do not apply to
               the types of SF that may form part of the SFP.</li>

          <li>The First Come First Served range tracks assignments of SFT values made by any
               party that defines an SF type. Reference through an Internet-Draft is desirable,
               but not required.</li>
          <li>The Private Use range is not tracked by IANA and is primarily intended for use
               in private networks where the meaning of the SFT values is locally tracked and
               under the control of a local administrator.</li>
        </ul>
        <t>It is envisaged that the majority of SFT values used will be assigned from the First Come
         First Served space in the registry.  This will ensure interoperability, especially in
         situations where software and hardware from different vendors are deployed in the same
         networks, or when networks are merged. However, operators of private networks may choose
         to develop their own SFs and manage the configuration and operation of their network through
         their own list of SFT values.</t>
        <t>This document also introduces a new BGP AFI/SAFI (values 31 and 9, respectively) for "SFC Routes".
         Two SFC Route Types are defined by this document: the Service Function Instance Route (SFIR) and
         the Service Function Path Route (SFPR).  As detailed in <xref target="sfcBGPRoutes" format="default"/>, the Route
         Type is indicated by a subfield in the Network Layer Reachability Information (NLRI).

        </t>
        <ul spacing="normal">
          <li>The SFIR is advertised by the node that provides access to the service function instance
               (i.e., the SFF).  The SFIR describes a particular instance of a particular SF
               (i.e., an SFI) and the way to forward a packet to it through
	       the underlay network, i.e., IP
               address and encapsulation information.</li>
          <li>
            <t>The SFPRs are originated by controllers.  One SFPR is originated for each SFP.  The SFPR specifies:
            </t>
            <ol spacing="normal" type="A"><li>the SPI of the path,</li>
              <li>the sequence of SFTs and/or SFIs of which the path consists, and</li>
              <li>for each such SFT or SFI, the SI that represents it in the identified path.</li>
            </ol>
          </li>
        </ul>
        <t>This approach assumes that there is an underlay network that provides connectivity between
         SFFs and controllers and that the SFFs are grouped to form one or more service function
         overlay networks through which SFPs are built.  We assume that the controllers have BGP
         connectivity to all SFFs and all classifiers within each service function overlay network.</t>
        <t>When choosing the next SFI in a path, the SFF uses the SPI and SI as well as the SFT to choose
         among the SFIs, applying, for example, a load-balancing algorithm or direct knowledge of the
         underlay network topology, as described in <xref target="mode" format="default"/>.</t>
        <t>The SFF then encapsulates the packet using the encapsulation specified by the SFIR of the
         selected SFI and forwards the packet.  See <xref target="SFCarch" format="default"/>.</t>
        <t>Thus, the SFF can be seen as a portal in the underlay network through which a particular SFI
         is reached.</t>
        <t><xref target="SFCarch" format="default"/> shows a reference model for the service function chaining architecture.  There are four SFFs
         (SFF-1 through SFF-4) connected by tunnels across the underlay network.  Packets arrive at
         a classifier and are channeled along SFPs to destinations reachable through SFF-4.</t>
        <t>SFF-1 and SFF-4 each have one instance of one SF attached (SFa and SFe).  SFF-2 has two types
         of SF attached: one instance of one (SFc) and three instances of the other (SFb).
         SFF-3 has just one instance of an SF (SFd), but in this case, the type of SFd is the same
         type as SFb (SFTx).</t>
        <t>This figure demonstrates how load balancing can be achieved by creating several SFPs that satisfy
         the same SFC.  Suppose an SFC needs to include SFa, an SF of type SFTx, and SFc.  A number of SFPs
         can be constructed using any instance of SFb or using SFd.  Load balancing may be applied at two
         places:
        </t>
        <ul spacing="normal">
          <li>The classifier may distribute different flows onto different SFPs to share the load in the
              network and across SFIs.</li>
          <li>SFF-2 may distribute different flows (on the same SFP) to different instances of SFb to share
              the processing load.</li>
        </ul>
        <t>Note that, for convenience and clarity, <xref target="SFCarch" format="default"/> shows only a few tunnels between
         SFFs.  There could be a full mesh of such tunnels, or more likely, a selection of tunnels connecting
         key SFFs to enable the construction of SFPs and balance load and traffic in the network.  Further,
         the figure does not show any controllers; these would each have BGP connectivity to the classifier and
         all of the SFFs.</t>
        <figure anchor="SFCarch">
          <name>The Service Function Chaining Architecture Reference Model</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    Packets
    | | |
 ------------
|            |
| Classifier |
|            |
 ------+-----
       |
    ---+---                 ---------           -------
   |       |    Tunnel     |         |         |       |
   | SFF-1 |===============|  SFF-2  |=========| SFF-4 |
   |       |               |         |         |       |
   |       |                -+-----+-          |       |
   |       |  ,,,,,,,,,,,,,,/,,     \          |       |
   |       | '  .........../.  '   ..\......   |       |
   |       | ' : SFb      /  : '  :   \ SFc :  |       |
   |       | ' :      ---+-  : '  :  --+--  :  |       |
   |       | ' :    -| SFI | : '  : | SFI | :  |       |
   |       | ' :  -|  -----  : '  :  -----  :  |       |
   |       | ' : |  -----    : '   .........   |       |
   |       | ' :  -----      : '               |       |
   |       | '  .............  '               |       |--- Dests
   |       | '                 '               |       |--- Dests
   |       | '    .........    '               |       |
   |       | '   :  -----  :   '               |       |
   |       | '   : | SFI | :   '               |       |
   |       | '   :  --+--  :   '               |       |
   |       | '   :SFd |    :   '               |       |
   |       | '    ....|....    '               |       |
   |       | '        |        '               |       |
   |       | ' SFTx   |        '               |       |
   |       | ',,,,,,,,|,,,,,,,,'               |       |
   |       |          |                        |       |
   |       |       ---+---                     |       |
   |       |      |       |                    |       |
   |       |======| SFF-3 |====================|       |
    ---+---       |       |                     ---+---
       |           -------                         |
   ....|....                                   ....|....
  :    | SFa:                                 :    | SFe:
  :  --+--  :                                 :  --+--  :
  : | SFI | :                                 : | SFI | :
  :  -----  :                                 :  -----  :
   .........                                   .........
   ]]></artwork>
        </figure>
        <t>As previously noted, <xref target="RFC8300" format="default"/> makes it clear that the mechanisms it defines
         are intended for use within a single provider's operational domain.  This reduces the
        requirements on the control plane function.</t>
	
        <t><xref target="RFC7665" section="5.2" sectionFormat="of"/> sets out the functions provided by a control plane for a service function chaining network.
          The functions are broken down into six items, the first four of which are
         completely covered by the mechanisms described in this document:
        </t>
        <ol spacing="normal" type="1"><li>Visibility of all SFs and the SFFs through which they are reached.</li>
          <li>Computation of SFPs and programming into the network.</li>
          <li>Selection of SFIs explicitly in the SFP or dynamically within the network.</li>
          <li>Programming of SFFs with forwarding path information.</li>
        </ol>
        <t>The fifth and sixth items in the list in RFC 7665 concern the use of metadata.  These are
         more peripheral to the control plane mechanisms defined in this document but are discussed
         in <xref target="classy" format="default"/>.</t>
      </section>
    </section>
    <section anchor="sfcBGPRoutes" numbered="true" toc="default">
      <name>BGP SFC Routes</name>
      <t>This document defines a new AFI/SAFI for BGP, known as "SFC", with an NLRI that is described
       in this section.</t>
      <t>The format of the SFC NLRI is shown in <xref target="SFCnlriFig" format="default"/>.</t>
      <figure anchor="SFCnlriFig">
        <name>The Format of the SFC NLRI</name>

        <artwork name="" type="" align="left" alt=""><![CDATA[
                 +---------------------------------------+
                 |  Route Type (2 octets)                |
                 +---------------------------------------+
                 |  Length (2 octets)                    |
                 +---------------------------------------+
                 |  Route Type specific (variable)       |
                 +---------------------------------------+
		 ]]></artwork>
      </figure>
      <t>The "Route Type" field determines the encoding of the rest of the Route Type specific SFC NLRI.</t>
      <t>The "Length" field indicates the length, in octets, of the "Route Type specific" field of the SFC
       NLRI.</t>
      <t>This document defines the following Route Types:
      </t>
      <ol spacing="normal" type="1"><li>Service Function Instance Route (SFIR)</li>
        <li>Service Function Path Route (SFPR)</li>
      </ol>
      <t>An SFIR is used to identify an SFI.  An SFPR defines a sequence of SFs (each of which has at least one instance advertised in
       an SFIR) that form an SFP.</t>
      <t>The detailed encoding and procedures for these Route Types are described in subsequent sections.</t>
      <t>The SFC NLRI is carried in BGP <xref target="RFC4271"
      format="default"/> using BGP Multiprotocol Extensions
       <xref target="RFC4760" format="default"/> with an Address Family Identifier (AFI) of 31 and a Subsequent Address
       Family Identifier (SAFI) of 9.  The "NLRI" field in the MP_REACH_NLRI/MP_UNREACH_NLRI attribute
       contains the SFC NLRI, encoded as specified above.</t>
      <t>In order for two BGP speakers to exchange SFC NLRIs, they
      <bcp14>MUST</bcp14> use BGP capabilities advertisements
       to ensure that they both are capable of properly processing such NLRIs.  This is done as specified
       in <xref target="RFC4760" format="default"/>, by using capability code
       1 (Multiprotocol BGP) with an AFI of 31 and
       a SAFI of 9.</t>
      <t>The "nexthop" field of the MP_REACH_NLRI attribute of the SFC NLRI <bcp14>MUST</bcp14> be set to a loopback address of
       the advertising SFF.</t>
      <section anchor="sfiRoutes" numbered="true" toc="default">
        <name>Service Function Instance Route (SFIR)</name>
        <t><xref target="sfiRouteFig" format="default"/> shows the Route Type specific NLRI of the SFIR.</t>
        <figure anchor="sfiRouteFig">
          <name>SFIR Route Type Specific NLRI</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
                 +--------------------------------------------+
                 |  Route Distinguisher (RD) (8 octets)       |
                 +--------------------------------------------+
                 |  Service Function Type (2 octets)          |
                 +--------------------------------------------+
                 ]]></artwork>
        </figure>
        <t><xref target="RFC4364" format="default"/> defines a Route
	Distinguisher (RD) as consisting of a two-byte "Type" field
          and a six-byte "Value" field, and it defines RD types 0, 1, and 2.  In this specification, the RD
          (used for the SFIR) <bcp14>MUST</bcp14> be of type 0, 1, or 2.</t>
        <t>If two SFIRs are originated from different administrative domains (within the same
          provider's operational domain), they <bcp14>MUST</bcp14> have different RDs.  In particular, SFIRs from
          different VPNs (for different service function overlay networks) <bcp14>MUST</bcp14> have different RDs, and
          those RDs <bcp14>MUST</bcp14> be different from any non-VPN SFIRs.</t>
        <t>The SFT identifies the functions/features an
	SF can offer, e.g.,
          classifier, firewall, load balancer.  There may be several SFIs that can perform a given
          service function.  Each node hosting an SFI <bcp14>MUST</bcp14> originate an SFIR for each type of SF that it
          hosts (as indicated by the SFT value), and it <bcp14>MAY</bcp14> advertise an SFIR for each instance of each type of SF.  A minimal
          advertisement allows construction of valid SFPs and leaves the selection of SFIs to the local SFF;
          a detailed advertisement may have scaling concerns but allows a controller that constructs an
          SFP to make an explicit choice of SFI.</t>
        <t>Note that a node may advertise all its SFIs of one SFT in one shot
	using normal BGP UPDATE packing.
          That is, all of the SFIRs in an Update share a common Tunnel Encapsulation and Route Target (RT) attribute.
          See also <xref target="sfpatt" format="default"/>.</t>
        <t>The SFIR representing a given SFI will contain an NLRI with "RD" field set to an RD as specified above,
          and with the "SFT" field set to identify that SFI's SFT.  The values for the "SFT"
          field are taken from a registry administered by IANA (see <xref target="iana" format="default"/>).  A BGP UPDATE
          containing one or more SFIRs <bcp14>MUST</bcp14> also include a tunnel encapsulation attribute
          <xref target="RFC9012" format="default"/>.  If a data packet needs to be sent to an SFI identified
          in one of the SFIRs, it will be encapsulated as specified by the tunnel encapsulation attribute and
          then transmitted through the underlay network.</t>
        <t>Note that the tunnel encapsulation attribute <bcp14>MUST</bcp14> contain sufficient information to allow the
          advertising SFF to identify the overlay or VPN network that a received packet is transiting.
          This is because the [SPI, SI] in a received packet is specific to a particular overlay or VPN
          network.</t>
        <section anchor="poolid" numbered="true" toc="default">
          <name>SFIR Pool Identifier Extended Community</name>
          <t>This document defines a new transitive Extended Community <xref target="RFC4360" format="default"/> of type 0x0b called
             the "SFC Extended Community".  When used with Sub-Type 1, this is called the "SFIR Pool Identifier extended
             community".  It <bcp14>MAY</bcp14> be included in SFIR
	     advertisements, and it is used to indicate the identity of a pool of
             SFIRs to which an SFIR belongs.  Since an SFIR may be a member of
	     more than one pool, multiple of these extended
             communities may be present on a single SFIR advertisement.</t>
          <t>SFIR pools allow SFIRs to be grouped for any purpose.  Possible uses include control plane scalability and
             stability.  A pool identifier may be included in an SFPR to indicate a set of SFIs that are acceptable at
             a specific point on an SFP (see Sections <xref format="counter"
	     target="sfttlv"/> and <xref target="SFPR" format="counter"/>).</t>
          <t>The SFIR Pool Identifier Extended Community is encoded in 8 octets as shown in <xref target="poolFig" format="default"/>.</t>
          <figure anchor="poolFig">
            <name>The SFIR Pool Identifier Extended Community</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
             +--------------------------------------------+
             |  Type = 0x0b (1 octet)                     |
             +--------------------------------------------+
             |  Sub-Type = 1 (1 octet)                    |
             +--------------------------------------------+
             |  SFIR Pool Identifier value (6 octets)     |
             +--------------------------------------------+
             ]]></artwork>
          </figure>
          <t>The SFIR Pool Identifier value is encoded in a 6-octet field in network byte order, and the value is unique
             within the scope of an overlay network.  This means that pool identifiers need to be centrally managed, which
             is consistent with the assignment of SFIs to pools.</t>
        </section>
        <section anchor="swapnstack" numbered="true" toc="default">
          <name>MPLS Mixed Swapping/Stacking Extended Community</name>
          <t>As noted in <xref target="poolid" format="default"/>, this document defines a new transitive Extended Community of type 0x0b
             called the "SFC Extended Community".  When used with Sub-Type 2, this is called the "MPLS Mixed Swapping/Stacking
             Labels Extended Community".  The community is encoded as shown in <xref target="swapFig" format="default"/>.
             It contains a pair of MPLS labels: an SFC Context Label and an SF Label, as described in
             <xref target="RFC8595" format="default"/>.  Each label is 20 bits encoded in a 3-octet (24-bit) field with
             4 trailing  bits that <bcp14>MUST</bcp14> be set to zero.</t>
          <figure anchor="swapFig">
            <name>The MPLS Mixed Swapping/Stacking Labels Extended Community</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
             +--------------------------------------------+
             |  Type = 0x0b (1 octet)                     |
             +--------------------------------------------|
             |  Sub-Type = 2 (1 octet)                    |
             +--------------------------------------------|
             |  SFC Context Label (3 octets)              |
             +--------------------------------------------|
             |  SF Label (3 octets)                       |
             +--------------------------------------------+
             ]]></artwork>
          </figure>
          <t>Note that it is assumed that each SFF has one or more globally
	  unique SFC Context Labels and that the context-label
             space and the SPI-address space are disjoint. In other words, a
	     label value cannot be used to indicate both an SFC context and an
	     SPI,
             and it can be determined from knowledge of the label spaces
	  whether a label indicates an SFC context or an SPI.</t>
          <t>If an SFF supports SFP Traversal with an MPLS Label Stack, it
	  <bcp14>MUST</bcp14> include this Extended Community with the SFIRs
             that it advertises.</t>
          <t>See <xref target="swapOp" format="default"/> for a description of how this Extended Community is used.</t>
        </section>
      </section>
      <section anchor="sfpRoutes" numbered="true" toc="default">
        <name>Service Function Path Route (SFPR)</name>
        <t><xref target="sfpRouteFig" format="default"/> shows the Route Type specific NLRI of the SFPR.</t>
        <figure anchor="sfpRouteFig">
          <name>SFPR Route Type Specific NLRI</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[          
             +-----------------------------------------------+
             |  Route Distinguisher (RD) (8 octets)          |
             +-----------------------------------------------+
             |  Service Path Identifier (SPI) (3 octets)     |
             +-----------------------------------------------+
             ]]></artwork>
        </figure>
        <t><xref target="RFC4364" format="default"/> defines a Route Distinguisher (RD) as consisting of a two-byte "Type" field
          and a six-byte "Value" field, and it defines RD types 0, 1, and 2.  In this specification, the RD
          (used for the SFPR) <bcp14>MUST</bcp14> be of type 0, 1, or 2.</t>
        <t>All SFPs <bcp14>MUST</bcp14> be associated with an RD.  The association of an SFP with
          an RD is determined by provisioning.  If two SFPRs are originated from different controllers, they
          <bcp14>MUST</bcp14> have different RDs.  Additionally, SFPRs from different VPNs (i.e., in different service
          function overlay networks) <bcp14>MUST</bcp14> have different RDs, and those RDs <bcp14>MUST</bcp14> be different from any
          non-VPN SFPRs.</t>
        <t>The Service path identifier is defined in <xref target="RFC8300" format="default"/> and is the value
          to be placed in the "Service Path Identifier" field of the NSH of any packet sent on this
          SFP.  It is expected that one or more controllers will originate
          these routes in order to configure a service function overlay network.</t>
        <t>The SFP is described in a new BGP Path attribute, the SFP attribute.  <xref target="sfpatt" format="default"/>
          shows the format of that attribute.</t>
        <section anchor="sfpatt" numbered="true" toc="default">
          <name>The SFP Attribute</name>
          <t><xref target="RFC4271" format="default"/> defines BGP Path attributes.  This document introduces a new
             Optional Transitive Path attribute called the "SFP attribute", with value 37.  The first SFP attribute <bcp14>MUST</bcp14> be processed, and subsequent instances <bcp14>MUST</bcp14> be ignored.</t>
          <t>The common fields of the SFP attribute are set as follows:
          </t>
          <ul spacing="normal">
            <li>The Optional bit is set to 1 to indicate that this is an optional attribute.</li>
            <li>The Transitive bit is set to 1 to indicate that this is a transitive attribute.</li>
            <li>The Extended Length bit is set if the length of the SFP attribute is encoded in one
                  octet (set to 0) or two octets (set to 1), as described in <xref target="RFC4271" format="default"/>.</li>
            <li>The Attribute Type Code is set to 37.</li>
          </ul>
          <t>The content of the SFP attribute is a series of Type-Length-Value (TLV) constructs.
             Some TLVs may include Sub-TLVs.  All TLVs and Sub-TLVs have a common format:
          </t>
          <dl>
            <dt>Type:</dt><dd> A single octet indicating the type of the SFP attribute TLV.  Values are
                  taken from the registry described in <xref target="ianasftlv" format="default"/>.</dd>
            <dt>Length:</dt><dd> A two-octet field indicating the length of the data following the "Length"
                  field, counted in octets.</dd>
            <dt>Value:</dt><dd> The contents of the TLV.</dd>
          </dl>
          <t>The formats of the TLVs defined in this document are shown in the following sections.
             The presence rules and meanings are as follows.
          </t>
          <ul spacing="normal">
            <li>The SFP attribute contains a sequence of zero or more Association TLVs.  That is, the
                  Association TLV is <bcp14>OPTIONAL</bcp14>.  Each Association TLV provides an association between this
                  SFPR and another SFPR.  Each associated SFPR is indicated using the RD with which it is
                  advertised (we say the SFPR-RD to avoid ambiguity).</li>
            <li>The SFP attribute contains a sequence of one or more Hop TLVs.  Each Hop TLV contains
                  all of the information about a single hop in the SFP.</li>
            <li>Each Hop TLV contains an SI value and a sequence of one or more SFT TLVs.  Each SFT
                  TLV contains an SFI reference for each instance of an SF that is allowed at this hop
                  of the SFP for the specific SFT.  Each SFI is indicated using the RD with which
                  it is advertised (we say the SFIR-RD to avoid ambiguity).</li>
          </ul>
          <t><xref target="RFC4271" section="6" sectionFormat="of"/> describes the handling of malformed BGP attributes,
             or those that are in error in some way.  <xref target="RFC7606" format="default"/> revises BGP error handling
             specifically for the UPDATE message, provides guidelines for the authors of documents
             defining new attributes, and revises the error-handling procedures for a number of existing
             attributes.  This document introduces the SFP attribute and so defines error handling as
             follows:

          </t>
          <ul spacing="normal">
            <li>When parsing a message, an unknown Attribute Type Code or a length that suggests that
                  the attribute is longer than the remaining message is treated as a malformed message,
                  and the "treat-as-withdraw" approach is used as per <xref target="RFC7606" format="default"/>.</li>
            <li>
              <t>When parsing a message that contains an SFP attribute, the following cases constitute
                  errors:
              </t>
              <ol spacing="normal" type="1"><li>Optional bit is set to 0 in the SFP attribute.</li>
                <li>Transitive bit is set to 0 in the SFP attribute.</li>
                <li>Unknown "TLV Type" field found in the SFP attribute.</li>
                <li>TLV length that suggests the TLV extends beyond the end of the SFP attribute.</li>
                <li>Association TLV contains an unknown SFPR-RD.</li>
                <li>No Hop TLV found in the SFP attribute.</li>
                <li>No Sub-TLV found in a Hop TLV.</li>
                <li>Unknown SFIR-RD found in an SFT TLV.</li>
              </ol>
            </li>
            <li>
              <t>The errors listed above are treated as follows:
              </t>
              <dl newline="false" spacing="normal">
                <dt>1, 2, 4, 6, 7:</dt>
                <dd>The attribute <bcp14>MUST</bcp14> be treated as malformed and
                      the "treat-as-withdraw" approach used as per <xref target="RFC7606" format="default"/>.</dd>
                <dt>3:</dt>
                <dd>Unknown TLVs <bcp14>MUST</bcp14> be ignored, and message processing <bcp14>MUST</bcp14>
                      continue.</dd>
                <dt>5, 8:</dt>
                <dd>The absence of an RD with which to correlate is nothing more than
                      a soft error.  The receiver <bcp14>SHOULD</bcp14> store the information from the SFP attribute until
                      a corresponding advertisement is received.</dd>
              </dl>
            </li>
          </ul>
          <section anchor="assoctlv" numbered="true" toc="default">
            <name>The Association TLV</name>
            <t>The Association TLV is an optional TLV in the SFP attribute.  It <bcp14>MAY</bcp14> be present
                multiple times.  Each occurrence provides an association with another SFP as
                advertised in another SFPR.  The format of the Association TLV is shown in
                <xref target="assoctlvfig" format="default"/>.</t>
            <figure anchor="assoctlvfig">
              <name>The Format of the Association TLV</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[                
             +--------------------------------------------+
             |  Type = 1 (1 octet)                        |
             +--------------------------------------------|
             |  Length (2 octets)                         |
             +--------------------------------------------|
             |  Association Type (1 octet)                |
             +--------------------------------------------|
             |  Associated SFPR-RD (8 octets)             |
             +--------------------------------------------|
             |  Associated SPI (3 octets)                 |
             +--------------------------------------------+
             ]]></artwork>
            </figure>
            <t>The fields are as follows:
            </t>
            <ul spacing="normal">
              <li>"Type" is set to 1 to indicate an Association TLV.</li>
              <li>"Length" indicates the length in octets of the "Association Type" and "Associated
                     SFPR-RD" fields.  The value of the "Length" field is 12.</li>
              <li>The "Association Type" field indicates the type of association.  The values are
                     tracked in an IANA registry (see <xref target="ianaassoc" format="default"/>).  Only one value
                     is defined in this document: Type 1 indicates association of two unidirectional
                     SFPs to form a bidirectional SFP.  An SFP attribute <bcp14>SHOULD NOT</bcp14> contain more than
                     one Association TLV with Association Type 1; if more than one is present, the
                     first one <bcp14>MUST</bcp14> be processed, and subsequent instances <bcp14>MUST</bcp14> be ignored.  Note that
                     documents that define new association types must also define the presence rules
                     for Association TLVs of the new type.</li>
              <li>The Associated SFPR-RD contains the RD of the associated SFP as advertised in an
                     SFPR.</li>
              <li>The Associated SPI contains the SPI of the associated SFP as advertised in an
                     SFPR.</li>
            </ul>
            <t>Association TLVs with unknown Association Type values <bcp14>SHOULD</bcp14> be ignored.  Association TLVs
                that contain an Associated SFPR-RD value equal to the RD of the SFPR in which they are
                contained <bcp14>SHOULD</bcp14> be ignored.  If the Associated SPI is not equal to the SPI advertised in
                the SFPR indicated by the Associated SFPR-RD, then the Association TLV <bcp14>SHOULD</bcp14> be ignored.
                In all three of these cases, an implementation <bcp14>MAY</bcp14> reject the SFP attribute as malformed and
                use the "treat-as-withdraw" approach per <xref target="RFC7606" format="default"/>; however, implementors are
                cautioned that such an approach may make an implementation less flexible in the event of
                future extensions to this protocol.</t>
            <t>Note that when two SFPRs reference each other using the Association TLV, one SFPR advertisement
                will be received before the other.  Therefore, processing of an association <bcp14>MUST NOT</bcp14> be
                rejected simply because the Associated SFPR-RD is unknown.</t>
            <t>Further discussion of correlation of SFPRs is provided in <xref target="correlation" format="default"/>.</t>
          </section>
          <section anchor="hoptlv" numbered="true" toc="default">
            <name>The Hop TLV</name>
            <t>There is one Hop TLV in the SFP attribute for each hop in the SFP.  The format of
                the Hop TLV is shown in <xref target="hoptlvfig" format="default"/>.  At least one Hop TLV <bcp14>MUST</bcp14> be
                present in an SFP attribute.</t>
            <figure anchor="hoptlvfig">
              <name>The Format of the Hop TLV</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[       
             +--------------------------------------------+
             |  Type = 2 (1 octet)                        |
             +--------------------------------------------|
             |  Length (2 octets)                         |
             +--------------------------------------------|
             |  Service Index (1 octet)                   |
             +--------------------------------------------|
             |  Hop Details (variable)                    |
             +--------------------------------------------+
                ]]></artwork>
            </figure>
            <t>The fields are as follows:
            </t>
            <ul spacing="normal">
              <li>"Type" is set to 2 to indicate a Hop TLV.</li>
              <li>"Length" indicates the length, in octets, of the "Service Index" and "Hop
                     Details" fields.</li>
              <li>The Service Index is defined in <xref target="RFC8300" format="default"/> and is the value found in the
                     "Service Index" field of the NSH that an SFF will
		     use to look up to which next
                     SFI a packet is to be sent.</li>
              <li>The "Hop Details" field consists of a sequence of one or more Sub-TLVs.</li>
            </ul>
            <t>Each hop of the SFP may demand that a specific type of SF is executed, and that type is
                indicated in Sub-TLVs of the Hop TLV.  At least one Sub-TLV <bcp14>MUST</bcp14> be present. This document
                defines the SFT Sub-TLV (see <xref target="sfttlv"
		format="default"/>) and the MPLS Swapping/Stacking Sub-TLV
                (see <xref target="swapTLV" format="default"/>); other Sub-TLVs may be defined in future. The SFT Sub-TLV
                provides a list of which types of SF are acceptable at a specific hop, and for each type it
                allows a degree of control to be imposed on the choice of SFIs of that particular type.  The MPLS 
  Swapping/Stacking Sub-TLV indicates the type of SFC encoding to use
  in an MPLS label stack. </t>
            <t>If no Hop TLV is present in an SFP attribute, it is a malformed attribute.</t>
          </section>
          <section anchor="sfttlv" numbered="true" toc="default">
            <name>The SFT Sub-TLV</name>
            <t>The SFT Sub-TLV <bcp14>MAY</bcp14> be included in the list of Sub-TLVs of the Hop TLV.  The format of the SFT Sub-TLV
                is shown in <xref target="sfttlvfig" format="default"/>.  The Hop Sub-TLV contains a list of SFIR-RD values each taken from
                the advertisement of an SFI.  Together they form a list of acceptable SFIs of the indicated type.</t>
            <figure anchor="sfttlvfig">
              <name>The Format of the SFT Sub-TLV</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[
             +--------------------------------------------+
             |  Type = 3 (1 octet)                        |
             +--------------------------------------------|
             |  Length (2 octets)                         |
             +--------------------------------------------|
             |  Service Function Type (2 octets)          |
             +--------------------------------------------|
             |  SFIR-RD List (variable)                   |
             +--------------------------------------------+
               ]]></artwork>
            </figure>
            <t>The fields are as follows:
            </t>
            <ul>
              <li>"Type" is set to 3 to indicate an SFT Sub-TLV.</li>
              <li>"Length" indicates the length, in octets, of the "Service
	      Function Type" and "SFIR-RD List" fields.</li>
              <li>The SFT value indicates the category (type) of SF that is to be
                     executed at this hop.  The types are as advertised for the SFs supported by the SFFs.
                     SFT values in the range 1-31 are special-purpose SFT values and have meanings defined by
                     the documents that describe them -- the value "Change Sequence" is defined in
                     <xref target="changeseq" format="default"/> of this document.</li>
              <li>The hop description is further qualified beyond the specification of the SFTs by listing, for
                     each SFT in each hop, the SFIs that may be used at the hop.  The SFIs are identified using
                     the SFIR-RDs from the advertisements of the SFIs in the SFIRs.  Note that if the list contains
                     one or more SFIR Pool Identifiers, then for each, the SFIR-RD list is effectively expanded to
                     include the SFIR-RD of each SFIR advertised with that SFIR Pool Identifier.  An SFIR-RD of value
                     zero has special meaning, as described in <xref target="selection" format="default"/>.  Each entry in the list
                     is eight octets long, and the number of entries in the list can be deduced from the value of the
                     "Length" field.</li>
              <li>Note that an SFIR-RD is of type 0, 1, or 2 (as described in
	      <xref target="sfiRoutes" format="default"/>).  Thus, the
                     high-order octet of an RD found in an SFIR-RD List always
		     has a value of 0x00.  However, the high-order octet of an
		     SFIR Pool Identifier (an Extended Community with "Type"
		     field 0x0b) will always
                     have a nonzero value.  This allows the node processing the SFIR-RD list to distinguish between
                     the two types of list entry.</li>
            </ul>
          </section>
          <section anchor="swapTLV" numbered="true" toc="default">
            <name>MPLS Swapping/Stacking Sub-TLV</name>
            <t>The MPLS Swapping/Stacking Sub-TLV (Type value 4) is a zero-length Sub-TLV that is <bcp14>OPTIONAL</bcp14> in the Hop TLV
                and is used when the data representation is MPLS (see <xref target="representation" format="default"/>).  When present, it indicates to
                the classifier imposing an MPLS label stack that the current hop is to use an {SFC Context Label, SF label} rather
                than an {SPI, SF} label pair.  See <xref target="swapOp" format="default"/> for more details.</t>
          </section>
          <section anchor="sfpTraverse" numbered="true" toc="default">
            <name>SFP Traversal With MPLS Label Stack TLV</name>
            <t>The SFP Traversal With MPLS Label Stack TLV (Type value 5) is a zero-length TLV that can be carried in the
                SFP attribute and indicates to the classifier and the SFFs on the SFP that an MPLS label stack with label
                swapping/stacking is to be used for packets traversing the SFP.  All of the SFFs specified at each of the SFP's
                hops <bcp14>MUST</bcp14> have advertised an  MPLS Mixed Swapping/Stacking Extended Community (see <xref target="swapnstack" format="default"/>)
                for the SFP to be considered usable.</t>
          </section>
        </section>
        <section anchor="sfparules" numbered="true" toc="default">
          <name>General Rules for the SFP Attribute</name>
          <t>It is possible for the same SFI, as described by an SFIR, to be used in multiple SFPRs.</t>
          <t>When two SFPRs have the same SPI but different SFPR-RDs, there can be three cases:
          </t>
          <ol type="1" spacing="normal">
            <li>Two or more controllers are originating SFPRs for the same SFP.  In this case, the
                   content of the SFPRs is identical, and the duplication is to ensure receipt and
                   provide controller redundancy.</li>
            <li>There is a transition in content of the advertised SFP, and the advertisements may
                   originate from one or more controllers.  In this case, the content of the SFPRs will be
                   different.</li>
            <li>The reuse of an SPI may result from a configuration error.</li>
          </ol>
          <t>There is no way in any of these cases for the receiving SFF to know which SFPR to process, and the
              SFPRs could be received in any order.  At any point in time, when multiple SFPRs have the
              same SPI but different SFPR-RDs, the SFF <bcp14>MUST</bcp14> use the SFPR with the numerically lowest
              SFPR-RD when interpreting the RDs as 8-octet integers in network byte order.  The SFF
              <bcp14>SHOULD</bcp14> log this occurrence to assist with debugging.</t>
          <t>Furthermore, a controller that wants to change the content of an SFP is <bcp14>RECOMMENDED</bcp14> to use a
              new SPI and so create a new SFP onto which the classifiers can transition packet flows before
              the SFPR for the old SFP is withdrawn.  This avoids any race conditions with SFPR advertisements.</t>
          <t>Additionally, a controller <bcp14>SHOULD NOT</bcp14> reuse an SPI after it has withdrawn the SFPR that used it
              until at least a configurable amount of time has passed.  This timer <bcp14>SHOULD</bcp14> have a default of one
              hour.</t>
        </section>
      </section>
    </section>
    <section anchor="mode" numbered="true" toc="default">
      <name>Mode of Operation</name>
      <t>This document describes the use of BGP as a control plane to create and manage a service
       function overlay network.</t>
      <section anchor="rt" numbered="true" toc="default">
        <name>Route Targets</name>
        <t>The main feature introduced by this document is the ability to create multiple service
          function overlay networks through the use of Route Targets (RTs) <xref target="RFC4364" format="default"/>.</t>
        <t>Every BGP UPDATE containing an SFIR or SFPR carries one or more RTs.  The RT carried by a particular
          SFIR or SFPR is determined by the provisioning of the route's originator.</t>
        <t>Every node in a service function overlay network is configured with one or more import RTs.
          Thus, each SFF will import only the SFPRs with matching RTs, allowing the construction of
          multiple service function overlay networks or the instantiation of SFCs
          within a Layer 3 Virtual Private Network (L3VPN) or Ethernet VPN (EVPN) instance
          (see <xref target="private" format="default"/>).  An SFF that has a presence in multiple service function
          overlay networks (i.e., one that imports more than one RT) will
	  usually maintain separate forwarding
          state for each overlay network.</t>
      </section>
      <section anchor="SFIR" numbered="true" toc="default">
        <name>Service Function Instance Routes</name>
        <t>The SFIR (see <xref target="sfiRoutes" format="default"/>) is used to advertise the existence and location
          of a specific SFI; it consists of:

        </t>
        <ul spacing="normal">
          <li>The RT as just described.</li>
          <li>A Service Function Type (SFT) that is the type of service function that is
                provided (such as "firewall").</li>
          <li>A Route Distinguisher (RD) that is unique to a specific overlay.</li>
        </ul>
      </section>
      <section anchor="SFPR" numbered="true" toc="default">
        <name>Service Function Path Routes</name>
        <t>The SFPR (see <xref target="sfpRoutes" format="default"/>)
	describes a specific path of an SFC.
          The SFPR contains the Service Path Identifier (SPI) used to identify the SFP in the NSH
          in the data plane.  It also contains a sequence of Service Indexes (SIs).  Each SI
          identifies a hop in the SFP, and each hop is a choice between one or more SFIs.</t>
        <t>As described in this document, each SFP route is identified in the
          service function overlay network by an RD and an SPI.  The SPI is unique within a single
          VPN instance supported by the underlay network.</t>
        <t>The SFPR advertisement comprises:
        </t>
        <ul spacing="normal">
          <li>An RT as described in <xref target="rt" format="default"/>.</li>
          <li>
            <t>A tuple that identifies the SFPR.
            </t>
            <ul spacing="normal">
              <li>An RD that identifies an advertisement of an SFPR.</li>
              <li>The SPI that uniquely identifies this path within the VPN instance distinguished
                     by the RD.  This SPI also appears in the NSH.</li>
            </ul>
          </li>
          <li>A series of SIs.  Each SI is used in the context of a particular SPI and
               identifies one or more SFs (distinguished by their SFTs). For
	       each SF, it identifies a set of
               SFIs that instantiate the SF.  The values of the SI indicate the order in which the
               SFs are to be executed in the SFP that is represented by the SPI.</li>
          <li>The SI is used in the NSH to identify the entries in the SFP.  Note that the SI values
               have meaning only relative to a specific path.  They have no semantic other than to indicate
               the order of SFs within the path and are assumed to be monotonically
               decreasing from the start to the end of the path <xref target="RFC8300" format="default"/>.</li>
          <li>
            <t>Each SI is associated with a set of one or more SFIs
               that can be used to provide the indexed SF within the path.  Each member of
               the set comprises:
            </t>
            <ul spacing="normal">
              <li>The RD used in an SFIR advertisement of the SFI.</li>
              <li>The SFT that indicates the type of function as used in the same SFIR advertisement
                     of the SFI.</li>
            </ul>
          </li>
        </ul>
        <t>This may be summarized as follows, where the notations "SFPR-RD" and "SFIR-RD" are used
          to distinguish the two different RDs, and where "*" indicates a multiplier:
        </t>
        <artwork>
   RT, {SFPR-RD, SPI}, m * {SI, {n * {SFT, p * SFIR-RD} } }
          </artwork>
	
        <t>Where:
        </t>
	
        <dl>
          <dt>RT:</dt><dd> Route Target</dd>
          <dt>SFPR-RD:</dt><dd>The Route Descriptor of the SFPR advertisement</dd>
          <dt>SPI:</dt><dd>Service Path Identifier used in the NSH</dd>
          <dt>m:</dt><dd>The number of hops in the SFP</dd>
          <dt>n:</dt><dd>The number of choices of SFT for a specific hop</dd>
          <dt>p:</dt><dd>The number of choices of SFI
	  for a given SFT in a specific hop</dd>
          <dt>SI:</dt><dd>Service Index used in the NSH to indicate a specific hop</dd>
          <dt>SFT:</dt><dd>The Service Function Type used in the same advertisement of the SFIR
	</dd>
          <dt>SFIR-RD:</dt><dd>The Route Descriptor used in an advertisement of the SFIR</dd>
        </dl>
        <t>That is, there can be multiple SFTs at a given hop, as described in <xref target="selection" format="default"/>.</t>
        <t>Note that the values of SI are from the set {255, ..., 1} and are monotonically decreasing
          within the SFP.  SIs <bcp14>MUST</bcp14> appear in order within the SFPR (i.e., monotonically decreasing)
          and <bcp14>MUST NOT</bcp14> appear more than once.  Gaps <bcp14>MAY</bcp14> appear in the sequence, as described in
          <xref target="lacunae" format="default"/>.  Malformed SFPRs <bcp14>MUST</bcp14> be discarded and <bcp14>MUST</bcp14> cause any
          previous instance of the SFPR (same SFPR-RD and SPI) to be discarded.</t>
        <t>Note that if the SFIR-RD list in an SFT TLV contains one or more SFIR Pool Identifiers, then
          in the above expression, "p" is the sum of the number of individual SFIR-RD values
          and the sum for each SFIR Pool Identifier of the number of SFIRs advertised with that SFIR Pool
          Identifier.  In other words, the list of SFIR-RD values is effectively expanded to include the SFIR-RD
          of each SFIR advertised with each SFIR Pool Identifier in the SFIR-RD list.</t>
        <t>The choice of SFI is explained further in <xref target="selection" format="default"/>.  Note that an SFIR-RD
          value of zero has special meaning, as described in that section.</t>
      </section>
      <section anchor="classy" numbered="true" toc="default">
        <name>Classifier Operation</name>
        <t>As shown in <xref target="SFCarch" format="default"/>, the classifier is a component that is used to assign
           packets to an SFP.</t>
        <t>The classifier is responsible for determining to which packet flow a packet belongs.  The
           mechanism it uses to achieve that classification is out of the scope of this document but might
           include inspection of the packet header.  The classifier has been instructed (by the controller
           or through some other configuration mechanism -- see <xref target="fspecclassy" format="default"/>) which flows
           are to be assigned to which SFPs, and so it can impose an NSH on each packet and initialize the
           NSH with the SPI of the selected SFP and the SI of its first hop.</t>
        <t>Note that instructions delivered to the classifier may include information about the metadata
           to encode (and the format for that encoding) on packets that are classified by the classifier
           to a particular SFP.  As mentioned in <xref target="ctrlover" format="default"/>, this corresponds to the
           fifth element of control plane functionality described in <xref target="RFC7665" format="default"/>.  Such
           instructions fall outside the scope of this specification (but
	   see <xref target="fspecclassy" format="default"/>),
           as do instructions to other service function chaining elements on how to interpret metadata (as described in the
           sixth element of control plane functionality described in <xref target="RFC7665" format="default"/>).</t>
      </section>
      <section anchor="SFF" numbered="true" toc="default">
        <name>Service Function Forwarder Operation</name>
        <t>Each packet sent to an SFF is transmitted encapsulated in an NSH.  The NSH includes an SPI
          and SI: the SPI indicates the SFPR advertisement that announced the SFP;
          the tuple SPI/SI indicates a specific hop in a specific path and maps to the RD/SFT of a
          particular SFIR advertisement.</t>
        <t>When an SFF gets an SFPR advertisement, it will first determine whether to import the route
          by examining the RT.  If the SFPR is imported, the SFF then determines whether it is on the
          SFP by looking for its own SFIR-RDs or any SFIR-RD with value zero in the SFPR.  For each
          occurrence in the SFP, the SFF creates forwarding state for incoming packets and forwarding
          state for outgoing packets that have been processed by the specified SFI.</t>
        <t>The SFF creates local forwarding state for packets that it receives from other SFFs.  This
          state makes the association between the SPI/SI in the NSH of the received packet and one or
          more specific local SFIs, as identified by the SFIR-RD/SFT.  If there are multiple local SFIs
          that match, this is because a single advertisement was made for a set of equivalent SFIs, and
          the SFF may use local policy (such as load balancing) to determine to which SFI to forward a
          received packet.</t>
        <t>The SFF also creates next-hop forwarding state for packets received back from the local SFI
          that need to be forwarded to the next hop in the SFP.  There may be a choice of next hops,
          as described in <xref target="SFPR" format="default"/>.  The SFF could install forwarding state for all
          potential next hops or it could choose to only install forwarding state for a subset of the
          potential next hops.  If a choice is made, then it will be as described in
          <xref target="selection" format="default"/>.</t>
        <t>The installed forwarding state may change over time, reacting to changes in the underlay network
          and the availability of particular SFIs.  Note that the forwarding state describes how one SFF
          sends packets to another SFF, but not how those packets are routed through the underlay network.
          SFFs may be connected by tunnels across the underlay, or packets may be sent addressed to the
          next SFF and routed through the underlay.  In any case, transmission across the underlay requires
          encapsulation of packets with a header for transport in the underlay network.</t>
        <t>Note that SFFs only create and store forwarding state for the SFPs on which they are included.
          They do not retain state for all SFPs advertised.</t>
        <t>An SFF may also install forwarding state to support looping, jumping, and branching.
          The protocol mechanism for explicit control of looping, jumping, and
          branching uses a specific reserved SFT value at a given hop of an SFPR and is described in
          <xref target="changeseq" format="default"/>.</t>
        <section anchor="lacunae" numbered="true" toc="default">
          <name>Processing with "Gaps" in the SI Sequence</name>
          <t>The behavior of an SF, as described in <xref target="RFC8300" format="default"/>, is to decrement
             the value of the "SI" field in the NSH by one before returning a packet to the local SFF for
             further processing.  This means that there is a good reason to assume that the SFP is
             composed of a series of SFs, each indicated by an SI value one less than the previous.</t>
          <t>However,  there is an advantage to having nonsuccessive SIs in an SPI.  Consider the case
             where an SPI needs to be modified by the insertion or removal of an SF.  In the latter case,
             this would lead to a "gap" in the sequence of SIs, and in the former case, this could only
             be achieved if a gap already existed into which the new SF with its new SI value could be
             inserted.  Otherwise, all "downstream" SFs would need to be renumbered.</t>
          <t>Now, of course, such renumbering could be performed, but it would lead to a significant
             disruption to the SFC as all the SFFs along the SFP were "reprogrammed".  Thus, to achieve
             dynamic modification of an SFP (and even in-service modification), it is desirable to be
             able to make these modifications without changing the SIs of the elements that were
             present before the modification.  This will produce much more consistent/predictable
             behavior during the convergence period, where otherwise the change would need to be
             fully propagated.</t>
          <t>Another approach says that any change to an SFP simply creates a new SFP that can be
             assigned a new SPI.  All that would be needed would be to give a new instruction to the
             classifier, and traffic would be switched to the new SFP that contains the new set of SFs.
             This approach is practical but neglects to consider that the SFP may be referenced by
             other SFPs (through "branch" instructions) and used by many classifiers.  In those cases,
             the corresponding configuration resulting from a change in SPI may have wide ripples and
             create scope for errors that are hard to trace.</t>
          <t>Therefore, while this document requires that the SI values in an SFP are monotonically decreasing,
             it makes no assumption that the SI values are sequential.  Configuration tools may apply
             that rule, but they are not required to.  To support this, an SFF <bcp14>SHOULD</bcp14> process as follows
             when it receives a packet:
          </t>
          <ul spacing="normal">
            <li>If the SI indicates a known entry in the SFP, the SFF <bcp14>MUST</bcp14> process the packet as
                   normal, looking up the SI and determining to which local SFI to deliver the packet.</li>
            <li>If the SI does not match an entry in the SFP, the SFF <bcp14>MUST</bcp14> reduce the SI value to the
                   next (smaller) value present in the SFP and process the packet using that SI.</li>
            <li>If there is no smaller SI (i.e., if the end of the SFP has been reached), the SFF <bcp14>MUST</bcp14>
                   treat the SI value as not valid, as described in <xref target="RFC8300" format="default"/>.</li>
          </ul>
          <t>
             This makes the behavior described in this document a superset of the function in
             <xref target="RFC8300" format="default"/>.  That is, an implementation that strictly follows RFC 8300 in
             performing SI decrements in units of one is perfectly in line with the mechanisms
             defined in this document.</t>
          <t>SFF implementations <bcp14>MAY</bcp14> choose to only support contiguous SI values in an SFP.  Such an
             implementation will not support receiving an SI value that is not present in the SFP and
             will discard the packets as described in <xref target="RFC8300" format="default"/>.</t>
        </section>
      </section>
    </section>
    <section anchor="selection" numbered="true" toc="default">
      <name>Selection within Service Function Paths</name>
      <t>As described in <xref target="overview" format="default"/>, the SPI/SI in the NSH passed back from an SFI to
       the SFF may leave the SFF with a choice of next-hop SFTs and a choice of SFIs for each SFT.
       That is, the SPI indicates an SFPR, and the SI indicates an entry in that SFPR.  Each entry in
       an SFPR is a set of one or more SFT/SFIR-RD pairs.  The SFF <bcp14>MUST</bcp14> choose one of these, identify
       the SFF that supports the chosen SFI, and send the packet to that next-hop SFF.</t>
      <t>The choice be may offered for load balancing across multiple SFIs, or for discrimination between
       different actions necessary at a specific hop in the SFP.  Different SFT values may exist at
       a given hop in an SFP to support several cases:
      </t>
      <ul spacing="normal">
        <li>There may be multiple instances of similar service functions that are distinguished by
            different SFT values.  For example, firewalls made by vendor A and vendor B may need to
            be identified by different SFT values because, while they have similar functionality, their
            behavior is not identical.  Then, some SFPs may limit the choice of SF at a given hop by
            specifying the SFT for vendor A, but other SFPs might not need to control which vendor's
            SF is used and so can indicate that either SFT can be used.</li>
        <li>There may be an obvious branch needed in an SFP, such as the processing after a firewall
            where admitted packets continue along the SFP, but suspect packets are diverted to a
            "penalty box".  In this case, the next hop in the SFP will be indicated with two
            different SFT values.</li>
      </ul>
      <t>In the typical case, the SFF chooses a next-hop SFF by looking at the set of all SFFs that
       support the SFs identified by the SI (that set having been advertised in individual SFIR
       advertisements), finding the one or more that are "nearest" in the underlay network, and
       choosing between next-hop SFFs using its own load-balancing algorithm.</t>
      <t>An SFI may influence this choice process by passing additional information back, along
       with the packet and NSH.  This information may influence local policy
       at the SFF to either cause it to favor a next-hop SFF (perhaps selecting one
       that is not nearest in the underlay) or influence the load-balancing algorithm.</t>
      <t>This selection applies to the normal case but also applies in the case of looping,
       jumping, and branching (see <xref target="looping" format="default"/>).</t>

      <t>Suppose an SFF in a particular service function overlay network (identified by a particular import
       RT, RT-z) needs to forward an NSH-encapsulated packet whose SPI is SPI-x and whose SI is SI-y.
       It does the following:

      </t>
      <ol spacing="normal" type="1"><li>It looks for an installed SFPR that carries RT-z and has SPI-x in its NLRI.
             If there is none, then such packets cannot be forwarded.</li>
        <li>From the SFP attribute of that SFPR, it finds the Hop TLV with SI value set to SI-y.
             If there is no such Hop TLV, then such packets cannot be forwarded.</li>
        <li>
          <t>It then finds the "relevant" set of SFIRs by going through the list of SFT TLVs
             contained in the Hop TLV as follows:
          </t>
          <ol spacing="normal" type="A"><li>An SFIR is relevant if it carries RT-z, the SFT in its NLRI matches
                   the SFT value in one of the SFT TLVs, and the RD value in its NLRI matches
                   an entry in the list of SFIR-RDs in that SFT TLV.</li>
            <li>If an entry in the SFIR-RD list of an SFT TLV contains the value zero, then
                   an SFIR is relevant if it carries RT-z and the SFT in its NLRI matches
                   the SFT value in that SFT TLV.  That is, any SFIR in the service function
                   overlay network defined by RT-z and with the correct SFT is relevant.</li>
            <li>If a pool identifier is in use, then an SFIR is relevant if it is a member of
                   the pool.</li>
          </ol>
        </li>
      </ol>
      <t>Each of the relevant SFIRs identifies a single SFI and contains a tunnel encapsulation
       attribute that specifies how to send a packet to that SFI.  For a particular packet, the
       SFF chooses a particular SFI from the set of relevant SFIRs.  This choice is made according
       to local policy.</t>
      <t>A typical policy might be to figure out the set of SFIs that are closest and load balance
       among them.  But this is not the only possible policy.</t>
      <t>Thus, at any point in time when an SFF selects its next hop, it chooses from the intersection
       of the set of next-hop RDs contained in the SFPR and the RDs contained in the SFF's local set of
       SFIRs (i.e., according to the determination of "relevance", above).  If the intersection is
       null, the SFPR is unusable.  Similarly, when this condition applies on the controller that originated
       the SFPR, it <bcp14>SHOULD</bcp14> either withdraw the SFPR or re-advertise it with a new set of RDs for the affected
       hop.</t>
    </section>
    <section anchor="looping" numbered="true" toc="default">
      <name>Looping, Jumping, and Branching</name>
      <t>As described in <xref target="overview" format="default"/>, an SFI or an SFF may cause a packet to
       "loop back" to a previous SF on a path in order that a sequence of functions may be
       re-executed.  This is simply achieved by replacing the SI in the NSH with a higher value,
       instead of decreasing it as would normally be the case, to determine the next hop in the
       path.</t>
      <t><xref target="overview" format="default"/> also describes how an SFI or SFF may cause a packet to
       "jump forward" to an SF on a path that is not the immediate next SF in the SFP.  This
       is simply achieved by replacing the SI in the NSH with a lower value than would be
       achieved by decreasing it by the normal amount.</t>
      <t>A more complex option to move packets from one SFP to another is described in
       <xref target="RFC8300" format="default"/> and <xref target="overview"
       format="default"/>, where it is termed
       "branching".  This mechanism allows an SFI or SFF to make a choice of downstream
       treatments for packets based on local policy and the output of the local SF.  Branching is
       achieved by changing the SPI in the NSH to indicate the new path and setting the SI to
       indicate the point in the path at which the packets enter.</t>
      <t>Note that the NSH does not include a marker to indicate whether a specific packet has
       been around a loop before.  Therefore, the use of NSH metadata <xref target="RFC8300" format="default"/>
       may be required in order to prevent infinite loops.</t>
      <section anchor="changeseq" numbered="true" toc="default">
        <name>Protocol Control of Looping, Jumping, and Branching</name>
        <t>If the SFT value in an SFT TLV in an SFPR has the special-purpose SFT value "Change
          Sequence" (see <xref target="iana" format="default"/>), then this is an indication that the SFF may
          make a loop, jump, or branch according to local policy and information returned by
          the local SFI.</t>
        <t>In this case, the SPI and SI of the next hop are encoded in the eight bytes of an entry
          in the SFIR-RD list as follows:
        </t>
        <ul empty="true" spacing="normal">
          <li>3 bytes SPI</li>
          <li>1 byte SI</li>
          <li>4 bytes Reserved (<bcp14>SHOULD</bcp14> be set to zero and ignored)</li>
        </ul>
        <t>If the SI in this encoding is not part of the SFPR indicated by the SPI in this
          encoding, then this is an explicit error that <bcp14>SHOULD</bcp14> be detected by the SFF when it
          parses the SFPR.  The SFPR <bcp14>SHOULD NOT</bcp14> cause any forwarding state to be installed in
          the SFF, and packets received with the SPI that indicates this SFPR <bcp14>SHOULD</bcp14> be silently
          discarded.</t>
        <t>If the SPI in this encoding is unknown, the SFF <bcp14>SHOULD NOT</bcp14> install any forwarding state
          for this SFPR but <bcp14>MAY</bcp14> hold the SFPR pending receipt of another SFPR that does use the
          encoded SPI.</t>

        <t>If the SPI matches the current SPI for the path, this is a loop or jump.  In this case,
          if the SI is greater than or equal to the current SI, it is a loop.  If the SPI matches and the SI
          is less than the next SI, it is a jump.</t>
        <t>If the SPI indicates another path, this is a branch, and the SI indicates the point at
          which to enter that path.</t>
        <t>The Change Sequence SFT is just another SFT that may appear in a set of SFI/SFT tuples
          within an SI and is selected as described in <xref target="selection" format="default"/>.</t>
        <t>Note that special-purpose SFTs <bcp14>MUST NOT</bcp14> be advertised in SFIRs.  If such an SFIR is
          received, it <bcp14>SHOULD</bcp14> be ignored.</t>
      </section>
      <section anchor="implications" numbered="true" toc="default">
        <name>Implications for Forwarding State</name>
        <t>Support for looping and jumping requires that the SFF has forwarding state established
        to an SFF that provides access to an instance of the appropriate SF.

	This means
          that the SFF must have seen the relevant SFIR advertisements and mush have known that it needed to
          create the forwarding state.  This is a matter of local configuration and implementation;
          for example, an implementation could be configured to install forwarding state for specific
          looping/jumping.</t>
        <t>Support for branching requires that the SFF has forwarding state established to an SFF that
          provides access to an instance of the appropriate entry SF on the other SFP.  This means
          that the SFF must have seen the relevant SFIR and SFPR advertisements and known that it
          needed to create the forwarding state.  This is a matter of local configuration and
          implementation; for example, an implementation could be configured to install forwarding
          state for specific branching (identified by SPI and SI).</t>
      </section>
    </section>
    <section anchor="advanced" numbered="true" toc="default">
      <name>Advanced Topics</name>
      <t>This section highlights several advanced topics introduced elsewhere in this document.</t>
      <section anchor="correlation" numbered="true" toc="default">
        <name>Correlating Service Function Path Instances</name>
        <t>It is often useful to create bidirectional SFPs to enable packet
	flows to traverse the same
         set of SFs, but in the reverse order.  However, packets on SFPs in the data plane (per
         <xref target="RFC8300" format="default"/>) do not contain a direction indicator, so each direction
         must use a different SPI.</t>
        <t>As described in <xref target="assoctlv" format="default"/>, an SFPR can contain one or more correlators
        encoded in Association TLVs.
	If the Association Type indicates "Bidirectional SFP", then
         the SFP advertised in the SFPR is one direction of a bidirectional pair of SFPs, where the
         other in the pair is advertised in the SFPR with RD as carried in the "Associated SFPR-RD"
         field of the Association TLV.  The SPI carried in the "Associated SPI" field of the
         Association TLV provides a cross-check against the SPI advertised in the SFPR with
         RD as carried in the "Associated SFPR-RD" field of the Association TLV.</t>
        <t>As noted in <xref target="assoctlv" format="default"/>, when SFPRs reference each other, one SFPR advertisement
         will be received before the other.  Therefore, processing of an association will require
         that the first SFPR not be rejected simply because the Associated SFPR-RD it carries is
         unknown.  However, the SFP defined by the first SFPR is valid and <bcp14>SHOULD</bcp14> be available for
         use as a unidirectional SFP, even in the absence of an advertisement of its partner.</t>
        <t>Furthermore, in error cases where SFPR-a associates with SFPR-b, but SFPR-b associates
         with SFPR-c such that a bidirectional pair of SFPs cannot be formed, the individual SFPs
         are still valid and <bcp14>SHOULD</bcp14> be available for use as unidirectional SFPs.  An implementation
         <bcp14>SHOULD</bcp14> log this situation, because it represents a controller error.</t>
        <t>Usage of a bidirectional SFP may be programmed into the classifiers by the controller.
         Alternatively, a classifier may look at incoming packets on a bidirectional packet flow,
         extract the SPI from the received NSH, and look up the SFPR to find the reverse-direction
         SFP to use when it sends packets.</t>
        <t>See <xref target="example" format="default"/> for an example of how this works.</t>
      </section>
      <section anchor="stateful" numbered="true" toc="default">
        <name>Considerations for Stateful Service Functions</name>
        <t>Some service functions are stateful.  That means that they build and maintain state derived
         from configuration or the packet flows that they handle.  In such cases, it can be
         important or necessary that all packets from a flow continue to traverse the same instance
         of a service function so that the state can be leveraged and does not need to be regenerated.</t>
        <t>In the case of bidirectional SFPs, it may be necessary to traverse the same instances of a
         stateful service function in both directions.  A firewall is a good example of such a service
         function.</t>
        <t>This issue becomes a concern where there are multiple parallel instances of a service function
         and a determination of which one to use could normally be left to the SFF as a load-balancing
         or local-policy choice.</t>
        <t>For the forward-direction SFP, the concern is that the same choice of SF is made
         for all packets of a flow under normal network conditions.  It may be possible to guarantee
         that the load-balancing functions applied in the SFFs are stable and repeatable, but a controller
         that constructs SFPs might not want to trust to this.  The controller can, in these cases, build
         a number of more specific SFPs, each traversing a specific instance of the stateful SFs.  In this
         case, the load-balancing choice can be left up to the classifier.  Thus, the classifier selects
         which instance of a stateful SF is used by a particular flow by selecting the SFP that the flow
         uses.</t>
        <t>For bidirectional SFPs where the same instance of a stateful SF must be traversed in both
         directions, it is not enough to leave the choice of SFI as a local choice,
         even if the load balancing is stable, because coordination would be required between the decision
         points in the forward and reverse directions, and this may be hard to achieve in all cases except
         where it is the same SFF that makes the choice in both directions.</t>
        <t>Note that this approach necessarily increases the amount of SFP state in the network (i.e., there
         are more SFPs).  It is possible to mitigate this effect by careful construction of SFPs built
         from a concatenation of other SFPs.</t>
        <t><xref target="examplestate" format="default"/> includes some simple examples of SFPs for stateful SFs.</t>
      </section>
      <section anchor="private" numbered="true" toc="default">
        <name>VPN Considerations and Private Service Functions</name>
        <t>Likely deployments include reserving specific instances of SFs for specific
         customers or allowing customers to deploy their own SFs within the network.
         Building SFs in such environments requires that suitable identifiers be used
         to ensure that SFFs distinguish which SFIs can be used and which cannot.</t>

        <t>This problem is similar to a problem in the way that VPNs are supported and is solved in a similar way.  The "RT"
         field is used to indicate a set of SFs from which all choices must be made.</t>
      </section>
      <section anchor="fspecclassy" numbered="true" toc="default">
        <name>Flow Specification for SFC Classifiers</name>
        <t><xref target="RFC8955" format="default"/> defines a set of BGP
         routes that can be used to identify the packets in a given flow using fields in the header of
         each packet, and a set of actions -- encoded as Extended Communities -- that can be used to
         disposition those packets.  This document enables the use of these mechanisms by SFC
         classifiers by defining a new action Extended Community called "Flow Specification for SFC Classifiers",
         identified by the value 0x0d.  Note that implementation of this section of this specification will be
         controllers or classifiers communicating with each other directly for the purpose of instructing the
         classifier how to place packets onto an SFP.  So that the implementation of classifiers can be
         kept simple, and to avoid the confusion between the purposes of different Extended Communities, a
         controller <bcp14>MUST NOT</bcp14> include other action Extended Communities at the same time as a "Flow Specification
         for SFC Classifiers" Extended Community. A "Flow Specification for SFC Classifiers" Traffic Filtering Action
         Extended Community advertised with any other Traffic Filtering Action Extended Community <bcp14>MUST</bcp14> be treated as
         malformed in line with <xref target="RFC8955" format="default"/> and result in the flow-specification
         UPDATE message being handled as "treat-as-withdraw", according to
	<xref target="RFC7606" section="2" sectionFormat="comma"/>.</t>
        <t>To put the flow specification into context, when multiple service function chaining overlays are present in one
         network, each FlowSpec update <bcp14>MUST</bcp14> be tagged with the route target of the overlay or VPN
         network for which it is intended.</t>
        <t>This Extended Community is encoded as an 8-octet value, as shown in <xref target="fspecclassyfig" format="default"/>.</t>
        <figure anchor="fspecclassyfig">
          <name>The Format of the Flow Specification for SFC Classifiers Extended Community</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[   
                      1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Type=0x80     | Sub-Type=0x0d |  SPI                          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  SPI  (cont.) |   SI          |  SFT                          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          ]]></artwork>
        </figure>
        <t>The Extended Community contains the Service Path Identifier (SPI), Service Index (SI), and
         Service Function Type (SFT), as defined elsewhere in this document.  Thus, each action extended
         community defines the entry point (not necessarily the first hop) into a specific SFP.  This allows, for example, different flows to enter the same SFP at different points.</t>
        <t>Note that, according to <xref target="RFC8955" format="default"/>, a given flow-specification
         update may include multiple of these action Extended Communities.  If a given action extended
         community does not contain an installed SFPR with the specified {SPI, SI, SFT}, it <bcp14>MUST NOT</bcp14> be
         used for dispositioning the packets of the specified flow.</t>
        <t>The normal case of packet classification for service function chaining will see a packet enter the SFP at its first
         hop.  In this case, the SI in the Extended Community is superfluous, and the SFT may also be
         unnecessary.  To allow these cases to be handled, a special meaning is assigned to an SI of zero (not a valid value) and an SFT of zero (a reserved value in the registry -- see
         <xref target="SFTreg" format="default"/>).
        </t>
        <ul spacing="normal">
          <li>If an SFC Classifiers Extended Community is received with SI = 0, then it means that the
              first hop of the SFP indicated by the SPI <bcp14>MUST</bcp14> be used.</li>
          <li>
            <t>If an SFC Classifiers Extended Community is received with SFT = 0, then there are two
              subcases:
            </t>
            <ul spacing="normal">
              <li>If there is a choice of SFT in the hop indicated by the value of the SI (including
                    SI = 0), then SFT = 0 means there is a free choice of
	      which SFT to use, according to local policy).</li>
              <li>If there is no choice of SFT in the hop indicated by the value of SI, then SFT = 0
                    means that the value of the SFT at that hop, as indicated in the SFPR for the
                    indicated SPI, <bcp14>MUST</bcp14> be used.</li>
            </ul>
          </li>
        </ul>
        <t>One of the filters that the flow specification may describe is the VPN to which the traffic belongs.
         Additionally, as noted above, to put the indicated SPI into context when multiple SFC overlays are
         present in one network, each FlowSpec update <bcp14>MUST</bcp14> be tagged with the route target of the
         overlay or VPN network for which it is intended.</t>
        <t>Note that future extensions might be made to the Flow Specification for SFC Classifiers Extended Community
         to provide instruction to the classifier about what metadata to add to packets that it classifies
         for forwarding on a specific SFP; however, that is outside the scope of this document.</t>
      </section>
      <section anchor="representation" numbered="true" toc="default">
        <name>Choice of Data Plane SPI/SI Representation</name>
        <t>This document ties together the control and data planes of a service function chaining overlay network through the use
         of the SPI/SI that is nominally carried in the NSH of a given packet.  However, in order to handle
         situations in which the NSH is not ubiquitously deployed, it is also possible to use alternative
         data plane representations of the SPI/SI by carrying the identical semantics in other protocol fields,
         such as MPLS labels <xref target="RFC8595" format="default"/>.</t>
        <t>This document defines a new Sub-TLV for the tunnel encapsulation attribute <xref target="RFC9012" format="default"/>,
         the SPI/SI Representation Sub-TLV of type 16.  This Sub-TLV <bcp14>MAY</bcp14> be present in each Tunnel TLV contained
         in a tunnel encapsulation attribute when the attribute is carried by an SFIR.  The "Value" field of this
         Sub-TLV is a two-octet field of flags numbered counting from the most significant bit, each of which
         describes how the originating SFF expects to see the SPI/SI represented in the data plane for packets
         carried in the tunnels described by the Tunnel TLV.</t>
        <t>The following bits are defined by this document and are tracked in an IANA registry described in
         <xref target="IANAbits" format="default"/>:
        </t>
        <dl newline="false" spacing="normal">
          <dt>Bit 0:</dt>
          <dd>If this bit is set, the NSH is to be used to carry the SPI/SI in the data plane.</dd>
          <dt>Bit 1:</dt>
          <dd>If this bit is set, two labels in an MPLS label stack are to be used as described in
                                <xref target="MPLS-NSH" format="default"/>.</dd>
        </dl>
        <t>If a given Tunnel TLV does not contain an SPI/SI Representation Sub-TLV, then it <bcp14>MUST</bcp14> be processed as if
         such a Sub-TLV is present with Bit 0 set and no other bits set.  That is, the absence of the Sub-TLV
         <bcp14>SHALL</bcp14> be interpreted to mean that the NSH is to be used.</t>
        <t>If a given Tunnel TLV contains an SPI/SI Representation Sub-TLV
	with a "Value" field that has no flag set, then
         the tunnel indicated by the Tunnel TLV <bcp14>MUST NOT</bcp14> be used for forwarding SFC packets.  If a given Tunnel TLV
         contains an SPI/SI Representation Sub-TLV with both bit 0 and bit 1 set, then the tunnel indicated by the
         Tunnel TLV <bcp14>MUST NOT</bcp14> be used for forwarding SFC
	 packets.  The meaning and rules for the presence of other bits
         is to be defined in future documents, but implementations of this specification <bcp14>MUST</bcp14> set other bits to
         zero and ignore them on receipt.</t>
        <t>If a given Tunnel TLV contains more than one SPI/SI Representation Sub-TLV, then the first one <bcp14>MUST</bcp14> be
         considered and subsequent instances <bcp14>MUST</bcp14> be ignored.</t>
        <t>Note that the MPLS representation of the logical NSH may be used even if the tunnel is not an MPLS tunnel.
         Conversely, MPLS tunnels may be used to carry other encodings of the logical NSH (specifically, the NSH
         itself).  It is a requirement that both ends of a tunnel over the underlay network know that the tunnel is
         used for service function chaining and know what form of NSH representation is used.  The signaling mechanism described here
         allows coordination of this information.</t>
        <section anchor="MPLS-NSH" numbered="true" toc="default">
          <name>MPLS Representation of the SPI/SI</name>
          <t>If bit 1 is set in the SPI/SI Representation Sub-TLV, then labels in the MPLS label stack are
            used to indicate SFC forwarding and processing instructions to achieve the semantics of a logical NSH.
            The label stack is encoded as shown in <xref target="RFC8595" format="default"/>.</t>
        </section>
      </section>
      <section anchor="swapOp" numbered="true" toc="default">
        <name>MPLS Label Swapping/Stacking Operation</name>
        <t>When a classifier constructs an MPLS label stack for an SFP, it starts with that SFP's last hop.  If the
         last hop requires an {SPI, SI} label pair for label swapping, it pushes the SI (set to the SI value of the
         last hop) and the SFP's SPI onto the MPLS label stack.  If the last hop requires a {context label, SFI
         label} label pair for label stacking, it selects a specific SFIR and pushes that SFIR's SFI label and
         context label onto the MPLS label stack.</t>
        <t>The classifier then moves sequentially back through the SFP one hop at a time.  For each hop, if the hop
         requires an {SPI, SI} and there is an {SPI, SI} at the top of the MPLS label stack, the SI is set to the
         SI value of the current hop.  If there is not an {SPI, SI} at the top of the MPLS label stack, it pushes
         the SI (set to the SI value of the current hop) and the SFP's SPI onto the MPLS label stack.</t>
        <t>If the hop requires a {context label, SFI label}, it selects a specific SFIR and pushes that SFIR's
         SFI label and context label onto the MPLS label stack.</t>
      </section>
      <section anchor="mpls-encaps" numbered="true" toc="default">
        <name>Support for MPLS-Encapsulated NSH Packets</name>
        <t><xref target="RFC8596" format="default"/> describes how to transport SFC packets using the NSH 
        over an MPLS transport network.

	  Signaling that this approach is in use is supported by this document
  as follows:</t>
<ul spacing="normal">
  <li>A "BGP Tunnel Encapsulation Attribute" Sub-TLV is included with the
    codepoint 10 (representing "MPLS Label Stack") from the "BGP Tunnel
    Encapsulation Attribute Sub-TLVs" registry defined in
    <xref target="RFC9012" format="default"/>.</li>

  <li>An "SFP Traversal With MPLS Label Stack" TLV is included containing
    an "SPI/SI Representation" Sub-TLV with bit 0 set and bit 1 cleared.</li></ul>
        <t>In this case, the MPLS label stack constructed by the SFF to forward a packet to the next SFF on the
          SFP will consist of the labels needed to reach that SFF, and if label stacking is used, it will also
          include the labels advertised in the MPLS Label Stack Sub-TLV and the labels remaining in the stack
          needed to traverse the remainder of the SFP.</t>
      </section>
    </section>
    <section anchor="example" numbered="true" toc="default">
      <name>Examples</name>
      <t>Most of the examples in this section use IPv4 addressing.  But there is nothing special about
       IPv4 in the mechanisms described in this document, and they are equally applicable to IPv6.  A
       few examples using IPv6 addressing are provided in <xref target="v6samples" format="default"/>.</t>

      <t>Assume we have a service function overlay network with four SFFs (SFF1, SFF2, SFF3, and SFF4).
       The SFFs have addresses in the underlay network as follows:</t>
      <sourcecode><![CDATA[          
   SFF1 192.0.2.1
   SFF2 192.0.2.2
   SFF3 192.0.2.3
   SFF4 192.0.2.4
   ]]></sourcecode>
      <t>Each SFF provides access to some SFIs from the four SFTs, SFT=41, SFT=42,
       SFT=43, and SFT=44, as follows:</t>
      <sourcecode><![CDATA[           
   SFF1 SFT=41 and SFT=42
   SFF2 SFT=41 and SFT=43
   SFF3 SFT=42 and SFT=44
   SFF4 SFT=43 and SFT=44
   ]]></sourcecode>
      <t>The service function network also contains a controller with address 198.51.100.1.</t>
      <t>This example service function overlay network is shown in <xref target="examplefig" format="default"/>.</t>
      <figure anchor="examplefig">
        <name>Example Service Function Overlay Network</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[          
       --------------
      |  Controller  |
      | 198.51.100.1 |   ------     ------    ------     ------
       --------------   | SFI  |   | SFI  |  | SFI  |   | SFI  |
                        |SFT=41|   |SFT=42|  |SFT=41|   |SFT=43|
                         ------     ------    ------     ------
                              \     /              \     /
                             ---------            ---------
               ----------   |   SFF1  |          |   SFF2  |
   Packet --> |          |  |192.0.2.1|          |192.0.2.2|
   Flows  --> |Classifier|   ---------            ---------  -->Dest
              |          |                                   -->
               ----------    ---------            ---------
                            |   SFF3  |          |   SFF4  |
                            |192.0.2.3|          |192.0.2.4|
                             ---------            ---------
                              /     \              /     \
                         ------     ------    ------     ------
                        | SFI  |   | SFI  |  | SFI  |   | SFI  |
                        |SFT=42|   |SFT=44|  |SFT=43|   |SFT=44|
                         ------     ------    ------     ------           
			 ]]></artwork>
      </figure>
      <t>The SFFs advertise routes to the SFIs they support.  These advertisements
       contain RDs that are set according to the network operator's
       configuration model.  In all of these IPv4 examples, we use RDs of Type 1 such that the
       available six octets are partitioned as four octets for the IPv4 address of the advertising
       SFF, and two octets that are a local index of the SFI.  This scheme is chosen purely for
       convenience of documentation, and an operator is totally free to use any other scheme so
       long as it conforms to the definitions of SFIR and SFPR in Sections
       <xref target="sfiRoutes" format="counter"/> and
       <xref target="sfpRoutes" format="counter"/>.</t>
      <t>Thus, we see the following SFIRs advertised:</t>
      <sourcecode><![CDATA[
   RD = 192.0.2.1/1, SFT = 41
   RD = 192.0.2.1/2, SFT = 42
   RD = 192.0.2.2/1, SFT = 41
   RD = 192.0.2.2/2, SFT = 43
   RD = 192.0.2.3/7, SFT = 42
   RD = 192.0.2.3/8, SFT = 44
   RD = 192.0.2.4/5, SFT = 43
   RD = 192.0.2.4/6, SFT = 44
         ]]></sourcecode>
      <t>Note that the addressing used for communicating between SFFs is taken
       from the tunnel encapsulation attribute of the SFIR and not from the SFIR-RD.</t>
      <section anchor="exampleexplicit" numbered="true" toc="default">
        <name>Example Explicit SFP with No Choices</name>
        <t>Consider the following SFPR.</t>
        <sourcecode><![CDATA[
   SFP1:  RD = 198.51.100.1/101, SPI = 15,
          [SI = 255, SFT = 41, RD = 192.0.2.1/1],
          [SI = 250, SFT = 43, RD = 192.0.2.2/2]
          ]]></sourcecode>
        <t>The SFP consists of an SF of Type 41 located at SFF1, followed by an SF
          of Type 43 located at SFF2.  This path is fully explicit, and each SFF is
          offered no choice in forwarding packets along the path.</t>
        <t>SFF1 will receive packets on the path from the classifier and will identify the path
          from the SPI (15).  The initial SI will be 255, and so SFF1 will deliver the packets to the
          SFI for SFT 41.</t>
        <t>When the packets are returned to SFF1 by the SFI, the SI will be decreased to 250 for the next hop.
           SFF1 has no flexibility in the choice of SFF to support the next-hop SFI and will forward
           the packet to SFF2, which will send the packets to the SFI that supports SFT 43 before
           forwarding the packets to their destinations.</t>
      </section>
      <section anchor="examplechoice" numbered="true" toc="default">
        <name>Example SFP with Choice of SFIs</name>
        <sourcecode><![CDATA[         
   SFP2:  RD = 198.51.100.1/102, SPI = 16,
          [SI = 255, SFT = 41, RD = 192.0.2.1/1],
          [SI = 250, SFT = 43, {RD = 192.0.2.2/2,
                                RD = 192.0.2.4/5 } ]           
         ]]></sourcecode>
        <t>In this example, the path also consists of an SF of Type 41 located at SFF1, and this is
          followed by an SF of Type 43. However, in this case, the SI = 250 contains a choice between the
          SFI located at SFF2 and the SFI located at SFF4.</t>
        <t>SFF1 will receive packets on the path from the classifier and will identify the path
          from the SPI (16).  The initial SI will be 255, and so SFF1 will deliver the packets to the
          SFI for SFT 41.</t>
        <t>When the packets are returned to SFF1 by the SFI, the SI will be decreased to 250 for
           the next hop.  SFF1 now has a choice of next-hop SFFs to execute the next hop in the path.
           It can either forward packets to SFF2 or SFF4 to execute a function of Type 43.  It uses
           its local load-balancing algorithm to make this choice.  The chosen SFF will send the
           packets to the SFI that supports SFT 43 before forwarding the packets to their
           destinations.</t>
      </section>
      <section anchor="exampleopen" numbered="true" toc="default">
        <name>Example SFP with Open Choice of SFIs</name>
        <sourcecode><![CDATA[
   SFP3:  RD = 198.51.100.1/103, SPI = 17,
          [SI = 255, SFT = 41, RD = 192.0.2.1/1],
          [SI = 250, SFT = 44, RD = 0]
           ]]></sourcecode>
        <t>In this example, the path also consists of an SF of Type 41 located at SFF1, and this is
          followed by an SI with an RD of zero and SF of Type 44.  This means that a choice can be
          made between any SFF that supports an SFI of Type 44.</t>
        <t>SFF1 will receive packets on the path from the classifier and will identify the path
          from the SPI (17).  The initial SI will be 255, and so SFF1 will deliver the packets to the
          SFI for SFT 41.</t>
        <t>When the packets are returned to SFF1 by the SFI, the SI will be decreased to 250 for
           the next hop.  SFF1 now has a free choice of next-hop SFFs to execute the next hop in the
           path, selecting between all SFFs that support SFs of Type 44.  Looking at the SFIRs it
           has received, SFF1 knows that SF Type 44 is supported by SFF3 and SFF4.  SFF1 uses its
           local load-balancing algorithm to make this choice.  The chosen SFF will send the packets
           to the SFI that supports SFT 44 before forwarding the packets to their destinations.</t>
      </section>
      <section anchor="examplesft" numbered="true" toc="default">
        <name>Example SFP with Choice of SFTs</name>
        <sourcecode><![CDATA[
   SFP4:  RD = 198.51.100.1/104, SPI = 18,
          [SI = 255, SFT = 41, RD = 192.0.2.1/1],
          [SI = 250, {SFT = 43, RD = 192.0.2.2/2,
                      SFT = 44, RD = 192.0.2.3/8 } ]
         ]]></sourcecode>
        <t>This example provides a choice of SF type in the second hop in the path.  The SI of 250
          indicates a choice between SF Type 43 located at SF2 and SF Type 44 located at SF3.</t>
        <t>SFF1 will receive packets on the path from the classifier and will identify the path
          from the SPI (18).  The initial SI will be 255, and so SFF1 will deliver the packets to the
          SFI for SFT 41.</t>
        <t>When the packets are returned to SFF1 by the SFI, the SI will be decreased to 250 for
          the next hop.  SFF1 now has a free choice of next-hop SFFs to execute the next hop in the
          path, selecting between all SFFs that support an SF of Type 43 and
	  SFF3, which supports an
          SF of Type 44.  These may be completely different functions that are to be executed dependent
          on specific conditions, or they may be similar functions identified with different type
          identifiers (such as firewalls from different vendors).  SFF1 uses
	  its local policy and load-balancing algorithm to make this choice
	  and may use additional information passed back from
          the local SFI to help inform its selection.  The chosen SFF will send the packets to the SFI
          that supports the chosen SFT before forwarding the packets to their destinations.</t>
      </section>
      <section anchor="exampleco" numbered="true" toc="default">
        <name>Example Correlated Bidirectional SFPs</name>
        <sourcecode><![CDATA[
  SFP5:  RD = 198.51.100.1/105, SPI = 19,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/106, Assoc-SPI = 20,
         [SI = 255, SFT = 41, RD = 192.0.2.1/1],
         [SI = 250, SFT = 43, RD = 192.0.2.2/2]

  SFP6:  RD = 198.51.100.1/106, SPI = 20,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/105, Assoc-SPI = 19,
         [SI = 254, SFT = 43, RD = 192.0.2.2/2],
         [SI = 249, SFT = 41, RD = 192.0.2.1/1]
          ]]></sourcecode>
        <t>This example demonstrates correlation of two SFPs to form a bidirectional SFP, as
          described in <xref target="correlation" format="default"/>.</t>
        <t>Two SFPRs are advertised by the controller.  They have different SPIs (19 and 20),
          so they are known to be separate SFPs, but they both have Association TLVs with Association Type
          set to 1, indicating bidirectional SFPs.  Each has an "Associated SFPR-RD" field containing the value
          of the other SFPR-RD to correlate the two SFPs as a bidirectional pair.</t>
        <t>As can be seen from the SFPRs in this example, the paths are symmetric: the hops in
          SFP5 appear in the reverse order in SFP6.</t>
      </section>
      <section anchor="exampleass" numbered="true" toc="default">
        <name>Example Correlated Asymmetrical Bidirectional SFPs</name>
        <sourcecode><![CDATA[
  SFP7:  RD = 198.51.100.1/107, SPI = 21,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/108, Assoc-SPI = 22,
         [SI = 255, SFT = 41, RD = 192.0.2.1/1],
         [SI = 250, SFT = 43, RD = 192.0.2.2/2]

  SFP8:  RD = 198.51.100.1/108, SPI = 22,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/107, Assoc-SPI = 21,
         [SI = 254, SFT = 44, RD = 192.0.2.4/6],
         [SI = 249, SFT = 41, RD = 192.0.2.1/1]
           ]]></sourcecode>
        <t>Asymmetric bidirectional SFPs can also be created.  This example shows a pair of SFPs
          with distinct SPIs (21 and 22) that are correlated in the same way as in the example in
          <xref target="exampleco" format="default"/>.</t>
        <t>However, unlike in that example, the SFPs are different in each direction.  Both paths
          include a hop of SF Type 41, but SFP7 includes a hop of SF Type 43 supported at SFF2, while
          SFP8 includes a hop of SF Type 44 supported at SFF4.</t>
      </section>
      <section anchor="exampleloop" numbered="true" toc="default">
        <name>Example Looping in an SFP</name>
        <sourcecode><![CDATA[          
   SFP9:  RD = 198.51.100.1/109, SPI = 23,
          [SI = 255, SFT = 41, RD = 192.0.2.1/1],
          [SI = 250, SFT = 44, RD = 192.0.2.4/5],
          [SI = 245, {SFT = 1, RD = {SPI=23, SI=255, Rsv=0},
                      SFT = 42, RD = 192.0.2.3/7 } ]          
         ]]></sourcecode>
        <t>Looping and jumping are described in <xref target="looping" format="default"/>.  This example shows
          an SFP that contains an explicit loop-back instruction that is presented as a choice
          within an SFP hop.</t>
        <t>The first two hops in the path (SI = 255 and SI = 250) are normal.  That is, the packets
          will be delivered to SFF1 and SFF4 in turn for execution of SFs of Type 41 and 44,
          respectively.</t>
        <t>The third hop (SI = 245) presents SFF4 with a choice of next hop.  It can either forward
          the packets to SFF3 for an SF of Type 42 (the second choice) or it can loop back.</t>
        <t>The loop-back entry in the SFPR for SI = 245 is indicated by the special-purpose SFT value
          1 ("Change Sequence").  Within this hop, the RD is interpreted as encoding the SPI and SI
          of the next hop (see <xref target="changeseq" format="default"/>).
	  In this case, the SPI is 23, which
          indicates that this is a loop or branch, i.e., the next hop is on the same SFP.  The SI is
          set to 255; this is a higher number than the current SI (245), indicating a loop.</t>
        <t>SFF4 must make a choice between these two next hops. The packet
	will be either forwarded to SFF3 with the NSH SI decreased
	to 245 or looped back to SFF1 with the NSH SI reset to 255.
          This choice will be made according to local policy, information passed back by the local SFI,
          and details in the packets' metadata that are used to prevent infinite looping.</t>
      </section>
      <section anchor="examplebranch" numbered="true" toc="default">
        <name>Example Branching in an SFP</name>
        <sourcecode><![CDATA[
   SFP10:  RD = 198.51.100.1/110, SPI = 24,
          [SI = 254, SFT = 42, RD = 192.0.2.3/7],
          [SI = 249, SFT = 43, RD = 192.0.2.2/2]

   SFP11:  RD = 198.51.100.1/111, SPI = 25,
          [SI = 255, SFT = 41, RD = 192.0.2.1/1],
          [SI = 250, SFT = 1, RD = {SPI=24, SI=254, Rsv=0}]          
         ]]></sourcecode>
        <t>Branching follows a similar procedure to that for looping (and jumping), as shown in
          <xref target="exampleloop" format="default"/>. However, there are two SFPs involved.</t>
        <t>SFP10 shows a normal path with packets forwarded to SFF3 and SFF2 for execution of
          service functions of Type 42 and 43, respectively.</t>
        <t>SFP11 starts as normal (SFF1 for an SF of Type 41), but then SFF1 processes the
          next hop in the path and finds a "Change Sequence" special-purpose SFT.  The "SFIR-RD"
          field includes an SPI of 24, which indicates SFP10, not the current SFP.  The SI in the
          SFIR-RD is 254, so SFF1 knows that it must set the SPI/SI in the NSH to 24/254 and
          send the packets to the appropriate SFF, as advertised in the SFPR for SFP10 (that is,
          SFF3).</t>
      </section>
      <section anchor="examplestate" numbered="true" toc="default">
        <name>Examples of SFPs with Stateful Service Functions</name>
        <t>This section provides some examples to demonstrate establishing SFPs when there is a choice
          of service functions at a particular hop, and where consistency of choice is required in
          both directions.  The scenarios that give rise to this requirement are discussed in
          <xref target="stateful" format="default"/>.</t>
        <section anchor="stateegsff" numbered="true" toc="default">
          <name>Forward and Reverse Choice Made at the SFF</name>
          <t>Consider the topology shown in <xref target="egsfffig" format="default"/>.  There are three SFFs
             arranged neatly in a line, and the middle one (SFF2) supports three SFIs all of
             SFT 42.  These three instances can be used by SFF2 to load balance so that no
             one instance is swamped.</t>
          <figure anchor="egsfffig">
            <name>Example Where Choice Is Made at the SFF</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
                ------     ------   ------   ------    ------
               | SFI  |   | SFIa | | SFIb | | SFIc |  | SFI  |
               |SFT=41|   |SFT=42| |SFT=42| |SFT=42|  |SFT=43|
                ------     ------\  ------  /------    ------
                     \            \   |    /           /
                    ---------     ---------     ---------
      ----------   |   SFF1  |   |   SFF2  |   |   SFF3  |
 --> |          |..|192.0.2.1|...|192.0.2.2|...|192.0.2.3|-->
 --> |Classifier|   ---------     ---------     ---------
     |          |
      ----------
         ]]></artwork>
          </figure>
          <t>This leads to the following SFIRs being advertised.</t>
          <sourcecode><![CDATA[         
   RD = 192.0.2.1/11, SFT = 41
   RD = 192.0.2.2/11, SFT = 42  (for SFIa)
   RD = 192.0.2.2/12, SFT = 42  (for SFIb)
   RD = 192.0.2.2/13, SFT = 42  (for SFIc)
   RD = 192.0.2.3/11, SFT = 43           
         ]]></sourcecode>
          <t>The controller can create a single forward SFP (SFP12), giving SFF2 the choice
             of which SFI to use to provide a function of SFT 42, as follows.  The
             load-balancing choice between the three available SFIs is assumed to be
             within the capabilities of the SFF, and if the SFs are stateful, it is
             assumed that the SFF knows this and arranges load balancing in a stable,
             flow-dependent way.</t>
          <sourcecode><![CDATA[           
   SFP12:  RD = 198.51.100.1/112, SPI = 26,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/113, Assoc-SPI = 27,
          [SI = 255, SFT = 41, RD = 192.0.2.1/11],
          [SI = 254, SFT = 42, {RD = 192.0.2.2/11,
                                     192.0.2.2/12,
                                     192.0.2.2/13 }],
          [SI = 253, SFT = 43, RD = 192.0.2.3/11]
          ]]></sourcecode>
          <t>The reverse SFP (SFP13) in this case may also be created as shown below, using
            association with the forward SFP and giving the load-balancing choice to
            SFF2.  This is safe, even in the case that the SFs of Type 42 are stateful,
            because SFF2 is doing the load balancing in both directions and can apply
            the same algorithm to ensure that packets associated with the same flow use
            the same SFI regardless of the direction of travel.</t>
          <sourcecode><![CDATA[           
   SFP13:  RD = 198.51.100.1/113, SPI = 27,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/112, Assoc-SPI = 26,
          [SI = 255, SFT = 43, RD = 192.0.2.3/11],
          [SI = 254, SFT = 42, {RD = 192.0.2.2/11,
                                     192.0.2.2/12,
                                     192.0.2.2/13 }],
          [SI = 253, SFT = 41, RD = 192.0.2.1/11]           
         ]]></sourcecode>
          <t>How an SFF knows that an attached SFI is stateful is out of the scope of this
            document.  It is assumed that this will form part of the process by which
            SFIs are registered as local to SFFs.  <xref target="stateful" format="default"/> provides
            additional observations about the coordination of the use of stateful SFIs
            in the case of bidirectional SFPs.</t>
          <t>In general, the problems of load balancing and the selection of the same SFIs
            in both directions of a bidirectional SFP can be addressed by using sufficiently
            precisely specified SFPs (specifying the exact SFIs to use) and suitable
            programming of the classifiers at each end of the SFPs to make sure that the
            matching pair of SFPs are used.</t>
        </section>
        <section anchor="stateeg1pll" numbered="true" toc="default">
          <name>Parallel End-to-End SFPs with Shared SFF</name>
          <t>The mechanism described in <xref target="stateegsff" format="default"/> might not be desirable because of
            the functional assumptions it places on SFF2 to be able to load balance with suitable flow
            identification, stability, and equality in both directions.  Instead, it may be desirable
            to place the responsibility for flow classification in the classifier and let it determine
            load balancing with the implied choice of SFIs.</t>
          <t>Consider the network graph as shown in <xref target="egsfffig" format="default"/> and with the same set of
            SFIRs as listed in <xref target="stateegsff" format="default"/>.
	    In this case, the controller could specify
            three forward SFPs with their corresponding associated reverse SFPs.  Each bidirectional
            pair of SFPs uses a different SFI for the SF of Type 42.  The controller can instruct the
            classifier how to place traffic on the three bidirectional SFPs,
	    or it can treat them as a group,
            leaving the classifier responsible for balancing the load.</t>
          <sourcecode><![CDATA[           
   SFP14:  RD = 198.51.100.1/114, SPI = 28,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/117, Assoc-SPI = 31,
          [SI = 255, SFT = 41, RD = 192.0.2.1/11],
          [SI = 254, SFT = 42, RD = 192.0.2.2/11],
          [SI = 253, SFT = 43, RD = 192.0.2.3/11]

   SFP15:  RD = 198.51.100.1/115, SPI = 29,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/118, Assoc-SPI = 32,
          [SI = 255, SFT = 41, RD = 192.0.2.1/11],
          [SI = 254, SFT = 42, RD = 192.0.2.2/12],
          [SI = 253, SFT = 43, RD = 192.0.2.3/11]

   SFP16:  RD = 198.51.100.1/116, SPI = 30,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/119, Assoc-SPI = 33,
          [SI = 255, SFT = 41, RD = 192.0.2.1/11],
          [SI = 254, SFT = 42, RD = 192.0.2.2/13],
          [SI = 253, SFT = 43, RD = 192.0.2.3/11]

   SFP17:  RD = 198.51.100.1/117, SPI = 31,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/114, Assoc-SPI = 28,
          [SI = 255, SFT = 43, RD = 192.0.2.3/11],
          [SI = 254, SFT = 42, RD = 192.0.2.2/11],
          [SI = 253, SFT = 41, RD = 192.0.2.1/11]

   SFP18:  RD = 198.51.100.1/118, SPI = 32,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/115, Assoc-SPI = 29,
          [SI = 255, SFT = 43, RD = 192.0.2.3/11],
          [SI = 254, SFT = 42, RD = 192.0.2.2/12],
          [SI = 253, SFT = 41, RD = 192.0.2.1/11]

   SFP19:  RD = 198.51.100.1/119, SPI = 33,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/116, Assoc-SPI = 30,
          [SI = 255, SFT = 43, RD = 192.0.2.3/11],
          [SI = 254, SFT = 42, RD = 192.0.2.2/13],
          [SI = 253, SFT = 41, RD = 192.0.2.1/11]           
         ]]></sourcecode>
        </section>
        <section anchor="stateeg2pll" numbered="true" toc="default">
          <name>Parallel End-to-End SFPs with Separate SFFs</name>
          <t>While the examples in Sections <xref target="stateegsff"
	  format="counter"/> and <xref target="stateeg1pll" format="counter"/>
            place the choice of SFI as subtended from the same SFF, it is also possible that the
            SFIs are each subtended from a different SFF, as shown in <xref target="eg2pllfig" format="default"/>.
            In this case, it is harder to coordinate the choices for forward and reverse paths
            without some form of coordination between SFF1 and SFF3.  Therefore, it would be
            normal to consider end-to-end parallel SFPs, as described in <xref target="stateeg1pll" format="default"/>.</t>
          <figure anchor="eg2pllfig">
            <name>Second Example with Parallel End-to-End SFPs</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[         
                                     ------
                                    | SFIa |
                                    |SFT=42|
                                     ------
                      ------           |
                     | SFI  |      ---------
                     |SFT=41|     |   SFF5  |
                      ------    ..|192.0.2.5|..
                        |     ..:  ---------  :..
                    ---------.:                 :.---------
      ----------   |   SFF1  |     ---------     |   SFF3  |
 --> |          |..|192.0.2.1|....|   SFF6  |....|192.0.2.3| -->
 --> |Classifier|   ---------:    |192.0.2.6|    :---------
     |          |            :     ---------     :    |
      ----------             :         |         :  ------
                             :       ------      : | SFI  |
                             :..    | SFIb |   ..: |SFT=43|
                               :..  |SFT=42| ..:    ------
                                 :   ------  :
                                 :.---------.:
                                  |   SFF7  |
                                  |192.0.2.7|
                                   ---------
                                       |
                                     ------
                                    | SFIc |
                                    |SFT=42|
                                     ------           
         ]]></artwork>
          </figure>
          <t>In this case, five SFIRs are advertised as follows:</t>
          <sourcecode><![CDATA[          
   RD = 192.0.2.1/11, SFT = 41
   RD = 192.0.2.5/11, SFT = 42  (for SFIa)
   RD = 192.0.2.6/11, SFT = 42  (for SFIb)
   RD = 192.0.2.7/11, SFT = 42  (for SFIc)
   RD = 192.0.2.3/11, SFT = 43           
         ]]></sourcecode>
          <t>In this case, the controller could specify three forward SFPs with their corresponding
            associated reverse SFPs.  Each bidirectional pair of SFPs uses a different SFF and SFI
            for the middle hop (for an SF of Type 42).  The controller can instruct the classifier how
            to place traffic on the three bidirectional SFPs, or it can treat them as a group, leaving
            the classifier responsible for balancing the load.</t>
          <sourcecode><![CDATA[          
   SFP20:  RD = 198.51.100.1/120, SPI = 34,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/123, Assoc-SPI = 37,
          [SI = 255, SFT = 41, RD = 192.0.2.1/11],
          [SI = 254, SFT = 42, RD = 192.0.2.5/11],
          [SI = 253, SFT = 43, RD = 192.0.2.3/11]

   SFP21:  RD = 198.51.100.1/121, SPI = 35,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/124, Assoc-SPI = 38,
          [SI = 255, SFT = 41, RD = 192.0.2.1/11],
          [SI = 254, SFT = 42, RD = 192.0.2.6/11],
          [SI = 253, SFT = 43, RD = 192.0.2.3/11]

   SFP22:  RD = 198.51.100.1/122, SPI = 36,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/125, Assoc-SPI = 39,
          [SI = 255, SFT = 41, RD = 192.0.2.1/11],
          [SI = 254, SFT = 42, RD = 192.0.2.7/11],
          [SI = 253, SFT = 43, RD = 192.0.2.3/11]

   SFP23:  RD = 198.51.100.1/123, SPI = 37,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/120, Assoc-SPI = 34,
          [SI = 255, SFT = 43, RD = 192.0.2.3/11],
          [SI = 254, SFT = 42, RD = 192.0.2.5/11],
          [SI = 253, SFT = 41, RD = 192.0.2.1/11]

   SFP24:  RD = 198.51.100.1/124, SPI = 38,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/121, Assoc-SPI = 35,
          [SI = 255, SFT = 43, RD = 192.0.2.3/11],
          [SI = 254, SFT = 42, RD = 192.0.2.6/11],
          [SI = 253, SFT = 41, RD = 192.0.2.1/11]

   SFP25:  RD = 198.51.100.1/125, SPI = 39,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/122, Assoc-SPI = 36,
          [SI = 255, SFT = 43, RD = 192.0.2.3/11],
          [SI = 254, SFT = 42, RD = 192.0.2.7/11],
          [SI = 253, SFT = 41, RD = 192.0.2.1/11]           
         ]]></sourcecode>
        </section>
        <section anchor="stateegpllchc" numbered="true" toc="default">
          <name>Parallel SFPs Downstream of the Choice</name>
          <t>The mechanism of parallel SFPs demonstrated in <xref
	  target="stateeg2pll" format="default"/>
            is perfectly functional and may be practical in many environments.  However,
            there may be scaling concerns because of the large amount of state (knowledge
            of SFPs -- i.e., SFPR advertisements retained) if there is a very large number
            of possible SFIs (for example, tens of instances of the same stateful SF) or
            if there are multiple choices of stateful SF along a path.  This situation may
            be mitigated using SFP fragments that are combined to form the end-to-end SFPs.</t>
          <t>The example presented here is necessarily simplistic but should convey the
            basic principle.  The example presented in <xref target="eg2pllchcfig" format="default"/> is
            similar to that in <xref target="stateeg2pll" format="default"/> but with an additional first
            hop.</t>
          <figure anchor="eg2pllchcfig">
            <name>Example with Parallel SFPs Downstream of Choice</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[          
                                          ------
                                         | SFIa |
                                         |SFT=43|
                                          ------
               ------      ------           |
              | SFI  |    | SFI  |      ---------
              |SFT=41|    |SFT=42|     |   SFF5  |
               ------      ------    ..|192.0.2.5|..
                 |           |     ..:  ---------  :..
             ---------   ---------.:                 :.---------
    ------  |   SFF1  | |   SFF2  |     ---------     |   SFF3  |
-->|Class-|.|192.0.2.1|.|192.0.2.2|....|   SFF6  |....|192.0.2.3|-->
-->| ifier|  ---------   ---------:    |192.0.2.6|    :---------
    ------                        :     ---------     :    |
                                  :         |         :  ------
                                  :       ------      : | SFI  |
                                  :..    | SFIb |   ..: |SFT=44|
                                    :..  |SFT=43| ..:    ------
                                      :   ------  :
                                      :.---------.:
                                       |   SFF7  |
                                       |192.0.2.7|
                                        ---------
                                            |
                                          ------
                                         | SFIc |
                                         |SFT=43|
                                          ------         
         ]]></artwork>
          </figure>
          <t>The six SFIs are advertised as follows:</t>
          <sourcecode><![CDATA[           
   RD = 192.0.2.1/11, SFT = 41
   RD = 192.0.2.2/11, SFT = 42
   RD = 192.0.2.5/11, SFT = 43  (for SFIa)
   RD = 192.0.2.6/11, SFT = 43  (for SFIb)
   RD = 192.0.2.7/11, SFT = 43  (for SFIc)
   RD = 192.0.2.3/11, SFT = 44          
         ]]></sourcecode>
          <t>SFF2 is the point at which a load-balancing choice must be made.  So "tail-end"
            SFPs are constructed as follows.  Each takes in a different SFF that provides
            access to an SF of Type 43.</t>
          <sourcecode><![CDATA[          
   SFP26:  RD = 198.51.100.1/126, SPI = 40,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/130, Assoc-SPI = 44,
          [SI = 255, SFT = 43, RD = 192.0.2.5/11],
          [SI = 254, SFT = 44, RD = 192.0.2.3/11]

   SFP27:  RD = 198.51.100.1/127, SPI = 41,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/131, Assoc-SPI = 45,
          [SI = 255, SFT = 43, RD = 192.0.2.6/11],
          [SI = 254, SFT = 44, RD = 192.0.2.3/11]

   SFP28:  RD = 198.51.100.1/128, SPI = 42,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/132, Assoc-SPI = 46,
          [SI = 255, SFT = 43, RD = 192.0.2.7/11],
          [SI = 254, SFT = 44, RD = 192.0.2.3/11]           
         ]]></sourcecode>
          <t>Now an end-to-end SFP with load-balancing choice can be constructed as follows.
            The choice made by SFF2 is expressed in terms of entering one of the three
            "tail-end" SFPs.</t>
          <sourcecode><![CDATA[          
   SFP29:  RD = 198.51.100.1/129, SPI = 43,
          [SI = 255, SFT = 41, RD = 192.0.2.1/11],
          [SI = 254, SFT = 42, RD = 192.0.2.2/11],
          [SI = 253, {SFT = 1, RD = {SPI=40, SI=255, Rsv=0},
                               RD = {SPI=41, SI=255, Rsv=0},
                               RD = {SPI=42, SI=255, Rsv=0} } ]           
         ]]></sourcecode>
          <t>Now, despite the load-balancing choice being made elsewhere than at the initial
            classifier, it is possible for the reverse SFPs to be well constructed without
            any ambiguity.  The three reverse paths appear as follows.</t>
          <sourcecode><![CDATA[           
   SFP30:  RD = 198.51.100.1/130, SPI = 44,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/126, Assoc-SPI = 40,
          [SI = 255, SFT = 44, RD = 192.0.2.4/11],
          [SI = 254, SFT = 43, RD = 192.0.2.5/11],
          [SI = 253, SFT = 42, RD = 192.0.2.2/11],
          [SI = 252, SFT = 41, RD = 192.0.2.1/11]

   SFP31:  RD = 198.51.100.1/131, SPI = 45,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/127, Assoc-SPI = 41,
          [SI = 255, SFT = 44, RD = 192.0.2.4/11],
          [SI = 254, SFT = 43, RD = 192.0.2.6/11],
          [SI = 253, SFT = 42, RD = 192.0.2.2/11],
          [SI = 252, SFT = 41, RD = 192.0.2.1/11]

   SFP32:  RD = 198.51.100.1/132, SPI = 46,
         Assoc-Type = 1, Assoc-RD = 198.51.100.1/128, Assoc-SPI = 42,
          [SI = 255, SFT = 44, RD = 192.0.2.4/11],
          [SI = 254, SFT = 43, RD = 192.0.2.7/11],
          [SI = 253, SFT = 42, RD = 192.0.2.2/11],
          [SI = 252, SFT = 41, RD = 192.0.2.1/11]          
         ]]></sourcecode>
        </section>
      </section>
      <section anchor="v6samples" numbered="true" toc="default">
        <name>Examples Using IPv6 Addressing</name>
        <t>This section provides several examples using IPv6 addressing.  As
          will be seen from the examples, there is nothing special or clever
          about using IPv6 addressing rather than IPv4 addressing.</t>
        <t>The reference network for these IPv6 examples is based on that described
          at the top of <xref target="example" format="default"/> and shown in <xref target="examplefig" format="default"/>.</t>
        <t>Assume we have a service function overlay network with four SFFs (SFF1, SFF3, SFF3, and SFF4).
          The SFFs have addresses in the underlay network as follows:</t>
        <sourcecode><![CDATA[             
      SFF1 2001:db8::192:0:2:1
      SFF2 2001:db8::192:0:2:2
      SFF3 2001:db8::192:0:2:3
      SFF4 2001:db8::192:0:2:4
      ]]></sourcecode>
        <t>Each SFF provides access to some SFIs from the four service function types SFT=41, SFT=42,
          SFT=43, and SFT=44, just as before:</t>
        <sourcecode><![CDATA[              
      SFF1 SFT=41 and SFT=42
      SFF2 SFT=41 and SFT=43
      SFF3 SFT=42 and SFT=44
      SFF4 SFT=43 and SFT=44              
            ]]></sourcecode>
        <t>The service function network also contains a controller with address 2001:db8::198:51:100:1.</t>
        <t>This example service function overlay network is shown in <xref target="eg6fig" format="default"/>.</t>
        <figure anchor="eg6fig">
          <name>Example Service Function Overlay Network</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[              
       ------------------------
      |       Controller       |
      | 2001:db8::198:51:100:1 |
       ------------------------
                    ------     ------        ------     ------
                   | SFI  |   | SFI  |      | SFI  |   | SFI  |
                   |SFT=41|   |SFT=42|      |SFT=41|   |SFT=43|
                    ------     ------        ------     ------
                         \     /                  \     /
                    -------------------     -------------------
                   |       SFF1        |   |       SFF2        |
                   |2001:db8::192:0:2:1|   |2001:db8::192:0:2:2|
                    -------------------     -------------------
               ----------
   Packet --> |          |                                    -->
   Flows  --> |Classifier|                                    -->Dest
              |          |                                    -->
               ----------
                   -------------------      -------------------
                  |       SFF3        |    |       SFF4        |
                  |2001:db8::192:0:2:3|    |2001:db8::192:0:2:4|
                   -------------------      -------------------
                         /     \                  /     \
                    ------     ------        ------     ------
                   | SFI  |   | SFI  |      | SFI  |   | SFI  |
                   |SFT=42|   |SFT=44|      |SFT=43|   |SFT=44|
                    ------     ------        ------     ------              
            ]]></artwork>
        </figure>
        <t>The SFFs advertise routes to the SFIs they support.  These advertisements
       contain RDs that are set according to the network operator's
       configuration model.  Note that in an IPv6 network, the RD is not large enough to
       contain the full IPv6 address, as only six octets are available. So, in all of these IPv6
       examples, we use RDs of Type 1 such that the available six octets are partitioned as four
       octets for an IPv4 address of the advertising SFF, and two octets that are a local index
       of the SFI.  Furthermore, we have chosen an IPv6 addressing scheme so that the low-order
       four octets of the IPv6 address match an IPv4 address of the advertising node.  This scheme
       is chosen purely for convenience of documentation, and an operator is totally free to use
       any other scheme so long as it conforms to the definitions of SFIR and
       SFPR in Sections
       <xref target="sfiRoutes" format="counter"/> and <xref target="sfpRoutes" format="counter"/>.</t>
        <t>Observant readers will notice that this makes the BGP advertisements shown in these examples
       exactly the same as in the previous examples.  All that is different is that the advertising
       SFFs and controller have IPv6 addresses.</t>
        <t>Thus, we see the following SFIRs advertised.</t>
        <t>The SFFs advertise routes to the SFIs they support.  So we see the following
          SFIRs:</t>
        <sourcecode><![CDATA[              
      RD = 192.0.2.1/1, SFT = 41
      RD = 192.0.2.1/2, SFT = 42
      RD = 192.0.2.2/1, SFT = 41
      RD = 192.0.2.2/2, SFT = 43
      RD = 192.0.2.3/7, SFT = 42
      RD = 192.0.2.3/8, SFT = 44
      RD = 192.0.2.4/5, SFT = 43
      RD = 192.0.2.4/6, SFT = 44              
            ]]></sourcecode>
        <t>Note that the addressing used for communicating between SFFs is taken
          from the tunnel encapsulation attribute of the SFIR and not from the SFIR-RD.</t>
        <section anchor="eg6explicit" numbered="true" toc="default">
          <name>Example Explicit SFP with No Choices</name>
          <t>Consider the following SFPR similar to that in <xref target="exampleexplicit" format="default"/>.</t>
          <sourcecode><![CDATA[             
      SFP1:  RD = 198.51.100.1/101, SPI = 15,
             [SI = 255, SFT = 41, RD = 192.0.2.1/1],
             [SI = 250, SFT = 43, RD = 192.0.2.2/2]             
            ]]></sourcecode>
          <t>The SFP consists of an SF of Type 41 located at SFF1, followed by an SF
             of Type 43 located at SFF2.  This path is fully explicit, and each SFF is
             offered no choice in forwarding a packet along the path.</t>
          <t>SFF1 will receive packets on the path from the classifier and will identify the path
             from the SPI (15).  The initial SI will be 255, and so SFF1 will deliver the packets to the
             SFI for SFT 41.</t>
          <t>When the packets are returned to SFF1 by the SFI, the SI will be
	  decreased to 250 for the next hop.
              SFF1 has no flexibility in the choice of SFF to support the next-hop SFI and will forward
              the packet to SFF2, which will send the packets to the SFI that supports SFT 43 before
              forwarding the packets to their destinations.</t>
        </section>
        <section anchor="eg6choice" numbered="true" toc="default">
          <name>Example SFP with Choice of SFIs</name>
          <sourcecode><![CDATA[             
      SFP2:  RD = 198.51.100.1/102, SPI = 16,
             [SI = 255, SFT = 41, RD = 192.0.2.1/1],
             [SI = 250, SFT = 43, {RD = 192.0.2.2/2,
                                   RD = 192.0.2.4/5 } ]              
            ]]></sourcecode>
          <t>In this example, like that in <xref target="examplechoice" format="default"/>, the path also consists of an
             SF of Type 41 located at SFF1, and this is followed by an SF of
	     Type 43; but in this case, the
             SI = 250 contains a choice between the SFI located at SFF2 and the SFI located at SFF4.</t>
          <t>SFF1 will receive packets on the path from the classifier and will identify the path
             from the SPI (16).  The initial SI will be 255, and so SFF1 will deliver the packets to the
             SFI for SFT 41.</t>
          <t>When the packets are returned to SFF1 by the SFI, the SI will be decreased to 250 for
              the next hop.  SFF1 now has a choice of next-hop SFFs to execute the next hop in the path.
              It can either forward packets to SFF2 or SFF4 to execute a function of Type 43.  It uses
              its local load-balancing algorithm to make this choice.  The chosen SFF will send the
              packets to the SFI that supports SFT 43 before forwarding the packets to their
              destinations.</t>
        </section>
        <section anchor="eg6open" numbered="true" toc="default">
          <name>Example SFP with Open Choice of SFIs</name>
          <sourcecode><![CDATA[              
      SFP3:  RD = 198.51.100.1/103, SPI = 17,
             [SI = 255, SFT = 41, RD = 192.0.2.1/1],
             [SI = 250, SFT = 44, RD = 0]              
            ]]></sourcecode>
          <t>In this example, like that in <xref target="exampleopen"
	  format="default"/>, the path also consists of an
             SF of Type 41 located at SFF1, and this is followed by an SI with an RD of zero and SF of
             Type 44.  This means that a choice can be made between any SFF that supports an SFI of
             Type 44.</t>
          <t>SFF1 will receive packets on the path from the classifier and will identify the path
             from the SPI (17).  The initial SI will be 255, and so SFF1 will deliver the packets to the
             SFI for SFT 41.</t>
          <t>When the packets are returned to SFF1 by the SFI, the SI will be decreased to 250 for
              the next hop.  SFF1 now has a free choice of next-hop SFFs to execute the next hop in the
              path, selecting between all SFFs that support SFs of Type 44.  Looking at the SFIRs it
              has received, SFF1 knows that SF Type 44 is supported by SFF3 and SFF4.  SFF1 uses its
              local load-balancing algorithm to make this choice.  The chosen SFF will send the packets
              to the SFI that supports SFT 44 before forwarding the packets to their destinations.</t>
        </section>
        <section anchor="eg6sft" numbered="true" toc="default">
          <name>Example SFP with Choice of SFTs</name>
          <sourcecode><![CDATA[             
      SFP4:  RD = 198.51.100.1/104, SPI = 18,
             [SI = 255, SFT = 41, RD = 192.0.2.1/1],
             [SI = 250, {SFT = 43, RD = 192.0.2.2/2,
                         SFT = 44, RD = 192.0.2.3/8 } ]              
            ]]></sourcecode>
          <t>This example, similar to that in <xref target="examplesft"
	  format="default"/>, provides a choice of SF type
             in the second hop in the path.  The SI of 250 indicates a choice between SF Type 43 located
             through SF2 and SF Type 44 located at SF3.</t>
          <t>SFF1 will receive packets on the path from the classifier and will identify the path
             from the SPI (18).  The initial SI will be 255, and so SFF1 will deliver the packets to the
             SFI for SFT 41.</t>
          <t>When the packets are returned to SFF1 by the SFI, the SI will be decreased to 250 for
             the next hop.  SFF1 now has a free choice of next-hop SFFs to execute the next hop in the
             path, selecting between all SFFs that support an SF of Type 43
	     and SFF3, which supports an
             SF of Type 44.  These may be completely different functions that are to be executed dependent
             on specific conditions, or they may be similar functions identified with different type
             identifiers (such as firewalls from different vendors).  SFF1
	     uses its local policy and load-balancing algorithm to make this
	     choice, and it may use additional information passed back from
             the local SFI to help inform its selection.  The chosen SFF will send the packets to the SFI
             that supports the chosen SFT before forwarding the packets to their destinations.</t>
        </section>
      </section>
    </section>
    <section anchor="security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>The mechanisms in this document use BGP for the control plane.
       Hence, techniques such as those discussed in <xref target="RFC5925" format="default"/>
       can be used to help authenticate BGP sessions and, thus, the messages
       between BGP peers, making it harder to spoof updates (which
       could be used to install bogus SFPs or advertise false SIs)
       or withdrawals.</t>
      <t>Further discussion of security considerations for BGP may be found in
       the BGP specification itself <xref target="RFC4271" format="default"/> and the security
       analysis for BGP <xref target="RFC4272" format="default"/>.





<xref target="RFC5925" format="default"/> contains a discussion of the inappropriateness of the TCP
MD5 signature option for protecting BGP sessions.  <xref target="RFC6952"/> includes
an analysis of BGP keying and authentication issues.</t>
      <t>Additionally, this document depends on other documents that specify BGP
       Multiprotocol Extensions and the documents that define the attributes that
       are carried by BGP UPDATEs of the SFC AFI/SAFI.  <xref target="RFC4760" format="default"/>
       observes that the use of AFI/SAFI does not change the underlying security issues
       inherent in the existing BGP.  Relevant additional security measures are
       considered in <xref target="RFC9012" format="default"/>.</t>
      <t>This document does not fundamentally change the security behavior of BGP
       deployments, which depend considerably on the network operator's perception
       of risk in their network.  It may be observed that the application of the
       mechanisms described in this document is scoped to a single domain, as implied
       by <xref target="RFC8300" format="default"/> and noted in <xref target="funcover" format="default"/> of this document.
       Applicability of BGP within a single domain may enable a network operator to make
       easier and more consistent decisions about what security measures to apply, and the
       domain boundary, which BGP enforces by definition, provides a safeguard that prevents
       leakage of SFC programming in either direction at the boundary.</t>
      <t>Service function chaining provides a significant attack opportunity; packets can be diverted
       from their normal paths through the network, packets can be made to execute unexpected functions, and
       the functions that are instantiated in software can be subverted.  However, this specification
       does not change the existence of service function chaining, and security issues specific to
       service function chaining are covered in <xref target="RFC7665" format="default"/> and
       <xref target="RFC8300" format="default"/>.</t>
      <t>This document defines a control plane for service function chaining.  Clearly, this provides
       an attack vector for a service function chaining system, as an attack on this control plane
       could be used to make the system misbehave.  Thus, the security of the BGP system is critically
       important to the security of the whole service function chaining system.  The control plane
       mechanisms are very similar to those used for BGP/MPLS IP VPNs as described in              
       <xref target="RFC4364"/>, and so the security considerations in that document (Section <xref target="RFC4364" section="13" sectionFormat="bare"/>)
       provide good guidance for securing service function chaining systems reliant on this specification.  Of particular
       relevance is the need to securely distinguish between messages intended for the control of
       different SFC overlays, which is similar to the need to distinguish between different VPNs.
       <xref target="RFC7432" section="19" sectionFormat="of"/> also provides useful guidance on the use of BGP in a
       similar environment.</t>
      <t>Note that a component of a service function chaining system that uses the procedures described in this document also
       requires communications between a controller and the service function chaining network elements (specifically the SFFs
       and classifiers).  This communication covers instructing the classifiers using BGP mechanisms (see
       <xref target="fspecclassy" format="default"/>); therefore, the use of BGP security is strongly recommended.  But it also
       covers other mechanisms for programming the classifier and instructing the SFFs and SFs (for
       example, to bind SFs to an SFF, and to cause the establishment of tunnels between SFFs).  This
       document does not cover these latter mechanisms, and so their security is out of scope, but it
       should be noted that these communications provide an attack vector on the service function chaining system, and so
       attention must be paid to ensuring that they are secure.</t>
      <t>There is an intrinsic assumption in service function chaining systems that nodes that announce support for specific
       SFs actually offer those functions and that SFs are not, themselves, attacked or subverted.
       This is particularly important when the SFs are implemented as software that can be updated.
       Protection against this sort of concern forms part of the security of any service function chaining system and so is
       outside the scope of the control plane mechanisms described in this document.</t>
      <t>Similarly, there is a vulnerability if a rogue or subverted controller announces SFPs, especially
       if that controller "takes over" an existing SFP and changes its contents.  This corresponds
       to a rogue BGP speaker entering a routing system, or even a Route Reflector becoming
       subverted.  Protection mechanisms, as above, include securing BGP sessions and protecting
       software loads on the controllers.</t>
      <t>In an environment where there is concern that rogue controllers might be introduced to the
       network and inject false SFPRs or take over and change existing SFPRs, it is <bcp14>RECOMMENDED</bcp14> that
       each SFF and classifier be configured with the identities of authorized controllers.  Thus, the
       announcement of an SFPR by any other BGP peer would be rejected.</t>
      <t>Lastly, note that <xref target="sfparules" format="default"/> makes two operational suggestions that have
       implications for the stability and security of the mechanisms described in this document:
      </t>
      <ul spacing="normal">
        <li>That modifications to active SFPs not be made.</li>
        <li>That SPIs not be immediately reused.</li>
      </ul>
    </section>
    <section anchor="iana" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <section anchor="afisafi" numbered="true" toc="default">
        <name>New BGP AF/SAFI</name>
	
        <t>IANA maintains the "Address Family Numbers" registry.  IANA has assigned a new
          Address Family Number from the "Standards Action" range called "BGP SFC" (31), with this document as a reference.</t>
        <t>IANA maintains the "Subsequent Address Family Identifiers (SAFI) Parameters" registry.  IANA
          has assigned a new SAFI value from the "Standards Action" range called "BGP SFC"
          (9), with this document as a reference.</t>
      </section>
      <section anchor="ianasfpatt" numbered="true" toc="default">
        <name>&quot;SFP attribute&quot; BGP Path Attribute</name>
        <t>IANA maintains a registry of "Border Gateway Protocol (BGP) Parameters" with a subregistry of
          "BGP Path Attributes".  IANA has assigned a new Path attribute called "SFP attribute" with a value of 37 and with this document as a reference.</t>
      </section>
      <section anchor="ianasftlv" numbered="true" toc="default">
        <name>&quot;SFP Attribute TLVs&quot; Registry</name>
        <t>IANA maintains a registry of "Border Gateway Protocol (BGP) Parameters".  IANA has created a new subregistry called the "SFP Attribute TLVs" registry.</t>
        <t>Valid values are in the range 0 to 65535.
        </t>
        <ul spacing="normal">
	  
          <li>Values 0 and 65535 are marked "Reserved".</li>
          <li>Values 1 through 65534 are to be assigned according to the "First Come
               First Served" policy <xref target="RFC8126" format="default"/>.</li>
        </ul>
        <t>This document is a reference for this registry.</t>
        <t>The registry tracks:
        </t>
        <ul spacing="normal">
          <li>Type</li>
          <li>Name</li>
          <li>Reference</li>
          <li>Registration Date</li>
        </ul>
        <t>The registry is initially populated as follows:</t>
        <table>
	  <name>SFP Attribute TLVs Subregistry Initial Contents</name>
	  <thead>
	    <tr>
	      <th>Type</th>
	      <th>Name</th>
	      <th>Reference</th>
	      <th>Registration Date</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td>1</td>
	      <td>Association TLV</td>
	      <td>RFC 9015</td>
	      <td>2020-09-02</td>
	    </tr>
	    <tr>
	      <td>2</td>
	      <td>Hop TLV</td>
	      <td>RFC 9015</td>
	      <td>2020-09-02</td>
	    </tr>
	    <tr>
	      <td>3</td>
	      <td>SFT TLV</td>
	      <td>RFC 9015</td>
	      <td>2020-09-02</td>
	    </tr>
	    <tr>
	      <td>4</td>
	      <td>MPLS Swapping/Stacking</td>
	      <td>RFC 9015</td>
	      <td>2020-09-02</td>
	    </tr>
	    <tr>
	      <td>5</td>
	      <td>SFP Traversal With MPLS</td>
	      <td>RFC 9015</td>
	      <td>2020-09-02</td>
	    </tr>
	  </tbody>
	</table>
      </section>
      <section anchor="ianaassoc" numbered="true" toc="default">
        <name>&quot;SFP Association Type&quot; Registry</name>
        <t>IANA maintains a registry of "Border Gateway Protocol (BGP) Parameters".  IANA has created a new subregistry called the "SFP Association Type" registry.</t>
        <t>Valid values are in the range 0 to 65535.
        </t>
        <ul spacing="normal">
          <li>Values 0 and 65535 are marked "Reserved".</li>
          <li>Values 1 through 65534 are assigned according to the "First Come
               First Served" policy <xref target="RFC8126" format="default"/>.</li>
        </ul>
        <t>This document is given as a reference for this registry.</t>
        <t>The new registry tracks:
        </t>
        <ul spacing="normal">
          <li>Association Type</li>
          <li>Name</li>
          <li>Reference</li>
          <li>Registration Date</li>
        </ul>
        <t>The registry should initially be populated as follows:</t>

	<table>
	  <name>SFP Association Type Subregistry Initial Contents</name>
	  <thead>
	    <tr>
	      <th>Association Type</th>
	      <th>Name</th>
	      <th>Reference</th>
	      <th>Date</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td>1</td>
	      <td>Bidirectional SFP</td>
	      <td>RFC 9015</td>
	      <td>2020-09-02</td>
	    </tr>
	  </tbody>
	</table>
	
      </section>
      
      <section anchor="SFTreg" numbered="true" toc="default">
        <name>&quot;Service Function Chaining Service Function Types&quot; Registry</name>
        <t>IANA has created a new top-level registry called "Service Function Chaining Service Function Types".</t>
        <t>Valid values are in the range 0 to 65535.
        </t>
        <ul spacing="normal">
          <li>Values 0 and 65535 are marked "Reserved".</li>
          <li>Values 1 through 31 are to be assigned by "Standards Action" <xref target="RFC8126" format="default"/> and are referred to
               as the "special-purpose SFT values".</li>
          <li>Values 32 through 64495 are to be assigned according to the "First Come
               First Served" policy <xref target="RFC8126" format="default"/>.</li>
          <li>Values 64496 through 65534 are for Private Use and are not to be recorded by IANA.</li>
        </ul>
        <t>This document is given as a reference for this registry.</t>
        <t>The registry tracks:
        </t>
        <ul spacing="normal">
          <li>Value</li>
          <li>Name</li>
          <li>Reference</li>
          <li>Registration Date</li>
        </ul>

        <t>The registry is initially populated as follows.</t>
	  
	<table>
	  <name>Service Function Chaining Service Function Types Registry Initial Contents</name>
	    <thead>
	      <tr>
		<th>Value</th>
		<th>Name</th>
		<th>Reference</th>
		<th>Date</th>
	      </tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>0</td>
		<td>Reserved</td>
		<td>RFC 9015</td> 
	        <td>2020-09-02</td>
	      </tr>
	      <tr>
		<td>1</td>
		<td>Change Sequence</td>
		<td>RFC 9015</td>
		<td>2020-09-02</td>
	      </tr>
	      <tr>
		<td>2-31</td>
		<td>Unassigned</td>
		<td></td>
		<td></td>
              </tr>
	      <tr>
		<td>32</td>
		<td>Classifier</td>
		<td>RFC 9015, <xref
		target="I-D.dawra-idr-bgp-ls-sr-service-segments" format="default"/></td>
		<td>2020-09-02</td>
              </tr>
              <tr>
		<td>33</td>
		<td>Firewall</td>
		<td>RFC 9015, <xref
		target="I-D.dawra-idr-bgp-ls-sr-service-segments" format="default"/></td>
		<td>2020-09-02</td>
	      </tr>
	      <tr>
                
		<td>34</td>
		<td>Load balancer</td>
		<td>RFC 9015, <xref
		target="I-D.dawra-idr-bgp-ls-sr-service-segments" format="default"/></td>
		<td>2020-09-02</td>
	      </tr>
	      <tr>
                
		<td>35</td>
		<td>Deep packet inspection engine</td>
		<td>RFC 9015, <xref
		target="I-D.dawra-idr-bgp-ls-sr-service-segments" format="default"/></td>
		<td>2020-09-02</td>
	      </tr>
	      <tr>
		
		<td>36</td>
		<td>Penalty box</td>
		<td>RFC 9015, <xref target="RFC8300"/></td>
		<td>2020-09-02</td>
              </tr>
	      <tr>               
		<td>37</td>
		<td>WAN accelerator</td>
		<td>RFC 9015, <xref target="RFC7665"/>, <xref target="RFC8300"/></td>
		<td>2020-09-02</td>
              </tr>
	      <tr>             
		<td>38</td>
		<td>Application accelerator</td>
		<td>RFC 9015, <xref target="RFC7665"/></td>
		<td>2020-09-02</td>
                  </tr>
		  <tr>               
		    <td>39</td>
		    <td>TCP optimizer</td>
		    <td>RFC 9015, <xref target="RFC7665"/></td>
		    <td>2020-09-02</td>
                  </tr>
		  <tr>             
		    <td>40</td>
		    <td>Network Address Translator</td>
		    <td>RFC 9015, <xref target="RFC7665"/></td>
		    <td>2020-09-02</td>
                  </tr>
		  <tr>  
		    <td>41</td>
		<td>NAT44</td>
                <td>RFC 9015, <xref target="RFC7665"/>, <xref target="RFC3022"/></td> 
		<td>2020-09-02</td>
                  </tr>
		  <tr>            
		    <td>42</td>
		    <td>NAT64</td>
                    <td>RFC 9015, <xref target="RFC7665"/>, <xref target="RFC6146"/></td> 
              	    <td>2020-09-02</td>
                  </tr>
		  <tr>             
		<td>43</td>
		<td>NPTv6</td> 
		<td>RFC 9015, <xref target="RFC7665"/>, <xref target="RFC6296"/></td> 
		<td>2020-09-02</td>
                
                  </tr>
		  <tr>              
		    <td>44</td>
		    <td>Lawful intercept</td>
		    <td>RFC 9015, <xref target="RFC7665"/></td>
		    <td>2020-09-02</td>
                  </tr>
	      <tr>                
		<td>45</td>
		<td>HOST_ID injection</td>
		<td>RFC 9015, <xref target="RFC7665"/></td>
		<td>2020-09-02</td>
              </tr>
	      <tr>                 
		<td>46</td>
		<td>HTTP header enrichment</td>
		<td>RFC 9015, <xref target="RFC7665"/></td>
		<td>2020-09-02</td>
                  </tr>
		  <tr>             
		    <td>47</td>
		    <td>Caching engine </td>
		    <td>RFC 9015, <xref target="RFC7665"/></td>
		  <td>2020-09-02</td></tr>
		  <tr>
                    <td>48-64495</td>
		    <td>Unassigned</td>
		    <td></td>
		    <td></td>
		  </tr>
		   <tr>
                    <td>64496-65534</td>
		    <td>Reserved for Private Use</td>
		    <td></td>
		    <td></td>
		  </tr>
		  <tr>
		    <td>65535</td>
		    <td>Reserved, not to be allocated </td>               
		    <td>RFC 9015</td>
		    <td>2020-09-02</td>
		  </tr>
	    </tbody>
          </table>
	  
      </section>
      <section anchor="ExpExtComreg" numbered="true" toc="default">
        <name>Flow Specification for SFC Classifiers</name>
        <t>IANA maintains a registry of "Border Gateway Protocol (BGP) Extended Communities" with a subregistry of
          "Generic Transitive Experimental Use Extended Community Sub-Types".  IANA has assigned a
          new subtype as follows:
        </t>
        <ul  empty="true" spacing="normal">
          <li>"Flow Specification for SFC Classifiers" with a value of 0x0d and with this document as the reference.</li>
        </ul>
      </section>
      <section anchor="TransExtComreg" numbered="true" toc="default">
        <name>New BGP Transitive Extended Community Type</name>
        <t>IANA maintains a registry of "Border Gateway Protocol (BGP) Extended Communities" with a subregistry of
          "BGP Transitive Extended Community Types".  IANA has assigned a new type as follows:
        </t>
        <ul  empty="true" spacing="normal">
          <li>SFC (Sub-Types are defined in the "SFC Extended Community
	  Sub-Types" registry) with a value of 0x0b and with this document as
	  the reference.</li>
        </ul>
      </section>
      <section anchor="SFCExtComreg" numbered="true" toc="default">
        <name>&quot;SFC Extended Community Sub-Types&quot; Registry</name>
        <t>IANA maintains a registry of "Border Gateway Protocol (BGP) Parameters".  IANA has created a new subregistry called the "SFC Extended Community Sub-Types" registry.</t>
        <t>IANA has included the following note:
        </t>
	<aside><t>
          This registry contains values of the second octet (the "Sub-Type"
               field) of an extended community when the value of the first
               octet (the "Type" field) is set to 0x0b.</t>
        </aside>
        <t>The allocation policy for this registry is First Come First Served.</t>
        <t>Valid values are 0 to 255.  The value 0 is reserved and should not be allocated.</t>
        <t>IANA has populated this registry with the following entries:</t>
        <table>
         <name>SFC Extended Community Sub-Types Subregistry Initial Contents</name>
	  <thead>
	    <tr>
	      <th>Sub-Type                                    
	      Value</th>
	      <th>Name</th>
	      <th>Reference</th>
	      <th>Date</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td>0</td>
	      <td>Reserved</td>
	      <td>RFC 9015</td>
	      <td></td>
	    </tr>
	    <tr>
	      <td>1</td>
	      <td>SFIR pool identifier</td>
	      <td>RFC 9015</td>
	      <td>2020-09-02</td>
	    </tr>
	    <tr>
	      <td>2</td>
	      <td>MPLS Label Stack Mixed Swapping/Stacking Labels</td>                
	      <td>RFC 9015</td>
	      <td>2020-09-02</td>
	      
	    </tr>
	    <tr>
	      <td>3-255</td>
	      <td>Unassigned</td>
	      <td></td>
	      <td></td>
	    </tr>
	  </tbody>   
        </table>
	
      </section>
      <section anchor="SpiSiRep" numbered="true" toc="default">
        <name>New SPI/SI Representation Sub-TLV</name>
        <t>IANA has assigned a codepoint from the "BGP Tunnel Encapsulation Attribute
          Sub-TLVs" registry for the "SPI/SI Representation Sub-TLV"  with a value of 16 and with this
          document as the reference.</t>
      </section>
      <section anchor="IANAbits" numbered="true" toc="default">
        <name>&quot;SFC SPI/SI Representation Flags&quot; Registry</name>
        <t>IANA maintains the "BGP Tunnel Encapsulation Attribute Sub-TLVs" registry and has created an associated registry called the "SFC SPI/SI Representation Flags" registry.</t>
        <t>Bits are to be assigned by Standards Action. The field is 16 bits long, and bits are counted
         from the most significant bit as bit zero.</t>
         <t>IANA has populated the registry as follows:</t>
	 
         <table>
          <name>SFC SPI/SI Representation Flags Registry Initial Contents</name>
	  <thead>
	    <tr>
	      <th>Value</th>
	      <th>Name</th>
              <th>Reference</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
     	      <td>0</td>
	      <td>NSH data plane</td>
	      <td>RFC 9015</td>
	    </tr>
	    <tr>
	      <td>1</td>
	      <td>MPLS data plane</td>
	      <td>RFC 9015</td>
	    </tr>
	    </tbody>
	</table>
	
      </section>
    </section>
    
  </middle>
  <back>

<displayreference target="I-D.dawra-idr-bgp-ls-sr-service-segments" to="BGP-LS-SR"/>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4271.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4360.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4364.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4760.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7432.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7606.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7665.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8300.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8595.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8596.xml"/>

<!--[I-D.ietf-idr-rfc5575bis]; Pub'd as RFC 8955-->
	
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8955.xml"/>


<!--[I-D.ietf-idr-tunnel-encaps]; Pub'd as RFC 9012-->
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9012.xml"/>

      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3022.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4272.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5925.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6146.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6296.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6952.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7498.xml"/>

<!-- [I-D.dawra-idr-bgp-ls-sr-service-segments] IESG state I-D Exists -->

<xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.dawra-idr-bgp-ls-sr-service-segments.xml"/>

      </references>
    </references>
    <section anchor="acks" numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t>Thanks to <contact fullname="Tony Przygienda"/>, <contact
      fullname="Jeff Haas"/>, and <contact fullname="Andy Malis"/> for helpful
      comments, and to
       <contact fullname="Joel Halpern"/> for discussions that improved this
       document.  <contact fullname="Yuanlong Jiang"/> provided
       a useful review and caught some important issues.  <contact fullname="Stephane Litkowski"/> did an
       exceptionally good and detailed Document Shepherd review.</t>
      <t><contact fullname="Andy Malis"/> contributed text that formed the
      basis of <xref target="mpls-encaps" format="default"/>.</t>
      <t><contact fullname="Brian Carpenter"/> and <contact fullname="Martin
      Vigoureux"/> provided useful reviews during IETF Last Call.
       Thanks also to <contact fullname="Sheng Jiang"/>, <contact
       fullname="Med Boucadair"/>, <contact fullname="Ravi Singh"/>, <contact
       fullname="Benjamin Kaduk"/>, <contact fullname="Roman Danyliw"/>,
       <contact fullname="Adam Roach"/>, <contact fullname="Alvaro Retana"/>, <contact fullname="Barry Leiba"/>, and <contact fullname="Murray Kucherawy"/> for review comments.
       <contact fullname="Ketan Talaulikar"/> provided helpful discussion of
       the SFT codepoint registry.  <contact fullname="Ron Bonica"/>
       kept us honest on the difference between an RD and an RT; <contact
       fullname="Benjamin Kaduk"/> kept us on message
       about the difference between an RD and an Extended Community.</t>
    </section>

    <section anchor="contributors" numbered="false" toc="default">
      <name>Contributors</name>      
        
   <contact fullname="Stuart Mackie">
     <organization>Juniper Networks</organization>
     <address>
       <email>wsmackie@juinper.net</email>

     </address>
   </contact>

   <contact fullname="Keyur Patel">
     <organization>Arrcus, Inc.</organization>
     <address>
       <email>keyur@arrcus.com</email>
     </address>
   </contact>
   
   <contact fullname="Avinash Lingala">
     <organization>AT&amp;T</organization>
     <address>
       <email>ar977m@att.com</email>
     </address>
   </contact>        

    </section>

    

  </back>
</rfc>
