<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" 
     category="std" 
     docName="draft-ietf-babel-rfc6126bis-20" 
     number="8966"
     ipr="trust200902" 
     obsoletes="6126,7557" 
     updates="" 
     submissionType="IETF" 
     consensus="true"
     xml:lang="en" 
     tocInclude="true" 
     tocDepth="2" 
     symRefs="true" 
     sortRefs="true" 
     version="3">
  <!-- xml2rfc v2v3 conversion 3.0.0 -->
  <front>

    <title>The Babel Routing Protocol</title>
    <seriesInfo name="RFC" value="8966"/>
    <author fullname="Juliusz Chroboczek" initials="J." surname="Chroboczek">
      <organization>IRIF, University of Paris-Diderot</organization>
      <address>
        <postal>
          <street>Case 7014</street>
          <city>Paris CEDEX 13</city>
          <code>75205</code>
          <country>France</country>
        </postal>
        <email>jch@irif.fr</email>
      </address>
    </author>
    <author fullname="David Schinazi" surname="Schinazi" initials="D.">
      <organization>Google LLC</organization>
      <address>
        <postal>
          <street>1600 Amphitheatre Parkway</street>
          <city>Mountain View</city>
          <region>California</region>
          <code>94043</code>
          <country>United States of America</country>
        </postal>
        <email>dschinazi.ietf@gmail.com</email>
      </address>
    </author>
    <date month="January" year="2021"/>
<keyword>Bellman-Ford</keyword>
<keyword>IGP</keyword>
<keyword>loop-avoidance</keyword>
<keyword>mesh network</keyword>
    <abstract>
      <t>Babel is a loop-avoiding, distance-vector routing protocol that is
robust and efficient both in ordinary wired networks and in wireless mesh
networks.  This document describes the Babel routing protocol and
obsoletes RFC 6126 and RFC 7557.</t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>Babel is a loop-avoiding distance-vector routing protocol that is
designed to be robust and efficient both in networks using prefix-based
routing and in networks using flat routing ("mesh networks"), and both in
relatively stable wired networks and in highly dynamic wireless networks.
This document describes the Babel routing protocol and obsoletes
<xref target="RFC6126" format="default"/> and <xref target="RFC7557" format="default"/>.</t>
      <section numbered="true" toc="default">
        <name>Features</name>
        <t>The main property that makes Babel suitable for unstable networks is
that, unlike naive distance-vector routing protocols <xref target="RFC2453" format="default"/>,
it strongly limits the frequency and duration of routing pathologies such
as routing loops and black-holes during reconvergence.  Even after
a mobility event is detected, a Babel network usually remains loop-free.
Babel then quickly reconverges to a configuration that preserves the
loop-freedom and connectedness of the network, but is not necessarily
optimal; in many cases, this operation requires no packet exchanges at
all.  Babel then slowly converges, in a time on the scale of minutes, to
an optimal configuration.  This is achieved by using sequenced routes,
a technique pioneered by Destination-Sequenced Distance-Vector routing
<xref target="DSDV" format="default"/>.</t>
        <t>More precisely, Babel has the following properties:
</t>
        <ul spacing="normal">
          <li>when every prefix is originated by at most one router, Babel never
  suffers from routing loops;</li>
          <li>when a single prefix is originated by multiple routers, Babel may
  occasionally create a transient routing loop for this particular prefix;
  this loop disappears in time proportional to the loop's diameter, and never
  again (up to an arbitrary garbage-collection (GC) time) will the routers
  involved participate in a routing loop for the same prefix;</li>
          <li>assuming bounded packet loss rates, any routing black-holes that
  may appear after a mobility event are corrected in a time at most
  proportional to the network's diameter.</li>
        </ul>
        <t>Babel has provisions for link quality estimation and for fairly
arbitrary metrics.  When configured suitably, Babel can implement
shortest-path routing, or it may use a metric based, for example, on
measured packet loss.</t>
        <t>Babel nodes will successfully establish an association even when they
are configured with different parameters.  For example, a mobile node that
is low on battery may choose to use larger time constants (hello and update
intervals, etc.) than a node that has access to wall power.  Conversely, a
node that detects high levels of mobility may choose to use smaller time
constants.  The ability to build such heterogeneous networks makes Babel
particularly adapted to the unmanaged or wireless environment.</t>
        <t>Finally, Babel is a hybrid routing protocol, in the sense that it can
carry routes for multiple network-layer protocols (IPv4 and IPv6),
regardless of which protocol the Babel packets are themselves being
carried over.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Limitations</name>
        <t>Babel has two limitations that make it unsuitable for use in some
environments.  First, Babel relies on periodic routing table updates
rather than using a reliable transport; hence, in large, stable networks
it generates more traffic than protocols that only send updates when the
network topology changes.  In such networks, protocols such as OSPF <xref target="RFC2328" format="default"/>, IS-IS <xref target="IS-IS" format="default"/>, or the Enhanced Interior
Gateway Routing Protocol (EIGRP) <xref target="EIGRP" format="default"/> might be more
suitable.</t>
        <t>Second, unless the second algorithm described in <xref target="hold-time" format="default"/>
is implemented, Babel does impose a hold time when a prefix is retracted.
While this hold time does not apply to the exact prefix being retracted,
and hence does not prevent fast reconvergence should it become available
again, it does apply to any shorter prefix that covers it.  This may make
those implementations of Babel that do not implement the optional
algorithm described in <xref target="hold-time" format="default"/> unsuitable for use in
networks that implement automatic prefix aggregation.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Specification of Requirements</name>
<t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119" format="default"/> 
    <xref target="RFC8174" format="default"/> when, and only when, 
    they appear in all capitals, as shown here.
</t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Conceptual Description of the Protocol</name>
      <t>Babel is a loop-avoiding distance-vector protocol: it is based on the
Bellman-Ford algorithm, just like the venerable RIP <xref target="RFC2453" format="default"/>,
but includes a number of refinements that either prevent loop formation
altogether, or ensure that a loop disappears in a timely manner and
doesn't form again.</t>
      <t>Conceptually, Bellman-Ford is executed in parallel for every source of
routing information (destination of data traffic).  In the following
discussion, we fix a source S; the reader will recall that the same
algorithm is executed for all sources.</t>
      <section numbered="true" toc="default">
        <name>Costs, Metrics, and Neighbourship</name>
        <t>For every pair of neighbouring nodes A and B, Babel computes an
abstract value known as the cost of the link from A to B, written
C(A,&nbsp;B).  Given a route between any two (not necessarily
neighbouring) nodes, the metric of the route is the sum of the costs of
all the links along the route.  The goal of the routing algorithm is to
compute, for every source S, the tree of routes of lowest metric to S.</t>
        <t>Costs and metrics need not be integers.  In general, they can be values
in any algebra that satisfies two fairly general conditions
(<xref target="metric-computation" format="default"/>).</t>
        <t>A Babel node periodically sends Hello messages to all of its
neighbours; it also periodically sends an IHU ("I Heard You") message to
every neighbour from which it has recently heard a Hello.  From the
information derived from Hello and IHU messages received from its neighbour
B, a node A computes the cost C(A,&nbsp;B) of the link from A to B.</t>
      </section>
      <section numbered="true" toc="default">
        <name>The Bellman-Ford Algorithm</name>
        <t>Every node A maintains two pieces of data: its estimated distance to S,
written D(A), and its next-hop router to S, written NH(A).  Initially, D(S)
= 0, D(A) is infinite, and NH(A) is undefined.</t>
        <t>Periodically, every node B sends to all of its neighbours a route
update, a message containing D(B).  When a neighbour A of B receives the
route update, it checks whether B is its selected next hop; if that is the
case, then NH(A) is set to B, and D(A) is set to C(A, B) + D(B).  If that
is not the case, then A compares C(A, B) + D(B) to its current value of
D(A).  If that value is smaller, meaning that the received update
advertises a route that is better than the currently selected route, then
NH(A) is set to B, and D(A) is set to C(A, B) + D(B).</t>
        <t>A number of refinements to this algorithm are possible, and are used by
Babel.  In particular, convergence speed may be increased by sending
unscheduled "triggered updates" whenever a major change in the topology is
detected, in addition to the regular, scheduled updates.  Additionally,
a node may maintain a number of alternate routes, which are being
advertised by neighbours other than its selected neighbour, and which can
be used immediately if the selected route were to fail.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Transient Loops in Bellman-Ford</name>
        <t>It is well known that a naive application of Bellman-Ford to distributed
routing can cause transient loops after a topology change.  Consider for
example the following topology:
</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
         B
      1 /|
   1   / |
S --- A  |1
       \ |
      1 \|
         C
]]></artwork>
        <t>
After convergence, D(B) = D(C) = 2, with NH(B) = NH(C) = A.</t>
        <t>Suppose now that the link between S and A fails:
</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
         B
      1 /|
       / |
S     A  |1
       \ |
      1 \|
         C
]]></artwork>
        <t>When it detects the failure of the link, A switches its next hop to
B (which is still advertising a route to S with metric 2), and advertises
a metric equal to 3, and then advertises a new route with metric 3.  This
process of nodes changing selected neighbours and increasing their metric
continues until the advertised metric reaches "infinity", a value larger
than all the metrics that the routing protocol is able to carry.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Feasibility Conditions</name>
        <t>Bellman-Ford is a very robust algorithm: its convergence properties
are preserved when routers delay route acquisition or when they
discard some updates.  Babel routers discard received route
announcements unless they can prove that accepting them cannot
possibly cause a routing loop.</t>
        <t>More formally, we define a condition over route announcements, known as
the "feasibility condition", that guarantees the absence of routing loops
whenever all routers ignore route updates that do not satisfy the
feasibility condition.  In effect, this makes Bellman-Ford into a family
of routing algorithms, parameterised by the feasibility condition.</t>
        <t>Many different feasibility conditions are possible.  For example, BGP
can be modelled as being a distance-vector protocol with a (rather
drastic) feasibility condition: a routing update is only accepted when the
receiving node's AS number is not included in the update's AS_PATH
attribute (note that BGP's feasibility condition does not ensure the
absence of transient "micro-loops" during reconvergence).</t>
        <t>Another simple feasibility condition, used in the Destination-Sequenced
Distance-Vector (DSDV) routing protocol <xref target="DSDV" format="default"/> and in the
Ad hoc On-Demand Distance Vector (AODV) protocol <xref target="RFC3561" format="default"/>,
stems from the following observation: a routing loop can only arise after
a router has switched to a route with a larger metric than the route that
it had previously selected.  Hence, one may define that a route is
feasible when its metric at the local node would be no larger than
the metric of the currently selected route, i.e., an announcement carrying
a metric D(B) is accepted by A when C(A, B) + D(B) &lt;= D(A).  If all
routers obey this constraint, then the metric at every router is
nonincreasing, and the following invariant is always preserved: if A has
selected B as its next hop, then D(B) &lt; D(A), which implies that the
forwarding graph is loop-free.</t>
        <t>Babel uses a slightly more refined feasibility condition, derived from
EIGRP <xref target="DUAL" format="default"/>.  Given a router A, define the feasibility
distance of A, written FD(A), as the smallest metric that A has ever
advertised for S to any of its neighbours.  An update sent by a neighbour
B of A is feasible when the metric D(B) advertised by B is strictly
smaller than A's feasibility distance, i.e., when D(B) &lt; FD(A).</t>
        <t>It is easy to see that this latter condition is no more restrictive than
DSDV-feasibility.  Suppose that node A obeys DSDV-feasibility; then D(A) is
nonincreasing, hence at all times D(A) &lt;= FD(A).  Suppose now that
A receives a DSDV-feasible update that advertises a metric D(B).  Since the
update is DSDV-feasible, C(A, B) + D(B) &lt;= D(A), hence D(B) &lt; D(A),
and since D(A) &lt;= FD(A), D(B) &lt; FD(A).</t>
        <t>To see that it is strictly less restrictive, consider the following
diagram, where A has selected the route through B, and D(A) = FD(A) = 2.
Since D(C) = 1 &lt; FD(A), the alternate route through C is feasible for A,
although its metric C(A, C) + D(C) = 5 is larger than that of the
currently selected route:
</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   B
1 / \ 1
 /   \
S     A
 \   /
1 \ / 4
   C
]]></artwork>
        <t>To show that this feasibility condition still guarantees loop-freedom,
recall that at the time when A accepts an update from B, the metric D(B)
announced by B is no smaller than FD(B); since it is smaller than FD(A),
at that point in time FD(B) &lt; FD(A).  Since this property is preserved
when A sends updates and also when it picks a different next hop, it
remains true at all times, which ensures that the forwarding graph has no
loops.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Solving Starvation: Sequencing Routes</name>
        <t>Obviously, the feasibility conditions defined above cause starvation
when a router runs out of feasible routes.  Consider the following diagram,
where both A and B have selected the direct route to S:
</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   A
1 /|        D(A) = 1
 / |       FD(A) = 1
S  |1
 \ |        D(B) = 2
2 \|       FD(B) = 2
   B
]]></artwork>
        <t>Suppose now that the link between A and S breaks:
</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   A
   |
   |       FD(A) = 1
S  |1
 \ |        D(B) = 2
2 \|       FD(B) = 2
   B
]]></artwork>
        <t>The only route available from A to S, the one that goes through B, is
not feasible: A suffers from spurious starvation.  At that point, the
whole subtree suffering from starvation must be reset, which is
essentially what EIGRP does when it performs a global synchronisation of
all the routers in the starving subtree (the "active" phase of EIGRP).</t>
        <t>Babel reacts to starvation in a less drastic manner, by using sequenced
routes, a technique introduced by DSDV and adopted by AODV.  In addition to
a metric, every route carries a sequence number, a nondecreasing integer
that is propagated unchanged through the network and is only ever
incremented by the source; a pair (s, m), where s is a sequence number and
m a metric, is called a distance.</t>
        <t>A received update is feasible when either it is more recent than the
feasibility distance maintained by the receiving node, or it is equally
recent and the metric is strictly smaller.  More formally, if FD(A) =
(s,&nbsp;m), then an update carrying the distance (s',&nbsp;m') is feasible
when either s' &gt; s, or s = s' and m' &lt; m.</t>
        <t>Assuming the sequence number of S is 137, the diagram above becomes:
</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   A
   |
   |       FD(A) = (137, 1)
S  |1
 \ |        D(B) = (137, 2)
2 \|       FD(B) = (137, 2)
   B
]]></artwork>
        <t>After S increases its sequence number, and the new sequence number is
propagated to B, we have:
</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   A
   |
   |       FD(A) = (137, 1)
S  |1
 \ |        D(B) = (138, 2)
2 \|       FD(B) = (138, 2)
   B
]]></artwork>
        <t>
at which point the route through B becomes feasible again.</t>
        <t>Note that while sequence numbers are used for determining feasibility,
they are not used in route selection: a node ignores the sequence number
when selecting the best route to a given destination
(<xref target="route-selection" format="default"/>).  Doing otherwise would cause
route oscillation while a sequence number propagates through the network,
and might even cause persistent black-holes with some exotic metrics.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Requests</name>
        <t>In DSDV, the sequence number of a source is increased periodically.
A route becomes feasible again after the source increases its sequence
number, and the new sequence number is propagated through the network,
which may, in general, require a significant amount of time.</t>
        <t>Babel takes a different approach.  When a node detects that it is
suffering from a potentially spurious starvation, it sends an explicit
request to the source for a new sequence number.  This request is forwarded
hop by hop to the source, with no regard to the feasibility condition.
Upon receiving the request, the source increases its sequence number and
broadcasts an update, which is forwarded to the requesting node.</t>
        <t>Note that after a change in network topology not all such requests
will, in general, reach the source, as some will be sent over links that
are now broken.  However, if the network is still connected, then at least
one among the nodes suffering from spurious starvation has an (unfeasible)
route to the source; hence, in the absence of packet loss, at least one
such request will reach the source.  (Resending requests a small number of
times compensates for packet loss.)</t>
        <t>Since requests are forwarded with no regard to the feasibility
condition, they may, in general, be caught in a forwarding loop; this is
avoided by having nodes perform duplicate detection for the requests that
they forward.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Multiple Routers</name>
        <t>The above discussion assumes that each prefix is originated by a single
router.  In real networks, however, it is often necessary to have a single
prefix originated by multiple routers: for example, the default route will
be originated by all of the edge routers of a routing domain.</t>
        <t>Since synchronising sequence numbers between distinct routers is
problematic, Babel treats routes for the same prefix as distinct entities
when they are originated by different routers: every route announcement
carries the router-id of its originating router, and feasibility distances
are not maintained per prefix, but per source, where a source is a pair of
a router-id and a prefix.  In effect, Babel guarantees loop-freedom for the
forwarding graph to every source; since the union of multiple acyclic
graphs is not in general acyclic, Babel does not in general guarantee
loop-freedom when a prefix is originated by multiple routers, but any
loops will be broken in a time at most proportional to the diameter of the
loop -- as soon as an update has "gone around" the routing loop.</t>
        <t>Consider for example the following topology, where A has selected the
default route through S, and B has selected the one through S':
</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
           1     1     1
::/0 -- S --- A --- B --- S' -- ::/0
]]></artwork>
        <t>Suppose that both default routes fail at the same time; then nothing
prevents A from switching to B, and B simultaneously switching to A.
However, as soon as A has successfully advertised the new route to B, the
route through A will become unfeasible for B.  Conversely, as soon as
B will have advertised the route through A, the route through B will
become unfeasible for A.</t>
        <t>In effect, the routing loop disappears at the latest when routing
information has gone around the loop.  Since this process can be delayed by
lost packets, Babel makes certain efforts to ensure that updates are sent
reliably after a router-id change (<xref target="triggered-updates" format="default"/>).</t>
        <t>Additionally, after the routers have advertised the two routes, both
sources will be in their source tables, which will prevent them from ever
again participating in a routing loop involving routes from S and S' (up to
the source GC time, which, available memory permitting, can be set to
arbitrarily large values).</t>
      </section>
      <section anchor="overlapping-prefixes" numbered="true" toc="default">
        <name>Overlapping Prefixes</name>
        <t>In the above discussion, we have assumed that all prefixes are disjoint,
as is the case in flat ("mesh") routing.  In practice, however, prefixes
may overlap: for example, the default route overlaps with all of the routes
present in the network.</t>
        <t>After a route fails, it is not correct in general to switch to a route
that subsumes the failed route.  Consider for example the following
configuration:
</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
           1     1
::/0 -- A --- B --- C
]]></artwork>
        <t>Suppose that node C fails.  If B forwards packets destined to C by
following the default route, a routing loop will form, and persist until
A learns of B's retraction of the direct route to C.  B avoids this
pitfall by installing an "unreachable" route after a route is retracted;
this route is maintained until it can be guaranteed that the former route
has been retracted by all of B's neighbours (<xref target="hold-time" format="default"/>).</t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Protocol Operation</name>
      <t>Every Babel speaker is assigned a router-id, which is an arbitrary
string of 8 octets that is assumed unique across the routing domain.  For
example, router-ids could be assigned randomly, or they could be derived
from a link-layer address.  (The protocol encoding is slightly more
compact when router-ids are assigned in the same manner as the IPv6 layer
assigns host IDs; see the definition of the "R" flag in
<xref target="update" format="default"/>.)</t>
      <section anchor="transmission-reception" numbered="true" toc="default">
        <name>Message Transmission and Reception</name>
        <t>Babel protocol packets are sent in the body of a UDP datagram (as
described in <xref target="protocol-encoding" format="default"/>).  Each Babel packet
consists of zero or more TLVs.  Most TLVs may contain sub-TLVs.</t>
        <t>Babel's control traffic can be carried indifferently over IPv6
or over IPv4, and prefixes of either address family can be announced over
either protocol.  Thus, there are at least two natural deployment models:
using IPv6 exclusively for all control traffic, or running two distinct
protocol instances, one for each address family.  The exclusive use of
IPv6 for all control traffic is <bcp14>RECOMMENDED</bcp14>, since using both protocols at
the same time doubles the amount of traffic devoted to neighbour discovery
and link quality estimation.</t>
        <t>The source address of a Babel packet is always a unicast address,
link-local in the case of IPv6.  Babel packets may be sent to a well-known
(link-local) multicast address or to a (link-local) unicast address.  In
normal operation, a Babel speaker sends both multicast and unicast packets
to its neighbours.</t>

        <t>With the exception of acknowledgments, all Babel TLVs
can be sent to either unicast or multicast addresses, and their semantics
does not depend on whether the destination is a unicast or a multicast
address.  Hence, a Babel speaker does not need to determine the destination
address of a packet that it receives in order to interpret it.</t>
        <t>A moderate amount of jitter may be applied to packets sent by a Babel
speaker: outgoing TLVs are buffered and <bcp14>SHOULD</bcp14> be sent with a random
delay.  This is done for two purposes: it avoids synchronisation of
multiple Babel speakers across a network <xref target="JITTER" format="default"/>, and it
allows for the aggregation of multiple TLVs into a single packet.</t>
        <t>The maximum amount of delay a TLV can be subjected to depends on the
TLV.  When the protocol description specifies that a TLV is urgent (as in
<xref target="triggered-updates" format="default"/> and <xref target="handling-requests" format="default"/>),
then the TLV <bcp14>MUST</bcp14> be sent within a short time known as the urgent timeout
(see <xref target="parameters" format="default"/> for recommended values).  When the TLV is
governed by a timeout explicitly included in a previous TLV, such as in
the case of Acknowledgments (<xref target="ack" format="default"/>),
Updates (<xref target="sending-updates" format="default"/>), and IHUs
(<xref target="bidirectional-reachability" format="default"/>), then the TLV <bcp14>MUST</bcp14> be sent
early enough to meet the explicit deadline (with a small margin to allow
for propagation delays).  In all other cases, the TLV <bcp14>SHOULD</bcp14> be sent out
within one-half of the Multicast Hello interval.</t>
        <t>In order to avoid packet drops (either at the sender or at the
receiver), a delay <bcp14>SHOULD</bcp14> be introduced between successive packets sent
out on the same interface, within the constraints of the previous
paragraph.  Note, however, that such packet pacing might impair the ability
of some link layers (e.g., IEEE&nbsp;802.11 <xref target="IEEE802.11" format="default"/>)
to perform packet aggregation.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Data Structures</name>
        <t>In this section, we describe the data structures that
every Babel speaker maintains.  This description is conceptual: a Babel
speaker may use different data structures as long as the resulting
protocol is the same as the one described in this document.  For example,
rather than maintaining a single table containing both selected and
unselected (fallback) routes, as described in <xref target="route-table" format="default"/>, 
an actual implementation would probably use two tables, one with
selected routes and one with fallback routes.</t>
        <section anchor="sequence-number" numbered="true" toc="default">
          <name>Sequence Number Arithmetic</name>
          <t>Sequence numbers (seqnos) appear in a number of Babel data structures,
and they are interpreted as integers modulo 2<sup>16</sup>.  For the purposes of
this document, arithmetic on sequence numbers is defined as follows.</t>
          <t>Given a seqno s and a non-negative integer n, the sum of s and n is
defined by the following:
</t>
            <t indent="3">s + n (modulo 2<sup>16</sup>) = (s + n) MOD 2<sup>16</sup></t>
          <t>
or, equivalently,
</t>
            <t indent="3">s + n (modulo 2<sup>16</sup>) = (s + n) AND 65535</t>
          <t>
where MOD is the modulo operation yielding a non-negative integer, and AND is
the bitwise conjunction operation.</t>
          <t>Given two sequence numbers s and s', the relation s is less than s'
(s&nbsp;&lt;&nbsp;s') is defined by the following:
</t>
            <t indent="3">s &lt; s' (modulo 2<sup>16</sup>) when 0 &lt; ((s' - s) MOD 2<sup>16</sup>) &lt; 32768 </t>
          <t>
or, equivalently,
</t>
            <t indent="3">s &lt; s' (modulo 2<sup>16</sup>) when s /= s' and ((s' - s) AND 32768) = 0.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Node Sequence Number</name>
          <t>A node's sequence number is a 16-bit integer that is included in route
updates sent for routes originated by this node.</t>
          <t>A node increments its sequence number (modulo 2<sup>16</sup>) whenever it
receives a request for a new sequence number (<xref target="handling-seqno-requests" format="default"/>).  A node <bcp14>SHOULD NOT</bcp14> increment its
sequence number (seqno) spontaneously, since increasing seqnos makes it
less likely that other nodes will have feasible alternate routes when
their selected routes fail.</t>
        </section>
        <section numbered="true" toc="default">
          <name>The Interface Table</name>
          <t>The interface table contains the list of interfaces on which the node
speaks the Babel protocol.  Every interface table entry contains the
interface's outgoing Multicast Hello seqno, a 16-bit integer that is sent
with each Multicast Hello TLV on this interface and is incremented (modulo
2<sup>16</sup>) whenever a Multicast Hello is sent.  (Note that an interface's
Multicast Hello seqno is unrelated to the node's seqno.)</t>
          <t>There are two timers associated with each interface table entry.
The periodic multicast hello timer governs the sending of scheduled
Multicast Hello and IHU packets (<xref target="neighbour-acquisition" format="default"/>).
The periodic Update timer governs the sending of periodic route updates
(<xref target="periodic-updates" format="default"/>).  See <xref target="parameters" format="default"/> for
suggested time constants.</t>
        </section>
        <section numbered="true" toc="default">
          <name>The Neighbour Table</name>
          <t>The neighbour table contains the list of all neighbouring interfaces
from which a Babel packet has been recently received.  The neighbour table
is indexed by pairs of the form (interface, address), and every neighbour table
entry contains the following data:
</t>
          <ul spacing="normal">
            <li>the local node's interface over which this neighbour is reachable;</li>
            <li>the address of the neighbouring interface;</li>
            <li>a history of recently received Multicast Hello packets from this
neighbour; this can, for example, be a sequence of n bits, for some small
value n, indicating which of the n hellos most recently sent by this
neighbour have been received by the local node;</li>
            <li>a history of recently received Unicast Hello packets from this neighbour;</li>
            <li>the "transmission cost" value from the last IHU packet received from
this neighbour, or FFFF hexadecimal (infinity) if the IHU hold timer for
this neighbour has expired;</li>
            <li>the expected incoming Multicast Hello sequence number for this neighbour,
an integer modulo 2<sup>16</sup>.</li>
            <li>the expected incoming Unicast Hello sequence number for this neighbour,
an integer modulo 2<sup>16</sup>.</li>
            <li>the outgoing Unicast Hello sequence number for this neighbour, an integer
modulo 2<sup>16</sup> that is sent with each Unicast Hello TLV to this neighbour and
is incremented (modulo 2<sup>16</sup>) whenever a Unicast Hello is sent.  (Note that
the outgoing Unicast Hello seqno for a neighbour is distinct from the
interface's outgoing Multicast Hello seqno.)</li>
          </ul>
          <t>There are three timers associated with each neighbour entry -- the
multicast hello timer, which is set to the interval value carried by
scheduled Multicast Hello TLVs sent by this neighbour, the unicast hello
timer, which is set to the interval value carried by scheduled Unicast
Hello TLVs, and the IHU timer, which is set to a small multiple of the
interval carried in IHU TLVs (see "IHU Hold time" in
<xref target="parameters" format="default"/> for suggested values).</t>
          <t>Note that the neighbour table is indexed by IP addresses, not by
router-ids: neighbourship is a relationship between interfaces, not between
nodes.  Therefore, two nodes with multiple interfaces can participate in
multiple neighbourship relationships, a situation that can notably arise
when wireless nodes with multiple radios are involved.</t>
        </section>
        <section numbered="true" toc="default">
          <name>The Source Table</name>
          <t>The source table is used to record feasibility distances.  It is indexed
by triples of the form (prefix, plen, router-id), and every source table
entry contains the following data:
</t>
          <ul spacing="normal">
            <li>the prefix (prefix, plen), where plen is the prefix length in bits,
that this entry applies to;</li>
            <li>the router-id of a router originating this prefix;</li>
            <li>a pair (seqno, metric), this source's feasibility distance.</li>
          </ul>
          <t>There is one timer associated with each entry in the source table
-- the source garbage-collection timer.  It is initialised to a time
on the order of minutes and reset as specified in <xref target="maintaining-fd" format="default"/>.</t>
        </section>
        <section anchor="route-table" numbered="true" toc="default">
          <name>The Route Table</name>
          <t>The route table contains the routes known to this node.  It is indexed
by triples of the form (prefix, plen, neighbour), and every route table
entry contains the following data:
</t>
          <ul spacing="normal">
            <li>the source (prefix, plen, router-id) for which this route is advertised;</li>
            <li>the neighbour (an entry in the neighbour table) that advertised this
route;</li>
            <li>the metric with which this route was advertised by the neighbour, or
FFFF hexadecimal (infinity) for a recently retracted route;</li>
            <li>the sequence number with which this route was advertised;</li>
            <li>the next-hop address of this route;</li>
            <li>a boolean flag indicating whether this route is selected, i.e., whether
it is currently being used for forwarding and is being advertised.</li>
          </ul>
          <t>There is one timer associated with each route table entry -- the
route expiry timer.  It is initialised and reset as specified in
<xref target="route-acquisition" format="default"/>.</t>
          <t>Note that there are two distinct (seqno, metric) pairs associated with 
each route: the route's distance, which is stored in the route table, and
the feasibility distance, which is stored in the source table and shared between
all routes with the same source.</t>
        </section>
        <section numbered="true" toc="default">
          <name>The Table of Pending Seqno Requests</name>
          <t>The table of pending seqno requests contains a list of seqno requests
that the local node has sent (either because they have been originated
locally, or because they were forwarded) and to which no reply has been
received yet.  This table is indexed by triples of the form (prefix, plen,
router-id), and every entry in this table contains the following data:
</t>
          <ul spacing="normal">
            <li>the prefix, plen, router-id, and seqno being requested;</li>
            <li>the neighbour, if any, on behalf of which we are forwarding this
request;</li>
            <li>a small integer indicating the number of times that this request will be
resent if it remains unsatisfied.</li>
          </ul>
          <t>There is one timer associated with each pending seqno request; it governs
both the resending of requests and their expiry.</t>
        </section>
      </section>
      <section anchor="acknowledgments" numbered="true" toc="default">
        <name>Acknowledgments and Acknowledgment Requests</name>
        <t>A Babel speaker may request that a neighbour receiving a given packet
reply with an explicit acknowledgment within a given time.  While the use
of acknowledgment requests is optional, every Babel speaker <bcp14>MUST</bcp14> be able
to reply to such a request.</t>
        <t>An acknowledgment <bcp14>MUST</bcp14> be sent to a unicast destination.  On the other
hand, acknowledgment requests may be sent to either unicast or multicast
destinations, in which case they request an acknowledgment from all of the
receiving nodes.</t>
        <t>When to request acknowledgments is a matter of local policy; the
simplest strategy is to never request acknowledgments and to rely on
periodic updates to ensure that any reachable routes are eventually
propagated throughout the routing domain.  In order to improve convergence
speed and to reduce the amount of control traffic, acknowledgment requests
<bcp14>MAY</bcp14> be used in order to reliably send urgent updates (<xref target="triggered-updates" format="default"/>) and retractions (<xref target="hold-time" format="default"/>),
especially when the number of neighbours on a given interface is small.
Since Babel is designed to deal gracefully with packet loss on unreliable
media, sending all packets with acknowledgment requests is not necessary
and <bcp14>NOT RECOMMENDED</bcp14>, as the acknowledgments cause additional traffic and
may force additional Address Resolution Protocol (ARP) or Neighbour
Discovery (ND) exchanges.</t>
      </section>
      <section anchor="neighbour-acquisition" numbered="true" toc="default">
        <name>Neighbour Acquisition</name>
        <t>Neighbour acquisition is the process by which a Babel node discovers the
set of neighbours heard over each of its interfaces and ascertains
bidirectional reachability.  On unreliable media, neighbour acquisition
additionally provides some statistics that may be useful for link quality
computation.</t>
        <t>Before it can exchange routing information with a neighbour, a Babel
node <bcp14>MUST</bcp14> create an entry for that neighbour in the neighbour table.  When
to do that is implementation-specific; suitable strategies include
creating an entry when any Babel packet is received, or creating an entry
when a Hello TLV is parsed.  Similarly, in order to conserve system
resources, an implementation <bcp14>SHOULD</bcp14> discard an entry when it has been
unused for long enough; suitable strategies include dropping the neighbour
after a timeout, and dropping a neighbour when the associated Hello
histories become empty (see <xref target="cost-computation-examples" format="default"/>).</t>
        <section anchor="reverse-reachability" numbered="true" toc="default">
          <name>Reverse Reachability Detection</name>
          <t>Every Babel node sends Hello TLVs to its neighbours, at regular or irregular intervals, to indicate that it
is alive.  Each Hello TLV carries an
increasing (modulo 2<sup>16</sup>) sequence number and an upper bound on the time
interval until the next Hello of the same type (see below).  If the time
interval is set to 0, then the Hello TLV does not establish a new promise:
the deadline carried by the previous Hello of the same type still applies
to the next Hello (if the most recent scheduled Hello of the right kind
was received at time t0 and carried interval i, then the previous promise
of sending another Hello before time t0&nbsp;+&nbsp;i still holds).  We
say that a Hello is "scheduled" if it carries a nonzero interval, and
"unscheduled" otherwise.</t>
          <t>There are two kinds of Hellos: Multicast Hellos, which use
a per-interface Hello counter (the Multicast Hello seqno), and Unicast
Hellos, which use a per-neighbour counter (the Unicast Hello seqno).
A Multicast Hello with a given seqno <bcp14>MUST</bcp14> be sent to all neighbours on
a given interface, either by sending it to a multicast address or by
sending it to one unicast address per neighbour (hence, the term
"Multicast Hello" is a slight misnomer).  A Unicast Hello carrying a given
seqno should normally be sent to just one neighbour (over unicast), since
the sequence numbers of different neighbours are not in general
synchronised.</t>
          <t>Multicast Hellos sent over multicast can be used for neighbour
discovery; hence, a node <bcp14>SHOULD</bcp14> send periodic (scheduled) Multicast Hellos
unless neighbour discovery is performed by means outside of the Babel
protocol.  A node <bcp14>MAY</bcp14> send Unicast Hellos or unscheduled Hellos of either
kind for any reason, such as reducing the amount of multicast traffic or
improving reliability on link technologies with poor support for
link-layer multicast.</t>
          <t>A node <bcp14>MAY</bcp14> send a scheduled Hello ahead of time.  A node <bcp14>MAY</bcp14> change its
scheduled Hello interval.  The Hello interval <bcp14>MAY</bcp14> be decreased at any
time; it <bcp14>MAY</bcp14> be increased immediately before sending a Hello TLV, but
<bcp14>SHOULD NOT</bcp14> be increased at other times.  (Equivalently, a node <bcp14>SHOULD</bcp14> send
a scheduled Hello immediately after increasing its Hello interval.)</t>
          <t>How to deal with received Hello TLVs and what statistics to maintain
are considered local implementation matters; typically, a node will
maintain some sort of history of recently received Hellos.  An example of
a suitable algorithm is described in <xref target="hello-history" format="default"/>.</t>
          <t>After receiving a Hello, or determining that it has missed one, the node
recomputes the association's cost (<xref target="cost-computation" format="default"/>) and
runs the route selection procedure (<xref target="route-selection" format="default"/>).</t>
        </section>
        <section anchor="bidirectional-reachability" numbered="true" toc="default">
          <name>Bidirectional Reachability Detection</name>
          <t>In order to establish bidirectional reachability, every node sends
periodic IHU ("I Heard You") TLVs to each of its neighbours.  Since IHUs
carry an explicit interval value, they <bcp14>MAY</bcp14> be sent less often than Hellos
in order to reduce the amount of routing traffic in dense networks; in
particular, they <bcp14>SHOULD</bcp14> be sent less often than Hellos over links with
little packet loss.  While IHUs are conceptually unicast, they <bcp14>MAY</bcp14> be
sent to a multicast address in order to avoid an ARP or Neighbour Discovery
exchange and to aggregate multiple IHUs into a single packet.</t>
          <t>In addition to the periodic IHUs, a node <bcp14>MAY</bcp14>, at any time, send an
unscheduled IHU packet.  It <bcp14>MAY</bcp14> also, at any time, decrease its IHU
interval, and it <bcp14>MAY</bcp14> increase its IHU interval immediately before sending
an IHU, but <bcp14>SHOULD NOT</bcp14> increase it at any other time.  (Equivalently,
a node <bcp14>SHOULD</bcp14> send an extra IHU immediately after increasing its Hello
interval.)</t>
          <t>Every IHU TLV contains two pieces of data: the link's rxcost (reception
cost) from the sender's perspective, used by the neighbour for computing
link costs (<xref target="cost-computation" format="default"/>), and the interval between
periodic IHU packets.  A node receiving an IHU sets the value of the
txcost (transmission cost) maintained in the neighbour table to the value
contained in the IHU, and resets the IHU timer associated to this
neighbour to a small multiple of the interval value received in the IHU
(see "IHU Hold time" in <xref target="parameters" format="default"/> for suggested values).
When a neighbour's IHU timer expires, the neighbour's txcost is set to
infinity.</t>
          <t>After updating a neighbour's txcost, the receiving node recomputes the
neighbour's cost (<xref target="cost-computation" format="default"/>) and runs the route
selection procedure (<xref target="route-selection" format="default"/>).</t>
        </section>
        <section anchor="cost-computation" numbered="true" toc="default">
          <name>Cost Computation</name>
          <t>A neighbourship association's link cost is computed from the values
maintained in the neighbour table: the statistics kept in the neighbour
table about the reception of Hellos, and the txcost computed from received
IHU packets.</t>
          <t>For every neighbour, a Babel node computes a value known as this
neighbour's rxcost.  This value is usually derived from the Hello history,
which may be combined with other data, such as statistics maintained by
the link layer.  The rxcost is sent to a neighbour in each IHU.</t>
          <t>Since nodes do not necessarily send periodic Unicast Hellos but do
usually send periodic Multicast Hellos (<xref target="reverse-reachability" format="default"/>),
a node <bcp14>SHOULD</bcp14> use an algorithm that yields a finite rxcost when only
Multicast Hellos are received, unless interoperability with nodes that
only send Multicast Hellos is not required.</t>
          <t>How the txcost and rxcost are combined in order to compute a link's
cost is a matter of local policy; as far as Babel's correctness is
concerned, only the following conditions <bcp14>MUST</bcp14> be satisfied:
</t>
          <ul spacing="normal">
            <li>the cost is strictly positive;</li>
            <li>if no Hello TLVs of either kind were received recently, then the cost
  is infinite;</li>
            <li>if the txcost is infinite, then the cost is infinite.</li>
          </ul>
          <t>See <xref target="cost-computation-examples" format="default"/> for <bcp14>RECOMMENDED</bcp14>
strategies for computing a link's cost.</t>
        </section>
      </section>
      <section anchor="route-maintenance" numbered="true" toc="default">
        <name>Routing Table Maintenance</name>
        <t>Conceptually, a Babel update is a quintuple (prefix, plen, router-id,
seqno, metric), where (prefix, plen) is the prefix for which a route is
being advertised, router-id is the router-id of the router originating this
update, seqno is a nondecreasing (modulo 2<sup>16</sup>) integer that carries the
originating router seqno, and metric is the announced metric.</t>
        <t>Before being accepted, an update is checked against the feasibility
condition (<xref target="feasibility-condition" format="default"/>), which ensures that the
route does not create a routing loop.  If the feasibility condition is not
satisfied, the update is either ignored or prevents the route from being
selected, as described in <xref target="route-acquisition" format="default"/>.  If the
feasibility condition is satisfied, then the update cannot possibly cause
a routing loop.</t>
        <section anchor="feasibility-condition" numbered="true" toc="default">
          <name>The Feasibility Condition</name>
          <t>The feasibility condition is applied to all received updates.  The
feasibility condition compares the metric in the received update with the
metrics of the updates previously sent by the receiving node; updates that
fail the feasibility condition, and therefore have metrics large enough to
cause a routing loop, are either ignored or prevent the resulting route
from being selected.</t>
          <t>A feasibility distance is a pair (seqno, metric), where seqno is an
integer modulo 2<sup>16</sup> and metric is a positive integer.  Feasibility
distances are compared lexicographically, with the first component
inverted: we say that a distance (seqno, metric) is strictly better than
a distance (seqno', metric'), written
</t>
            <t indent="3">(seqno, metric) &lt; (seqno', metric')</t>
          <t>
when
</t>
            <t indent="3">seqno &gt; seqno' or (seqno = seqno' and metric &lt; metric')</t>
          <t>
where sequence numbers are compared modulo 2<sup>16</sup>.</t>
          <t>Given a source (prefix, plen, router-id), a node's feasibility distance
for this source is the minimum, according to the ordering defined above,
of the distances of all the finite updates ever sent by this particular
node for the prefix (prefix, plen) and the given router-id.  Feasibility
distances are maintained in the source table, the exact procedure is given
in <xref target="maintaining-fd" format="default"/>.</t>
          <t>A received update is feasible when either it is a retraction (its metric
is FFFF hexadecimal), or the advertised distance is strictly better, in the
sense defined above, than the feasibility distance for the corresponding
source.  More precisely, a route advertisement carrying the quintuple
(prefix, plen, router-id, seqno, metric) is feasible if one of the
following conditions holds:
</t>
          <ul spacing="normal">
            <li>metric is infinite; or</li>
            <li>no entry exists in the source table indexed by (prefix, plen, router-id);
  or</li>
            <li>
              <t>an entry (prefix, plen, router-id, seqno', metric') exists in the
    source table, and either
              </t>
              <ul spacing="normal">
                <li>seqno' &lt; seqno or</li>
                <li>seqno = seqno' and metric &lt; metric'.</li>
              </ul>
            </li>
          </ul>
          <t>Note that the feasibility condition considers the metric advertised by
the neighbour, not the route's metric; hence, a fluctuation in
a neighbour's cost cannot render a selected route unfeasible.  Note
further that retractions (updates with infinite metric) are always
feasible, since they cannot possibly cause a routing loop.</t>
        </section>
        <section anchor="metric-computation" numbered="true" toc="default">
          <name>Metric Computation</name>
          <t>A route's metric is computed from the metric advertised by the neighbour
and the neighbour's link cost.  Just like cost computation, metric
computation is considered a local policy matter; as far as Babel is
concerned, the function M(c,&nbsp;m) used for computing a metric from
a locally computed link cost c and the metric m advertised by a neighbour
<bcp14>MUST</bcp14> only satisfy the following conditions:
</t>
          <ul spacing="normal">
            <li>if c is infinite, then M(c, m) is infinite;</li>
            <li>M is strictly monotonic: M(c, m) &gt; m.</li>
          </ul>
          <t>
Additionally, the metric <bcp14>SHOULD</bcp14> satisfy the following condition:
</t>
          <ul spacing="normal">
            <li>M is left-distributive: if m &lt;= m', then M(c, m) &lt;= M(c, m').</li>
          </ul>
          <t>
While strict monotonicity is essential to the integrity of the network
(persistent routing loops may arise if it is not satisfied), 
left-distributivity is not: if it is not satisfied, Babel will still converge
to a loop-free configuration, but might not reach a global optimum (in
fact, a global optimum may not even exist).</t>
          <t>The conditions above are easily satisfied by using the additive metric,
i.e., by defining M(c,&nbsp;m)&nbsp;= c&nbsp;+&nbsp;m.  Since the additive
metric is useful with a large range of cost computation strategies, it is
the <bcp14>RECOMMENDED</bcp14> default.  See also <xref target="filtering" format="default"/>, which
describes a technique that makes it possible to tweak the values of
individual metrics without running the risk of creating routing loops.</t>
        </section>
        <section anchor="route-acquisition" numbered="true" toc="default">
          <name>Route Acquisition</name>
          <t>When a Babel node receives an update (prefix, plen, router-id, seqno,
metric) from a neighbour neigh, it checks whether it already has a route
table entry indexed by (prefix, plen, neigh).</t>
          <t>If no such entry exists:
</t>
          <ul spacing="normal">
            <li>if the update is unfeasible, it <bcp14>MAY</bcp14> be ignored;</li>
            <li>if the metric is infinite (the update is a retraction of a route we
  do not know about), the update is ignored;</li>
            <li>otherwise, a new entry is created in the route table, indexed by (prefix,
  plen, neigh), with source equal to (prefix, plen, router-id), seqno
  equal to seqno, and an advertised metric equal to the metric carried by
  the update.</li>
          </ul>
          <t>
If such an entry exists:
</t>
          <ul spacing="normal">
            <li>if the entry is currently selected, the update is unfeasible, and the
  router-id of the update is equal to the router-id of the entry, then the
  update <bcp14>MAY</bcp14> be ignored;</li>
            <li>otherwise, the entry's sequence number, advertised metric, metric,
  and router-id are updated, and if the advertised metric is not infinite,
  the route's expiry timer is reset to a small multiple of the interval
  value included in the update (see "Route Expiry time" in
  <xref target="parameters" format="default"/> for suggested values).  If the update is
  unfeasible, then the (now unfeasible) entry <bcp14>MUST</bcp14> be immediately
  unselected.  If the update caused the router-id of the entry to change,
  an update (possibly a retraction) <bcp14>MUST</bcp14> be sent in a timely manner as
  described in <xref target="triggered-updates" format="default"/>.</li>
          </ul>
          <t>
Note that the route table may contain unfeasible routes, either because
they were created by an unfeasible update or due to a metric fluctuation.
Such routes are never selected, since they are not known to be loop-free.
Should all the feasible routes become unusable, however, the unfeasible
routes can be made feasible and therefore possible to select by sending
requests along them (see <xref target="sending-requests" format="default"/>).</t>
          <t>When a route's expiry timer triggers, the behaviour depends on whether
the route's metric is finite.  If the metric is finite, it is set to
infinity and the expiry timer is reset.  If the metric is already infinite,
the route is flushed from the route table.</t>
          <t>After the route table is updated, the route selection procedure
(<xref target="route-selection" format="default"/>) is run.</t>
        </section>
        <section anchor="hold-time" numbered="true" toc="default">
          <name>Hold Time</name>
          <t>When a prefix P is retracted (because all routes are unfeasible or have
an infinite metric, whether due to the expiry timer or for other reasons),
and a shorter prefix P' that covers P is reachable, P' cannot in general
be used for routing packets destined to P without running the risk of
creating a routing loop (<xref target="overlapping-prefixes" format="default"/>).</t>
          <t>To avoid this issue, whenever a prefix P is retracted, a route table
entry with infinite metric is maintained as described in <xref target="route-acquisition" format="default"/>.  
As long as this entry is maintained,
packets destined to an address within P <bcp14>MUST NOT</bcp14> be forwarded by following
a route for a shorter prefix.  This entry is removed as soon as
a finite-metric update for prefix P is received and the resulting route
selected.  If no such update is forthcoming, the infinite metric entry
<bcp14>SHOULD</bcp14> be maintained at least until it is guaranteed that no neighbour has
selected the current node as next hop for prefix P.  This can be achieved
by either:
</t>
          <ul spacing="normal">
            <li>waiting until the route's expiry timer has expired 
                (<xref target="route-acquisition" format="default"/>); or</li>
            <li>sending a retraction with an acknowledgment request (<xref target="acknowledgments" format="default"/>) to every reachable neighbour that has not
explicitly retracted prefix P, and waiting for all acknowledgments.</li>
          </ul>
          <t>
The former option is simpler and ensures that, at that point, any routes
for prefix P pointing at the current node have expired.  However, since
the expiry time can be as high as a few minutes, doing that prevents
automatic aggregation by creating spurious black-holes for aggregated
routes.  The latter option is <bcp14>RECOMMENDED</bcp14> as it dramatically reduces the
time for which a prefix is unreachable in the presence of aggregated
routes.</t>
        </section>
      </section>
      <section anchor="route-selection" numbered="true" toc="default">
        <name>Route Selection</name>
        <t>Route selection is the process by which a single route for a given
prefix is selected to be used for forwarding packets and to be
re-advertised to a node's neighbours.</t>
        <t>Babel is designed to allow flexible route selection policies.  As far as
  the algorithm's correctness is concerned, the route selection policy <bcp14>MUST</bcp14>
  only satisfy the following properties:
</t>
        <ul spacing="normal">
          <li>a route with infinite metric (a retracted route) is never selected;</li>
          <li>an unfeasible route is never selected.</li>
        </ul>
        <t>
Babel nodes using different route selection strategies will interoperate
and will not create routing loops as long as these two properties hold.</t>
        <t>Route selection <bcp14>MUST NOT</bcp14> take seqnos into account: a route <bcp14>MUST NOT</bcp14> be
preferred just because it carries a higher (more recent) seqno.  Doing
otherwise would cause route oscillation while a new seqno propagates
across the network, and might create persistent black-holes if the metric
being used is not left-distributive (<xref target="metric-computation" format="default"/>).</t>
        <t>The obvious route selection strategy is to pick, for every destination,
the feasible route with minimal metric.  When all metrics are stable, this
approach ensures convergence to a tree of shortest paths (assuming that
the metric is left-distributive, see <xref target="metric-computation" format="default"/>).
There are two reasons, however, why this strategy may lead to instability
in the presence of continuously varying metrics.  First, if two parallel
routes oscillate around a common value, then the smallest metric strategy
will keep switching between the two.  
   Second, the selection of a route increases congestion along it,
   which might increase packet loss, which in turn could
   cause its metric to increase; this kind of feedback loop
   is prone to causing persistent oscillations.</t>
        <t>In order to limit these kinds of instabilities, a route selection
strategy <bcp14>SHOULD</bcp14> include some form of hysteresis, i.e., be sensitive to
a route's history: 
the strategy should only switch from the currently selected route
to a different route if the latter has been
consistently good for some period of time.  A <bcp14>RECOMMENDED</bcp14> hysteresis
algorithm is given in <xref target="route-selection-hysteresis" format="default"/>.</t>
        <t>After the route selection procedure is run, triggered updates
(<xref target="triggered-updates" format="default"/>) and requests
(<xref target="sending-requests" format="default"/>) are sent.</t>
      </section>
      <section anchor="sending-updates" numbered="true" toc="default">
        <name>Sending Updates</name>
        <t>A Babel speaker advertises to its neighbours its set of selected
routes.  Normally, this is done by sending one or more multicast packets
containing Update TLVs on all of its connected interfaces; however, on
link technologies where multicast is significantly more expensive than
unicast, a node <bcp14>MAY</bcp14> choose to send multiple copies of updates in unicast
packets, especially when the number of neighbours is small.</t>
        <t>Additionally, in order to ensure that any black-holes are reliably
cleared in a timely manner, a Babel node may send retractions (updates
with an infinite metric) for any recently retracted prefixes.</t>
        <t>If an update is for a route injected into the Babel domain by the local
node (e.g., it carries the address of a local interface, the prefix of
a directly attached network, or a prefix redistributed from a different
routing protocol), the router-id is set to the local node's router-id, the
metric is set to some arbitrary finite value (typically 0), and the seqno
is set to the local router's sequence number.</t>
        <t>If an update is for a route learnt from another Babel speaker, the
router-id and sequence number are copied from the route table entry, and
the metric is computed as specified in <xref target="metric-computation" format="default"/>.</t>
        <section anchor="periodic-updates" numbered="true" toc="default">
          <name>Periodic Updates</name>
          <t>Every Babel speaker <bcp14>MUST</bcp14> advertise each of its selected routes on every
interface, at least once every Update interval.  Since Babel doesn't
suffer from routing loops (there is no "counting to infinity") and relies
heavily on triggered updates (<xref target="triggered-updates" format="default"/>), this
full dump only needs to happen infrequently (see <xref target="parameters" format="default"/>
for suggested intervals).</t>
        </section>
        <section anchor="triggered-updates" numbered="true" toc="default">
          <name>Triggered Updates</name>
          <t>In addition to periodic routing updates, a Babel speaker sends
unscheduled, or triggered, updates in order to inform its neighbours of
a significant change in the network topology.</t>
          <t>A change of router-id for the selected route to a given prefix may be
indicative of a routing loop in formation; hence, whenever it changes the
selected router-id for a given destination, a node <bcp14>MUST</bcp14> send an update as
an urgent TLV (as defined in <xref target="transmission-reception" format="default"/>).
Additionally, it <bcp14>SHOULD</bcp14> make a reasonable attempt at ensuring that all
reachable neighbours receive this update.</t>
          <t>There are two strategies for ensuring that.  If the number of neighbours
is small, then it is reasonable to send the update together with an
acknowledgment request; the update is resent until all neighbours have
acknowledged the packet, up to some number of times.  If the number of
neighbours is large, however, requesting acknowledgments from all of them
might cause a non-negligible amount of network traffic; in that case, it
may be preferable to simply repeat the update some reasonable number of
times (say, 3 for wireless and 2 for wired links).  The number of copies
<bcp14>MUST NOT</bcp14> exceed 5, and the copies <bcp14>SHOULD</bcp14> be separated by a small delay, as
described in <xref target="transmission-reception" format="default"/>.</t>
          <t>A route retraction is somewhat less worrying: if the route retraction
doesn't reach all neighbours, a black-hole might be created, which, unlike
a routing loop, does not endanger the integrity of the network.  When a
route is retracted, a node <bcp14>SHOULD</bcp14> send a triggered update and <bcp14>SHOULD</bcp14> make
a reasonable attempt at ensuring that all neighbours receive this
retraction.</t>
          <t>Finally, a node <bcp14>MAY</bcp14> send a triggered update when the metric for a given
prefix changes in a significant manner, due to a received update, because
a link's cost has changed or because a different next hop has been
selected.  A node <bcp14>SHOULD NOT</bcp14> send triggered updates for other reasons,
such as when there is a minor fluctuation in a route's metric, when the
selected next hop changes without inducing a significant change to the
route's metric, or to propagate a new sequence number (except to satisfy
a request, as specified in <xref target="requests" format="default"/>).</t>
        </section>
        <section anchor="maintaining-fd" numbered="true" toc="default">
          <name>Maintaining Feasibility Distances</name>
          <t>Before sending an update (prefix, plen, router-id, seqno, metric) with
finite metric (i.e., not a route retraction), a Babel node updates the
feasibility distance maintained in the source table.  This is done as
follows.</t>
          <t>If no entry indexed by (prefix, plen, router-id) exists in the source
table, then one is created with value (prefix, plen, router-id, seqno,
metric).</t>
          <t>If an entry (prefix, plen, router-id, seqno', metric') exists, then it
is updated as follows:
</t>
          <ul spacing="normal">
            <li>if seqno &gt; seqno', then seqno' := seqno, metric' := metric;</li>
            <li>if seqno = seqno' and metric' &gt; metric, then metric' := metric;</li>
            <li>otherwise, nothing needs to be done.</li>
          </ul>
          <t>The garbage-collection timer for the entry is then reset.  Note that
the feasibility distance is not updated and the garbage-collection timer
is not reset when a retraction (an update with infinite metric) is
sent.</t>
          <t>When the garbage-collection timer expires, the entry is removed from
the source table.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Split Horizon</name>
          <t>When running over a transitive, symmetric link technology, e.g.,
a point-to-point link or a wired LAN technology such as Ethernet, a Babel
node <bcp14>SHOULD</bcp14> use an optimisation known as split horizon.  When split
horizon is used on a given interface, a routing update for prefix P is not
sent on the particular interface over which the selected route towards
prefix P was learnt.</t>
          <t>Split horizon <bcp14>SHOULD NOT</bcp14> be applied to an interface unless the interface
is known to be symmetric and transitive; in particular, split horizon is
not applicable to decentralised wireless link technologies
(e.g., IEEE 802.11 in ad hoc mode) when routing updates are sent over
multicast.</t>
        </section>
      </section>
      <section anchor="requests" numbered="true" toc="default">
        <name>Explicit Requests</name>
        <t>In normal operation, a node's route table is populated by the regular
and triggered updates sent by its neighbours.  Under some circumstances,
however, a node sends explicit requests in order to cause a resynchronisation
with the source after a mobility event or to prevent a route from
spuriously expiring.</t>
        <t>The Babel protocol provides two kinds of explicit requests: route
requests, which simply request an update for a given prefix, and seqno
requests, which request an update for a given prefix with a specific
sequence number.  The former are never forwarded; the latter are forwarded
if they cannot be satisfied by the receiver.</t>
        <section anchor="handling-requests" numbered="true" toc="default">
          <name>Handling Requests</name>
          <t>Upon receiving a request, a node either forwards the request or sends an
update in reply to the request, as described in the following sections.  If
this causes an update to be sent, the update is either sent to a multicast
address on the interface on which the request was received, or to the
unicast address of the neighbour that sent the request.</t>
          <t>The exact behaviour is different for route requests and seqno requests.</t>
          <section anchor="handling-route-requests" numbered="true" toc="default">
            <name>Route Requests</name>
            <t>When a node receives a route request for a given prefix, it checks its
route table for a selected route to this exact prefix.  If such a route
exists, it <bcp14>MUST</bcp14> send an update (over unicast or over multicast); if such
a route does not exist, it <bcp14>MUST</bcp14> send a retraction for that prefix.</t>
            <t>When a node receives a wildcard route request, it <bcp14>SHOULD</bcp14> send a full
route table dump.  Full route dumps <bcp14>SHOULD</bcp14> be rate-limited, especially if
they are sent over multicast.</t>
          </section>
          <section anchor="handling-seqno-requests" numbered="true" toc="default">
            <name>Seqno Requests</name>
            <t>When a node receives a seqno request for a given router-id and sequence
number, it checks whether its route table contains a selected entry for
that prefix.  If a selected route for the given prefix exists and has
finite metric, and either the router-ids are different or the router-ids
are equal and the entry's sequence number is no smaller (modulo 2<sup>16</sup>) than
the requested sequence number, the node <bcp14>MUST</bcp14> send an update for the given
prefix.  If the router-ids match, but the requested seqno is larger (modulo
2<sup>16</sup>) than the route entry's, the node compares the router-id against its
own router-id.  If the router-id is its own, then it increases its
sequence number by 1 (modulo 2<sup>16</sup>) and sends an update.  A node <bcp14>MUST NOT</bcp14>
increase its sequence number by more than 1 in reaction to a single seqno
request.</t>
            <t>Otherwise, if the requested router-id is not its own, the received node
consults the Hop Count field of the request.  If the hop count is 2 or
more, and the node is advertising the prefix to its neighbours, the node
selects a neighbour to forward the request to as follows:
</t>
            <ul spacing="normal">
              <li>if the node has one or more feasible routes towards the requested prefix
with a next hop that is not the requesting node, then the node <bcp14>MUST</bcp14>
forward the request to the next hop of one such route;</li>
              <li>otherwise, if the node has one or more (not feasible) routes to the
requested prefix with a next hop that is not the requesting node, then the
node <bcp14>SHOULD</bcp14> forward the request to the next hop of one such route.</li>
            </ul>
            <t>
In order to actually forward the request, the node decrements the hop
count and sends the request in a unicast packet destined to the selected
neighbour.  The forwarded request <bcp14>SHOULD</bcp14> be sent as an urgent TLV (as
defined in <xref target="transmission-reception" format="default"/>).</t>
            <t>A node <bcp14>SHOULD</bcp14> maintain a list of recently forwarded seqno requests and
forward the reply (an update with a seqno sufficiently large to satisfy
the request) as an urgent TLV (as defined in
<xref target="transmission-reception" format="default"/>).  A node <bcp14>SHOULD</bcp14> compare every
incoming seqno request against its list of recently forwarded seqno
requests and avoid forwarding the request if it is redundant (i.e., if the node has
recently sent a request with the same prefix, router-id, and a seqno that
is not smaller modulo 2<sup>16</sup>).</t>
            <t>Since the request-forwarding mechanism does not necessarily obey the
feasibility condition, it may get caught in routing loops; hence, requests
carry a hop count to limit the time during which they remain in the network.
However, since requests are only ever forwarded as unicast packets, the
initial hop count need not be kept particularly low, and performing an
expanding horizon search is not necessary.  A single request <bcp14>MUST NOT</bcp14> be
duplicated: it <bcp14>MUST NOT</bcp14> be forwarded to a multicast address, and it <bcp14>MUST
NOT</bcp14> be forwarded to multiple neighbours.  However, if a seqno request is
resent by its originator, the subsequent copies may be forwarded to
a different neighbour than the initial one.</t>
          </section>
        </section>
        <section anchor="sending-requests" numbered="true" toc="default">
          <name>Sending Requests</name>
          <t>A Babel node <bcp14>MAY</bcp14> send a route or seqno request at any time to a
multicast or a unicast address; there is only one case when originating
requests is required (<xref target="avoiding-starvation" format="default"/>).</t>
          <section anchor="avoiding-starvation" numbered="true" toc="default">
            <name>Avoiding Starvation</name>
            <t>When a route is retracted or expires, a Babel node usually switches to
another feasible route for the same prefix.  It may be the case, however,
that no such routes are available.</t>
            <t>A node that has lost all feasible routes to a given destination but
still has unexpired unfeasible routes to that destination <bcp14>MUST</bcp14> send
a seqno request; if it doesn't have any such routes, it <bcp14>MAY</bcp14> still send
a seqno request.  The router-id of the request is set to the router-id of
the route that it has just lost, and the requested seqno is the value
contained in the source table plus 1.  The request carries a hop count,
which is used as a last-resort mechanism to ensure that it eventually
vanishes from the network; it <bcp14>MAY</bcp14> be set to any value that is larger than
the diameter of the network (64 is a suitable default value).</t>
            <t>If the node has any (unfeasible) routes to the requested destination,
then it <bcp14>MUST</bcp14> send the request to at least one of the next-hop neighbours
that advertised these routes, and <bcp14>SHOULD</bcp14> send it to all of them; in any
case, it <bcp14>MAY</bcp14> send the request to any other neighbours, whether they
advertise a route to the requested destination or not.  A simple
implementation strategy is therefore to unconditionally multicast the
request over all interfaces.</t>
            <t>Similar requests will be sent by other nodes that are affected by the
route's loss.  If the network is still connected, and assuming no packet
loss, then at least one of these requests will be forwarded to the source,
resulting in a route being advertised with a new sequence number.  (Due to
duplicate suppression, only a small number of such requests are expected
to actually reach the source.)</t>
            <t>In order to compensate for packet loss, a node <bcp14>SHOULD</bcp14> repeat such
a request a small number of times if no route becomes feasible within
a short time (see "Request timeout" in <xref target="parameters" format="default"/> for
suggested values).  In the presence of heavy packet loss, however, all
such requests might be lost; in that case, the mechanism in the next
section will eventually ensure that a new seqno is received.</t>
          </section>
          <section anchor="request-unfeasible" numbered="true" toc="default">
            <name>Dealing with Unfeasible Updates</name>
            <t>When a route's metric increases, a node might receive an unfeasible
update for a route that it has currently selected.  As specified in
<xref target="feasibility-condition" format="default"/>, the receiving node will either
ignore the update or unselect the route.</t>
            <t>In order to keep routes from spuriously expiring because they have
become unfeasible, a node <bcp14>SHOULD</bcp14> send a unicast seqno request when it
receives an unfeasible update for a route that is currently selected.  The
requested sequence number is computed from the source table as in <xref target="avoiding-starvation" format="default"/>.</t>
            <t>Additionally, since metric computation does not necessarily coincide
with the delay in propagating updates, a node might receive an unfeasible
update from a currently unselected neighbour that is preferable to the
currently selected route (e.g., because it has a much smaller metric); in
that case, the node <bcp14>SHOULD</bcp14> send a unicast seqno request to the neighbour
that advertised the preferable update.</t>
          </section>
          <section anchor="request-expiring" numbered="true" toc="default">
            <name>Preventing Routes from Expiring</name>
            <t>In normal operation, a route's expiry timer never triggers: since
a route's hold time is computed from an explicit interval included in
Update TLVs, a new update (possibly a retraction) should arrive in time to
prevent a route from expiring.</t>
            <t>In the presence of packet loss, however, it may be the case that no
update is successfully received for an extended period of time, causing
a route to expire.  In order to avoid such spurious expiry, shortly before
a selected route expires, a Babel node <bcp14>SHOULD</bcp14> send a unicast route request
to the neighbour that advertised this route; since nodes always send
either updates or retractions in response to non-wildcard route requests
(<xref target="handling-route-requests" format="default"/>), this will usually result in
the route being either refreshed or retracted.</t>
          </section>
        </section>
      </section>
    </section>
    <section anchor="protocol-encoding" numbered="true" toc="default">
      <name>Protocol Encoding</name>
      <t>A Babel packet <bcp14>MUST</bcp14> be sent as the body of a UDP datagram, with
network-layer hop count set to 1, destined to a well-known multicast
address or to a unicast address, over IPv4 or IPv6; in the case of IPv6,
these addresses are link-local.  Both the source and destination UDP port
are set to a well-known port number.  A Babel packet <bcp14>MUST</bcp14> be silently
ignored unless its source address is either a link-local IPv6 address or
an IPv4 address belonging to the local network, and its source port is the
well-known Babel port.  It <bcp14>MAY</bcp14> be silently ignored if its destination
address is a global IPv6 address.</t>
      <t>In order to minimise the number of packets being sent while avoiding
lower-layer fragmentation, a Babel node <bcp14>SHOULD</bcp14> maximise the size of the
packets it sends, up to the outgoing interface's MTU adjusted for
lower-layer headers (28 octets for UDP over IPv4, 48 octets for UDP over
IPv6).  It <bcp14>MUST NOT</bcp14> send packets larger than the attached interface's MTU
adjusted for lower-layer headers or 512 octets, whichever is larger, but
not exceeding 2<sup>16</sup> - 1 adjusted for lower-layer headers.  Every Babel
speaker <bcp14>MUST</bcp14> be able to receive packets that are as large as any attached
interface's MTU adjusted for lower-layer headers or 512 octets, whichever
is larger.  Babel packets <bcp14>MUST NOT</bcp14> be sent in IPv6 jumbograms
<xref target="RFC2675" format="default"/>.</t>
      <section numbered="true" toc="default">
        <name>Data Types</name>
        <section numbered="true" toc="default">
          <name>Representation of Integers</name>
          <t>All multi-octet fields that represent integers are encoded with the
most significant octet first (in Big-Endian format <xref target="IEN137" format="default"/>,
also called network order).  The base protocol only carries unsigned
values; if an extension needs to carry signed values, it will need to
specify their encoding (e.g., two's complement).</t>
        </section>
        <section numbered="true" toc="default">
          <name>Interval</name>
          <t>Relative times are carried as 16-bit values specifying a number of
centiseconds (hundredths of a second).  This allows times up to roughly 11
minutes with a granularity of 10 ms, which should cover all reasonable
applications of Babel (see also <xref target="parameters" format="default"/>).</t>
        </section>
        <section anchor="router-id-def" numbered="true" toc="default">
          <name>Router-Id</name>
          <t>A router-id is an arbitrary 8-octet value.  A router-id <bcp14>MUST NOT</bcp14>
consist of either all binary zeroes (0000000000000000 hexadecimal) or all
binary ones (FFFFFFFFFFFFFFFF hexadecimal).</t>
        </section>
        <section numbered="true" toc="default">
          <name>Address</name>
          <t>Since the bulk of the protocol is taken by addresses, multiple ways of
encoding addresses are defined.  Additionally, within Update TLVs a common
subnet prefix may be omitted when multiple addresses are sent in a single
packet -- this is known as address compression (<xref target="update" format="default"/>).</t>
          <t>Address encodings (AEs):
</t>
          <dl spacing="normal" indent="10">
            <dt>AE 0:</dt><dd>Wildcard address.  The value is 0 octets long.</dd>
            <dt>AE 1:</dt><dd>IPv4 address.  Compression is allowed.  4 octets or less.</dd>
            <dt>AE 2:</dt><dd>IPv6 address.  Compression is allowed.  16 octets or less.</dd>
            <dt>AE 3:</dt><dd>Link-local IPv6 address.  Compression is not allowed.  The value
is 8 octets long, a prefix of fe80::/64 is implied.</dd>
          </dl>
          <t>The address family associated with an address encoding is either IPv4 or
IPv6: it is undefined for AE 0, IPv4 for AE 1, and IPv6 for AEs 2 and
3.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Prefixes</name>
          <t>A network prefix is encoded just like a network address, but it is
stored in the smallest number of octets that are enough to hold the
significant bits (up to the prefix length).</t>
        </section>
      </section>
      <section anchor="packet-format" numbered="true" toc="default">
        <name>Packet Format</name>
        <t>A Babel packet consists of a 4-octet header, followed by a sequence of
TLVs (the packet body), optionally followed by a second sequence of TLVs
(the packet trailer).  The format is designed to be extensible; see
<xref target="extensions" format="default"/> for extensibility considerations.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Magic     |    Version    |        Body length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Packet Body...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
|         Packet Trailer...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>

        <t>Fields:
</t>
        <dl newline="false" spacing="normal" indent="10">
          <dt>Magic</dt>
          <dd>The arbitrary but carefully chosen value 42 (decimal);
packets with a first octet different from 42 <bcp14>MUST</bcp14> be silently ignored.</dd>
          <dt>Version</dt>
          <dd>This document specifies version 2 of the Babel
  protocol.  Packets with a second octet different from 2 <bcp14>MUST</bcp14> be silently
  ignored.</dd>
          <dt>Body length</dt>
          <dd>The length in octets of the body following the
packet header (excluding the Magic, Version, and Body length fields, and
excluding the packet trailer).</dd>
          <dt>Packet Body</dt>
          <dd>The packet body; a sequence of TLVs.</dd>
          <dt>Packet Trailer</dt>
          <dd>The packet trailer; another sequence of TLVs.</dd>
        </dl>
        <t>The packet body and trailer are both sequences of TLVs.  The packet
body is the normal place to store TLVs; the packet trailer only contains
specialised TLVs that do not need to be protected by cryptographic
security mechanisms.  When parsing the trailer, the receiver <bcp14>MUST</bcp14> ignore
any TLV unless its definition explicitly states that it is allowed to
appear there.  Among the TLVs defined in this document, only Pad1 and PadN
are allowed in the trailer; since these TLVs are ignored in any case, an
implementation <bcp14>MAY</bcp14> silently ignore the packet trailer without even parsing
it, unless it implements at least one protocol extension that defines TLVs
that are allowed to appear in the trailer.</t>
      </section>
      <section numbered="true" toc="default">
        <name>TLV Format</name>
        <t>With the exception of Pad1, all TLVs have the following structure:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     Payload...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
        <t>Fields:
</t>
        <dl newline="false" spacing="normal" indent="10">
          <dt>Type</dt>
          <dd>The type of the TLV.</dd>
          <dt>Length</dt>
          <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
          <dt>Payload</dt>
          <dd>The TLV payload, which consists of a body and, for
selected TLV types, an optional list of sub-TLVs.</dd>
        </dl>
        <t>TLVs with an unknown type value <bcp14>MUST</bcp14> be silently ignored.</t>
      </section>
      <section anchor="sub-tlv-format" numbered="true" toc="default">
        <name>Sub-TLV Format</name>
        <t>Every TLV carries an explicit length in its header; however, most TLVs
are self-terminating, in the sense that it is possible to determine the
length of the body without reference to the explicit Length field.  If
a TLV has a self-terminating format, then the space between the natural
size of the TLV and the size announced in the Length field may be used to
store a sequence of sub-TLVs.</t>
        <t>Sub-TLVs have the same structure as TLVs.  With the exception of Pad1,
all TLVs have the following structure:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     Body...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
        <t>Fields:
</t>
        <dl newline="false" spacing="normal" indent="10">
          <dt>Type</dt>
          <dd>The type of the sub-TLV.</dd>
          <dt>Length</dt>
          <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
          <dt>Body</dt>
          <dd>The sub-TLV body, the interpretation of which depends
on both the type of the sub-TLV and the type of the TLV within which it is
embedded.</dd>
        </dl>
        <t>The most significant bit of the sub-TLV type (the bit with value 80
hexadecimal), is called the mandatory bit; in other words, sub-TLV types
128 through 255 have the mandatory bit set.  This bit indicates how to
handle unknown sub-TLVs.  If the mandatory bit is not set, then an unknown
sub-TLV <bcp14>MUST</bcp14> be silently ignored, and the rest of the TLV is processed
normally.  If the mandatory bit is set, then the whole enclosing TLV <bcp14>MUST</bcp14>
be silently ignored (except for updating the parser state by a Router-Id,
Next Hop, or Update TLV, as described in the next section).</t>
      </section>
      <section anchor="parser-state" numbered="true" toc="default">
        <name>Parser State and Encoding of Updates</name>
        <t>In a large network, the bulk of Babel traffic consists of route
updates; hence, some care has been given to encoding them efficiently.
The data conceptually contained in an update (<xref target="route-maintenance" format="default"/>)
is split into three pieces:
</t>
        <ul spacing="normal">
          <li>the prefix, seqno, and metric are contained in the Update TLV itself
(<xref target="update" format="default"/>);</li>
          <li>the router-id is taken from the Router-Id TLV that precedes the Update TLV
and may be shared among multiple Update TLVs (<xref target="router-id" format="default"/>);</li>
          <li>the next hop is taken either from the source address of the
network-layer packet that contains the Babel packet or from an explicit
Next Hop TLV (<xref target="next-hop" format="default"/>).</li>
        </ul>
        <t>
In addition to the above, an Update TLV can omit a prefix of the prefix
being announced, which is then extracted from the preceding Update TLV
in the same address family (IPv4 or IPv6).  Finally, as a special
optimisation for the case when a router-id coincides with the interface-id
part of an IPv6 address, the Router-Id TLV itself may be omitted, and the
router-id is derived from the low-order bits of the advertised prefix
(<xref target="update" format="default"/>).</t>
        <t>In order to implement these compression techniques, Babel uses
a stateful parser: a TLV may refer to data from a previous TLV.  The
parser state consists of the following pieces of data:
</t>
        <ul spacing="normal">
          <li>for each address encoding that allows compression, the current
  default prefix: this is undefined at the start of the packet and is
  updated by each Update TLV with the Prefix flag set
  (<xref target="update" format="default"/>);</li>
          <li>for each address family (IPv4 or IPv6), the current next hop: this is
  the source address of the enclosing packet for the matching address
  family at the start of a packet, and it is updated by each Next Hop TLV
  (<xref target="next-hop" format="default"/>);</li>
          <li>the current router-id: this is undefined at the start of the packet,
  and it is updated by each Router-Id TLV (<xref target="router-id" format="default"/>)
  and by each Update TLV with Router-Id flag set.</li>
        </ul>
        <t>Since the parser state must be identical across implementations, it is
updated before checking for mandatory sub-TLVs: parsing a TLV <bcp14>MUST</bcp14> update
the parser state even if the TLV is otherwise ignored due to an unknown
mandatory sub-TLV or for any other reason.</t>
        <t>None of the TLVs that modify the parser state are allowed in the packet
trailer; hence, an implementation may choose to use a dedicated stateless
parser to parse the packet trailer.</t>
      </section>
      <section anchor="tlv-details" numbered="true" toc="default">
        <name>Details of Specific TLVs</name>

        <section numbered="true" toc="default">
          <name>Pad1</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|   Type = 0    |
+-+-+-+-+-+-+-+-+
]]></artwork>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 0 to indicate a Pad1 TLV.</dd>
          </dl>
          <t>This TLV is silently ignored on reception.  It is allowed in the packet
trailer.</t>
        </section>
        <section numbered="true" toc="default">
          <name>PadN</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 1   |    Length     |      MBZ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 1 to indicate a PadN TLV.</dd>
            <dt>Length</dt>
            <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
            <dt>MBZ</dt>
            <dd>Must be zero, set to 0 on transmission.</dd>
          </dl>
          <t>This TLV is silently ignored on reception.  It is allowed in the packet
trailer.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Acknowledgment Request</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 2   |    Length     |          Reserved             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Opaque            |          Interval             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          <t>This TLV requests that the receiver send an Acknowledgment TLV
within the number of centiseconds specified by the Interval field.</t>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 2 to indicate an Acknowledgment Request TLV.</dd>
            <dt>Length</dt>
            <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
            <dt>Reserved</dt>
            <dd>Sent as 0 and <bcp14>MUST</bcp14> be ignored on
  reception.</dd>
            <dt>Opaque</dt>
            <dd>An arbitrary value that will be echoed in the
receiver's Acknowledgment TLV.</dd>
            <dt>Interval</dt>
            <dd>A time interval in centiseconds after which the
sender will assume that this packet has been lost.  This <bcp14>MUST NOT</bcp14> be 0.
The receiver <bcp14>MUST</bcp14> send an Acknowledgment TLV before this time has elapsed
(with a margin allowing for propagation time). </dd>
          </dl>
          <t>This TLV is self-terminating and allows sub-TLVs.</t>
        </section>
        <section anchor="ack" numbered="true" toc="default">
          <name>Acknowledgment</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 3   |    Length     |           Opaque              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          <t>This TLV is sent by a node upon receiving an Acknowledgment Request TLV.</t>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 3 to indicate an Acknowledgment TLV.</dd>
            <dt>Length</dt>
            <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
            <dt>Opaque</dt>
            <dd>Set to the Opaque value of the Acknowledgment Request
that prompted this Acknowledgment.</dd>
          </dl>
          <t>Since Opaque values are not globally unique, this TLV <bcp14>MUST</bcp14> be sent to
a unicast address.</t>
          <t>This TLV is self-terminating and allows sub-TLVs.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Hello</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 4   |    Length     |            Flags              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Seqno              |          Interval             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          <t>This TLV is used for neighbour discovery and for determining a
neighbour's reception cost.</t>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 4 to indicate a Hello TLV.</dd>
            <dt>Length</dt>
            <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
            <dt>Flags</dt>
            <dd>The individual bits of this field specify special
handling of this TLV (see below).</dd>
            <dt>Seqno</dt>
            <dd>If the Unicast flag is set, this is the value of the
sending node's outgoing Unicast Hello seqno for this neighbour.  Otherwise,
it is the sending node's outgoing Multicast Hello seqno for this interface.</dd>
            <dt>Interval</dt>
            <dd>If nonzero, this is an upper bound, expressed in
centiseconds, on the time after which the sending node will send a new
scheduled Hello TLV with the same setting of the Unicast flag.  If this is
0, then this Hello represents an unscheduled Hello and doesn't carry any
new information about times at which Hellos are sent.</dd>
          </dl>
          <t>The Flags field is interpreted as follows:
</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|U|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          <dl spacing="normal" indent="10">

            <dt>U (Unicast) flag (8000 hexadecimal):</dt><dd>if set, then this Hello
represents a Unicast Hello, otherwise it represents a Multicast Hello;</dd>
            <dt>X:</dt><dd>all other bits <bcp14>MUST</bcp14> be sent as 0 and silently ignored on reception.</dd>
          </dl>
          <t>Every time a Hello is sent, the corresponding seqno counter <bcp14>MUST</bcp14> be
incremented.  Since there is a single seqno counter for all the Multicast
Hellos sent by a given node over a given interface, if the Unicast flag is
not set, this TLV <bcp14>MUST</bcp14> be sent to all neighbours on this link, which can be
achieved by sending to a multicast destination or by sending multiple
packets to the unicast addresses of all reachable neighbours.  Conversely,
if the Unicast flag is set, this TLV <bcp14>MUST</bcp14> be sent to a single neighbour,
which can achieved by sending to a unicast destination.  In order to avoid
large discontinuities in link quality, multiple Hello TLVs <bcp14>SHOULD NOT</bcp14> be
sent in the same packet.</t>
          <t>This TLV is self-terminating and allows sub-TLVs.</t>
        </section>
        <section numbered="true" toc="default">
          <name>IHU</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 5   |    Length     |       AE      |    Reserved   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Rxcost             |          Interval             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Address...
+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
          <t>An IHU ("I Heard You") TLV is used for confirming bidirectional
reachability and carrying a link's transmission cost.</t>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 5 to indicate an IHU TLV.</dd>
            <dt>Length</dt>
            <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
            <dt>AE</dt>
            <dd>The encoding of the Address field.  This should be 1 or 3
in most cases.  As an optimisation, it <bcp14>MAY</bcp14> be 0 if the TLV is
sent to a unicast address, if the association is over a point-to-point
link, or when bidirectional reachability is ascertained by means outside of
the Babel protocol.</dd>
            <dt>Reserved</dt>
            <dd>Sent as 0 and <bcp14>MUST</bcp14> be ignored on reception.</dd>
            <dt>Rxcost</dt>
            <dd>The rxcost according to the sending node of the
interface whose address is specified in the Address field.  The value FFFF
hexadecimal (infinity) indicates that this interface is unreachable.</dd>
            <dt>Interval</dt>
            <dd>An upper bound, expressed in centiseconds, on the
time after which the sending node will send a new IHU; this <bcp14>MUST NOT</bcp14> be 0.
The receiving node will use this value in order to compute a hold time for
this symmetric association.</dd>
            <dt>Address</dt>
            <dd>The address of the destination node, in the format
specified by the AE field.  Address compression is not allowed.</dd>
          </dl>
          <t>Conceptually, an IHU is destined to a single neighbour.  However, IHU
TLVs contain an explicit destination address, and <bcp14>MAY</bcp14> be sent to
a multicast address, as this allows aggregation of IHUs destined to
distinct neighbours into a single packet and avoids the need for an ARP or
Neighbour Discovery exchange when a neighbour is not being used for data
traffic.</t>
          <t>IHU TLVs with an unknown value in the AE field <bcp14>MUST</bcp14> be silently
ignored.</t>
          <t>This TLV is self-terminating and allows sub-TLVs.</t>
        </section>
        <section anchor="router-id" numbered="true" toc="default">
          <name>Router-Id</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 6   |    Length     |          Reserved             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                           Router-Id                           +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          <t>A Router-Id TLV establishes a router-id that is implied by subsequent
Update TLVs, as described in <xref target="parser-state" format="default"/>.  This TLV sets
the router-id even if it is otherwise ignored due to an unknown mandatory
sub-TLV.</t>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 6 to indicate a Router-Id TLV.</dd>
            <dt>Length</dt>
            <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
            <dt>Reserved</dt>
            <dd>Sent as 0 and <bcp14>MUST</bcp14> be ignored on reception.</dd>
            <dt>Router-Id</dt>
            <dd>The router-id for routes advertised in subsequent
Update TLVs.  This <bcp14>MUST NOT</bcp14> consist of all zeroes or all ones.</dd>
          </dl>
          <t>This TLV is self-terminating and allows sub-TLVs.</t>
        </section>
        <section anchor="next-hop" numbered="true" toc="default">
          <name>Next Hop</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 7   |    Length     |      AE       |   Reserved    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Next hop...
+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
          <t>A Next Hop TLV establishes a next-hop address for a given address
family (IPv4 or IPv6) that is implied in subsequent Update TLVs, as
described in <xref target="parser-state" format="default"/>.  This TLV sets up the next hop
for subsequent Update TLVs even if it is otherwise ignored due to an
unknown mandatory sub-TLV.</t>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 7 to indicate a Next Hop TLV.</dd>
            <dt>Length</dt>
            <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
            <dt>AE</dt>
            <dd>The encoding of the Address field.  This <bcp14>SHOULD</bcp14> be
1 (IPv4) or 3 (link-local IPv6), and <bcp14>MUST NOT</bcp14> be 0.</dd>
            <dt>Reserved</dt>
            <dd>Sent as 0 and <bcp14>MUST</bcp14> be ignored on reception.</dd>
            <dt>Next hop</dt>
            <dd>The next-hop address advertised by subsequent Update
TLVs for this address family.</dd>
          </dl>
          <t>When the address family matches the network-layer protocol over which this
packet is transported, a Next Hop TLV is not needed: in the absence
of a Next Hop TLV in a given address family, the next-hop address is taken
to be the source address of the packet.</t>
          <t>Next Hop TLVs with an unknown value for the AE field <bcp14>MUST</bcp14> be silently
ignored.</t>
          <t>This TLV is self-terminating, and allows sub-TLVs.</t>
        </section>
        <section anchor="update" numbered="true" toc="default">
          <name>Update</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 8   |    Length     |       AE      |    Flags      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Plen      |    Omitted    |            Interval           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Seqno             |            Metric             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Prefix...
+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
          <t>An Update TLV advertises or retracts a route.  As an optimisation, it
can optionally have the side effect of establishing a new implied
router-id and a new default prefix, as described in
<xref target="parser-state" format="default"/>.</t>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 8 to indicate an Update TLV.</dd>
            <dt>Length</dt>
            <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
            <dt>AE</dt>
            <dd>The encoding of the Prefix field.</dd>
            <dt>Flags</dt>
            <dd>The individual bits of this field specify special
handling of this TLV (see below).</dd>
            <dt>Plen</dt>
            <dd>The length in bits of the advertised prefix.  If AE is
3 (link-local IPv6), the Omitted field <bcp14>MUST</bcp14> be 0.</dd>
            <dt>Omitted</dt>
            <dd>The number of octets that have been omitted at
the beginning of the advertised prefix and that should be taken from a
preceding Update TLV in the same address family with the Prefix flag set.</dd>
            <dt>Interval</dt>
            <dd>An upper bound, expressed in centiseconds, on the
time after which the sending node will send a new update for this prefix.
This <bcp14>MUST NOT</bcp14> be 0.  The receiving node will use this value to compute
a hold time for the route table entry.  The value FFFF hexadecimal
(infinity) expresses that this announcement will not be repeated unless
a request is received (<xref target="request-expiring" format="default"/>).</dd>
            <dt>Seqno</dt>
            <dd>The originator's sequence number for this update.</dd>
            <dt>Metric</dt>
            <dd>The sender's metric for this route.  The value FFFF
hexadecimal (infinity) means that this is a route retraction.</dd>
            <dt>Prefix</dt>
            <dd>The prefix being advertised.  This field's size is
(Plen/8&nbsp;-&nbsp;Omitted) rounded upwards.</dd>
          </dl>
          <t>The Flags field is interpreted as follows:
</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|P|R|X|X|X|X|X|X|
+-+-+-+-+-+-+-+-+
]]></artwork>
          <dl spacing="normal" indent="10">

            <dt>P (Prefix) flag (80 hexadecimal):</dt><dd>if set, then this Update
TLV establishes a new default prefix for subsequent Update TLVs with a matching
address encoding within the same packet, even if this TLV is otherwise
ignored due to an unknown mandatory sub-TLV;</dd>
              <dt>R (Router-Id) flag (40 hexadecimal):</dt><dd><t>if set, then this TLV establishes
a new default router-id for this TLV and subsequent Update TLVs in the
same packet, even if this TLV is otherwise ignored due to an unknown
mandatory sub-TLV.  This router-id is computed from the first address of
the advertised prefix as follows:
</t>
              <ul spacing="normal">
                <li>if the length of the address is 8 octets or more, then the new
  router-id is taken from the 8 last octets of the address;</li>
                <li>if the length of the address is smaller than 8 octets, then the new
  router-id consists of the required number of zero octets followed by the
  address, i.e., the address is stored on the right of the router-id.  For
  example, for an IPv4 address, the router-id consists of 4 octets of
  zeroes followed by the IPv4 address.</li>
              </ul>
            </dd>
            <dt>X:</dt><dd>all other bits <bcp14>MUST</bcp14> be sent as 0 and silently ignored on reception.</dd>
          </dl>
          <t>The prefix being advertised by an Update TLV is computed as follows:
</t>
          <ul spacing="normal">
            <li>the first Omitted octets of the prefix are taken from the previous
Update TLV with the Prefix flag set and the same address encoding,
even if it was ignored due to an unknown mandatory sub-TLV; if the Omitted field is
not zero and there is no such TLV, then this Update <bcp14>MUST</bcp14> be ignored;</li>
            <li>the next (Plen/8 - Omitted) rounded upwards octets are taken from the
Prefix field;</li>
            <li>if Plen is not a multiple of 8, then any bits beyond Plen (i.e., the
low-order (8 - Plen MOD 8) bits of the last octet) are cleared;</li>
            <li>the remaining octets are set to 0.</li>
          </ul>
          <t>If the Metric field is finite, the router-id of the originating node
for this announcement is taken from the prefix advertised by this Update
if the Router-Id flag is set, computed as described above.  Otherwise, it
is taken either from the preceding Router-Id TLV, or the preceding
Update TLV with the Router-Id flag set, whichever comes last, even if
that TLV is otherwise ignored due to an unknown mandatory sub-TLV; if
there is no suitable TLV, then this update is ignored.</t>
          <t>The next-hop address for this update is taken from the last preceding
Next Hop TLV with a matching address family (IPv4 or IPv6) in the same
packet even if it was otherwise ignored due to an unknown mandatory
sub-TLV; if no such TLV exists, it is taken from the network-layer source
address of this packet if it belongs to the same address family as the
prefix being announced; otherwise, this Update <bcp14>MUST</bcp14> be ignored.</t>
          <t>If the metric field is FFFF hexadecimal, this TLV specifies
a retraction.  In that case, the router-id, next hop, and seqno are not
used.  AE <bcp14>MAY</bcp14> then be 0, in which case this Update retracts all of the
routes previously advertised by the sending interface.  If the metric is
finite, AE <bcp14>MUST NOT</bcp14> be 0; Update TLVs with finite metric and AE equal to
0 <bcp14>MUST</bcp14> be ignored.  If the metric is infinite and AE is 0, Plen and
Omitted <bcp14>MUST</bcp14> both be 0; Update TLVs that do not satisfy this requirement
<bcp14>MUST</bcp14> be ignored.</t>
          <t>Update TLVs with an unknown value in the AE field <bcp14>MUST</bcp14> be silently
ignored.</t>
          <t>This TLV is self-terminating and allows sub-TLVs.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Route Request</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 9   |    Length     |      AE       |     Plen      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Prefix...
+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
          <t>A Route Request TLV prompts the receiver to send an update for a given
prefix, or a full route table dump.</t>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 9 to indicate a Route Request TLV.</dd>
            <dt>Length</dt>
            <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
            <dt>AE</dt>
            <dd>The encoding of the Prefix field.  The value 0 specifies
that this is a request for a full route table dump (a wildcard
request).</dd>
            <dt>Plen</dt>
            <dd>The length in bits of the requested prefix.</dd>
            <dt>Prefix</dt>
            <dd>The prefix being requested.  This field's size is
Plen/8 rounded upwards.</dd>
          </dl>
          <t>A Request TLV prompts the receiver to send an update message (possibly
a retraction) for the prefix specified by the AE, Plen, and Prefix fields,
or a full dump of its route table if AE is 0 (in which case Plen must be
0 and Prefix is of length 0).  A Request TLV with AE set to 0 and Plen not
set to 0 <bcp14>MUST</bcp14> be ignored.</t>
          <t>This TLV is self-terminating and allows sub-TLVs.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Seqno Request</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 10  |    Length     |      AE       |    Plen       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Seqno             |  Hop Count    |   Reserved    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                          Router-Id                            +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Prefix...
+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          <t>A Seqno Request TLV prompts the receiver to send an Update for a given
prefix with a given sequence number, or to forward the request further if
it cannot be satisfied locally.</t>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 10 to indicate a Seqno Request TLV.</dd>
            <dt>Length</dt>
            <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
            <dt>AE</dt>
            <dd>The encoding of the Prefix field.  This <bcp14>MUST NOT</bcp14> be 0.</dd>
            <dt>Plen</dt>
            <dd>The length in bits of the requested prefix.</dd>
            <dt>Seqno</dt>
            <dd>The sequence number that is being requested.</dd>
            <dt>Hop Count</dt>
            <dd>The maximum number of times that this TLV may be
forwarded, plus 1.  This <bcp14>MUST NOT</bcp14> be 0.</dd>
            <dt>Reserved</dt>
            <dd>Sent as 0 and <bcp14>MUST</bcp14> be ignored on reception.</dd>
            <dt>Router-Id</dt>
            <dd>The Router-Id that is being requested.  This <bcp14>MUST
NOT</bcp14> consist of all zeroes or all ones.</dd>
            <dt>Prefix</dt>
            <dd>The prefix being requested.  This field's size is
Plen/8 rounded upwards.</dd>
          </dl>
          <t>A Seqno Request TLV prompts the receiving node to send a finite-metric
Update for the prefix specified by the AE, Plen, and Prefix fields, with
either a router-id different from what is specified by the Router-Id
field, or a Seqno no less (modulo 2<sup>16</sup>) than what is specified by the
Seqno field.  If this request cannot be satisfied locally, then it is
forwarded according to the rules set out in
 <xref target="handling-seqno-requests" format="default"/>.</t>
          <t>While a Seqno Request <bcp14>MAY</bcp14> be sent to a multicast address, it <bcp14>MUST NOT</bcp14> be
forwarded to a multicast address and <bcp14>MUST NOT</bcp14> be forwarded to more than
one neighbour.  A request <bcp14>MUST NOT</bcp14> be forwarded if its Hop Count field is
1.</t>
          <t>This TLV is self-terminating and allows sub-TLVs.</t>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>Details of specific sub-TLVs</name>
        <section anchor="pad1" numbered="true" toc="default">
          <name>Pad1</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|   Type = 0    |
+-+-+-+-+-+-+-+-+
]]></artwork>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 0 to indicate a Pad1 sub-TLV.</dd>
          </dl>
          <t>This sub-TLV is silently ignored on reception.  It is allowed within
any TLV that allows sub-TLVs.</t>
        </section>
        <section numbered="true" toc="default">
          <name>PadN</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 1   |    Length     |      MBZ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
          <t>Fields:
</t>
          <dl newline="false" spacing="normal" indent="10">
            <dt>Type</dt>
            <dd>Set to 1 to indicate a PadN sub-TLV.</dd>
            <dt>Length</dt>
            <dd>The length of the body in octets, exclusive of the
Type and Length fields.</dd>
            <dt>MBZ</dt>
            <dd>Must be zero, set to 0 on transmission.</dd>
          </dl>
          <t>This sub-TLV is silently ignored on reception.  It is allowed within
any TLV that allows sub-TLVs.</t>
        </section>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>IANA has registered the UDP port number 6696, called "babel", for use
by the Babel protocol.</t>
      <t>IANA has registered the IPv6 multicast group ff02::1:6 and the
IPv4 multicast group 224.0.0.111 for use by the Babel protocol.</t>
      <t>IANA has created a registry called "Babel TLV Types".  The allocation
policy for this registry is Specification Required <xref target="RFC8126" format="default"/>
for Types 0-223 and Experimental Use for Types 224-254.  The values in
this registry are as follows:</t>
      <table align="center">
        <thead>
          <tr>
            <th align="left">Type</th>
            <th align="left">Name</th>
            <th align="left">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">0</td>
            <td align="left">Pad1</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">1</td>
            <td align="left">PadN</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">2</td>
            <td align="left">Acknowledgment Request</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">3</td>
            <td align="left">Acknowledgment</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">4</td>
            <td align="left">Hello</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">5</td>
            <td align="left">IHU</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">6</td>
            <td align="left">Router-Id</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">7</td>
            <td align="left">Next Hop</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">8</td>
            <td align="left">Update</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">9</td>
            <td align="left">Route Request</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">10</td>
            <td align="left">Seqno Request</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">11</td>
            <td align="left">TS/PC</td>
            <td align="left">
              <xref target="RFC7298" format="default"/></td>
          </tr>
          <tr>
            <td align="left">12</td>
            <td align="left">HMAC</td>
            <td align="left">
              <xref target="RFC7298" format="default"/></td>
          </tr>
          <tr>
            <td align="left">13</td>
            <td align="left">Reserved</td>
            <td align="left"></td>
          </tr>
          <tr>
            <td align="left">14</td>
            <td align="left">Reserved</td>
            <td align="left"></td>
          </tr>
          <tr>
            <td align="left">15</td>
            <td align="left">Reserved</td>
            <td align="left"></td>
          </tr>
          <tr>
            <td align="left">224-254</td>
            <td align="left">Reserved for Experimental Use</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">255</td>
            <td align="left">Reserved for expansion of the type space</td>
            <td align="left">RFC 8966</td>
          </tr>
        </tbody>
      </table>

      <t>IANA has created a registry called "Babel Sub-TLV Types".  The allocation
policy for this registry is Specification Required for Types 0-111 and
128-239, and Experimental Use for Types 112-126 and 240-254.  The values
in this registry are as follows:</t>
      <table align="center">
        <thead>
          <tr>
            <th align="left">Type</th>
            <th align="left">Name</th>
            <th align="left">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">0</td>
            <td align="left">Pad1</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">1</td>
            <td align="left">PadN</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">2</td>
            <td align="left">Diversity</td>
            <td align="left">
              <xref target="I-D.chroboczek-babel-diversity-routing" format="default"/></td>
          </tr>
          <tr>
            <td align="left">3</td>
            <td align="left">Timestamp</td>
            <td align="left">
              <xref target="I-D.ietf-babel-rtt-extension" format="default"/></td>
          </tr>
          <tr>
            <td align="left">4-111</td>
            <td align="left">Unassigned</td>
            <td align="left"/>
          </tr>
          <tr>
            <td align="left">112-126</td>
            <td align="left">Reserved for Experimental Use</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">127</td>
            <td align="left">Reserved for expansion of the type space</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">128</td>
            <td align="left">Source Prefix</td>
            <td align="left">
              <xref target="I-D.ietf-babel-source-specific" format="default"/></td>
          </tr>
          <tr>
            <td align="left">129-239</td>
            <td align="left">Unassigned</td>
            <td align="left"/>
          </tr>
          <tr>
            <td align="left">240-254</td>
            <td align="left">Reserved for Experimental Use</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">255</td>
            <td align="left">Reserved for expansion of the type space</td>
            <td align="left">RFC 8966</td>
          </tr>
        </tbody>
      </table>
      <t>IANA has created a registry called "Babel Address
Encodings".  The allocation policy for this registry is Specification
Required for Address Encodings (AEs) 0-223, and Experimental Use for AEs
224-254.  The values in this registry are as follows:</t>
      <table align="center">
        <thead>
          <tr>
            <th align="left">AE</th>
            <th align="left">Name</th>
            <th align="left">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">0</td>
            <td align="left">Wildcard address</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">1</td>
            <td align="left">IPv4 address</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">2</td>
            <td align="left">IPv6 address</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">3</td>
            <td align="left">Link-local IPv6 address</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">4-223</td>
            <td align="left">Unassigned</td>
            <td align="left"/>
          </tr>
          <tr>
            <td align="left">224-254</td>
            <td align="left">Reserved for Experimental Use</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">255</td>
            <td align="left">Reserved for expansion of the AE space</td>
            <td align="left">RFC 8966</td>
          </tr>
        </tbody>
      </table>
      <t>IANA has renamed the registry called "Babel Flags Values" to "Babel Update Flags Values".  The allocation policy for this registry is Specification Required.  
The values in this registry are as follows:</t>
      <table align="center">
        <thead>
          <tr>
            <th align="left">Bit</th>
            <th align="left">Name</th>
            <th align="left">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">0</td>
            <td align="left">Default prefix</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">1</td>
            <td align="left">Default router-id</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">2-7</td>
            <td align="left">Unassigned</td>
            <td align="left"/>
          </tr>
        </tbody>
      </table>
      <t>IANA has created a new registry called "Babel Hello Flags
Values".  The allocation policy for this registry is Specification
Required.  The initial values in this registry are as follows:</t>
      <table align="center">
        <thead>
          <tr>
            <th align="left">Bit</th>
            <th align="left">Name</th>
            <th align="left">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">0</td>
            <td align="left">Unicast</td>
            <td align="left">RFC 8966</td>
          </tr>
          <tr>
            <td align="left">1-15</td>
            <td align="left">Unassigned</td>
            <td align="left"/>
          </tr>
        </tbody>
      </table>
      <t>IANA has replaced all references to RFCs&nbsp;6126 and 7557
in all of the registries mentioned above with references to this document.</t>
    </section>
    <section numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>As defined in this document, Babel is a completely insecure protocol.
Without additional security mechanisms, Babel trusts any information it
receives in plaintext UDP datagrams and acts on it.  An attacker that is
present on the local network can impact Babel operation in a variety of
ways; for example they can:
</t>
      <ul spacing="normal">
        <li>spoof a Babel packet, and redirect traffic by announcing a route with
a smaller metric, a larger sequence number, or a longer prefix;</li>
        <li>spoof a malformed packet, which could cause an insufficiently robust
implementation to crash or interfere with the rest of the network;</li>
        <li>replay a previously captured Babel packet, which could cause traffic to
be redirected, black-holed, or otherwise interfere with the network.</li>
      </ul>
      <t>
When carried over IPv6, Babel packets are ignored unless they are sent
from a link-local IPv6 address; since routers don't forward link-local
IPv6 packets, this mitigates the attacks outlined above by restricting
them to on-link attackers.  No such natural protection exists when Babel
packets are carried over IPv4, which is one of the reasons why it is
recommended to deploy Babel over IPv6
(<xref target="transmission-reception" format="default"/>).</t>
      <t>It is usually difficult to ensure that packets arriving at a Babel node
are trusted, even in the case where the local link is believed to be
secure.  For that reason, it is <bcp14>RECOMMENDED</bcp14> that all Babel traffic be
protected by an application-layer cryptographic protocol.  There are
currently two suitable mechanisms, which implement different trade-offs
between implementation simplicity and security:
</t>
      <ul spacing="normal">
        <li>Babel over DTLS <xref target="RFC8968" format="default"/> runs the majority of Babel
traffic over DTLS and leverages DTLS to authenticate nodes and provide
confidentiality and integrity protection;</li>
        <li>MAC authentication <xref target="RFC8967" format="default"/> appends a message
authentication code (MAC) to every Babel packet to prove that it
originated at a node that knows a shared secret, and includes sufficient
additional information to prove that the packet is fresh (not replayed).</li>
      </ul>
      <t>
Both mechanisms enable nodes to ignore packets generated by attackers
without the proper credentials.  They also ensure integrity of messages
and prevent message replay.  While Babel-DTLS supports asymmetric keying
and ensures confidentiality, Babel-MAC has a much more limited scope (see
Sections <xref target="RFC8967" section="1.1" sectionFormat="bare"/>, 
<xref target="RFC8967" section="1.2" sectionFormat="bare"/>, and 
<xref target="RFC8967" section="7" sectionFormat="bare"/> of 
<xref target="RFC8967" format="default"/>).  Since Babel-MAC
is simpler and more lightweight, it is recommended in preference to
Babel-DTLS in deployments where its limitations are acceptable, i.e., when
symmetric keying is sufficient and where the routing information is not
considered confidential.</t>
      <t>Every implementation of Babel <bcp14>SHOULD</bcp14> implement BABEL-MAC.</t>
      <t>One should be aware that the information that a mobile Babel node
announces to the whole routing domain is sufficient to determine the mobile
node's physical location with reasonable precision, which might cause
privacy concerns even if the control traffic is protected from
unauthenticated attackers by a cryptographic mechanism such as Babel-DTLS.
This issue may be mitigated somewhat by using randomly chosen router-ids
and randomly chosen IP addresses, and changing them often enough.</t>
    </section>
  </middle>
  <back>

<displayreference target="RFC0793" to="RFC793"/>
<displayreference target="RFC2453" to="RIP"/>
<displayreference target="RFC5444" to="PACKETBB"/>
<displayreference target="RFC2328" to="OSPF"/>
<displayreference target="I-D.chroboczek-babel-diversity-routing" to="BABEL-DIVERSITY"/>
<displayreference target="I-D.ietf-babel-rtt-extension" to="BABEL-RTT"/>
<displayreference target="I-D.ietf-babel-source-specific" to="BABEL-SS"/>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>

        <reference anchor="RFC8967" target="https://www.rfc-editor.org/info/rfc8967">
          <front>
            <title>MAC Authentication for the Babel Routing Protocol</title>
            <author fullname="Clara Dô" initials="C." surname="Dô">
               <organization/>
            </author>
            <author fullname="Weronika Kolodziejak" initials="W." surname="Kolodziejak">
               <organization/>
            </author>
            <author fullname="Juliusz Chroboczek" initials="J." surname="Chroboczek">
               <organization/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8967"/>
          <seriesInfo name="DOI" value="10.17487/RFC8967"/>
        </reference>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0793.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6126.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7557.xml"/>

        <reference anchor="RFC8968" target="https://www.rfc-editor.org/info/rfc8968">
          <front>
            <title>Babel Routing Protocol over Datagram Transport Layer Security</title>
            <author fullname="Antonin Décimo" initials="A." surname="Décimo">
               <organization/>
            </author>
            <author fullname="David Schinazi" initials="D." surname="Schinazi">
               <organization/>
            </author>
            <author fullname="Juliusz Chroboczek" initials="J." surname="Chroboczek">
               <organization/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8968"/>
          <seriesInfo name="DOI" value="10.17487/RFC8968"/>
        </reference>

        <reference anchor="JITTER">
          <front>
            <title>The Synchronization of Periodic Routing Messages</title>
            <author fullname="Sally Floyd" initials="S." surname="Floyd"/>
            <author fullname="Van Jacobson" initials="V." surname="Jacobson"/>
            <date month="April" year="1994"/>
          </front>
          <refcontent>IEEE/ACM Transactions on Networking</refcontent>
          <refcontent>2, 2, 122-136</refcontent>
          <seriesInfo name="DOI" value="10.1109/90.298431"/>
        </reference>

        <reference anchor="DSDV">
          <front>
            <title>Highly dynamic Destination-Sequenced Distance-Vector routing
      (DSDV) for mobile computers</title>
            <author fullname="Charles E. Perkins" initials="C." surname="Perkins"/>
            <author fullname="Pravin Bhagwat" initials="P." surname="Bhagwat"/>
            <date year="1994" month="October"/>
          </front>
          <refcontent>ACM SIGCOMM '94: Proceedings of the conference on 
           Communications architectures, protocols and applications</refcontent> 
          <refcontent>234-244</refcontent>
          <seriesInfo name="DOI" value="10.1145/190314.190336"/>
        </reference>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2453.xml"/>

        <reference anchor="DUAL">
          <front>
            <title>Loop-free routing using diffusing computations</title>
            <author fullname="J. J. Garcia Luna Aceves" initials="J. J." surname="Garcia Luna Aceves"/>
            <date month="February" year="1993"/>
          </front>
          <refcontent>IEEE/ACM Transactions on Networking</refcontent>
          <refcontent>1:1</refcontent>
          <seriesInfo name="DOI" value="10.1109/90.222913"/>
        </reference>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2328.xml"/>

        <reference anchor="IS-IS">
          <front>
            <title>Information technology -- Telecommunications and
    information exchange between systems -- Intermediate System to
    Intermediate System intra-domain routeing information exchange protocol
    for use in conjunction with the protocol for providing the
    connectionless-mode network service (ISO 8473)</title>
            <author>
              <organization>International Organization for Standardization</organization>
             </author>
            <date year="2002"/>
          </front>
          <refcontent>ISO/IEC 10589:2002</refcontent>
        </reference>

        <reference anchor="EIGRP">
          <front>
            <title>EIGRP -- a Fast Routing Protocol Based on Distance Vectors</title>
            <author fullname="Bob Albrightson" initials="B." surname="Albrightson"/>
            <author fullname="J. J. Garcia Luna Aceves" initials="J. J." surname="Garcia Luna Aceves"/>
            <author fullname="Joanne Boyle" initials="J." surname="Boyle"/>
            <date year="1994"/>
          </front>
          <refcontent>Proc. Networld/Interop 94</refcontent> 
        </reference>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3561.xml"/>

        <reference anchor="ETX">
          <front>
            <title>A high-throughput path metric for multi-hop wireless networks</title>
            <author fullname="Douglas S. J. De Couto" initials="D." surname="De Couto"/>
            <author fullname="Daniel Aguayo" initials="D." surname="Aguayo"/>
            <author fullname="John Bicket" initials="J." surname="Bicket"/>
            <author fullname="Robert Morris" initials="R." surname="Morris"/>
            <date year="2003" month="September"/>
          </front>
          <refcontent>MobiCom '03: Proceedings of the 9th annual international 
           conference on Mobile computing and networking</refcontent> 
          <refcontent>134-146</refcontent>
          <seriesInfo name="DOI" value="10.1145/938985.939000"/>
        </reference>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5444.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7298.xml"/>
        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-babel-source-specific.xml"/>
        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-babel-rtt-extension.xml"/>
        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.chroboczek-babel-diversity-routing.xml"/>

        <reference anchor="IEEE802.11">
          <front>
            <title>IEEE Standard for Information technology--Telecommunications and
information exchange between systems Local and metropolitan area
networks--Specific requirements Part 11: Wireless LAN Medium Access
Control (MAC) and Physical Layer (PHY) Specifications</title>
            <author>
              <organization>IEEE</organization>
            </author>
            <date  month="April" year="2012"/>
          </front>
          <seriesInfo name="IEEE" value="802.11-2012"/>
          <seriesInfo name="DOI" value="10.1109/ieeestd.2012.6178212"/>
        </reference>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2675.xml"/>

        <reference anchor="IEN137">
          <front>
            <title>On Holy Wars and a Plea for Peace</title>
            <author initials="D." surname="Cohen" fullname="Danny Cohen"/>
            <date day="1" month="April" year="1980"/>
          </front>
	  <seriesInfo name="IEN" value="137"/>
        </reference>

      </references>
    </references>
    <section numbered="true" toc="default">
      <name>Cost and Metric Computation</name>
      <t>The strategy for computing link costs and route metrics is a local
matter; Babel itself only requires that it comply with the conditions given
in <xref target="cost-computation" format="default"/> and <xref target="metric-computation" format="default"/>.
Different nodes may use different strategies in a single network and may
use different strategies on different interface types.  This section describes
a set of strategies that have been found to work well in actual networks.</t>
      <t>In summary, a node maintains per-neighbour statistics about the last 16
received Hello TLVs of each kind (<xref target="hello-history" format="default"/>),
it computes costs by using the 2-out-of-3 strategy (<xref target="k-j" format="default"/>) on
wired links and Expected Transmission Cost (ETX) (<xref target="etx" format="default"/>) on wireless links.  It uses an
additive algebra for metric computation (<xref target="metric-computation" format="default"/>).</t>
      <section anchor="hello-history" numbered="true" toc="default">
        <name>Maintaining Hello History</name>
        <t>For each neighbour, a node maintains two sets of Hello history, one for
each kind of Hello, and an expected sequence number, one for Multicast and
one for Unicast Hellos.  Each Hello history is a vector of 16 bits, where
a 1 value represents a received Hello, and a 0 value a missed Hello.  For
each kind of Hello, the expected sequence number, written ne, is the
sequence number that is expected to be carried by the next received Hello
from this neighbour.</t>
        <t>Whenever it receives a Hello packet of a given kind from a neighbour,
a node compares the received sequence number nr for that kind of Hello
with its expected sequence number ne.  Depending on the outcome of this
comparison, one of the following actions is taken:
</t>
        <ul spacing="normal">
          <li>if the two differ by more than 16 (modulo 2<sup>16</sup>), then the sending
  node has probably rebooted and lost its sequence number; the whole
  associated neighbour table entry is flushed and a new one is created;</li>
          <li>otherwise, if the received nr is smaller (modulo 2<sup>16</sup>) than the
  expected sequence number ne, then the sending node has increased its
  Hello interval without our noticing; the receiving node removes the last
  (ne - nr) entries from this neighbour's Hello history (we "undo
  history");</li>
          <li>otherwise, if nr is larger (modulo 2<sup>16</sup>) than ne, then the sending
  node has decreased its Hello interval, and some Hellos were lost; the
  receiving node adds (nr - ne) 0 bits to the Hello history (we
  "fast-forward").</li>
        </ul>
        <t>
The receiving node then appends a 1 bit to the Hello history and sets ne
to (nr + 1).  If the Interval field of the received Hello is not zero, it
resets the neighbour's hello timer to 1.5 times the advertised Interval
(the extra margin allows for delay due to jitter).</t>
        <t>Whenever either hello timer associated with a neighbour expires, the
local node adds a 0 bit to the corresponding Hello history, and increments
the expected Hello number.  If both Hello histories are empty (they
contain 0 bits only), the neighbour entry is flushed; otherwise, the
relevant hello timer is reset to the value advertised in the last Hello of
that kind received from this neighbour (no extra margin is necessary in
this case, since jitter was already taken into account when computing the
timeout that has just expired).</t>
      </section>
      <section anchor="cost-computation-examples" numbered="true" toc="default">
        <name>Cost Computation</name>
        <t>This section describes two algorithms suitable for computing costs
(<xref target="cost-computation" format="default"/>) based on Hello history.
<xref target="k-j" format="default"/> applies to wired links and <xref target="etx" format="default"/> to
wireless links.  <bcp14>RECOMMENDED</bcp14> default values of the parameters that appear
in these algorithms are given in <xref target="parameters" format="default"/>.</t>
        <section anchor="k-j" numbered="true" toc="default">
          <name>k-out-of-j</name>
          <t>K-out-of-j link sensing is suitable for wired links that are either up,
in which case they only occasionally drop a packet, or down, in which case
they drop all packets.</t>
          <t>The k-out-of-j strategy is parameterised by two small integers k and j,
such that 0 &lt; k &lt;= j, and the nominal link cost, a constant C &gt;= 1.
A node keeps a history of the last j hellos; if k or more of those have
been correctly received, the link is assumed to be up, and the rxcost is
set to C; otherwise, the link is assumed to be down, and the rxcost is set
to infinity.</t>
          <t>Since Babel supports two kinds of Hellos, a Babel node performs
k-out-of-j twice for each neighbour, once on the Unicast Hello history and once on the
Multicast Hello history.  If either of the instances of k-out-of-j
indicates that the link is up, then the link is assumed to be up, and the
rxcost is set to C; if both instances indicate that the link is down, then
the link is assumed to be down, and the rxcost is set to infinity.  In
other words, the resulting rxcost is the minimum of the rxcosts yielded by
the two instances of k-out-of-j link sensing.</t>
          <t>The cost of a link performing k-out-of-j link sensing is defined as
follows:
          </t>
          <ul spacing="normal">
            <li>cost = FFFF hexadecimal if rxcost = FFFF hexadecimal;</li>
            <li>cost = txcost otherwise.</li>
          </ul>
        </section>
        <section anchor="etx" numbered="true" toc="default">
          <name>ETX</name>
          <t>Unlike wired links which are bimodal (either up or down), wireless
links exhibit continuous variation of the link quality.  Naive application
of hop-count routing in networks that use wireless links for transit tends
to select long, lossy links in preference to shorter, lossless links,
which can dramatically reduce throughput.  For that reason, a routing
protocol designed to support wireless links must perform some form of
link quality estimation.</t>
          <t>The Expected Transmission Cost algorithm, or ETX <xref target="ETX" format="default"/>,
is a simple link quality estimation algorithm that is designed to work
well with the IEEE&nbsp;802.11 MAC <xref target="IEEE802.11" format="default"/>.  By
default, the IEEE&nbsp;802.11 MAC performs Automatic Repeat Query (ARQ)
and rate adaptation on unicast frames, but not on multicast frames, which
are sent at a fixed rate with no ARQ; therefore, measuring the loss rate
of multicast frames yields a useful estimate of a link's quality.</t>
          <t>A node performing ETX link quality estimation uses a neighbour's
Multicast Hello history to compute an estimate, written beta, of the
probability that a Hello TLV is successfully received.  Beta can be
computed as the fraction of 1 bits within a small number (say, 6) of the
most recent entries in the Multicast Hello history, or it can be an
exponential average, or some combination of both approaches.  Let rxcost
be 256/beta.</t>
          <t>Let alpha be MIN(1, 256/txcost), an estimate of the probability of
successfully sending a Hello TLV.  The cost is then computed by
          </t>
            <t indent="3">cost = 256/(alpha * beta)</t>
          <t>
or, equivalently,
          </t>
            <t indent="3">cost = (MAX(txcost, 256) * rxcost) / 256.</t>
          <t>Since the IEEE&nbsp;802.11 MAC performs ARQ on unicast frames, unicast
frames do not provide a useful measure of link quality, and therefore ETX
ignores the Unicast Hello history.  Thus, a node performing ETX
link quality estimation will not route through neighbouring nodes unless
they send periodic Multicast Hellos (possibly in addition to Unicast
Hellos).</t>
        </section>
      </section>
      <section anchor="route-selection-hysteresis" numbered="true" toc="default">
        <name>Route Selection and Hysteresis</name>
        <t>Route selection (<xref target="route-selection" format="default"/>) is the process by
which a node selects a single route among the routes that it has available
towards a given destination.  With Babel, any route selection procedure
that only ever chooses feasible routes with a finite metric will yield
a set of loop-free routes; however, in the presence of continuously
variable metrics such as ETX (<xref target="etx" format="default"/>), a naive route
selection procedure might lead to persistent oscillations.  Such
oscillations can be limited or avoided altogether by implementing
hysteresis within the route selection algorithm, i.e., by making the route
selection algorithm sensitive to a route's history.  Any reasonable
hysteresis algorithm should yield good results; the following algorithm
is simple to implement and has been successfully deployed in a variety of
environments.</t>
        <t>For every route R, in addition to the route's metric m(R), maintain
a smoothed version of m(R) written ms(R) (we RECOMMEND computing ms(R) as an
exponentially smoothed average (see <xref target="RFC0793" section="3.7" sectionFormat="of" format="default"/>)
of m(R) with a time constant equal to the Hello interval multiplied by
a small number such as 3).  If no route to a given destination is selected,
then select the route with the smallest metric, ignoring the smoothed
metric.  If a route R is selected, then switch to a route R' only when
both m(R')&nbsp;&lt;&nbsp;m(R) and ms(R')&nbsp;&lt;&nbsp;ms(R).</t>
        <t>Intuitively, the smoothed metric is a long-term estimate of the quality
of a route.  The algorithm above works by only switching routes when both
the instantaneous and the long-term estimates of the route's quality
indicate that switching is profitable.</t>
      </section>
    </section>
    <section anchor="parameters" numbered="true" toc="default">
      <name>Protocol Parameters</name>
      <t>The choice of time constants is a trade-off between fast detection of
mobility events and protocol overhead.  Two instances of Babel running
with different time constants will interoperate, although the resulting
worst-case convergence time will be dictated by the slower of the two.</t>
      <t>The Hello interval is the most important time constant: an outage or
a mobility event is detected within 1.5 to 3.5 Hello intervals.  Due to
Babel's use of a redundant route table, and due to its reliance on
triggered updates and explicit requests, the Update interval has little
influence on the time needed to reconverge after an outage: in practice,
it only has a significant effect on the time needed to acquire new routes
after a mobility event.  While the protocol allows intervals as low as
10 ms, such low values would cause significant amounts of protocol traffic
for little practical benefit.</t>
      <t>The following values have been found to work well in a variety of
environments and are therefore <bcp14>RECOMMENDED</bcp14> default values:
</t>
      <dl spacing="normal" indent="10">
        <dt>Multicast Hello interval:</dt><dd>4 seconds.</dd>
        <dt>Unicast Hello interval:</dt><dd>infinite (no Unicast Hellos are sent).</dd>
        <dt>Link cost:</dt><dd>estimated using ETX on wireless links; 2-out-of-3 with C=96
on wired links.</dd>
        <dt>IHU interval:</dt><dd>the advertised IHU interval is always 3 times the
Multicast Hello interval.  IHUs are actually sent with each Hello on lossy
links (as determined from the Hello history), but only with every third
Multicast Hello on lossless links.</dd>
        <dt>Update interval:</dt><dd>4 times the Multicast Hello interval.</dd>
        <dt>IHU Hold time:</dt><dd>3.5 times the advertised IHU interval.</dd>
        <dt>Route Expiry time:</dt><dd>3.5 times the advertised update interval.</dd>
        <dt>Request timeout:</dt><dd>initially 2 seconds, doubled every time a request is
resent, up to a maximum of three times.</dd>
        <dt>Urgent timeout:</dt><dd>0.2 seconds.</dd>
        <dt>Source GC time:</dt><dd>3 minutes.</dd>
      </dl>
    </section>
    <section anchor="filtering" numbered="true" toc="default">
      <name>Route Filtering</name>
      <t>Route filtering is a procedure where an instance of a routing protocol
either discards some of the routes announced by its neighbours or learns
them with a metric that is higher than what would be expected.  Like all
distance-vector protocols, Babel has the ability to apply arbitrary
filtering to the routes it learns, and implementations of Babel that apply
different sets of filtering rules will interoperate without causing
routing loops.  The protocol's ability to perform route filtering is
a consequence of the latitude given in <xref target="metric-computation" format="default"/>:
Babel can use any metric that is strictly monotonic, including one that
assigns an infinite metric to a selected subset of routes.  (See also
<xref target="handling-requests" format="default"/>, where requests for nonexistent routes
are treated in the same way as requests for routes with infinite metric.)</t>
      <t>It is not in general correct to learn a route with a metric smaller
than the one it was announced with, or to replace a route's destination
prefix with a more specific (longer) one.  Doing either of these may cause
persistent routing loops.</t>
      <t>Route filtering is a useful tool, since it allows fine-grained tuning
of the routing decisions made by the routing protocol.  Accordingly, some
implementations of Babel implement a rich configuration language that
allows applying filtering to sets of routes defined, for example, by
incoming interface and destination prefix.</t>
      <t>In order to limit the consequences of misconfiguration, Babel
implementations provide a reasonable set of default filtering rules even
when they don't allow configuration of filtering by the user.  At
a minimum, they discard routes with a destination prefix in fe80::/64,
ff00::/8, 127.0.0.1/32, 0.0.0.0/32, and 224.0.0.0/8.</t>
    </section>
    <section anchor="extensions" numbered="true" toc="default">
      <name>Considerations for Protocol Extensions</name>
      <t>Babel is an extensible protocol, and this document defines a number of
mechanisms that can be used to extend the protocol in a backwards
compatible manner:
</t>
      <ul spacing="normal">
        <li>increasing the version number in the packet header;</li>
        <li>defining new TLVs;</li>
        <li>defining new sub-TLVs (with or without the mandatory bit set);</li>
        <li>defining new AEs;</li>
        <li>using the packet trailer.</li>
      </ul>
      <t>This appendix is intended to guide designers of protocol extensions in
choosing a particular encoding.</t>
      <t>The version number in the Babel header should only be increased if the
new version is not backwards compatible with the original protocol.</t>
      <t>In many cases, an extension could be implemented either by defining
a new TLV or by adding a new sub-TLV to an existing TLV.  For example, an
extension whose purpose is to attach additional data to route updates can
be implemented either by creating a new "enriched" Update TLV, by adding
a nonmandatory sub-TLV to the Update TLV, or by adding a mandatory
sub-TLV.</t>
      <t>The various encodings are treated differently by implementations that
do not understand the extension.  In the case of a new TLV or of a sub-TLV
with the mandatory bit set, the whole TLV is ignored by implementations
that do not implement the extension, while in the case of a nonmandatory
sub-TLV, the TLV is parsed and acted upon, and only the unknown sub-TLV is
silently ignored.  Therefore, a nonmandatory sub-TLV should be used by
extensions that extend the Update in a compatible manner (the extension
data may be silently ignored), while a mandatory sub-TLV or a new TLV must
be used by extensions that make incompatible extensions to the meaning of
the TLV (the whole TLV must be thrown away if the extension data is not
understood).</t>
      <t>Experience shows that the need for additional data tends to crop up in
the most unexpected places.  Hence, it is recommended that extensions that
define new TLVs should make them self-terminating and allow attaching
sub-TLVs to them.</t>
      <t>Adding a new AE is essentially equivalent to adding a new TLV: Update
TLVs with an unknown AE are ignored, just like unknown TLVs.  However,
adding a new AE is more involved than adding a new TLV, since it creates
a new set of compression state.  Additionally, since the Next Hop TLV
creates state specific to a given address family, as opposed to a given
AE, a new AE for a previously defined address family must not be used in
the Next Hop TLV if backwards compatibility is required.  A similar issue
arises with Update TLVs with unknown AEs establishing a new router-id (due
to the Router-Id flag being set).  Therefore, defining new AEs must be
done with care if compatibility with unextended implementations is
required.</t>
      <t>The packet trailer is intended to carry cryptographic signatures that
only cover the packet body; storing the cryptographic signatures in the
packet trailer avoids clearing the signature before computing a hash of
the packet body, and makes it possible to check a cryptographic signature
before running the full, stateful TLV parser.  Hence, only TLVs that don't
need to be protected by cryptographic security protocols should be allowed
in the packet trailer.  Any such TLVs should be easy to parse and, in
particular, should not require stateful parsing.</t>
    </section>
    <section numbered="true" toc="default">
      <name>Stub Implementations</name>
      <t>Babel is a fairly economic protocol.  Updates take between 12 and 40
octets per destination, depending on the address family and how successful
compression is; in a dual-stack flat network, an average of less than 24
octets per update is typical.  The route table occupies about 35 octets
per IPv6 entry.  To put these values into perspective, a single full-size
Ethernet frame can carry some 65 route updates, and a megabyte of memory
can contain a 20,000-entry route table and the associated source table.</t>
      <t>Babel is also a reasonably simple protocol.  One complete implementation
consists of less than 12,000 lines of C code, and it compiles to less
than 120 KB of text on a 32-bit CISC architecture; about half of this
figure is due to protocol extensions and user-interface code.</t>
      <t>Nonetheless, in some very constrained environments, such as PDAs,
microwave ovens, or abacuses, it may be desirable to have subset
implementations of the protocol.</t>
      <t>There are many different definitions of a stub router, but for the
needs of this section, a stub implementation of Babel is one that announces
one or more directly attached prefixes into a Babel network but doesn't
re-announce any routes that it has learnt from its neighbours, and always
prefers the direct route to a directly attached prefix to a route learnt
over the Babel protocol, even when the prefixes are the same.  It may
either maintain a full routing table or simply select a default gateway
through any one of its neighbours that announces a default route.  Since
a stub implementation never forwards packets except from or to a directly
attached link, it cannot possibly participate in a routing loop, and hence
it need not evaluate the feasibility condition or maintain a source
table.</t>
      <t>No matter how primitive, a stub implementation must parse sub-TLVs
attached to any TLVs that it understands and check the mandatory bit.
It must answer acknowledgment requests and must participate in the
Hello/IHU protocol.  It must also be able to reply to seqno requests for
routes that it announces, and it should be able to reply to route
requests.</t>
      <t>Experience shows that an IPv6-only stub implementation of Babel can be
written in less than 1,000 lines of C code and compile to 13 KB of
text on 32-bit CISC architecture.</t>
    </section>
    <section numbered="true" toc="default">
      <name>Compatibility with Previous Versions</name>
      <t>The protocol defined in this document is a successor to the protocol
defined in <xref target="RFC6126" format="default"/> and <xref target="RFC7557" format="default"/>.  While
the two protocols are not entirely compatible, the new protocol has been
designed so that it can be deployed in existing RFC 6126 networks without
requiring a flag day.</t>
      <t>There are three optional features that make this protocol
incompatible with its predecessor.  First of all, RFC 6126 did not define
Unicast Hellos (<xref target="reverse-reachability" format="default"/>), and an
implementation of RFC 6126 will misinterpret a Unicast Hello for
a Multicast one; since the sequence number space of Unicast Hellos is
distinct from the sequence number space of Multicast Hellos, sending a Unicast
Hello to an implementation of RFC 6126 will confuse its link quality
estimator.  Second, RFC 6126 did not define unscheduled Hellos, and an
implementation of RFC 6126 will mis-parse Hellos with an interval equal to
0.  Finally, RFC 7557 did not define mandatory sub-TLVs 
(<xref target="sub-tlv-format" format="default"/>), and thus an implementation of RFCs 6126 and
7557 will not correctly ignore a TLV that carries an unknown mandatory
sub-TLV; depending on the sub-TLV, this might cause routing pathologies.</t>
      <t>An implementation of this specification that never sends Unicast or
unscheduled Hellos and doesn't implement any extensions that use mandatory
sub-TLVs is safe to deploy in a network in which some nodes implement the
protocol described in RFCs 6126 and 7557.</t>
      <t>Two changes need to be made to an implementation of RFCs 6126 and 7557
so that it can safely interoperate in all cases with implementations of
this protocol.  First, it needs to be modified either to ignore or to process
Unicast and unscheduled Hellos.  Second, it needs to be modified to parse
sub-TLVs of all the TLVs that it understands and that allow sub-TLVs, and
to ignore the TLV if an unknown mandatory sub-TLV is found.  It is not
necessary to parse unknown TLVs, as these are ignored in any case.</t>
      <t>There are other changes, but these are not of a nature to prevent
interoperability:
</t>
      <ul spacing="normal">
        <li>the conditions on route acquisition (<xref target="route-acquisition" format="default"/>)
have been relaxed;</li>
        <li>route selection should no longer use the route's sequence number
(<xref target="route-selection" format="default"/>);</li>
        <li>the format of the packet trailer has been defined
(<xref target="packet-format" format="default"/>);</li>
        <li>router-ids with a value of all-zeros or all-ones have been forbidden
(<xref target="router-id-def" format="default"/>);</li>
        <li>the compression state is now specific to an address family rather than
an address encoding (<xref target="parser-state" format="default"/>);</li>
        <li>packet pacing is now recommended
(<xref target="transmission-reception" format="default"/>).</li>
      </ul>
    </section>

    <section numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>A number of people have contributed text and ideas to this
specification.  The authors are particularly indebted to <contact fullname="Matthieu Boutier"/>,
<contact fullname="Gwendoline Chouasne"/>, <contact fullname="Margaret Cullen"/>, 
<contact fullname="Donald Eastlake"/>, <contact fullname="Toke Høiland-Jørgensen"/>, 
<contact fullname="Benjamin Kaduk"/>, <contact fullname="Joao Sobrinho"/>, and 
<contact fullname="Martin Vigoureux"/>.
The previous version of this specification <xref target="RFC6126" format="default"/>  
greatly benefited from the input of <contact fullname="Joel Halpern"/>.  The address compression
technique was inspired by <xref target="RFC5444" format="default"/>.</t>
    </section>
  </back>
</rfc>
