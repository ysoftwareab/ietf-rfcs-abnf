<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" docName="draft-ietf-idr-flow-spec-v6-22" 
number="8956" ipr="trust200902" updates="8955" obsoletes="" 
submissionType="IETF" category="std" consensus="true" xml:lang="en" tocInclude="true" tocDepth="2"
symRefs="true" sortRefs="true" version="3">

  <!-- xml2rfc v2v3 conversion 3.5.0 -->

  <front>
    <title abbrev="IPv6 Flow Specification">Dissemination of Flow Specification Rules for IPv6</title>
    <seriesInfo name="RFC" value="8956"/>
    <author role="editor" fullname="Christoph Loibl" initials="C" surname="Loibl">
      <organization>next layer Telekom GmbH</organization>
      <address>
        <postal>
          <street>Mariahilfer Guertel 37/7</street>
          <city>Vienna</city>
          <region/>
          <code>1150</code>
          <country>Austria</country>
        </postal>
        <phone>+43 664 1176414</phone>
        <email>cl@tix.at</email>
      </address>
    </author>
    <author fullname="Robert Raszuk" initials="R" surname="Raszuk" role="editor">
      <organization>NTT Network Innovations</organization>
      <address>
        <postal>
          <street>940 Stewart Dr</street>
          <city>Sunnyvale</city>
          <region>CA</region>
          <code>94085</code>
          <country>United States of America</country>
        </postal>
        <email>robert@raszuk.net</email>
      </address>
    </author>
    <author role="editor" fullname="Susan Hares" initials="S" surname="Hares">
      <organization>Huawei</organization>
      <address>
        <postal>
          <street>7453 Hickory Hill</street>
          <city>Saline</city>
          <region>MI</region>
          <code>48176</code>
          <country>United States of America</country>
        </postal>
        <email>shares@ndzh.com</email>
      </address>
    </author>
    <date year="2020" month="December" />
    <area>Routing</area>
    <workgroup>IDR</workgroup>
    <keyword>BGP Flow Specification</keyword>
    <keyword>V6</keyword>
    <abstract>
      <t>
   "Dissemination of Flow Specification Rules" (RFC 8955)
   provides a Border Gateway Protocol (BGP)
   extension for the propagation of traffic flow information for
   the purpose of rate limiting or filtering IPv4 protocol data packets.
      </t>
      <t>
   This document extends RFC 8955 with IPv6 functionality.
   It also updates RFC 8955 by changing the IANA Flow Spec 
   Component Types registry.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" numbered="true" toc="default">
      <name>Introduction</name>
      <t>The growing amount of IPv6 traffic in private and public networks
   requires the extension of tools used in IPv4-only networks to also support
   IPv6 data packets.
      </t>
      <t>
   This document analyzes the differences between describing IPv6
   <xref target="RFC8200" format="default"/> flows and those of IPv4 packets. It specifies
   new Border Gateway Protocol <xref target="RFC4271" format="default"/> encoding formats to enable
   "Dissemination of Flow Specification Rules" <xref target="RFC8955" format="default"/>
   for IPv6.
      </t>
      <t>
    This specification is an extension of the base established in <xref target="RFC8955" format="default"/>. 
    It only defines the delta changes required to support IPv6, while all other
    definitions and operation mechanisms of "Dissemination of Flow Specification
    Rules" will remain in the main specification and will not be repeated here.
      </t>
      <section numbered="true" toc="default">
        <name>Definitions of Terms Used in This Memo</name>
        <dl newline="false" spacing="normal" indent="10"> 
          <dt>AFI:</dt>
          <dd>Address Family Identifier</dd>
          <dt>AS: </dt>
          <dd>Autonomous System</dd>
          <dt>NLRI: </dt>
          <dd>Network Layer Reachability Information</dd>
          <dt>SAFI: </dt>
          <dd>Subsequent Address Family Identifier</dd>
          <dt>VRF: </dt>
          <dd>Virtual Routing and Forwarding</dd>
        </dl>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>IPv6 Flow Specification Encoding in BGP</name>
      <t>
   <xref target="RFC8955" format="default"/> defines SAFIs
   133 (Dissemination of Flow Specification rules) and 134 (L3VPN
   Dissemination of Flow Specification rules) in order to carry
   the corresponding Flow Specification.
      </t>
      <t>
   Implementations wishing to exchange IPv6 Flow Specifications <bcp14>MUST</bcp14> use
   BGP's Capability Advertisement facility to exchange the Multiprotocol
   Extension Capability Code (Code 1), as defined in <xref target="RFC4760" format="default"/>.
   The (AFI, SAFI) pair carried in the Multiprotocol Extension Capability <bcp14>MUST</bcp14> be
   (AFI=2, SAFI=133) for IPv6 Flow Specification rules and (AFI=2, SAFI=134) for L3VPN Dissemination of Flow Specification rules.
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>IPv6 Flow Specification Components</name>
      <t>
   The encoding of each of the components begins with a Type field (1 octet)
   followed by a variable length parameter. The following sections define
   component types and parameter encodings for IPv6.
      </t>
      <t>
   Types 4 (Port), 5 (Destination Port), 6 (Source Port), 9 (TCP Flags), 10 (Packet Length), 
   and 11 (DSCP), 
   as defined in <xref target="RFC8955" format="default"/>,
   also apply to IPv6. Note that IANA has updated the "Flow Spec Component Types" registry in order 
   to contain both IPv4 and IPv6 Flow Specification component type numbers in a single registry
   (<xref target="IANA" format="default"/>).   
      </t>
      <section anchor="type_1" toc="include" numbered="true">
        <name>Type 1 - Destination IPv6 Prefix</name>
	<dl newline="false" spacing="normal">
        <dt>Encoding:</dt>
	<dd>&lt;type (1 octet), length (1 octet), offset (1 octet), pattern (variable), 
	padding (variable) &gt;</dd>
	</dl>
        <t>This defines the destination prefix to match.  
      The offset has been defined to allow for flexible matching to portions of an
      IPv6 address where one is required to skip over the first N bits of the address.
      (These bits skipped are often indicated as "don't care" bits.)
      This can be especially useful where part of the IPv6 address
      consists of an embedded IPv4 address, and matching needs to happen
      only on the embedded IPv4 address. The encoded pattern contains
      enough octets for the bits used in matching (length minus offset
      bits).
        </t>
        <dl newline="false" spacing="normal" indent="11">
          <dt>length:</dt>
          <dd>This indicates the N-th most significant bit in the address where 
           bitwise pattern matching stops. 
        </dd>
          <dt>offset:</dt>
          <dd>This indicates the number of most significant address bits to 
           skip before bitwise pattern matching starts.
        </dd>
          <dt>pattern:</dt>
          <dd>This contains the matching pattern. The length of the pattern is defined by the 
           number of bits needed for pattern matching (length minus offset).
        </dd>
          <dt>padding:</dt>
          <dd>This contains the minimum number of bits required to pad the component to an octet boundary.
           Padding bits <bcp14>MUST</bcp14> be 0 on encoding and <bcp14>MUST</bcp14> be ignored on decoding.
        </dd>
        </dl>

        <t>
        If length = 0  and offset = 0, this component matches every address; otherwise, length <bcp14>MUST</bcp14> be in the 
	range offset &lt; length  &lt; 129 or the component is malformed.</t>
        <t>
        Note: This Flow Specification component can be represented by the notation ipv6address/length 
	if offset is 0 or  
        ipv6address/offset-length. The ipv6address in this notation is the textual IPv6 representation 
	of the pattern 
        shifted to the right by the number of offset bits. See also <xref target="examples" format="default"/>.    
        </t>
      </section>
      <section anchor="type_2" toc="include" numbered="true">
        <name>Type 2 - Source IPv6 Prefix</name>
	<dl newline="false" spacing="normal">
        <dt>Encoding:</dt>
	<dd>&lt;type (1 octet), length (1 octet), offset (1 octet), pattern (variable), 
	padding (variable) &gt;</dd>
	</dl>
        <t>This defines the source prefix to match. The length, offset, pattern, and padding
          are the same as in <xref target="type_1" format="default"/>.
        </t>
      </section>
      <section anchor="type_3" numbered="true" toc="default">
        <name>Type 3 - Upper-Layer Protocol</name>
	<dl newline="false" spacing="normal">
        <dt>Encoding:</dt>
	<dd>&lt;type (1 octet), [numeric_op, value]+&gt;</dd>
        </dl>
        <t>This contains a list of {numeric_op, value} pairs that
      are used to match the first Next Header value octet in IPv6 packets 
      that is not an extension header and thus indicates that the next item 
      in the packet is the corresponding upper-layer header (see 
      <xref target="RFC8200" sectionFormat="of" section="4"/>).
        </t>
        <t>This component uses the Numeric Operator (numeric_op) described in
      <xref target="RFC8955" sectionFormat="of" section="4.2.1.1"/>.
      Type 3 component values <bcp14>SHOULD</bcp14> be encoded as a single octet
      (numeric_op len=00).
        </t>
        <t>Note: While IPv6 allows for more than one Next Header field in the
	  packet, the main goal of the Type 3 Flow Specification component is to
      match on the first upper-layer IP protocol value.  Therefore, the
      definition is limited to match only on this specific Next Header field in
      the packet.
        </t>
      </section>
      <section anchor="type_7" toc="include" numbered="true">
        <name>Type 7 - ICMPv6 Type</name>
	<dl newline="false" spacing="normal">
        <dt>Encoding:</dt>
	<dd>&lt;type (1 octet), [numeric_op, value]+&gt;</dd>
        </dl>
        <t>This defines a list of {numeric_op, value} pairs used to match the
    Type field of an ICMPv6 packet (see also <xref target="RFC4443" sectionFormat="of" section="2.1"/>).
        </t>
        <t>
        This component uses the Numeric Operator (numeric_op) described
        in <xref target="RFC8955" sectionFormat="of" section="4.2.1.1"/>.
        Type 7 component values <bcp14>SHOULD</bcp14> be encoded as a single octet
        (numeric_op len=00).
        </t>
        <t>
        In case of the presence of the ICMPv6 type
        component, only ICMPv6 packets can match the entire Flow Specification.
        The ICMPv6 type component, if present, never matches when the packet's
        upper-layer IP protocol value is not 58 (ICMPv6), if the packet is fragmented
        and this is not the first fragment, or if the system is unable to
        locate the transport header. Different implementations may or may not be
        able to decode the transport header.
        </t>
      </section>
      <section anchor="type_8" toc="include" numbered="true">
        <name>Type 8 - ICMPv6 Code</name>
	<dl newline="false" spacing="normal">
        <dt>Encoding:</dt>
	<dd>&lt;type (1 octet), [numeric_op, value]+&gt;</dd>
	</dl>
        <t>
    This defines a list of {numeric_op, value} pairs used to match the
    code field of an ICMPv6 packet (see also <xref target="RFC4443" sectionFormat="of" section="2.1"/>).
        </t>
        <t>
        This component uses the Numeric Operator (numeric_op) described
        in <xref target="RFC8955" sectionFormat="of" section="4.2.1.1"/>.
        Type 8 component values <bcp14>SHOULD</bcp14> be encoded as a single octet
        (numeric_op len=00).
        </t>
        <t>
        In case of the presence of the ICMPv6 code
        component, only ICMPv6 packets can match the entire Flow Specification.
        The ICMPv6 code component, if present, never matches when the packet's
        upper-layer IP protocol value is not 58 (ICMPv6), if the packet is fragmented
        and this is not the first fragment, or if the system is unable to
        locate the transport header. Different implementations may or may not be
        able to decode the transport header.
        </t>
      </section>
      <section anchor="type_12" numbered="true" toc="default">
        <name>Type 12 - Fragment</name>
	<dl newline="false" spacing="normal">
        <dt>Encoding:</dt>
	<dd>&lt;type (1 octet), [bitmask_op, bitmask]+&gt;</dd>
        </dl>
        <t>This defines a list of {bitmask_op, bitmask} pairs used to match specific IP fragments.</t>
        <t>This component uses the Bitmask Operator (bitmask_op) described
      in <xref target="RFC8955" sectionFormat="of" section="4.2.1.2"/>. The
      Type 12 component bitmask <bcp14>MUST</bcp14> be encoded as a single octet bitmask
      (bitmask_op len=00).
        </t>
        <figure anchor="figure_fragment_bitmask_operand">
          <name>Fragment Bitmask Operand</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
                   0   1   2   3   4   5   6   7
                 +---+---+---+---+---+---+---+---+
                 | 0 | 0 | 0 | 0 |LF |FF |IsF| 0 |
                 +---+---+---+---+---+---+---+---+
]]></artwork>
        </figure>
        <t>Bitmask values:
        </t>
        <dl newline="false" spacing="normal" indent="6">
          <dt>IsF:</dt>
          <dd>Is a fragment other than the first -- match if IPv6 Fragment Header 
	  (<xref target="RFC8200" sectionFormat="of" section="4.5"/>) Fragment Offset is not 0</dd>
          <dt>FF:</dt>
          <dd>First fragment -- match if IPv6 Fragment Header (<xref target="RFC8200" sectionFormat="of"  
	  section="4.5"/>) Fragment Offset is 0 AND M flag is 1</dd>
          <dt>LF:</dt>
          <dd>Last fragment -- match if IPv6 Fragment Header (<xref target="RFC8200" sectionFormat="of"
	  section="4.5"/>) Fragment Offset is not 0 AND M flag is 0</dd>
          <dt>0:</dt>
          <dd><bcp14>MUST</bcp14> be set to 0 on NLRI encoding and <bcp14>MUST</bcp14> be ignored 
	  during decoding</dd>
        </dl>
      </section>
      <section anchor="type_13" numbered="true" toc="default">
        <name>Type 13 - Flow Label (new)</name>
	<dl newline="false" spacing="normal">
        <dt>Encoding:</dt>
	<dd>&lt;type (1 octet), [numeric_op, value]+&gt;</dd>
        </dl>
        <t>This contains a list of {numeric_op, value} pairs that are used to match
      the 20-bit Flow Label IPv6 header field (<xref target="RFC8200" sectionFormat="of" section="3"/>).
        </t>
        <t>This component uses the Numeric Operator (numeric_op) described in
      <xref target="RFC8955" sectionFormat="of" section="4.2.1.1"/>. Type 13
      component values <bcp14>SHOULD</bcp14> be encoded as 4-octet quantities
      (numeric_op len=10).
        </t>
      </section>
      <section anchor="examples" numbered="true" toc="default">
        <name>Encoding Examples</name>
        <section numbered="true">
          <name>Example 1</name>
          <t>
   The following example demonstrates the prefix encoding for
   packets from ::1234:5678:9a00:0/64-104 to 2001:db8::/32 and upper-layer protocol tcp.
	  </t>

<table anchor="example-1" align="left">
  <thead>
    <tr>
      <th>len</th>
      <th>destination</th>
      <th>source</th>
      <th>ul-proto</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x12</td>
      <td>01 20 00 20 01 0d bb</td>
      <td>02 68 40 12 34 56 78 9a</td>
      <td>03 81 06</td>
    </tr>
  </tbody>
</table>
          <t>Decoded:</t>
<table anchor="example-1-decoded" align="left">
  <thead>
    <tr>
      <th>Value</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x12</td>
      <td>length</td>
      <td>18 octets (if len&lt;240, 1 octet)</td>
    </tr>
    <tr>
      <td>0x01</td>
      <td>type</td>
      <td>Type 1 - Dest.&nbsp;IPv6 Prefix</td>
    </tr>
    <tr>
      <td>0x20</td>
      <td>length</td>
      <td>32 bits</td>
    </tr>
    <tr>
      <td>0x00</td>
      <td>offset</td>
      <td>0 bits</td>
    </tr>
    <tr>
      <td>0x20</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0x01</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0x0d</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0xb8</td>
      <td>pattern</td>
      <td>(no padding needed)</td>
    </tr>
    <tr>
      <td>0x02</td>
      <td>type</td>
      <td>Type 2 - Source IPv6 Prefix</td>
    </tr>
    <tr>
      <td>0x68</td>
      <td>length</td>
      <td>104 bits</td>
    </tr>
    <tr>
      <td>0x40</td>
      <td>offset</td>
      <td>64 bits</td>
    </tr>
    <tr>
      <td>0x12</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0x34</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0x56</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0x78</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0x9a</td>
      <td>pattern</td>
      <td>(no padding needed)</td>
    </tr>
    <tr>
      <td>0x03</td>
      <td>type</td>
      <td>Type 3 - Upper-Layer Protocol</td>
    </tr>
    <tr>
      <td>0x81</td>
      <td>numeric_op</td>
      <td>end-of-list, value size=1, ==</td>
    </tr>
    <tr>
      <td>0x06</td>
      <td>value</td>
      <td>06</td>
    </tr>
  </tbody>
</table>
          <t>This constitutes an NLRI with an NLRI length of 18 octets.</t>
          <t>
    Padding is not needed either for the destination prefix pattern
    (length - offset = 32 bits) or for the source prefix pattern
    (length - offset = 40 bits), as both patterns end on an octet
    boundary.
</t>
        </section>
        <section numbered="true">
          <name>Example 2</name>
          <t>
   The following example demonstrates the prefix encoding for all
   packets from ::1234:5678:9a00:0/65-104 to 2001:db8::/32.
</t>
<table anchor="example-2" align="left">
  <thead>
    <tr>
      <th>length</th>
      <th>destination</th>
      <th>source</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x0f</td>
      <td>01 20 00 20 01 0d b8</td>
      <td>02 68 41 24 68 ac f1 34</td>
    </tr>
  </tbody>
</table>
          <t>Decoded:</t>
<table anchor="example-2-decoded" align="left">
  <thead>
    <tr>
      <th>Value</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x0f</td>
      <td>length</td>
      <td>15 octets (if len&lt;240, 1 octet)</td>
    </tr>
    <tr>
      <td>0x01</td>
      <td>type</td>
      <td>Type 1 - Dest.&nbsp;IPv6 Prefix</td>
    </tr>
    <tr>
      <td>0x20</td>
      <td>length</td>
      <td>32 bits</td>
    </tr>
    <tr>
      <td>0x00</td>
      <td>offset</td>
      <td>0 bits</td>
    </tr>
    <tr>
      <td>0x20</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0x01</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0x0d</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0xb8</td>
      <td>pattern</td>
      <td>(no padding needed)</td>
    </tr>
    <tr>
      <td>0x02</td>
      <td>type</td>
      <td>Type 2 - Source IPv6 Prefix</td>
    </tr>
    <tr>
      <td>0x68</td>
      <td>length</td>
      <td>104 bits</td>
    </tr>
    <tr>
      <td>0x41</td>
      <td>offset</td>
      <td>65 bits</td>
    </tr>
    <tr>
      <td>0x24</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0x68</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0xac</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0xf1</td>
      <td>pattern</td>
      <td></td>
    </tr>
    <tr>
      <td>0x34</td>
      <td>pattern/pad</td>
      <td>(contains 1 bit of padding)</td>
    </tr>
  </tbody>
</table>
          <t>This constitutes an NLRI with an NLRI length of 15 octets.</t>
          <t>
    The source prefix pattern is 104 - 65 = 39 bits in length. 
    After the pattern, one bit of padding needs to be added so that the 
    component ends on an octet boundary. However, only the first 39 bits 
    are actually used for bitwise pattern matching, starting with a 65-bit 
    offset from the topmost bit of the address. 
</t>
        </section>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Ordering of Flow Specifications</name>
      <t>
	The definition for the order of traffic filtering rules from
    <xref target="RFC8955" sectionFormat="of" section="5.1"/> is
    reused with new consideration for the IPv6 prefix offset.  As long
    as the offsets are equal, the comparison is the same, retaining
    longest-prefix-match semantics.  If the offsets are not equal, the
    lowest offset has precedence, as this Flow Specification matches the most significant bit.
      </t>
      <t>
      The code in <xref target="flow_rule_cmp_src" format="default"/> shows a Python3 implementation
      of the resulting comparison algorithm. The full code was tested with Python 3.7.2 and can be
      obtained at <eref target="https://github.com/stoffi92/draft-ietf-idr-flow-spec-v6/tree/master/flowspec-cmp" brackets="angle"/>.
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>Validation Procedure</name>
      <t>
    The validation procedure is the same as specified in
    <xref target="RFC8955" sectionFormat="of" section="6"/> with the exception
    that item a) of the validation procedure should now read as follows:
      </t>
      <blockquote>
	<ol type="%c)">
	  <li>A destination prefix component with offset=0 is embedded in the
          Flow Specification</li>
	</ol>
      </blockquote>
    </section>
    <section numbered="true" toc="default">
      <name>IPv6 Traffic Filtering Action Changes</name>
      <t>Traffic Filtering Actions from <xref target="RFC8955" sectionFormat="of" section="7"/>
        can also be applied to IPv6 Flow Specifications. To allow
        an IPv6-Address-Specific Route-Target, a new Traffic Filtering
        Action IPv6-Address-Specific Extended Community is specified in
        <xref target="redirect_ipv6" format="default"/> below.
      </t>
      <section anchor="redirect_ipv6" numbered="true" toc="default">
        <name>Redirect IPv6 (rt-redirect-ipv6) Type 0x000d</name>
        <t>The redirect IPv6-Address-Specific Extended Community
       allows the traffic to be redirected to a VRF routing instance that
       lists the specified IPv6-Address-Specific Route-Target in its import
       policy.  If several local instances match this criteria, the choice
       between them is a local matter (for example, the instance with the
       lowest Route Distinguisher value can be elected).
        </t>
        <t>This IPv6-Address-Specific Extended Community uses the same encoding as the IPv6-Address-Specific 
	Route-Target Extended Community
       (<xref target="RFC5701" sectionFormat="of" section="2"/>) with the
       Type value always 0x000d.
        </t>
        <t>The Local Administrator subfield contains a number from a numbering
          space that is administered by the organization to which the IP
          address carried in the Global Administrator subfield has been
          assigned by an appropriate authority. 
        </t>
        <t>Interferes with: All BGP Flow Specification redirect Traffic Filtering
           Actions (with itself and those specified in
           <xref target="RFC8955" sectionFormat="of" section="7.4"/>).
        </t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>This document extends the functionality in <xref target="RFC8955" format="default"/> 
      to be applicable to IPv6 data packets. The same security considerations from <xref 
      target="RFC8955" format="default"/> now also apply to IPv6 networks.</t>
      <t><xref target="RFC7112" format="default"/> describes the impact of oversized 
      IPv6 header chains when trying to match on the transport header; <xref target="RFC8200"
      sectionFormat="of" section="4.5"/> also requires that the first fragment must include 
      the upper-layer header, but there could be wrongly formatted packets not respecting <xref
      target="RFC8200" format="default"/>. IPv6 Flow Specification component Type 3 (<xref 
      target="type_3" format="default"/>) will not be enforced for those illegal packets. 
      Moreover, there are hardware limitations in several routers (<xref target="RFC8883" 
      sectionFormat="of" section="1"/>) that may make it impossible to enforce a policy signaled 
      by a Type 3 Flow Specification component or Flow Specification components that match on 
      upper-layer properties of the packet.</t>
    </section>
    <section anchor="IANA" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This section complies with <xref target="RFC7153" format="default"/>.
      </t>
      <section numbered="true" toc="default">
        <name>Flow Spec IPv6 Component Types</name>
        <t>
    IANA has created and maintains a registry entitled "Flow Spec Component Types". 
    IANA has added this document as a reference for that registry.  
    Furthermore, the registry has been updated to also contain the IPv6 Flow Specification 
    Component Types as described below. The registration procedure remains unchanged.
        </t>
        <section numbered="true" toc="default">
          <name>Registry Template</name>
          <dl newline="false" spacing="normal" indent="13">
            <dt>Type Value:</dt>
            <dd>contains the assigned Flow Specification component type value</dd>
            <dt>IPv4 Name:</dt>
            <dd>contains the associated IPv4 Flow Specification component name as specified in 
	    <xref target="RFC8955" format="default"/></dd>
            <dt>IPv6 Name:</dt>
            <dd>contains the associated IPv6 Flow Specification component name as specified in
	    this document</dd>
            <dt>Reference:</dt>
            <dd>contains references to the specifications</dd>
          </dl>
        </section>
        <section numbered="true" toc="default">
          <name>Registry Contents</name>
          <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>0</dd>
        <dt>IPv4 Name:</dt>
	<dd>Reserved</dd>
	<dt>IPv6 Name:</dt> 
	<dd>Reserved</dd>
	<dt>Reference:</dt> 
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
          </dl>
          <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>1</dd>
        <dt>IPv4 Name:</dt> 
	<dd>Destination Prefix</dd>
        <dt>IPv6 Name:</dt>
	<dd>Destination IPv6 Prefix</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>2</dd>
        <dt>IPv4 Name:</dt> 
	<dd>Source Prefix</dd>
        <dt>IPv6 Name:</dt>
	<dd>Source IPv6 Prefix</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>3</dd>
        <dt>IPv4 Name:</dt> 
	<dd>IP Protocol</dd>
        <dt>IPv6 Name:</dt>
	<dd>Upper-Layer Protocol</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>4</dd>
        <dt>IPv4 Name:</dt>
	<dd>Port</dd>
        <dt>IPv6 Name:</dt>
	<dd>Port</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt>
	<dd>5</dd>
        <dt>IPv4 Name:</dt> 
	<dd>Destination Port</dd>
        <dt>IPv6 Name:</dt>
	<dd>Destination Port</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt>
	<dd>6</dd>
        <dt>IPv4 Name:</dt> 
	<dd>Source Port</dd>
        <dt>IPv6 Name:</dt>
	<dd>Source Port</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt>
	<dd>7</dd>
        <dt>IPv4 Name:</dt>
	<dd>ICMP Type</dd>
        <dt>IPv6 Name:</dt>
	<dd>ICMPv6 Type</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>8</dd>
        <dt>IPv4 Name:</dt> 
	<dd>ICMP Code</dd>
        <dt>IPv6 Name:</dt>
	<dd>ICMPv6 Code</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>9</dd>
        <dt>IPv4 Name:</dt>
	<dd>TCP Flags</dd>
        <dt>IPv6 Name:</dt>
	<dd>TCP Flags</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>10</dd>
        <dt>IPv4 Name:</dt>
	<dd>Packet Length</dd>
        <dt>IPv6 Name:</dt>
	<dd>Packet Length</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>11</dd>
        <dt>IPv4 Name:</dt>
	<dd>DSCP</dd>
        <dt>IPv6 Name:</dt>
	<dd>DSCP</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>12</dd>
        <dt>IPv4 Name:</dt> 
	<dd>Fragment</dd>
        <dt>IPv6 Name:</dt> 
	<dd>Fragment</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>13</dd>
        <dt>IPv4 Name:</dt> 
	<dd>Unassigned</dd>
        <dt>IPv6 Name:</dt> 
	<dd>Flow Label</dd>
        <dt>Reference:</dt>
	<dd>RFC 8956</dd>
            </dl>

            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>14-254</dd>
        <dt>IPv4 Name:</dt>
	<dd>Unassigned</dd>
        <dt>IPv6 Name:</dt>
	<dd>Unassigned</dd>
            </dl>
            <dl newline="false" spacing="compact" indent="13">
        <dt>Type Value:</dt> 
	<dd>255</dd>
        <dt>IPv4 Name:</dt>
	<dd>Reserved</dd>
        <dt>IPv6 Name:</dt>
	<dd>Reserved</dd>
        <dt>Reference:</dt>
	<dd><xref target="RFC8955" format="default"/>, RFC 8956</dd>
            </dl>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>IPv6-Address-Specific Extended Community Flow Spec IPv6 Actions</name>
        <t>
        IANA maintains a registry entitled "Transitive IPv6-Address-Specific
        Extended Community Types". For the purpose of
        this work, IANA has assigned a new value:
        </t>
        <table anchor="iana_ext_comm_subtypes" align="center">
          <name>Transitive IPv6-Address-Specific Extended Community Types Registry</name>
          <thead>
            <tr>
              <th align="left">Type Value</th>
              <th align="left">Name</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0x000d</td>
              <td align="left">Flow spec rt-redirect-ipv6 format</td>
              <td align="left">RFC 8956</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4271.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4443.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4760.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5701.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7112.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7153.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8883.xml"/>

<!-- draft-ietf-idr-rfc5575bis - RFC-to-be 8955 companion document -->

<reference anchor='RFC8955' target="https://www.rfc-editor.org/info/rfc8955">
<front>
<title>Dissemination of Flow Specification Rules</title>
<author initials='C' surname='Loibl' fullname='Christoph Loibl'>
    <organization />
</author>
<author initials='S' surname='Hares' fullname='Susan Hares'>
    <organization />
</author>
<author initials='R' surname='Raszuk' fullname='Robert Raszuk'>
    <organization />
</author>
<author initials='D' surname='McPherson' fullname='Danny McPherson'>
    <organization />
</author>
<author initials='M' surname='Bacher' fullname='Martin Bacher'>
    <organization />
</author>
<date month='December' year='2020' />
</front>
<seriesInfo name="RFC" value="8955"/>
<seriesInfo name="DOI" value="10.17487/RFC8955"/>
</reference>

    </references>
    <section anchor="flow_rule_cmp_src" numbered="true" toc="default">
      <name>Example Python Code: flow_rule_cmp_v6</name>
      <sourcecode name="" type="python" markers="true"><![CDATA[
"""
Copyright (c) 2020 IETF Trust and the persons identified as authors
of the code. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in Section
4.c of the IETF Trust's Legal Provisions Relating to IETF Documents
(https://trustee.ietf.org/license-info).
"""

import itertools
import collections
import ipaddress


EQUAL = 0
A_HAS_PRECEDENCE = 1
B_HAS_PRECEDENCE = 2
IP_DESTINATION = 1
IP_SOURCE = 2

FS_component = collections.namedtuple('FS_component', 
                                      'component_type value')


class FS_IPv6_prefix_component:
    def __init__(self, prefix, offset=0, 
                 component_type=IP_DESTINATION):
        self.offset = offset
        self.component_type = component_type
        # make sure if offset != 0 that none of the 
        # first offset bits are set in the prefix
        self.value = prefix
        if offset != 0:
            i = ipaddress.IPv6Interface(
                (self.value.network_address, offset))
            if i.network.network_address != \
                ipaddress.ip_address('0::0'):
                raise ValueError('Bits set in the offset')


class FS_nlri(object):
    """
    FS_nlri class implementation that allows sorting.

    By calling .sort() on an array of FS_nlri objects these 
    will be sorted according to the flow_rule_cmp algorithm.

    Example:
    nlri = [ FS_nlri(components=[
             FS_component(component_type=4, 
                          value=bytearray([0,1,2,3,4,5,6])),
             ]),
             FS_nlri(components=[
             FS_component(component_type=5, 
                          value=bytearray([0,1,2,3,4,5,6])),
             FS_component(component_type=6, 
                          value=bytearray([0,1,2,3,4,5,6])),
             ]),
           ]
    nlri.sort() # sorts the array according to the algorithm
    """
    def __init__(self, components = None):
        """
        components: list of type FS_component
        """
        self.components = components

    def __lt__(self, other):
        # use the below algorithm for sorting
        result = flow_rule_cmp_v6(self, other)
        if result == B_HAS_PRECEDENCE:
            return True
        else:
            return False


def flow_rule_cmp_v6(a, b):
    """
    Implementation of the flowspec sorting algorithm in 
    RFC 8956.
    """
    for comp_a, comp_b in itertools.zip_longest(a.components,
                                           b.components):
        # If a component type does not exist in one rule
        # this rule has lower precedence
        if not comp_a:
            return B_HAS_PRECEDENCE
        if not comp_b:
            return A_HAS_PRECEDENCE
        # Higher precedence for lower component type
        if comp_a.component_type < comp_b.component_type:
            return A_HAS_PRECEDENCE
        if comp_a.component_type > comp_b.component_type:
            return B_HAS_PRECEDENCE
        # component types are equal -> type-specific comparison
        if comp_a.component_type in (IP_DESTINATION, IP_SOURCE):
            if comp_a.offset < comp_b.offset:
                return A_HAS_PRECEDENCE
            if comp_a.offset > comp_b.offset:
                return B_HAS_PRECEDENCE
            # both components have the same offset
            # assuming comp_a.value, comp_b.value of type
            # ipaddress.IPv6Network
            # and the offset bits are reset to 0 (since they are 
            # not represented in the NLRI)
            if comp_a.value.overlaps(comp_b.value):
                # longest prefixlen has precedence
                if comp_a.value.prefixlen > \
                    comp_b.value.prefixlen:
                    return A_HAS_PRECEDENCE
                if comp_a.value.prefixlen < \
                    comp_b.value.prefixlen:
                    return B_HAS_PRECEDENCE
                # components equal -> continue with next 
                # component
            elif comp_a.value > comp_b.value:
                return B_HAS_PRECEDENCE
            elif comp_a.value < comp_b.value:
                return A_HAS_PRECEDENCE
        else:
            # assuming comp_a.value, comp_b.value of type 
            # bytearray
            if len(comp_a.value) == len(comp_b.value):
                if comp_a.value > comp_b.value:
                    return B_HAS_PRECEDENCE
                if comp_a.value < comp_b.value:
                    return A_HAS_PRECEDENCE
                # components equal -> continue with next 
                # component
            else:
                common = min(len(comp_a.value), 
                             len(comp_b.value))
                if comp_a.value[:common] > \
                    comp_b.value[:common]:
                    return B_HAS_PRECEDENCE
                elif comp_a.value[:common] < \
                      comp_b.value[:common]:
                    return A_HAS_PRECEDENCE
                # the first common bytes match
                elif len(comp_a.value) > len(comp_b.value):
                    return A_HAS_PRECEDENCE
                else:
                    return B_HAS_PRECEDENCE
    return EQUAL
]]></sourcecode>
    </section>
    <section numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>The authors would like to thank <contact fullname="Pedro Marques"/>, <contact 
      fullname="Hannes Gredler"/>, <contact fullname="Bruno Rijsman"/>, <contact 
      fullname="Brian Carpenter"/>, and <contact fullname="Thomas Mangin"/> for their valuable input.
      </t>
    </section>
    <section numbered="false" toc="default">
      <name>Contributors</name>
<contact fullname="Danny McPherson">
  <organization>Verisign, Inc.</organization>
  <address>
    <postal/>
    <email>dmcpherson@verisign.com</email>
  </address>
</contact>
<contact fullname="Burjiz Pithawala">
  <organization>Individual</organization>
  <address>
    <postal/>
    <email>burjizp@gmail.com</email>
  </address>
</contact>
<contact fullname="Andy Karch">
  <organization>Cisco Systems</organization>
  <address>
    <postal>
      <street>170 West Tasman Drive</street>
      <city>San Jose</city> 
      <region>CA</region> 
      <code>95134</code>
      <country>United States of America</country>
    </postal>
    <email>akarch@cisco.com</email>
  </address>
</contact>
    </section>
  </back>
</rfc>
