<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" number="8766" consensus="true"
     category="std" docName="draft-ietf-dnssd-hybrid-10" ipr="trust200902"
     obsoletes="" updates="" submissionType="IETF" xml:lang="en"
     tocInclude="true" tocDepth="3" symRefs="true" sortRefs="false"
     version="3">

  <front>
    <title abbrev="Multicast Service Discovery Proxy">Discovery Proxy
      for Multicast DNS-Based Service Discovery</title>
    <seriesInfo name="RFC" value="8766"/>
    <author initials="S." surname="Cheshire" fullname="Stuart Cheshire">
      <organization>Apple Inc.</organization>
      <address>
        <postal>
          <street>One Apple Park Way</street>
          <city>Cupertino</city>
          <region>California</region>
          <code>95014</code>
          <country>United States of America</country>
        </postal>
        <phone>+1 (408) 996-1010</phone>
        <email>cheshire@apple.com</email>
      </address>
    </author>
    <date year="2020" month="June"/>
    <area>INT</area>
    <workgroup>DNSSD</workgroup>

    <keyword>Multicast DNS</keyword>
    <keyword>DNS-Based Service Discovery</keyword>

    <abstract>
      <t>This document specifies a network proxy that uses Multicast DNS
      to automatically populate the wide-area unicast Domain Name System
      namespace
      with records describing devices and services found on the local
      link.</t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>Multicast DNS <xref target="RFC6762" format="default"></xref> and its
      companion technology DNS-based Service Discovery <xref target="RFC6763"
      format="default"/> were created to provide IP networking with the ease
      of use and autoconfiguration for which AppleTalk was well known <xref
      target="RFC6760" format="default"/> <xref target="ZC" format="default"/>
      <xref target="I-D.cheshire-dnssd-roadmap" format="default"/>.</t>
      <t>For a small home network consisting of just a single link (or a few
      physical links bridged together to appear as a single logical link from
      the point of view of IP), Multicast DNS <xref target="RFC6762"
      format="default"></xref> is sufficient for client devices
      to look up the ".local" host names of peers on the same home network,
      and to use Multicast DNS-based
      Service Discovery (DNS-SD) <xref target="RFC6763"
      format="default"></xref> to discover services offered on that
      home network.</t>
      <t>For a larger network consisting of multiple links that are
      interconnected using IP-layer routing instead of link-layer bridging,
      link-local Multicast DNS alone is insufficient because link-local
      Multicast DNS packets, by design, are not propagated onto other
      links.</t>
      <t>Using link-local multicast packets for Multicast DNS was a conscious
      design choice <xref target="RFC6762" format="default"/>.  Even when
      limited to a single link, multicast traffic is still generally
      considered to be more expensive than unicast, because multicast traffic
      impacts many devices instead of just a single recipient.  In addition,
      with some technologies like Wi-Fi <xref target="IEEE-11"
      format="default"></xref>, multicast traffic is inherently less
      efficient and less reliable than unicast, because Wi-Fi multicast
      traffic is sent at lower data rates, and is not acknowledged <xref
      target="I-D.ietf-mboned-ieee802-mcast-problems" format="default"/>.
      Increasing the amount of expensive multicast traffic by flooding it
      across multiple links would make the traffic load even worse.</t>
      <t>Partitioning the network into many small links curtails the spread
      of expensive multicast traffic but limits the discoverability of
      services.
      At the opposite end of the spectrum, using a very large local link with
      thousands of hosts enables better
      service discovery but at the cost of larger amounts of multicast
      traffic.</t>
      <t>Performing DNS-based Service Discovery using purely Unicast DNS is
      more efficient and doesn't require large multicast domains but does
      require that the relevant data be available in the Unicast DNS
      namespace.
      The Unicast DNS namespace in question could fall within a traditionally
      assigned globally unique domain name, or it could be within a private
      local
      unicast domain name such as ".home.arpa" <xref target="RFC8375"
      format="default"/>.</t>
      <t>In the DNS-SD specification <xref target="RFC6763"
      sectionFormat="comma" section="10"/> ("Populating
      the DNS with Information") discusses various possible ways that a
      service's PTR, SRV, TXT, and address records can make their way into the
      Unicast DNS namespace, including manual zone file configuration <xref
      target="RFC1034" format="default"/> <xref target="RFC1035"
      format="default"/>, DNS&nbsp;Update <xref target="RFC2136"
      format="default"/> <xref target="RFC3007" format="default"/>, and
      proxies
      of various kinds.</t>

      <t>One option is to make the relevant data available in the Unicast DNS
      namespace by
      manual DNS configuration. This option has been used for
      many years at IETF meetings to advertise the IETF terminal room printer.
      Details of this example are given in <xref
      target="I-D.cheshire-dnssd-roadmap" sectionFormat="of" section="A">the
      Roadmap document</xref>.  However, this manual DNS configuration is
      labor intensive, error prone, and requires a reasonable degree of DNS
      expertise.</t>

      <t>Another option is to populate the Unicast DNS namespace by having
      the devices offering the services do that themselves, using DNS Update
      <xref target="I-D.sctl-service-registration" format="default"/>
      <xref target="I-D.sekar-dns-ul" format="default"/>.
      However, this requires configuration
      of DNS Update keys on those devices, which has proven onerous and
      impractical for simple devices like printers and network cameras.</t>
      <t>Hence, to facilitate efficient and reliable DNS-based Service
      Discovery,
      a hybrid is needed that combines the ease of use of
      Multicast DNS with the efficiency and scalability of Unicast DNS.</t>
      <t>This document specifies a type of proxy called a "Discovery Proxy"
      that uses Multicast DNS <xref target="RFC6762" format="default"></xref>
      to discover
      Multicast DNS records on its local link on demand, and makes
      corresponding
      DNS records visible in the Unicast DNS namespace.</t>
      <t>In principle, similar mechanisms could be defined
      for other local discovery protocols, by creating a proxy that
      (i) uses the protocol in question to discover local information on
      demand, and then
      (ii) makes corresponding DNS records visible in the Unicast
      DNS namespace. Such mechanisms for other local discovery
      protocols could be addressed in future documents.</t>
      <t>The design of the Discovery Proxy is guided by the previously
      published DNS-based Service Discovery requirements document
      <xref target="RFC7558" format="default"></xref>.</t>
      <t>In simple terms, a descriptive DNS name is chosen for
      each link in an organization.
      Using a DNS NS record, responsibility for that DNS name is delegated to
      a Discovery Proxy physically attached to that link.
      When a remote client issues a unicast query for a name falling
      within
      the delegated subdomain, the normal DNS delegation mechanism
      results in the unicast query arriving at the Discovery Proxy,
      since it has been declared authoritative for those names.
      Now, instead of consulting a textual zone file on disk to discover
      the answer to the query as a traditional authoritative DNS server would,
      a Discovery Proxy consults its local link, using Multicast DNS,
      to find the answer to the question.</t>

      <t>For fault tolerance reasons, there may be more than one
      Discovery Proxy serving a given link.</t>
      <t>Note that the Discovery Proxy uses a "pull" model.
      Until some remote client has requested data,
      the local link is not queried using Multicast DNS.
      In the idle state, in the absence
      of client requests, the Discovery Proxy sends no packets and imposes
      no burden on the network. It operates purely "on demand".</t>
      <t>An alternative proposal that has been discussed is a proxy that
      performs DNS updates to a remote DNS server on behalf of the Multicast
      DNS devices on the local network.  The difficulty with this is that
      Multicast DNS devices do not routinely announce their records on the
      network. Generally, they remain silent until queried.  This means that
      the complete set of Multicast DNS records in use on a link can only be
      discovered by active querying, not by passive listening.  Because of
      this, a proxy can only know what names exist on a link by issuing
      queries for them, and since it would be impractical to issue queries for
      every possible name just to find out which names exist and which do not,
      there is no reasonable way for a proxy to programmatically learn all the
      answers it would need to push up to the remote DNS server using DNS
      Update.  Even if such a mechanism were possible, it would risk
      generating high load on the network continuously, even when there are no
      clients with any interest in that data.</t>
      <t>Hence, having a model where the query comes to the Discovery Proxy
      is much more efficient than
      a model where the Discovery Proxy pushes the answers out
      to some other remote DNS server.</t>
      <t>A client seeking to discover services and other information performs
      this by sending traditional DNS queries to the Discovery Proxy or by
      sending DNS Push Notification subscription requests <xref
      target="RFC8765" format="default"></xref>.</t>
      <t>How a client discovers what domain name(s) to use for its
      DNS-based Service Discovery queries
      (and, consequently, what Discovery Proxy or Proxies to use)
      is described in <xref target="dom-enum" format="default"/>.</t>
      <t>The diagram below illustrates a network topology using a
      Discovery Proxy to provide discovery service to a remote client.</t>

    <figure>
      <name>Example Deployment</name>
      <artwork name="" type="" align="center" alt=""><![CDATA[
 +--------+   Unicast     +-----------+  +---------+  +---------+
 | Remote | Communication | Discovery |  | Network |  | Network |
 | Client |---- . . . ----|   Proxy   |  | Printer |  | Camera  |
 +--------+               +-----------+  +---------+  +---------+
      |                         |             |            |
------------            --------------------------------------------
                       Multicast-capable LAN segment (e.g., Ethernet)

]]></artwork>
    </figure>

      <t>Note that there need not be any Discovery Proxy on the link
      to which the remote client is directly attached.
      The remote client communicates directly with the Discovery Proxy
      using normal unicast TCP/IP communication mechanisms,
      potentially spanning multiple IP hops,
      possibly including VPN tunnels and other similar
      long-distance communication channels.
      </t>

    </section>


    <section numbered="true" toc="default">
      <name>Operational Analogy</name>
      <t>A Discovery Proxy does not operate as a multicast relay or multicast
      forwarder.  There is no danger of multicast forwarding loops that result
      in traffic storms, because no multicast packets are forwarded.  A
      Discovery Proxy operates as a <em>proxy</em> for remote clients,
      performing
      queries on their behalf and reporting the results back.</t>
      <t>A reasonable analogy is making a telephone call to a colleague at
      your workplace and saying, "I'm out of the office right now. Would you
      mind bringing up a printer browser window and telling me the names of
      the printers you see?" That entails no risk of a forwarding loop causing
      a traffic storm, because no multicast packets are sent over the
      telephone call.</t>

      <t>A similar analogy, instead of enlisting another human being
      to initiate the service discovery operation on your behalf, is
      to log in to your own desktop work computer using screen sharing
      and then run the printer browser yourself to see the list of printers.
      Or, log in using Secure Shell (ssh) and type "dns-sd -B _ipp._tcp" and
      observe the
      list of discovered printer names. In neither case is there any risk
      of a forwarding loop causing a traffic storm, because no multicast
      packets are being sent over the screen-sharing or ssh connection.</t>
      <t>The Discovery Proxy provides another way of performing remote
      queries,
      which uses a different protocol instead of screen sharing or ssh.
      The Discovery Proxy mechanism can be thought of as a custom Remote
      Procedure Call (RPC) protocol that allows a remote client to exercise
      the Multicast DNS APIs on the Discovery Proxy device, just as a local
      client running on the Discovery Proxy device would use those APIs.</t>

      <t>When the Discovery Proxy software performs Multicast DNS
      operations, the exact same Multicast DNS caching mechanisms are
      applied as when any other client software on that Discovery Proxy
      device performs Multicast DNS operations, regardless of whether that be
      running
      a printer browser client locally, a remote user running the
      printer browser client via a screen-sharing connection, a remote
      user logged in via ssh running a command-line tool like "dns-sd",
      or a remote user sending DNS requests that cause a Discovery Proxy
      to perform discovery operations on its behalf.</t>
    </section>


    <section numbered="true" toc="default">
      <name>Conventions and Terminology Used in This Document</name>
     
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
    to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>


      <t>The Discovery Proxy builds on Multicast DNS,
      which works between hosts on the same link.
      For the purposes of this document,
      a set of hosts is considered to be "on the same link" if:

      </t>

      <ul spacing="normal">
        <li>when any host from that set sends a packet to any other host
        in that set, using unicast, multicast, or broadcast, the entire
        link-layer packet payload arrives unmodified, and</li>
        <li>a broadcast sent over that link, by any host from that set of
	hosts,
        can be received by every other host in that set.</li>
      </ul>
      <t>

      The link-layer <em>header</em> may be modified, such as in Token Ring
      Source Routing
      <xref target="IEEE-5" format="default"></xref>,
      but not the link-layer <em>payload</em>.
      In particular, if any device forwarding a packet modifies any
      part of the IP header or IP payload, then the packet is no longer
      considered to be on the same link. This means that the packet may
      pass through devices such as repeaters, bridges, hubs, or switches
      and still be considered to be on the same link for the purpose of
      this document, but not through a device such as an IP router that
      decrements the IP TTL or otherwise modifies the IP header.</t>
    </section>

    <section anchor="compatibility" numbered="true" toc="default">
      <name>Compatibility Considerations</name>
      <t>No changes to existing devices are required to work with a Discovery
      Proxy.</t>
      <t>Existing devices that advertise services using Multicast DNS work
      with a Discovery Proxy.</t>

      <t>Existing clients that support DNS-based Service Discovery over
      Unicast DNS work with a Discovery Proxy.  DNS-based Service Discovery
      over Unicast
      DNS was introduced in Mac OS X 10.4 Tiger in April 2005 and has been
      included in
      Apple products introduced since then, including the iPhone and iPad.
      It has also been included in
      products from other vendors, such as Microsoft Windows 10.</t>
      <t>An overview of the larger collection of associated DNS-based Service
      Discovery
      technologies, and how the Discovery Proxy technology relates to those,
      is given in the
      Service Discovery Road Map document <xref
      target="I-D.cheshire-dnssd-roadmap" format="default"></xref>.</t>
    </section>

    <section anchor="operation" numbered="true" toc="default">
      <name>Discovery Proxy Operation</name>
      <t>In a typical configuration, a Discovery Proxy is configured
      to be authoritative <xref target="RFC1034" format="default"/> <xref
      target="RFC1035" format="default"/>
      for four or more DNS subdomains, listed below.
      Authority for these subdomains is delegated
      from the parent domain to the Discovery Proxy
      in the usual way for DNS delegation, via NS records.
      </t>
      <dl newline="true" spacing="normal">
        <dt>A DNS subdomain for DNS-based Service Discovery records.</dt>
        <dd>
          This subdomain name may contain rich text, including
          spaces and other punctuation. This is because this
          subdomain name is used only in graphical user interfaces,
          where rich text is appropriate.</dd>
        <dt>A DNS subdomain for host name records.</dt>
        <dd>
          This subdomain name <bcp14>SHOULD</bcp14> be limited to letters,
	    digits, and
	        hyphens in order to facilitate the convenient use of host
		names in
		    command-line
		          interfaces.</dd>
        <dt>One or more DNS subdomains for IPv4 Reverse Mapping records.</dt>
        <dd>
          These subdomains will have names that end in "in-addr.arpa".</dd>
        <dt>One or more DNS subdomains for IPv6 Reverse Mapping records.</dt>
        <dd>
          These subdomains will have names that end in "ip6.arpa".</dd>
      </dl>
      <t>In an enterprise network, the naming and delegation of these
      subdomains
      is typically performed by conscious action of the network administrator.
      In a home network, naming and delegation would typically be performed
      using some automatic configuration mechanism such as Home Networking
      Control Protocol (HNCP)
      <xref target="RFC7788" format="default"/>.</t>
      <t>These three varieties of delegated subdomains
      (service discovery, host names, and reverse mapping) are described below
      in Sections <xref target="dom-sd" format="counter"/>, <xref
      target="dom-host" format="counter"/>, and <xref target="dom-rev"
      format="counter"/>.</t>
      <t>How a client discovers where to issue its DNS-based Service Discovery
      queries
      is described in <xref target="dom-enum" format="default"/>.</t>
      <section anchor="dom-sd" numbered="true" toc="default">
        <name>Delegated Subdomain for DNS-based Service Discovery
	Records</name>
        <t>In its simplest form, each link in an organization
      is assigned a unique Unicast DNS domain name such as
      "Building&nbsp;1.example.com" or
      "2nd&nbsp;Floor.Building&nbsp;3.example.com".
      Grouping multiple links under a single Unicast DNS domain
      name is to be specified in a future companion document, but for
      the purposes of this document, assume that each link has its own
      unique Unicast DNS domain name.
      In a graphical user interface these names are not displayed
      as strings with dots as shown above, but something more
      akin to a typical file browser graphical user interface
      (which is harder to illustrate in a text-only document)
      showing folders, subfolders, and files in a file system.

        </t>


<figure anchor="browser">
<name>Illustrative GUI
</name>
<artwork align="center" name="" type="" alt=""><![CDATA[
 +---------------+--------------+-------------+-------------------+
 | *example.com* |  Building 1  |  1st Floor  | Alice's printer   |
 |               |  Building 2  | *2nd Floor* | Bob's printer     |
 |               | *Building 3* |  3rd Floor  | Charlie's printer |
 |               |  Building 4  |  4th Floor  |                   |
 |               |  Building 5  |             |                   |
 |               |  Building 6  |             |                   |
 +---------------+--------------+-------------+-------------------+

]]></artwork>
</figure>

        <t>Each named link in an organization has one or more Discovery
        Proxies that serve it. This Discovery Proxy function
        could be performed by a device like a router or switch that is
        physically attached to that link.  In the parent domain, NS records
        are used to delegate ownership of each defined link name
        (e.g.,&nbsp;"Building&nbsp;1.example.com") to one or more
        Discovery Proxies that serve the named link.  In other words, the
        Discovery Proxies are the authoritative name servers for that
        subdomain.  As in the rest of DNS-based Service Discovery, all names
        are represented as-is using plain UTF-8 encoding and, as described in
        <xref target="notrans" format="default"/>, no text-encoding
        translations are performed.</t>
        <t>With appropriate VLAN
        configuration <xref target="IEEE-1Q" format="default"></xref>, a
	single Discovery Proxy device could have a
        logical presence on many links and serve as the Discovery Proxy for
        all those links.  In such a configuration, the Discovery Proxy device
        would have a single physical Ethernet <xref target="IEEE-3"
        format="default"></xref> port, configured as a VLAN trunk
        port, which would appear to software on that device as multiple
        virtual Ethernet interfaces, one connected to each of the VLAN
        links.</t>
        <t>As an alternative to using VLAN technology, using a Multicast DNS
	Discovery Relay
      <xref target="I-D.sctl-dnssd-mdns-relay" format="default"></xref>
      is another way that a Discovery Proxy can have
      a "virtual" presence on a remote link.</t>
        <t>When a DNS-SD client issues a Unicast DNS query to discover
        services in a particular Unicast DNS subdomain
        (e.g.,&nbsp;"_ipp._tcp.Building&nbsp;1.example.com.&nbsp;PTR&nbsp;?"),
        the normal DNS delegation mechanism results in that query being
        forwarded until it reaches the delegated authoritative name server for
        that subdomain, namely, the Discovery Proxy on the link in question.
        Like a conventional Unicast DNS server, a Discovery Proxy implements
        the usual Unicast DNS protocol <xref target="RFC1034"
        format="default"/> <xref target="RFC1035" format="default"/> over UDP
        and TCP.  However, unlike a conventional Unicast DNS server that
        generates answers from the data in its manually configured zone file,
        a Discovery Proxy learns answers using Multicast DNS.  A Discovery
        Proxy does this by consulting its Multicast DNS cache and/or issuing
        Multicast DNS queries, as appropriate according to the usual protocol
        rules of Multicast DNS <xref target="RFC6762"
	format="default"></xref>,
        for the corresponding Multicast DNS name, type, and class, with the
        delegated zone part of the name replaced with ".local" (e.g.,&nbsp;in
        this case, "_ipp._tcp.local.&nbsp;PTR&nbsp;?").  Then, from the
        received Multicast DNS data, the Discovery Proxy synthesizes the
        appropriate Unicast DNS response, with the ".local" top-level label
        of the owner name
        replaced with the name of the delegated zone.
        Further details of the name translation rules are
        described in <xref target="translation" format="default"/>.
        Rules specifying how long the Discovery
        Proxy should wait to accumulate Multicast DNS responses before sending
        its unicast reply are described in <xref target="aggregation"
        format="default"/>.
        </t>
        <t>The existing Multicast DNS caching mechanism is used to minimize
        unnecessary Multicast DNS queries on the wire.  The Discovery Proxy is
        acting as a client of the underlying Multicast DNS subsystem and
        benefits from the same caching and efficiency measures as any other
        client using that subsystem.</t>
        <t>Note that the contents of the delegated zone, generated as it is by
        performing ".local" Multicast DNS queries, mirrors the records
        available on the local link via Multicast DNS very closely, but not
        precisely.  There is not a full bidirectional equivalence between the
        two.  Certain records that are available via Multicast DNS may not
        have equivalents in the delegated zone possibly because they are
        invalid or not relevant in the delegated zone or because they are
        being suppressed because they are unusable outside the local link (see
        <xref target="unusable" format="default"/>).  Conversely, certain
        records that appear in the delegated zone may not have corresponding
        records available on the local link via Multicast DNS.  In particular,
        there are certain administrative SRV records (see <xref target="admin"
        format="default"/>) that logically fall within the delegated zone but
        semantically represent metadata <em>about</em> the zone rather than
	records
        <em>within</em> the zone. Consequently, these administrative records
	in
        the delegated zone do not have any corresponding counterparts in the
        Multicast DNS namespace of the local link.</t>
      </section>
      
      <section anchor="dom-enum" numbered="true" toc="default">
        <name>Domain Enumeration</name>
        <t>A DNS-SD client performs Domain Enumeration <xref target="RFC6763"
        format="default"/> via certain PTR queries, using both unicast and
        multicast.</t>
        
        <t>If a DNS-SD client receives a Domain Name configuration via DHCP
	then it issues
        unicast queries derived from this domain name.  It also issues unicast
	queries using
        names derived from its IPv4 subnet address(es) and IPv6 prefix(es).
        These unicast Domain Enumeration queries are described
        in <xref target="unicast" format="default"/>.
        A DNS-SD client
        also issues multicast Domain Enumeration queries in the "local" domain
        <xref target="RFC6762" format="default"/>, as described in
        <xref target="multicast" format="default"/>.  The results of all the
        Domain Enumeration queries are combined for DNS-based Service
	Discovery
        purposes.</t>


        <section anchor="unicast" numbered="true" toc="default">
          <name>Domain Enumeration via Unicast Queries</name>
          <t>The (human or automated) administrator creates
          Unicast DNS Domain Enumeration PTR records <xref
          target="RFC6763" format="default"/> to inform clients of available
          service discovery domains.  Two varieties of such Unicast DNS Domain
	    Enumeration
          PTR records exist: those with names derived from the domain name
          communicated to the clients via
          <xref target="RFC2132" format="default">DHCP option 15</xref>,
          and those with names derived
          from either IPv4 subnet address(es) or IPv6 prefix(es) in use by the
          clients.  Below is an example showing the name-based variety,
          where the DHCP server configured the client with the domain name
          "example.com":</t>
          <artwork name="" type="" align="center" alt=""><![CDATA[
    b._dns-sd._udp.example.com.    PTR   Building 1.example.com.
                                   PTR   Building 2.example.com.
                                   PTR   Building 3.example.com.
                                   PTR   Building 4.example.com.

    db._dns-sd._udp.example.com.   PTR   Building 1.example.com.

    lb._dns-sd._udp.example.com.   PTR   Building 1.example.com.]]></artwork>
          <t>The meaning of these records is defined in the <xref
	    target="RFC6763"
          format="default">DNS-based Service
          Discovery specification</xref> but, for convenience, is repeated
	    here.
          The "b" ("browse") records tell the client device the list of
          browsing domains to display for the user to select from.  The "db"
          ("default browse") record tells the client device which domain in
          that list should be selected by default.  The "db" domain
          <bcp14>MUST</bcp14> be one of the domains in the "b" list; if not,
          then no domain is selected by default.  The "lb" ("legacy browse")
          record tells the client device which domain to automatically browse
          on behalf of applications that don't implement user interface for
	    multi-domain
          browsing (which is most of them at the time of writing).  The "lb"
          domain is often the same as the "db" domain, or sometimes the "db"
          domain plus one or more others that should be included in the list
          of automatic browsing domains for legacy clients.</t>
          <t>Note that in the example above, for clarity, space characters in
          names are shown as actual spaces.  If this data is manually entered
          into a textual zone file for authoritative server software such as
          BIND, care must be taken because the space character is used as a
          field separator, and other characters like dot ('.'), semicolon
          (';'), dollar ('$'), backslash ('\'), etc., also have special
          meaning.  These characters have to be escaped when entered into a
          textual zone file, following the rules in <xref target="RFC1035"
          sectionFormat="of" section="5.1">the DNS specification</xref>.  For
          example, a literal space in a name is represented in the textual
          zone file using '\032', so "Building&nbsp;1.example.com" is entered
          as "Building\0321.example.com".</t>

          <t>DNS responses are limited to a maximum size of 65535 bytes.
        This limits the maximum number of domains that can be returned for
        a Domain Enumeration query as follows:</t>
          <t>A DNS response header is 12 bytes.
        That's typically followed by a single qname (up to 256 bytes)
        plus qtype (2&nbsp;bytes) and qclass (2&nbsp;bytes), leaving 65275
        for the Answer Section.</t>

          <t>An Answer Section Resource Record consists of:
          </t>

          <ul spacing="compact">
            <li>Owner name, encoded as a compression pointer, 2 bytes</li>
            <li>RRTYPE (type PTR), 2 bytes</li>
            <li>RRCLASS (class IN), 2 bytes</li>
            <li>TTL, 4 bytes</li>
            <li>RDLENGTH, 2 bytes</li>
            <li>RDATA (domain name), up to 256 bytes</li>
          </ul>
          <t>This means that each Resource Record in the Answer Section can
        take up to 268 bytes total, which means that the Answer Section
        can contain, in the worst case, no more than 243 domains.</t>
          <t>In a more typical scenario, where the domain names are not all
        maximum-sized names, and there is some similarity between names
        so that reasonable name compression is possible, each Answer
        Section Resource Record may average 140 bytes, which means that
        the Answer Section can contain up to 466 domains.</t>
          <t>It is anticipated that this should be sufficient for even a large
        corporate network or university campus.</t>
      </section>
        <section anchor="multicast" numbered="true" toc="default">
          <name>Domain Enumeration via Multicast Queries</name>
          <t>In the case where Discovery Proxy functionality is widely
          deployed within an enterprise (either by having a Discovery Proxy
	    physically on
          each link, or by having a Discovery Proxy with a remote "virtual"
          presence on each link using VLANs or Multicast DNS Discovery Relays
          <xref target="I-D.sctl-dnssd-mdns-relay" format="default"></xref>),
          this offers an additional way to provide Domain Enumeration
	    configuration data for
          clients.</t>

          <t>Note that this function of the Discovery Proxy is
          supplementary to the primary purpose of the Discovery Proxy,
          which is to facilitate <em>remote</em> clients discovering services
          on the Discovery Proxy's local link.
          This publication of Domain Enumeration configuration data
          via link-local multicast on the Discovery
          Proxy's local link is performed for the benefit of <em>local</em>
	    clients
          attached to that link, and typically directs those clients to
          contact other distant Discovery Proxies attached to other links.
          Generally, a client does not need to use the local Discovery
          Proxy on its own link, because a client is generally able to
          perform its own Multicast DNS queries on that link.
          (The exception to this is when the local Wi-Fi access point is
          blocking or filtering local multicast traffic, requiring even local
          clients to use their local Discovery Proxy to perform local
	    discovery.)</t>



          <t>A Discovery Proxy can be configured to generate Multicast DNS
	    responses
        for the following Multicast DNS Domain Enumeration queries issued by
	clients:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    b._dns-sd._udp.local.    PTR   ?
    db._dns-sd._udp.local.   PTR   ?
    lb._dns-sd._udp.local.   PTR   ?]]></artwork>
          <t>This provides the ability for Discovery Proxies to indicate
          recommended browsing domains to DNS-SD clients on a per-link
          granularity. In some enterprises, it may be preferable to provide
          this per-link configuration information in the form of Discovery
	    Proxy
          configuration data rather than by populating the Unicast DNS servers
	    with
          the same data (in the "ip6.arpa" or "in-addr.arpa" domains).</t>
          <t>Regardless of how the network operator chooses to provide this
	    configuration
        data, clients will perform Domain Enumeration via both unicast and
	multicast
        queries and then combine the results of these queries.</t>
        </section>
      </section>
      <section anchor="dom-host" numbered="true" toc="default">
        <name>Delegated Subdomain for LDH Host Names</name>
        <t>DNS-SD service instance names and domains are allowed
        to contain arbitrary Net-Unicode text <xref target="RFC5198"
	format="default"></xref>,
        encoded as precomposed UTF-8 <xref target="RFC3629"
	format="default"></xref>.</t>
        <t>Users typically interact with service discovery software by
        viewing a list of discovered service instance names on a display
        and selecting one of them by pointing, touching, or clicking.
        Similarly, in software that provides a multi-domain DNS-SD user
        interface, users view a list of offered domains on the display
        and select one of them by pointing, touching, or clicking.
        To use a service, users don't have to remember domain or instance
        names, or type them; users just have to be able to recognize what
        they see on the display and touch or click on the thing they want.</t>
        <t>In contrast, host names are often remembered and typed.  Also, host
        names have historically been used in command-line interfaces where
        spaces can be inconvenient. For this reason, host names have
        traditionally been restricted to letters, digits, and hyphens (LDH)
        with no spaces or other punctuation.</t> <t>While we do want to allow
        rich text for DNS-SD service instance names and domains, it is
        advisable, for maximum compatibility with existing usage, to restrict
        host names to the traditional letter-digit-hyphen rules.  This means
        that while the service name
        "My&nbsp;Printer._ipp._tcp.Building&nbsp;1.example.com" is acceptable
        and desirable (it is displayed in a graphical user interface as an
        instance called "My&nbsp;Printer" in the domain "Building&nbsp;1" at
        "example.com"), the host name "My-Printer.Building&nbsp;1.example.com"
        is less desirable (because of the space in "Building&nbsp;1").</t>
        <t>To accommodate this difference in allowable characters, a Discovery
        Proxy <bcp14>SHOULD</bcp14> support having two separate subdomains
        delegated to it for each link it serves: one whose name is allowed to
        contain arbitrary Net-Unicode text <xref target="RFC5198"
        format="default"/>, and a second more constrained subdomain whose name
        is restricted to contain only letters, digits, and hyphens, to be used
        for host name records (names of 'A' and 'AAAA' address records).  The
        restricted names may be any valid name consisting of only letters,
        digits, and hyphens, including Punycode-encoded names <xref
        target="RFC3492" format="default"/>.
        </t>
        <t>For example, a Discovery Proxy could have the two subdomains
        "Building&nbsp;1.example.com" and "bldg&nbhy;1.example.com" delegated
	to it.
        The Discovery Proxy would then translate these two Multicast DNS
	records:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   My Printer._ipp._tcp.local. SRV 0 0 631 prnt.local.
   prnt.local.                 A   203.0.113.2]]></artwork>
        <t>into Unicast DNS records as follows:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   My Printer._ipp._tcp.Building 1.example.com.
                               SRV 0 0 631 prnt.bldg-1.example.com.
   prnt.bldg-1.example.com.     A   203.0.113.2]]></artwork>
        <t>Note that the SRV record name is translated using the rich-text
        domain name ("Building&nbsp;1.example.com"), and the address record
        name is translated using the LDH domain ("bldg&nbhy;1.example.com").
        Further details of the name translation rules are
        described in <xref target="translation" format="default"/>.</t>
        <t>A Discovery Proxy <bcp14>MAY</bcp14> support only a single
        rich-text Net-Unicode domain and use that domain for all records,
        including 'A' and 'AAAA' address records, but implementers choosing
        this option should be aware that this choice may produce host names
        that are awkward to use in command-line environments.  Whether or not
	this is
        an issue depends on whether users in the target environment are
        expected to be using command-line interfaces.</t>
        <t>A Discovery Proxy <bcp14>MUST NOT</bcp14> be restricted to support
	only a
	letter-digit-hyphen
        subdomain, because that results in an unnecessarily poor user
	experience.</t>

        <t>As described in <xref target="unicast" format="default"/>, for
        clarity, in examples here space characters in names are shown as
	actual spaces.  If
        this dynamically discovered data were to be manually entered into a
	textual zone file (which
        it isn't), then spaces would need to be represented using '\032', so
        "My&nbsp;Printer._ipp._tcp.Building&nbsp;1.example.com" would become
        "My\032Printer._ipp._tcp.Building\0321.example.com".</t>
<t>
Note that the '\032' representation does not appear in DNS messages
sent over the air.  In the wire format of DNS messages, spaces are sent as
spaces, not as '\032', and likewise, in a graphical user interface at the
client device, spaces are shown as spaces, not as '\032'.
</t>
</section>

      <section anchor="dom-rev" numbered="true" toc="default">
        <name>Delegated Subdomain for Reverse Mapping</name>
        <t>A Discovery Proxy can facilitate easier management of reverse
        mapping domains, particularly for IPv6 addresses where manual
        management may be more onerous than it is for IPv4 addresses.</t>
        <t>To achieve this, in the parent domain, NS records are used to
        delegate ownership of the appropriate reverse mapping domain to
        the Discovery Proxy. In other words, the Discovery Proxy becomes the
        authoritative name server for the reverse mapping domain.
        For fault tolerance reasons, there may be more than one
        Discovery Proxy serving a given link.</t>
        <t>If a given link is using the IPv4 subnet 203.0.113/24, 
        then the domain "113.0.203.in-addr.arpa" 
        is delegated to the Discovery Proxy for that link.</t>
        <t>If a given link is using the 
        IPv6 prefix 2001:0DB8:1234:5678::/64, 
        then the domain "8.7.6.5.4.3.2.1.8.b.d.0.1.0.0.2.ip6.arpa" 
        is delegated to the Discovery Proxy for that link.</t>
        <t>When a reverse mapping query arrives at the Discovery Proxy, it
        issues the identical query on its local link, as a Multicast DNS
	query.
        The mechanism to force an apparently unicast name to be resolved using
        link-local Multicast DNS varies depending on the API set being used.
        For example, in the "dns_sd.h" APIs (available on macOS, iOS, Bonjour
        for Windows, Linux, and Android), using kDNSServiceFlagsForceMulticast
        indicates that the DNSServiceQueryRecord() call should perform the
        query using Multicast DNS.  Other API sets have different ways of
        forcing multicast queries.  When the host owning that IPv4 or IPv6
        address responds with a name of the form "something.local", the
        Discovery Proxy rewrites it to use its configured LDH host name
        domain instead of ".local" and returns the response to the caller.</t>
        <t>For example, a Discovery Proxy with the two subdomains
        "113.0.203.in&nbhy;addr.arpa" and "bldg&nbhy;1.example.com" delegated
	to it
        would translate this Multicast DNS record:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   2.113.0.203.in-addr.arpa. PTR prnt.local.]]></artwork>
        <t>into this Unicast DNS response:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   2.113.0.203.in-addr.arpa. PTR prnt.bldg-1.example.com.]]></artwork>

        <t>In this example the "prnt.local" host name is translated
        using the delegated LDH subdomain, as described in
        <xref target="translation" format="default"/>.</t>

        <t>Subsequent queries for the prnt.bldg&nbhy;1.example.com address
        record, falling as it does within the bldg&nbhy;1.example.com domain,
        which is delegated to this Discovery Proxy, will arrive at this
        Discovery Proxy where they are answered by issuing Multicast DNS
	queries
        and using the received Multicast DNS answers to synthesize Unicast
        DNS responses, as described above.</t>
        <t>Note that this description assumes that all addresses on a given
        IPv4 subnet or IPv6 prefix are mapped to host names using the
	Discovery
	Proxy mechanism.
        It would be possible to implement a Discovery Proxy that can be
	configured
        so that some address-to-name mappings are performed using Multicast
	DNS
        on the local link, while other address-to-name mappings within the
	same
        IPv4 subnet or IPv6 prefix are configured manually.</t>
      </section>

      <section anchor="translation" numbered="true" toc="default">
        <name>Data Translation</name>

        <t>For the delegated rich-text and LDH subdomains,
        generating appropriate Multicast DNS queries
        involves translating from the configured DNS domain
        (e.g.,&nbsp;"Building&nbsp;1.example.com") on the Unicast DNS side
        to ".local" on the Multicast DNS side.</t>

        <t>For the delegated reverse-mapping subdomain,
        generating appropriate Multicast DNS queries
        involves using the appropriate API mechanism to
        indicate that a query should be performed using
        Multicast DNS, as described in
        <xref target="dom-rev" format="default"/>.</t>

        <t>Generating appropriate Unicast DNS responses from the
        received Multicast DNS answers involves translating back
        from ".local" to the appropriate configured Unicast DNS
        domain as necessary, as described below.</t>

        <t>In the examples below, the delegated subdomains are as follows:</t>

        <artwork name="" type="" align="left" alt="">
Delegated subdomain for rich-text names       Building 1.example.com.
Delegated subdomain for LDH names                 bldg&nbhy;1.example.com.
Delegated subdomain for IPv4 reverse mapping  113.0.203.in-addr.arpa.</artwork>

        <t>Names in Multicast DNS answers that do not end in ".local"
        do not require any translation.</t>

        <t>Names in Multicast DNS answers that end in ".local"
        are only meaningful on the local link, and require translation
        to make them useable by clients outside the local link.</t>

        <t>Names that end in ".local" may appear both as the
        owner names of received Multicast DNS answer records,
        and in the RDATA of received Multicast DNS answer records.</t>

        <t>In a received Multicast DNS answer record,
        if the owner name ends with ".local",
        then the ".local" top-level label is replaced with the name
        of the delegated subdomain as was used in the originating query.</t>

        <t>In a received Multicast DNS answer record,
        if a name in the RDATA ends with ".local",
        then the name is translated according to the delegated subdomain
        that was used in the originating query, as explained below.</t>

        <t>For queries in subdomains delegated for LDH host names,
        ".local" names in RDATA
        are translated to that delegated LDH subdomain.
        For example, a query for "thing.bldg&nbhy;1.example.com" will be
	translated to a
        Multicast DNS query for "thing.local". If that query returns this
	CNAME record:</t>

        <artwork name="" type="" align="left" alt="">
  thing.local.               CNAME  prnt.local.</artwork>

        <t>then both the owner name and the name in the RDATA
        are translated from ".local" to the LDH subdomain
	"bldg&nbhy;1.example.com":</t>

        <artwork name="" type="" align="left" alt="">
  thing.bldg&nbhy;1.example.com.  CNAME  prnt.bldg&nbhy;1.example.com.</artwork>

        <t>For queries in subdomains delegated for reverse mapping names,
        ".local" names in RDATA
        are translated to the delegated LDH subdomain, if one is configured,
        or to the delegated rich-text subdomain otherwise.
        For example, consider a reverse mapping query that returns this PTR
	record:</t>

        <artwork name="" type="" align="left" alt="">
  2.113.0.203.in-addr.arpa.  PTR  prnt.local.</artwork>

        <t>The owner name is not translated because it does not end in
	".local".
        The name in the RDATA is
        translated from ".local" to the LDH subdomain
	"bldg&nbhy;1.example.com":</t>

        <artwork name="" type="" align="left" alt="">
  2.113.0.203.in-addr.arpa.  PTR  prnt.bldg&nbhy;1.example.com.</artwork>

        <t>For queries in subdomains delegated for rich-text names,
        ".local" names in RDATA
        are translated according to whether or not they represent host names
        (i.e., RDATA names that are the owner names of A and AAAA DNS
	records).
        RDATA names ending in ".local" that represent host names
        are translated to the delegated LDH subdomain, if one is configured,
        or to the delegated rich-text subdomain otherwise.
        All other RDATA names ending in ".local"
        are translated to the delegated rich-text subdomain.
        For example, consider a DNS-SD service browsing PTR query
        that returns this PTR record for IPP printing:</t>

        <artwork name="" type="" align="left" alt="">
  _ipp._tcp.local.  PTR  My Printer._ipp._tcp.local.</artwork>

        <t>Both the owner name and the name in the RDATA
        are translated from ".local" to the rich-text subdomain:</t>

        <artwork name="" type="" align="left" alt="">
  _ipp._tcp.Building 1.example.com.
                    PTR  My Printer._ipp._tcp.Building 1.example.com.</artwork>

        <t>In contrast, consider a query
        that returns this SRV record for a specific IPP printing instance:</t>

        <artwork name="" type="" align="left" alt="">
  My Printer._ipp._tcp.local.  SRV  0 0 631 prnt.local.</artwork>

        <t>As for all queries, the owner name
        is translated to the delegated subdomain of the originating query,
        the delegated rich-text subdomain "Building&nbsp;1.example.com".
        However, the ".local" name in the RDATA
        is the target host name field of an SRV record,
        a field that is used exclusively for host names.
        Consequently it is translated to the LDH subdomain
	"bldg&nbhy;1.example.com",
        if configured, instead of the rich-text subdomain:
        </t>

        <artwork name="" type="" align="left" alt="">
  My Printer._ipp._tcp.Building 1.example.com.
                               SRV  0 0 631 prnt.bldg&nbhy;1.example.com.</artwork>

        <t>Other beneficial translation and filtering operations are described
	below.</t>
        <section anchor="ttl" numbered="true" toc="default">
          <name>DNS TTL Limiting</name>
          <t>For efficiency, Multicast DNS typically uses moderately high DNS
          TTL values. For example, the typical TTL on DNS-SD service browsing
	    PTR records is 75
          minutes. What makes these moderately high TTLs acceptable is the
          cache coherency mechanisms built in to the Multicast DNS protocol,
          which protect against stale data persisting for too long.  When a
          service shuts down gracefully, it sends goodbye packets to remove
          its service browsing PTR record(s) immediately from neighboring
	    caches.  If a service
          shuts down abruptly without sending goodbye packets, the Passive
          Observation Of Failures (POOF) mechanism described in <xref
          target="RFC6762" sectionFormat="of" section="10.5">the Multicast DNS
          specification</xref> comes into play to purge the cache of stale
	    data.</t>
          <t>A traditional Unicast DNS client on a distant remote link does
          not get to participate in these Multicast DNS cache coherency
          mechanisms on the local link.  For traditional Unicast DNS queries
          (those received without using Long-Lived Queries (LLQ) <xref
          target="RFC8764" format="default"/> or DNS Push
          Notification subscriptions <xref target="RFC8765"
          format="default"/>), the DNS TTLs reported in the resulting Unicast
          DNS response <bcp14>MUST</bcp14> be capped to be no more than ten
          seconds.</t>
          <t>Similarly, for negative responses, the negative caching TTL
          indicated in the SOA record <xref target="RFC2308"
          format="default"/> should also be ten seconds (see <xref
	    target="soa"
          format="default"/>).</t>
          <t>This value of ten seconds is chosen based on user-experience
	      considerations.</t>
          <t>For negative caching, suppose a user is attempting to access a
          remote device (e.g., a printer), and they are unsuccessful because
          that device is powered off. Suppose they then place a telephone call
          and ask for the device to be powered on. We want the device to
          become available to the user within a reasonable time period. It is
          reasonable to expect it to take on the order of ten seconds for a
          simple device with a simple embedded operating system to power
          on. Once the device is powered on and has announced its presence on
          the network via Multicast DNS, we would like it to take no more than
          a further ten seconds for stale negative cache entries to expire
          from Unicast DNS caches, making the device available to the user
          desiring to access it.</t>
          <t>Similar reasoning applies to capping positive TTLs at ten
	      seconds.
          In the event of a device moving location, getting a new DHCP
	      address,
          or other renumbering events, we would like the updated information
	      to
          be available to remote clients in a relatively timely fashion.</t>
          <t>However, network administrators should be aware that many
	      recursive
          resolvers by default are configured to impose a minimum
	      TTL of
          30 seconds. If stale data appears to be persisting in the network to
	      the
          extent that it adversely impacts user experience, network
	      administrators
          are advised to check the configuration of their recursive
	    resolvers.</t>
          <t>For received Unicast DNS queries that use LLQ <xref
	    target="RFC8764" format="default"/> or
          DNS Push Notifications <xref target="RFC8765" format="default"/>,
	    the Multicast DNS
	        record's TTL <bcp14>SHOULD</bcp14> be
          returned unmodified, because the notification channel exists
          to inform the remote client as records come and go.
          For further details about Long-Lived Queries and its newer
	      replacement,
          DNS Push Notifications, see <xref target="aggregation"
	    format="default"/>.</t>
        </section>
        <section anchor="unusable" numbered="true" toc="default">
          <name>Suppressing Unusable Records</name>
          <t>A Discovery Proxy <bcp14>SHOULD</bcp14> offer a configurable
	    option,
          enabled by default, to suppress Unicast DNS answers
          for records that are not useful outside the local link.
          When the option to suppress unusable records is enabled:
          </t>
          <ul spacing="normal">
            <li>For a Discovery Proxy that is serving only clients outside the
	        local link,
              DNS A and AAAA records for
              IPv4 link-local addresses <xref target="RFC3927"
	            format="default"/>
              and
              IPv6 link-local addresses <xref target="RFC4862"
	            format="default"/>
              <bcp14>SHOULD</bcp14> be suppressed.</li>
            <li>Similarly, for sites that have multiple private address
	              realms <xref target="RFC1918" format="default"/>,
              in cases where the Discovery Proxy can determine that the
	                  querying client
              is in a different address realm, private addresses <bcp14>SHOULD
	            NOT</bcp14> be
              communicated to that client.</li>
            <li>
              IPv6 Unique Local Addresses <xref target="RFC4193"
	            format="default"></xref>
	                  <bcp14>SHOULD</bcp14> be suppressed
              in cases where the Discovery Proxy can determine that the
	                  querying client
              is in a different IPv6 address realm.</li>
            <li>By the same logic, DNS SRV records that reference target host
              names that have no addresses usable by the requester should be
              suppressed, and likewise, DNS-SD service browsing PTR records
	            that point to unusable
              SRV records should similarly be suppressed.</li>
          </ul>
        </section>
        <section numbered="true" toc="default">
          <name>NSEC and NSEC3 Queries</name>
          <t>Multicast DNS devices do not routinely announce their records
          on the network. Generally, they remain silent until queried.
          This means that the complete set of Multicast DNS records in use on
	      a
          link can only be discovered by active querying, not by passive
	      listening.
          Because of this, a Discovery Proxy can only know what names exist on
	      a link
          by issuing queries for them, and since it would be impractical to
          issue queries for every possible name just to find out which names
          exist and which do not, a Discovery Proxy cannot programmatically
          generate the traditional Unicast DNS
          NSEC <xref target="RFC4034" format="default"></xref> and
          NSEC3 <xref target="RFC5155" format="default"></xref> records
          that assert the nonexistence of a large range of names.</t>
          <t>When queried for an NSEC or NSEC3 record type, the Discovery
	      Proxy issues
          a qtype "ANY" query using Multicast DNS on the local link and then
          generates an NSEC or NSEC3 response with a Type Bit Map signifying
          which record types do and do not exist for just the specific name
	      queried,
          and no other names.</t>
          <t>Multicast DNS NSEC records received on the local link
          <bcp14>MUST NOT</bcp14> be forwarded unmodified to a unicast
	    querier, because there
	        are
          slight differences in the NSEC record data.
          In particular, Multicast DNS NSEC records do not have the NSEC
          bit set in the Type Bit Map, whereas conventional Unicast DNS
          NSEC records do have the NSEC bit set.</t>
        </section>
        <section anchor="notrans" numbered="true" toc="default">
          <name>No Text-Encoding Translation</name>
          <t>A Discovery Proxy does no translation between text encodings.
          Specifically, a Discovery Proxy does no translation between Punycode
	      encoding <xref
          target="RFC3492" format="default"></xref> and UTF-8 encoding <xref
          target="RFC3629" format="default"></xref>, either in
          the owner name of DNS records or anywhere in the RDATA of DNS
          records (such as the RDATA of PTR records, SRV records, NS records,
          or other record types like TXT, where it is ambiguous whether the
          RDATA may contain DNS names).  All bytes are treated as-is with no
          attempt at text-encoding translation.  A client implementing
          DNS-based Service Discovery <xref target="RFC6763"
          format="default"/> will use UTF-8 encoding for its unicast DNS-based
	    Service Discovery
          queries, which the Discovery Proxy passes through without any
          text-encoding translation to the Multicast DNS subsystem.  Responses
          from the Multicast DNS subsystem are similarly returned, without any
          text-encoding translation, back to the requesting unicast
	    client.</t>
        </section>

        <section numbered="true" toc="default">
          <name>Application-Specific Data Translation</name>
          <t>There may be cases where Application-Specific Data Translation is
	      appropriate.</t>

          <t>For example, AirPrint printers tend to advertise fairly verbose
          information about their capabilities in their DNS-SD TXT record.
          TXT record sizes in the range of 500-1000 bytes are not uncommon.
          This information is a legacy from lineprinter (LPR) printing,
          because LPR does not have in-band capability negotiation, so all of
          this information is conveyed using the DNS-SD TXT record instead.
          Internet Printing Protocol (IPP) printing does have in-band
          capability negotiation, but for convenience, printers tend to
	    include
          the same capability information in their IPP DNS-SD TXT records as
          well. For local Multicast DNS (mDNS) use, this extra TXT record
	    information is
          wasteful but not fatal.  However, when a Discovery Proxy
          aggregates data from multiple printers on a link, and sends it via
          unicast (via UDP or TCP), this amount of unnecessary TXT record
          information can result in large responses.  A DNS reply over TCP
          carrying information about 70 printers with an average of 700 bytes
          per printer adds up to about 50 kilobytes of data.  Therefore, a
          Discovery Proxy that is aware of the specifics of an
          application-layer protocol such as AirPrint (which uses IPP) can
          elide unnecessary key/value pairs from the DNS-SD TXT record for
          better network efficiency.</t>
          <t>Also, the DNS-SD TXT record for many printers contains an
          "adminurl" key (e.g.,
          "adminurl=http://printername.local/status.html").  For this URL to
	    be
          useful outside the local link, the embedded ".local" host name needs
          to be translated to an appropriate name with larger scope.  It is
          easy to translate ".local" names when they appear in well-defined
          places: as a record's owner name, or in domain name fields in the
	    RDATA of record types
          like PTR and SRV.  In the printing case, some application-specific
          knowledge about the semantics of the "adminurl" key is needed for
          the Discovery Proxy to know that it contains a name that needs to be
          translated.  This is somewhat analogous to the need for NAT gateways
          to contain ALGs (Application-Level Gateways) to facilitate the
          correct translation of protocols that embed addresses in unexpected
          places.</t>
          <t>To avoid the need for application-specific knowledge about the
          semantics of particular TXT record keys, protocol designers are
          advised to avoid placing link-local names or link-local IP addresses
          in TXT record keys if translation of those names or addresses would
          be required for off-link operation.  In the printing case, the
          consequence of failing to translate the "adminurl" key
          correctly would be that, when accessed from a different link,
	    printing
          will still work, but clicking the "Admin" user interface button will
	    fail to
          open the printer's administration page.  Rather than duplicating the
          host name from the service's SRV record in its "adminurl" key,
          thereby having the same host name appear in two places, a better
          design might have been to omit the host name from the "adminurl"
          key and instead have the client implicitly substitute the target
          host name from the service's SRV record in place of a missing host
          name in the "adminurl" key.  That way, the desired host name only
          appears once and is in a well-defined place where software like
          the Discovery Proxy is expecting to find it.</t>
          <t>Note that this kind of Application-Specific Data Translation is
          expected to be very rare; it is the exception rather than the rule.
          This is an example of a common theme in computing.  It is frequently
          the case that it is wise to start with a clean, layered design with
          clear boundaries. Then, in certain special cases, those layer
          boundaries may be violated where the performance and efficiency
          benefits outweigh the inelegance of the layer violation.</t>
          <t>These layer violations are optional. They are done primarily for
          efficiency reasons and generally should not be required for correct
          operation.  A Discovery Proxy <bcp14>MAY</bcp14> operate solely at
          the mDNS layer without any knowledge of semantics at the DNS-SD
          layer or above.</t>
        </section>
      </section>
      <section anchor="aggregation" numbered="true" toc="default">
        <name>Answer Aggregation</name>
        <t>In a simple analysis, simply gathering multicast answers and
        forwarding them in a unicast response seems adequate, but it raises
        the question of how long the Discovery Proxy should wait to be sure
        that it has received all the Multicast DNS answers it needs to form a
        complete Unicast DNS response.  If it waits too little time, then it
        risks its Unicast DNS response being incomplete.  If it waits too
        long, then it creates a poor user experience at the client end.  In
        fact, there may be no time that is both short enough to produce a
        good user experience and at the same time long enough to reliably
        produce complete results.</t>
        <t>Similarly, the Discovery Proxy (the authoritative name server for
        the subdomain in question) needs to decide what DNS TTL to report
        for these records.  If the TTL is too long, then the recursive
        resolvers issuing queries on behalf of their clients risk
        caching stale data for too long. If the TTL is too short, then the
        amount of network traffic will be more than necessary.  In fact, there
        may be no TTL that is both short enough to avoid undesirable stale
        data and, at the same time, long enough to be efficient on the
        network.</t>
        <t>Both these dilemmas are solved by the use of DNS Long-Lived Queries
	(LLQ)
        <xref target="RFC8764" format="default"/> or its newer replacement,
        DNS Push Notifications <xref target="RFC8765"
	format="default"></xref>.</t>
        <t>Clients supporting unicast DNS-based Service Discovery
	<bcp14>SHOULD</bcp14> implement
        DNS Push Notifications <xref target="RFC8765" format="default"></xref>
        for improved user experience.</t>

        <t>Clients and Discovery Proxies <bcp14>MAY</bcp14> support both
        LLQ and DNS&nbsp;Push Notifications, and when talking to a
        Discovery Proxy that supports both, the client may use either
        protocol, as it chooses, though it is expected that only
        DNS&nbsp;Push Notifications will continue to be supported in the long
        run.</t>

        <t>When a Discovery Proxy receives a query using LLQ
        or DNS Push Notifications, it responds immediately using the Multicast
        DNS records it already has in its cache (if any).  This provides a
        good client user experience by providing a near-instantaneous
        response. Simultaneously, the Discovery Proxy issues a Multicast DNS
        query on the local link to discover if there are any additional
        Multicast DNS records it did not already know about. Should additional
        Multicast DNS responses be received, these are then delivered to the
        client using additional LLQ or DNS Push Notification update
        messages.  The timeliness of such update messages is limited only by
        the timeliness of the device responding to the Multicast DNS query. If
        the Multicast DNS device responds quickly, then the update message is
        delivered quickly. If the Multicast DNS device responds slowly, then
        the update message is delivered slowly.  The benefit of using multiple
	update
        messages to deliver results as they become available is that the
	Discovery
        Proxy can respond promptly because it doesn't have to deliver all the
        results in a single response that needs to be delayed to allow for the
        expected worst-case delay for receiving all the Multicast DNS
	responses.</t>

        <t>With a proxy that supported only standard DNS queries, even if it
        were to try to provide reliability by assuming an
        excessively pessimistic worst-case time (thereby giving a very poor
        user experience), there would still be the risk of a slow Multicast
        DNS device taking even longer than that worst-case time (e.g., a
	device that is not
        even powered on until ten seconds after the initial query is
	received),
        resulting in incomplete responses.
        Using update messages to deliver subsequent asynchronous replies
	solves this
        dilemma: even very late responses are not lost; they are delivered in
        subsequent update messages.</t>

        <t>Note that while normal DNS queries are generally received via the
	client's configured
        recursive resolver, LLQ and DNS Push Notification subscriptions may be
        received directly from the client.</t>

        <t>There are two factors that determine how unicast responses
        are generated:</t>


        <t>The first factor is whether or not the Discovery Proxy already has
        at least one record in its cache that answers the question.
        </t>
        <t>
    The second factor is whether the client used a normal DNS query,
    or established a subscription using LLQ or DNS Push Notifications.
    Normal DNS queries
    are typically used for one-shot operations like SRV or address record
    queries.
    LLQ and DNS Push Notification subscriptions
    are typically used for long-lived service browsing PTR queries.
    Normal DNS queries and LLQ each have different response timing depending
    on the cache state, yielding the first four cases listed below.
    DNS Push Notifications, the newer protocol, has uniform behavior
    regardless of cache state, yielding the fifth case listed below.</t>


        <ul spacing="normal">
          <li>
            <t>Standard DNS query; no answer in
	            cache:</t>
            <t>
            Issue an mDNS query on the local link, exactly as a local client
            would issue an mDNS query, for the desired record name, type, and
            class, including retransmissions, as appropriate, according to the
            established mDNS retransmission schedule <xref target="RFC6762"
            format="default"/>. The Discovery Proxy awaits Multicast DNS
	        responses.</t>
            <t>
            As soon as any Multicast DNS response packet
            is received that contains one or more positive answers to that
            question (with or without the Cache Flush bit <xref
            target="RFC6762" format="default"/> set) or a negative answer
            (signified via a Multicast DNS NSEC record <xref target="RFC6762"
            format="default"/>), the Discovery Proxy generates a Unicast DNS
            response message containing the corresponding (filtered and
            translated) answers and sends it to the remote client.</t>
            <t>
            If after
            six seconds no relevant Multicast DNS answers have been received,
	        cancel
            the mDNS query and return a negative response to the remote
            client.  Six seconds is enough time
            for the underlying Multicast DNS subsystem
            to transmit three mDNS queries
            and allow some time for responses to arrive.</t>
            <t>
            (Reasoning: Queries not using LLQ or Push Notifications are
	            generally queries
            that expect an answer from only one device,
            so the first response is also the only response.)</t>
            <t>
            DNS TTLs in responses <bcp14>MUST</bcp14> be capped to at most ten
	            seconds.</t>
          </li>

          <li>
            <t>Standard DNS query; at least one answer in
	            cache:</t>
            <t>
            No local mDNS queries are performed.</t>
            <t>
            The Discovery Proxy generates a Unicast DNS
            response message containing the answer(s) from the cache right
	        away, to minimize delay.</t>
            <t>
            (Reasoning: Queries not using LLQ or Push Notifications are
	            generally queries
            that expect an answer from only one device.
            Given RRSet TTL harmonization, if the proxy has
            one Multicast DNS answer in its cache, it can reasonably
            assume that it has the whole set.)</t>
            <t>
            DNS TTLs in responses <bcp14>MUST</bcp14> be capped to at most ten
	            seconds.</t>
          </li>

          <li>
            <t>Long-Lived Query (LLQ); no answer in cache:</t>
            <t>
            As in the case above with no answer in the cache, plan to perform
	        mDNS
            querying for six seconds, returning an LLQ response message to the
	        remote
            client as soon as any relevant mDNS response is received.</t>
            <t>
            If after six seconds no relevant mDNS answers have been received,
            and the client has not cancelled its Long-Lived Query,
            return a negative LLQ response message to the remote client.</t>
            <t>
            (Reasoning: We don't need to rush to send an empty
	            answer.)</t>
            <t>
            Regardless of whether or not a relevant mDNS response is received
	        within
            six seconds, the Long-Lived Query remains active for as long as
	        the
            client maintains the LLQ state, and results in the ongoing
            transmission of mDNS queries until the Long-Lived Query is
	        cancelled.
            If the set of mDNS answers changes, LLQ Event Response messages
	        are sent.</t>
            <t>
            DNS TTLs in responses are returned unmodified.</t>
          </li>

          <li>
            <t>Long-Lived Query (LLQ); at least one answer in
	            cache:</t>
            <t>
            As in the case above with at least one answer in the cache,
            the Discovery Proxy generates a unicast LLQ
            response message containing the answer(s) from the cache right
	        away, to minimize delay.</t>
            <t>
            The Long-Lived Query remains active for as long as the client
	        maintains the LLQ state,
            and results in the transmission of mDNS queries
            (with appropriate Known Answer lists)
            to determine if further answers are available.
            If the set of mDNS answers changes, LLQ Event Response messages
	        are sent.</t>
            <t>
            (Reasoning: We want a user interface that is displayed very
	        rapidly yet
            continues to remain accurate even as the network environment
            changes.)</t>
            <t>
            DNS TTLs in responses are returned unmodified.</t>
          </li>

          <li>
            <t>Push Notification Subscription</t>
            <t>
            The Discovery Proxy acknowledges the subscription request
	        immediately.</t>
            <t>
            If one or more answers are already available in the cache,
            those answers are then sent in an immediately following DNS PUSH
	        message.</t>
            <t>
            The Push Notification subscription remains active until the client
	        cancels the subscription,
            and results in the transmission of mDNS queries
            (with appropriate Known Answer lists)
            to determine if further answers are available.
            If the set of mDNS answers changes, further DNS PUSH messages are
	        sent.</t>
            <t>
            (Reasoning: We want a user interface that is displayed very
	        rapidly yet
            continues to remain accurate even as the network environment
            changes.)</t>
            <t>
            DNS TTLs in responses are returned unmodified.</t>
          </li>
        </ul>

        <t>Where the text above refers to returning "a negative response to
        the remote client", it is describing returning a "no error no answer"
        negative response, not NXDOMAIN.  This is because the Discovery Proxy
        cannot know all the Multicast DNS domain names that may exist on a
        link at any given time, so any name with no answers may have child
        names that do exist, making it an "empty non-terminal" name.</t>
        <t>Note that certain aspects of the behavior described here
        do not have to be implemented overtly by the Discovery Proxy;
        they occur naturally as a result of using existing Multicast DNS
	APIs.</t>
        <t>For example, in the first case above (standard DNS query and no
        answers in the cache), if a new Multicast DNS query is requested
        (either by a local client on the Discovery Proxy device, or by the
        Discovery Proxy software on that device on behalf of a remote client),
        and there is not already an identical Multicast DNS query active and
        there are no matching answers already in the Multicast DNS cache on
        the Discovery Proxy device, then this will cause a series of Multicast
        DNS query packets to be issued with exponential backoff.  The
        exponential backoff sequence in some implementations starts at one
        second and then doubles for each retransmission (0, 1, 3, 7 seconds,
        etc.), and in others, it starts at one second and then triples for
        each retransmission (0, 1, 4, 13 seconds, etc.).  In either case, if
        no response has been received after six seconds, that is long enough
        that the underlying Multicast DNS implementation will have sent three
        query packets without receiving any response.  At that point, the
        Discovery Proxy cancels its Multicast DNS query (so no further
        Multicast DNS query packets will be sent for this query) and returns a
        negative response to the remote client via unicast.</t>
        <t>The six-second delay is chosen to be long enough to give enough
        time for devices to respond, yet short enough not to be too onerous
        for a human user waiting for a response.  For example, using the "dig"
        DNS debugging tool, the current default settings result in it waiting
        a total of 15 seconds for a reply (three transmissions of the DNS UDP
        query packet, with a wait of 5 seconds after each packet), which is
        ample time for it to have received a negative reply from a Discovery
        Proxy after six seconds.</t>

        <t>The text above states that for a standard DNS query,
        if at least one answer is already available in the cache, then a
        Discovery Proxy should not issue additional mDNS query packets.
        This also occurs naturally as a result of using existing
        Multicast DNS APIs. 
   If a new Multicast DNS query is requested
   (either locally, or by the Discovery Proxy on behalf of a remote client)
   for which there are relevant answers already in the Multicast DNS
   cache on the Discovery Proxy device, and after the answers are
   delivered the Multicast DNS query is immediately cancelled, then
   no Multicast DNS query packets will be generated for this query.
	</t>


      </section>
    </section>

    <section anchor="admin" numbered="true" toc="default">
      <name>Administrative DNS Records</name>
      <section anchor="soa" numbered="true" toc="default">
        <name>DNS SOA (Start of Authority) Record</name>
        <t>The MNAME field <bcp14>SHOULD</bcp14> contain the host name of the
	Discovery Proxy
	device
        (i.e., the same domain name as the RDATA of the NS record delegating
	the
        relevant zone(s) to this Discovery Proxy device).</t>
        <t>The RNAME field <bcp14>SHOULD</bcp14> contain the mailbox of the
	person
	responsible
        for administering this Discovery Proxy device.</t>
        <t>The SERIAL field <bcp14>MUST</bcp14> be zero.</t>
        <t>Zone transfers are undefined for Discovery Proxy zones, and
        consequently, the REFRESH, RETRY, and EXPIRE fields have no useful
        meaning for Discovery Proxy zones.  These fields <bcp14>SHOULD</bcp14>
        contain reasonable default values.  The <bcp14>RECOMMENDED</bcp14>
        values are: REFRESH 7200, RETRY 3600, and EXPIRE 86400.</t>
        <t>The MINIMUM field (used to control the lifetime of negative cache
	entries)
        <bcp14>SHOULD</bcp14> contain the value 10.
        This value is chosen based on user-experience
	considerations
        (see <xref target="ttl" format="default"/>).</t>
        <t>In the event that there are multiple Discovery Proxy devices on a
        link for fault tolerance reasons, this will result in clients
        receiving inconsistent SOA records (different MNAME and possibly
        RNAME) depending on which Discovery Proxy answers their SOA query.
        However, since clients generally have no reason to use the MNAME or
        RNAME data, this is unlikely to cause any problems.</t>
      </section>
      <section anchor="ns" numbered="true" toc="default">
        <name>DNS NS Records</name>
        <t>In the event that there are multiple Discovery Proxy devices on a
        link for fault tolerance reasons, the parent zone <bcp14>MUST</bcp14>
        be configured with NS records giving the names
        of all the Discovery Proxy devices on the link.</t>
        <t>Each Discovery Proxy device <bcp14>MUST</bcp14> be configured to
	answer NS queries
        for the zone apex name by giving its own NS record,
        and the NS records of its fellow Discovery Proxy devices on the same
        link, so that it can return the correct answers for NS queries.</t>
        <t>The target host name in the RDATA of an NS record <bcp14>MUST
	NOT</bcp14>
	reference
        a name that falls within any zone delegated to a Discovery Proxy.
        Apart from the zone apex name,
        all other host names (names of A and AAAA DNS records)
        that fall within a zone delegated to a Discovery
	Proxy
        correspond to local Multicast DNS host names,
        which logically belong to the respective Multicast DNS hosts defending
	those names,
        not the Discovery Proxy.
        Generally speaking, the Discovery Proxy does not own or control the
	delegated zone;
        it is merely a conduit to the corresponding ".local" namespace,
        which is controlled by the Multicast DNS hosts on that link.
        If an NS record were to reference a manually determined host name
        that falls within a delegated zone,
        that manually determined host name may inadvertently conflict with a
	corresponding
        ".local" host name that is owned and controlled by some device on that
	link.
        </t>
      </section>
      <section anchor="delegation" numbered="true" toc="default">
        <name>DNS Delegation Records</name>
        <t>Since the <xref target="RFC6762" format="default">Multicast DNS
        specification</xref> states that there can be no delegation
        (subdomains) within a ".local" namespace, this implies that any name
        within a zone delegated to a Discovery Proxy (except for the zone apex
        name itself) cannot have any answers for any DNS queries for RRTYPEs
        SOA, NS, or DS.  Consequently:
        </t>

        <ul spacing="normal">
          <li>for any query for the zone apex name of a zone delegated to a
          Discovery Proxy, the Discovery Proxy <bcp14>MUST</bcp14> generate
          the appropriate immediate answers as described above, and</li>

          <li>
          for any query for any name below the zone apex, for RRTYPEs SOA, NS,
	    or DS,
          the Discovery Proxy <bcp14>MUST</bcp14> generate
          an immediate negative answer.
          </li>
        </ul>
      </section>

      <section anchor="srv" numbered="true" toc="default">
        <name>DNS SRV Records</name>
        <t>There are certain special DNS records that logically fall within
        the delegated Unicast DNS subdomain, but rather than mapping to their
        corresponding ".local" namesakes, they actually contain metadata
        pertaining to the operation of the delegated Unicast DNS subdomain
        itself.  They do not exist in the corresponding ".local" namespace of
        the local link.  For these queries, a Discovery Proxy
        <bcp14>MUST</bcp14> generate immediate answers, whether positive or
        negative, to avoid delays while clients wait for their query to be
        answered.</t>

        <t>For example, if a Discovery Proxy implements Long-Lived Queries
        <xref target="RFC8764" format="default"></xref>, then it
        <bcp14>MUST</bcp14> positively respond to
        <tt>_dns&nbhy;llq._udp.&lt;zone&gt;&nbsp;SRV</tt> queries,
        <tt>_dns&nbhy;llq._tcp.&lt;zone&gt;&nbsp;SRV</tt> queries, and
        <tt>_dns&nbhy;llq&nbhy;tls._tcp.&lt;zone&gt;&nbsp;SRV</tt> queries as
        appropriate.  If it does not implement Long-Lived Queries, it
        <bcp14>MUST</bcp14> return an immediate negative answer for those
        queries, instead of passing those queries through to the local network
        as Multicast DNS queries and then waiting unsuccessfully for answers
        that will not be forthcoming.</t>

        <t>If a Discovery Proxy implements
        DNS Push Notifications <xref target="RFC8765"
	format="default"></xref>,
        then it <bcp14>MUST</bcp14> positively respond to
        <tt>_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</tt>
	queries.
        Otherwise, it <bcp14>MUST</bcp14> return an immediate negative answer
	for those
	queries.</t>
        <t>A Discovery Proxy <bcp14>MUST</bcp14> return an immediate negative
	answer for
        <tt>_dns&nbhy;update._udp.&lt;zone&gt;&nbsp;SRV</tt>
	queries,
        <tt>_dns&nbhy;update._tcp.&lt;zone&gt;&nbsp;SRV</tt>
	queries, and
        <tt>_dns&nbhy;update-tls._tcp.&lt;zone&gt;&nbsp;SRV</tt>
	queries,
        since using DNS Update <xref target="RFC2136" format="default"></xref>
	to change
        zones generated dynamically from local Multicast DNS data is not
	possible.</t>
      </section>

      <section numbered="true" toc="default">
        <name>Domain Enumeration Records</name>
        <t>If the network operator chooses to use address-based
        unicast Domain Enumeration queries for client configuration
        (see <xref target="unicast" format="default"/>),
        and the network operator also chooses to delegate the enclosing
        reverse mapping subdomain to a Discovery Proxy,
        then that Discovery Proxy becomes responsible for serving
        the answers to those address-based unicast Domain Enumeration
	queries.</t>

        <t>As with the SRV metadata records described above, a Discovery Proxy
        configured with delegated reverse mapping subdomains is responsible
        for generating immediate (positive or negative) answers for
        address-based unicast Domain Enumeration queries, rather than
        passing them though to the underlying Multicast DNS subsystem and
        then waiting unsuccessfully for answers that will not be
	forthcoming.</t>
      </section>

    </section>
    <section anchor="DNSSEC" numbered="true" toc="default">
      <name>DNSSEC Considerations</name>
      <section numbered="true" toc="default">
        <name>Online Signing Only</name>
        <t>The Discovery Proxy acts as the authoritative name server for
        designated subdomains, and if DNSSEC is to be used, the Discovery
        Proxy needs to possess a copy of the signing keys in order to
        generate authoritative signed data from the local Multicast DNS
        responses it receives.  Offline signing is not applicable to
        Discovery Proxy.</t>
      </section>
      <section numbered="true" toc="default">
        <name>NSEC and NSEC3 Records</name>
        <t>In DNSSEC,
        NSEC and NSEC3 records
        are used to assert the nonexistence of certain names,
        also described as "authenticated denial of existence"
        <xref target="RFC4034" format="default"></xref>
        <xref target="RFC5155" format="default"></xref>.</t>

        <t>Since a Discovery Proxy only knows what names exist on the local
        link by issuing queries for them, and since it would be impractical to
        issue queries for every possible name just to find out which names
        exist and which do not, a Discovery Proxy cannot programmatically
        synthesize the traditional NSEC and NSEC3 records that assert the
        nonexistence of a large range of names.  Instead, when generating a
        negative response, a Discovery Proxy programmatically synthesizes a
        single NSEC record asserting the nonexistence of just the specific
        name queried and no others.  Since the Discovery Proxy has the zone
        signing key, it can do this on demand.  Since the NSEC record asserts
        the nonexistence of only a single name, zone walking is not a concern,
        and NSEC3 is therefore not necessary.</t>
        <t>Note that this applies only to traditional immediate DNS queries,
        which may return immediate negative answers when no immediate positive
        answer is available.  When used with a DNS Push Notification
        subscription <xref target="RFC8765"
        format="default"></xref>, there are no negative answers, merely the
        absence of answers so far, which may change in the future if answers
        become available.</t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>IPv6 Considerations</name>
      <t>An IPv4-only host and an IPv6-only host behave as "ships that pass in
      the night". Even if they are on the same Ethernet <xref target="IEEE-3"
      format="default"></xref>, neither is aware of the other's traffic. For
      this reason, each link may have <em>two</em> unrelated ".local." zones:
      one for
      IPv4 and one for IPv6.  Since, for practical purposes, a group of
      IPv4-only hosts and a group of IPv6-only hosts on the same Ethernet act
      as if they were on two entirely separate Ethernet segments, it is
      unsurprising that their use of the ".local." zone should occur exactly
      as it would if they really were on two entirely separate Ethernet
      segments.</t>
      <t>It will be desirable to have a mechanism to "stitch" together
      these two unrelated ".local." zones so that they appear as one.
      Such a mechanism will need to be able to differentiate between a
      dual-stack (v4/v6) host participating in both ".local."
      zones, and two different hosts: one IPv4-only and the other IPv6-only,
      which are both trying to use the same name(s). Such a mechanism
      will be specified in a future companion document.</t>
      <t>At present, it is <bcp14>RECOMMENDED</bcp14> that a Discovery Proxy
      be configured
      with a single domain name for both the IPv4 and IPv6 ".local." zones
      on the local link, and when a unicast query is received, it should
      issue Multicast DNS queries using both IPv4 and IPv6 on the local link
      and then combine the results.</t>
    </section>
    <section numbered="true" toc="default">
      <name>Security Considerations</name>
      <section numbered="true" toc="default">
        <name>Authenticity</name>
        <t>A service proves its presence on a link by its ability to
        answer link-local multicast queries on that link.
        If greater security is desired, then the Discovery Proxy mechanism
        should not be used, and something with stronger security should
        be used instead such as authenticated secure DNS Update
        <xref target="RFC2136" format="default"/> <xref target="RFC3007"
	format="default"/>.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Privacy</name> <t>The Domain Name System is, generally speaking,
        a global public database.  Records that exist in the Domain Name
        System name hierarchy can be queried by name from, in principle,
        anywhere in the world.  If services on a mobile device (like a laptop
        computer) are made visible via the Discovery Proxy mechanism, then
        when those services become visible in a domain such as
        "My&nbsp;House.example.com", it might indicate to (potentially
        hostile) observers that the mobile device is in the owner's home.
	When those
        services disappear from "My&nbsp;House.example.com", that change could
        be used by observers to infer when the mobile device (and possibly its
        owner) may have left the house.  The privacy of this information may
        be protected using techniques like firewalls, split-view DNS, and
        Virtual Private Networks (VPNs), as are customarily used today to
        protect the privacy of corporate DNS information.</t>
        <t>The privacy issue is particularly serious for the IPv4 and IPv6
	reverse zones.
        If the public delegation of the reverse zones points to the
        Discovery Proxy, and the Discovery Proxy is reachable globally,
        then it could leak a significant amount of information.
        Attackers could discover hosts that otherwise might
        not be easy to identify, and learn their host names.
        Attackers could also discover the existence of links
        where hosts frequently come and go.</t>
        <t>The Discovery Proxy could provide sensitive records only to
	authenticated
        users. This is a general DNS problem, not specific to the Discovery
	Proxy.
        Work is underway in the IETF to tackle this problem <xref
	target="RFC7626" format="default"/>.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Denial of Service</name>
        <t>A remote attacker could use a rapid series of unique Unicast DNS
        queries to induce a Discovery Proxy to generate a rapid series of
        corresponding Multicast DNS queries on one or more of its local links.
        Multicast traffic is generally more expensive than unicast traffic,
        especially on Wi-Fi links
        <xref target="I-D.ietf-mboned-ieee802-mcast-problems"
	            format="default"/>,
        which makes this attack particularly
        serious.  To limit the damage that can be caused by such attacks, a
        Discovery Proxy (or the underlying Multicast DNS subsystem that it
        utilizes) <bcp14>MUST</bcp14> implement Multicast DNS query rate
        limiting appropriate to the link technology in question. For today's
        802.11b/g/n/ac Wi-Fi links (for which approximately 200 multicast
        packets per second is sufficient to consume approximately 100% of the
        wireless spectrum), a limit of 20 Multicast DNS query packets per
        second is <bcp14>RECOMMENDED</bcp14>.  On other link technologies like
        Gigabit Ethernet, higher limits may be appropriate.  A consequence of
        this rate limiting is that a rogue remote client could issue an
        excessive number of queries resulting in denial of service to other
        legitimate remote clients attempting to use that Discovery Proxy.
        However, this is preferable to a rogue remote client being able to
        inflict even greater harm on the local network, which could impact the
        correct operation of all local clients on that network.</t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This document has no IANA actions.</t>
    </section>

  </middle>
  <back>

<displayreference target="I-D.cheshire-dnssd-roadmap" to="ROADMAP"/>

<displayreference target="I-D.sctl-service-registration" to="REG-PROT"/>

<displayreference target="I-D.sctl-dnssd-mdns-relay" to="RELAY"/>

<displayreference target="I-D.ietf-mboned-ieee802-mcast-problems" to="MCAST"/>

<displayreference target="I-D.sekar-dns-ul" to="DNS-UL"/>


    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1918.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2308.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3629.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3927.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4034.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4862.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5155.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5198.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6763.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8490.xml"/>


<reference anchor='RFC8765' target="https://www.rfc-editor.org/info/rfc8765">
        <front>
        <title>DNS Push Notifications
	</title>
        <author initials='T' surname='Pusateri' fullname='Tom Pusateri'>
                <organization />
        </author>
        <author initials='S' surname='Cheshire' fullname='Stuart Cheshire'>
                <organization />
        </author>
        <date month='June' year='2020' />
        </front>
        <seriesInfo name='RFC' value='8765' />
        <seriesInfo name="DOI" value="10.17487/RFC8765"/>
</reference>


      </references>
      <references>
        <name>Informative References</name>

       <xi:include
	      href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.sekar-dns-ul.xml"/>

      <reference anchor="IEEE-1Q"
		  target="https://ieeexplore.ieee.org/document/6991462">
          <front>
            <title>IEEE Standard for Local and metropolitan area
	            networks -- Bridges and Bridged Networks
            </title>
            <author>
	                  <organization>IEEE</organization>
	    </author>
	            <date year="2014"/>
          </front>
        <seriesInfo name="IEEE Std" value="802.1Q-2014"/>
	<seriesInfo name="DOI" value="10.1109/IEEESTD.2014.6991462"/>
      </reference>




        <reference anchor="IEEE-3"
		      target="https://ieeexplore.ieee.org/document/8457469">
          <front>
            <title>
            IEEE Standard for Ethernet
            </title>
            <seriesInfo name="IEEE Std" value="802.3-2018"/>
            <seriesInfo name="DOI" value="10.1109/IEEESTD.2018.8457469"/>
            <author>
            <organization>IEEE</organization>
            </author>
            <date year="2008" month="December"/>
          </front>
        </reference>

        <reference anchor="IEEE-5"
		      target="https://standards.ieee.org/standard/802_5-1998.html">
          <front>
            <title>
Telecommunications and information exchange between systems - Local and
metropolitan area networks - Part 5: Token ring access method and physical
layer specifications
	    </title>
            <seriesInfo name="IEEE Std" value="802.5-1998"/>
            <author>
              <organization>IEEE</organization>
            </author>
	            <date year="1998"/>
          </front>
        </reference>


        <reference anchor="IEEE-11"
		      target="https://standards.ieee.org/standard/802_11-2016.html">
          <front>
            <title>
            Information technology - Telecommunications and information
	            exchange between systems -
            Local and metropolitan area networks - Specific requirements -
            Part 11: Wireless LAN Medium Access Control (MAC) and Physical
	            Layer (PHY) Specifications
            </title>
            <seriesInfo name="IEEE Std" value="802.11-2016"/>
            <author>
<organization>IEEE
</organization>
	    </author>
            <date year="2016" month="December"/>
          </front>
        </reference>

       <xi:include
	      href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-mboned-ieee802-mcast-problems.xml"/>

        <reference anchor="OHP"
		      target="https://github.com/sbyx/ohybridproxy/">
          <front>
            <title>
	                  ohybridproxy - an mDNS/DNS hybrid-proxy based on
			      mDNSResponder
	    </title>
            <author/>
	            <date month="June" year="2017"/>
          </front>
	      <refcontent>commit 464d6c9</refcontent>
	            
        </reference>

       <xi:include
	      href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.sctl-service-registration.xml"/>

       <xi:include
	      href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.sctl-dnssd-mdns-relay.xml"/>

        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2132.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2136.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3007.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3492.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4193.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6760.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7558.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7626.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7788.xml"/>
        <xi:include
	        href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8375.xml"/>


<reference anchor='RFC8764' target="https://www.rfc-editor.org/info/rfc8764">
  <front>
    <title>Apple's DNS Long-Lived Queries Protocol</title>
    
    <author initials='S' surname='Cheshire' fullname='Stuart Cheshire'>
      <organization />
    </author>
    
    <author initials='M' surname='Krochmal' fullname='Marc Krochmal'>
      <organization />
    </author>
    
    <date month='June' year='2020' />
  </front>
  
  <seriesInfo name='RFC' value='8764' />
  <seriesInfo name="DOI" value="10.17487/RFC8764"/>
</reference>

       <xi:include
	      href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.cheshire-dnssd-roadmap.xml"/>

        <reference anchor="ZC">
          <front>
            <title>Zero Configuration Networking: The Definitive Guide</title>
            <seriesInfo name="ISBN" value="0-596-10100-7"/>
            <author initials="S." surname="Cheshire" fullname="Stuart
	             Cheshire"/>
            <author initials="D.H." surname="Steinberg" fullname="Daniel
	        H. Steinberg"/>
            <date year="2005" month="December"/>
          </front>
            <refcontent>O'Reilly Media, Inc.</refcontent>
        </reference>

      </references>
    </references>

    <section anchor="implementation" numbered="true" toc="default">
      <name>Implementation Status</name>
      <t>Some aspects of the mechanism specified in this document already
      exist in
      deployed software. Some aspects are new. This section outlines which
      aspects
      already exist and which are new.</t>
      <section numbered="true" toc="default">
        <name>Already Implemented and Deployed</name>
        <t>Domain enumeration by the client
        ("b._dns-sd._udp.&lt;zone&gt;" queries) is already implemented and
	deployed.</t>
        <t>Performing unicast queries to the indicated discovery domain is
	already
        implemented and deployed.</t>
        <t>These are implemented and deployed in Mac OS X 10.4 Tiger and later
        (including all versions of Apple iOS, on all models of iPhones, iPads,
	Apple TVs and HomePods),
        in Bonjour for Windows,
        and in Android 4.1 "Jelly Bean" (API Level 16) and later.</t>
        <t>Domain enumeration and unicast querying have been
        used for several years at IETF meetings to make terminal room
        printers discoverable from outside the terminal room. When an IETF
        attendee presses "Cmd&nbhy;P" on a Mac, or selects AirPrint on an iPad
        or iPhone, and the terminal room printers appear, it is because
        the client is sending Unicast DNS queries to the IETF DNS servers.
        A walk-through giving the details of this particular specific example
        is given in <xref target="I-D.cheshire-dnssd-roadmap"
	sectionFormat="of" section="A">the Roadmap
	document</xref>.</t>

        <t>The Long-Lived Query mechanism <xref target="RFC8764"
	format="default"/>
        referred to in this specification exists and is deployed
        but was not standardized by the IETF.
        The IETF has developed a superior Long-Lived Query mechanism
        called DNS Push Notifications <xref target="RFC8765"
	format="default"/>,
        which is built on DNS Stateful Operations <xref target="RFC8490"
	format="default"/>.
        DNS Push Notifications is implemented and deployed in Mac OS X 10.15
	and later,
        and iOS 13 and later.</t>

      </section>

      <section numbered="true" toc="default">
        <name>Already Implemented</name>
        <t>A minimal portable Discovery Proxy implementation has been produced
	by
        Markus Stenberg and Steven Barth, which runs on OS X and several Linux
        variants including OpenWrt <xref target="OHP" format="default"/>.
        It was demonstrated at the Berlin IETF in July 2013.</t>

        <t>Tom Pusateri has an implementation that runs on any Unix/Linux
	system. It
        has a RESTful interface for management and an experimental demo
        command-line interface (CLI) and web interface.</t>
        <t>Ted Lemon also has produced a portable implementation of Discovery
	Proxy,
        which is available in the mDNSResponder open source code.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Partially Implemented</name>
        <t>At the time of writing,
        existing APIs make multiple domains visible to client software,
        but most client user interfaces lump all discovered services
        into a single flat list. This is largely a chicken-and-egg
        problem. Application writers were naturally reluctant to spend
        time writing domain-aware user interface code when few customers would
        benefit from it. If Discovery Proxy deployment becomes common, then
        application writers will have a reason to provide a better user
	experience.
        Existing applications will work with the Discovery Proxy but will
        show all services in a single flat list. Applications with
        improved user interfaces will show services grouped by domain.</t>
      </section>
    </section>
    <section numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>Thanks to <contact fullname="Markus Stenberg"/> for helping develop
      the policy
      regarding the four styles of unicast response according to what
      data is immediately available in the cache.
      Thanks to
      <contact fullname="Anders Brandt"/>,
      <contact fullname="Ben Campbell"/>,
      <contact fullname="Tim Chown"/>,
       <contact fullname="Alissa Cooper"/>,
       <contact fullname="Spencer Dawkins"/>,
       <contact fullname="Ralph Droms"/>,
       <contact fullname="Joel Halpern"/>,
       <contact fullname="Ray Hunter"/>,
       <contact fullname="Joel Jaeggli"/>,
       <contact fullname="Warren Kumari"/>,
       <contact fullname="Ted Lemon"/>,
       <contact fullname="Alexey Melnikov"/>,
       <contact fullname="Kathleen Moriarty"/>,
       <contact fullname="Tom Pusateri"/>,
       <contact fullname="Eric Rescorla"/>,
       <contact fullname="Adam Roach"/>,
       <contact fullname="David Schinazi"/>,
       <contact fullname="Markus Stenberg"/>,
       <contact fullname="Dave Thaler"/>,
      and  <contact fullname="Andrew Yourtchenko"/> for their comments.</t>
    </section>


  </back>
</rfc>
