<?xml version='1.0' encoding='utf-8'?>

<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" submissionType="IETF"
     category="std" consensus="yes" number="8680" ipr="trust200902"
     updates="6363" obsoletes="" xml:lang="en" tocInclude="true"
     symRefs="true" sortRefs="true" version="3" docName="draft-ietf-tsvwg-fecframe-ext-08">
  <!-- xml2rfc v2v3 conversion 2.34.0 -->
  <front>
    <title abbrev="FEC Framework Extension">Forward Error Correction (FEC) Framework Extension to Sliding Window Codes</title>
    <seriesInfo name="RFC" value="8680"/>
    <author fullname="Vincent Roca" initials="V" surname="Roca">
      <organization>INRIA</organization>
      <address>
        <postal>
          <street/>
          <city/>
	  <extaddr>Univ. Grenoble Alpes</extaddr>
          <country>France</country>
        </postal>
        <email>vincent.roca@inria.fr</email>
      </address>
    </author>
    <author fullname="Ali Begen" initials="A." surname="Begen">
      <organization>Networked Media</organization>
      <address>
        <postal>
          <street/>
          <city>Konya</city>
          <region/>
          <code/>
          <country>Turkey</country>
        </postal>
        <email>ali.begen@networked.media</email>
      </address>
    </author>
    <date month="January" year="2020"/>
    <workgroup>TSVWG</workgroup>
    <keyword>FEC</keyword>
    <keyword>FECFRAME</keyword>
    <keyword>packet loss recovery</keyword>
    <keyword>RLC</keyword>
    <keyword>Sliding Window FEC Codes</keyword>
    <abstract>
      <t>
RFC 6363 describes a framework for using Forward Error Correction (FEC)
codes to provide protection against packet loss. The framework
supports applying FEC to arbitrary packet flows over unreliable
transport and is primarily intended for real-time, or streaming, media.
However, FECFRAME as per RFC 6363 is restricted to block FEC codes.
This document updates RFC 6363 to support FEC codes based on a
sliding encoding window, in addition to block FEC codes, in a
backward-compatible way.
During multicast/broadcast real-time content delivery, the use of
sliding window codes significantly improves robustness in harsh
environments, with less repair traffic and lower FEC-related added latency.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <!-- ====================== -->
      <t> Many applications need to transport a continuous stream
of packetized data from a source (sender) to one or more destinations
(receivers) over networks that do not provide guaranteed packet delivery.
In particular, packets may be lost, which is strictly the focus of this
document: we assume that transmitted packets are either lost (e.g.,
because of a congested router, a poor signal-to-noise ratio in a
wireless network, or because the number of bit errors exceeds the
correction capabilities of the physical-layer error-correcting code) or
were received by the transport protocol without any corruption (i.e., the bit errors,
if any, have been fixed by the physical-layer error-correcting code and therefore
are hidden to the upper layers).
</t>
      <t>For these use cases, Forward Error Correction (FEC) applied within
the transport or application layer is an efficient
technique to improve packet transmission robustness in the presence of packet
losses (or "erasures") without going through packet retransmissions that
create a delay often incompatible with real-time constraints.
The FEC Building Block defined in <xref target="RFC5052" format="default"/> provides a
framework for the definition of Content Delivery Protocols (CDPs) 
that make use of separately defined FEC schemes. Any CDP
defined according to the requirements of the FEC Building Block can then
easily be used with any FEC scheme that is also defined according to
the requirements of the FEC Building Block.
</t>
      <t>
Then, FECFRAME <xref target="RFC6363" format="default"/> provides a framework to define
Content Delivery Protocols (CDPs) that provide FEC protection for arbitrary
packet flows over an unreliable datagram service transport, such as UDP.
It is primarily intended for real-time or streaming media applications
that are using broadcast, multicast, or on-demand delivery. A subset of
FECFRAME is currently part of the 3GPP Evolved Multimedia Broadcast/Multicast Service
(eMBMS) standard <xref target="MBMSTS"/>.
</t>

      <t>
However, <xref target="RFC6363" format="default"/> only considers block FEC schemes defined in
accordance with the FEC Building Block <xref target="RFC5052" format="default"/>
(e.g., <xref target="RFC6681" format="default"/>, <xref target="RFC6816" format="default"/>, or <xref target="RFC6865" format="default"/>).
These codes require the input flow(s) to be segmented into a sequence of blocks.
Then, FEC encoding (at a sender or an encoding middlebox) and decoding (at a receiver
or a decoding middlebox) are both performed on a per-block basis.
For instance, if the current block encompasses the 100's to 119's source symbols
(i.e., a block of size 20 symbols) of an input flow, encoding (and decoding) will
be performed on this block independently of other blocks.
This approach has major impacts on FEC encoding and decoding delays.
The data packets of continuous media flow(s) may be passed to the transport layer
immediately, without delay.
But the block creation time, which depends on the number of source symbols in
this block, impacts both the FEC encoding delay (since encoding requires that all
source symbols be known) and, mechanically, the packet loss recovery delay at a
receiver (since no repair symbol for the current block can be generated and
therefore received before that time).
Therefore, a good value for the block size is necessarily a balance between the
maximum FEC decoding latency at the receivers (which must be in line with the most
stringent real-time requirement of the protected flow(s), hence an incentive to
reduce the block size) and the desired robustness against long loss bursts (which
increases with the block size, hence an incentive to increase this size). 
</t>
      <t>
This document updates <xref target="RFC6363" format="default"/> in order to also support FEC codes
based on a sliding encoding window (a.k.a., convolutional codes) <xref target="RFC8406" format="default"/>.
This encoding window, either fixed or variable size, slides over the set of
source symbols.
FEC encoding is launched whenever needed from the set of source symbols present
in the sliding encoding window at that time.
This approach significantly reduces FEC-related latency, since repair symbols can
be generated and passed to the transport layer on the fly at any time and can be
regularly received by receivers to quickly recover packet losses.
Using sliding window FEC codes is therefore highly beneficial to real-time flows,
one of the primary targets of FECFRAME.
<xref target="RFC8681" format="default"/> provides an  example of such a FEC scheme for FECFRAME,
which is built upon the simple sliding window Random Linear Code (RLC).
</t>
      <t>
This document is fully backward compatible with <xref target="RFC6363" format="default"/>. Indeed:
</t>
      <ul spacing="normal">
        <li> This FECFRAME update does not prevent or compromise in any way the support
	of block FEC codes. Both types of codes can nicely coexist, just like different
	block FEC schemes can coexist.</li>
        <li> Each sliding window FEC scheme is associated with a specific FEC Encoding ID subject
	to IANA registration, just like block FEC schemes.</li>
        <li> Any receiver -- for instance, a legacy receiver that only supports
	block FEC schemes -- can easily identify the FEC scheme used in a FECFRAME session.
	Indeed, the FEC Encoding ID that identifies the FEC scheme is carried in
	FEC Framework Configuration Information (see <xref target="RFC6363"
	format="default" sectionFormat="of" section="5.5"/>).
	For instance, when the Session Description Protocol (SDP) is used to carry the
	FEC Framework Configuration Information, the FEC Encoding ID can be communicated
	in the "encoding-id=" parameter of a "fec-repair-flow" attribute <xref target="RFC6364" format="default"/>.
	This mechanism is the basic approach for a FECFRAME receiver to determine
	whether or not it supports the FEC scheme used in a given FECFRAME session. </li>
      </ul>
      <t>
This document leverages on <xref target="RFC6363" format="default"/> and reuses its structure.
It proposes new sections specific to sliding window FEC codes whenever required.
The only exception is <xref target="ArchitectureOverview" format="default"/>, which provides a quick
summary of FECFRAME in order to facilitate the understanding of this document to readers
not familiar with the concepts and terminology.
</t>
    </section>

    <section numbered="true" toc="default">
      <name>Terminology</name>
      <section anchor="definitionsAndAbbreviations" numbered="true" toc="default">
        <name>Definitions and Abbreviations</name>
        <!-- ====================== -->
        <t>The following list of definitions and abbreviations is copied from <xref target="RFC6363" format="default"/>,
adding only the Block FEC Code, Sliding Window FEC Code, and Encoding/Decoding Window definitions (tagged
with "ADDED"):
</t>
        <dl newline="true" spacing="normal">
          <dt>Application Data Unit (ADU):</dt>
          <dd> The unit of source data provided as
a payload to the transport layer. 
For instance, it can be a payload containing the result of the RTP packetization of a compressed video frame.
</dd>
          <dt>ADU Flow:</dt>
          <dd> A sequence of ADUs associated with a transport-layer flow
      identifier (such as the standard 5-tuple {source IP address, source
      port, destination IP address, destination port, transport
      protocol}).</dd>
          <dt>AL-FEC:</dt>
          <dd> Application-Layer Forward Error Correction.</dd>
          <dt>Application Protocol:</dt>
          <dd> Control protocol used to establish and control
      the source flow being protected, e.g., the Real-Time Streaming Protocol
      (RTSP).</dd>
          <dt>Content Delivery Protocol (CDP):</dt>
          <dd> A complete application protocol
      specification that, through the use of the framework defined in this
      document, is able to make use of FEC schemes to provide FEC
      capabilities.</dd>
          <dt>FEC Code:</dt>
          <dd> An algorithm for encoding data such that the encoded data
      flow is resilient to data loss. Note that, in general, FEC codes may also
      be used to make a data flow resilient to corruption, but that is not
      considered in this document.</dd>
          <dt>Block FEC Code: (ADDED)</dt>
          <dd> A FEC code that operates on blocks, i.e., for
which the input flow <bcp14>MUST</bcp14> be segmented into a sequence of blocks,
with FEC encoding and decoding being performed independently on a
per-block basis.</dd>
          <dt>Sliding Window FEC Code: (ADDED)</dt>
          <dd> A FEC code that can generate repair symbols
on the fly, at any time, from the set of source symbols present in the sliding
encoding window at that time.
These codes are also known as convolutional codes.</dd>
          <dt>FEC Framework:</dt>
          <dd> A protocol framework for the definition of Content
      Delivery Protocols using FEC, such as the framework defined in this
      document.</dd>
          <dt>FEC Framework Configuration Information:</dt>
          <dd> Information that controls
      the operation of the FEC Framework.</dd>
          <dt>FEC Payload ID:</dt>
          <dd> Information that identifies the contents and provides positional information of a packet
with respect to the FEC scheme.</dd>
          <dt>FEC Repair Packet:</dt>
          <dd> At a sender (respectively, at a receiver), a
      payload submitted to (respectively, received from) the transport
      protocol containing one or more repair symbols along with a Repair FEC
      Payload ID and possibly an RTP header.</dd>
          <dt>FEC Scheme:</dt>
          <dd> A specification that defines the additional protocol
      aspects required to use a particular FEC code with the FEC
      Framework.</dd>
          <dt>FEC Source Packet:</dt>
          <dd> At a sender (respectively, at a receiver), a
      payload submitted to (respectively, received from) the transport
      protocol containing an ADU along with an optional Explicit Source FEC
      Payload ID.</dd>
          <dt>Repair Flow:</dt>
          <dd> The packet flow carrying FEC data.</dd>
          <dt>Repair FEC Payload ID:</dt>
          <dd> A FEC Payload ID specifically for use with
      repair packets.</dd>
          <dt>Source Flow:</dt>
          <dd> The packet flow to which FEC protection is to be
      applied. A source flow consists of ADUs.</dd>
          <dt>Source FEC Payload ID:</dt>
          <dd> A FEC Payload ID specifically for use with
      source packets.</dd>
          <dt>Source Protocol:</dt>
          <dd> A protocol used for the source flow being protected,
      e.g., RTP.</dd>
          <dt>Transport Protocol:</dt>
          <dd> The protocol used for the transport of the source and
      repair flows. This protocol needs to provide an unreliable datagram
      service, as UDP does (<xref target="RFC6363" sectionFormat="comma" section="7"/>).
      </dd>

          <dt>Encoding Window: (ADDED)</dt>
          <dd> Set of source symbols available at the sender/coding node
      that are used (with a Sliding Window FEC code) to generate a repair symbol.</dd>
          <dt>Decoding Window: (ADDED)</dt>
          <dd> Set of received or decoded source and repair symbols available
          at a receiver that are used (with a Sliding Window FEC code) to
          decode lost source symbols.</dd>
          <dt>Code Rate:</dt>
          <dd> The ratio between the number of source symbols and the
      number of encoding symbols. By definition, the code rate is such that 0
      &lt; code rate &lt;= 1. A code rate close to 1 indicates that a small
      number of repair symbols have been produced during the encoding
      process.</dd>
          <dt>Encoding Symbol:</dt>
          <dd> Unit of data generated by the encoding process. With
      systematic codes, source symbols are part of the encoding symbols.</dd>
          <dt>Packet Erasure Channel:</dt>
          <dd> A communication path where packets are either
      lost (e.g., in our case, by a congested router, or because the number of
      transmission errors exceeds the correction capabilities of the
      physical-layer code) or received. When a packet is received, it is
      assumed that this packet is not corrupted (i.e., in our case, the bit errors,
      if any, are fixed by the physical-layer code and are therefore hidden to
      the upper layers). </dd>
          <dt>Repair Symbol:</dt>
          <dd> Encoding symbol that is not a source symbol.</dd>
          <dt>Source Block:</dt>
          <dd> Group of ADUs that are to be FEC protected as a single
      block.
This notion is restricted to Block FEC codes.</dd>
          <dt>Source Symbol:</dt>
          <dd> Unit of data used during the encoding process.</dd>
          <dt>Systematic Code:</dt>
          <dd> FEC code in which the source symbols are part of the
      encoding symbols.</dd>
        </dl>
      </section>
      <section numbered="true" toc="default">
        <name>Requirements Language</name>

        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
    "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
    interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/> <xref
    target="RFC8174"/> when, and only when, they appear in all capitals, as
    shown here.
        </t>

      </section>
    </section>
    <section anchor="ArchitectureOverview" numbered="true" toc="default">
      <name>Summary of Architecture Overview</name>
      <!-- ====================== -->
      <t>
The architecture of <xref target="RFC6363" format="default" sectionFormat="of"
section="3"/> equally applies to this
FECFRAME extension and is not repeated here.
However, this section includes a quick summary to facilitate the understanding of this
document to readers not familiar with the concepts and terminology.
</t>
      <figure anchor="fig_archi">
        <name>FECFRAME Architecture at a Sender</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
+----------------------+
|     Application      |
+----------------------+
           |
           | (1) Application Data Units (ADUs)
           |
           v
+----------------------+                           +----------------+
|    FEC Framework     |                           |                |
|                      |-------------------------->|   FEC Scheme   |
|(2) Construct source  |(3) Source Block           |                |
|    blocks            |                           |(4) FEC Encoding|
|(6) Construct FEC     |<--------------------------|                |
|    Source and Repair |                           |                |
|    Packets           |(5) Explicit Source FEC    |                |
+----------------------+    Payload IDs            +----------------+
           |                Repair FEC Payload IDs
           |                Repair symbols
           |
           |(7) FEC Source and Repair Packets
           v
+----------------------+
|  Transport Protocol  |
+----------------------+
]]></artwork>
      </figure>
      <t>
The FECFRAME architecture is illustrated in <xref target="fig_archi"
format="default"/> for a block FEC scheme from the sender's
point of view.
It shows an application generating an ADU flow (other flows from other applications may coexist).
These ADUs of variable size must be somehow mapped to source symbols of a fixed size (this fixed size
is a requirement of all FEC schemes, which comes from the way mathematical
operations are applied to the symbols' content).
This is the goal of an ADU-to-symbols mapping process that is FEC scheme specific (see below).
Once the source block is built, taking into account both the FEC scheme constraints (e.g., in terms
of maximum source block size) and the application's flow constraints (e.g., in terms of real-time constraints),
the associated source symbols are handed to the FEC scheme in order to produce an appropriate number
of repair symbols.
FEC Source Packets (containing ADUs) and FEC Repair Packets (containing one or more repair symbols each)
are then generated and sent using an appropriate transport protocol (more
precisely, <xref target="RFC6363" format="default" sectionFormat="of" section="7"/> requires a
transport protocol providing an unreliable datagram service, such as UDP).
In practice, FEC Source Packets may be passed to the transport layer as soon
as available without having to wait for
FEC encoding to take place.
In that case, a copy of the associated source symbols needs to be kept within FECFRAME for future
FEC encoding purposes.
</t>

      <t>
At a receiver (not shown), FECFRAME processing operates in a similar way,
taking as input the incoming FEC Source and Repair Packets received.  In case
of FEC Source Packet losses, the FEC decoding of the associated block may
recover all (in case of successful decoding) or a subset that is potentially empty
(if decoding fails) of the missing source symbols.  After source-symbol-to-ADU
mapping, when lost ADUs are recovered, they are then assigned to their
respective flow (see below).

ADUs are returned to the application(s), either in their initial transmission
order (in which case all ADUs received after a lost ADU will be delayed until
FEC decoding has taken place) or not (in which case each ADU is returned as
soon as it is received or recovered), depending on the application
requirements.
</t>
      <t>
FECFRAME features two subtle mechanisms whose details are FEC scheme dependent:
</t>
      <ul spacing="normal">
        <li> ADUs-to-source-symbols mapping:
		in order to manage variable size ADUs, FECFRAME and FEC schemes can use small, fixed-size
		symbols and create a mapping between ADUs and symbols.
		The mapping details are
      FEC scheme dependent and must be defined in the associated document.
      For instance, with certain FEC schemes, to each ADU, this mechanism prepends a length field (plus a flow identifier; see below) and
		pads the result to a multiple of the symbol size.
		A small ADU may be mapped to a single source symbol, while a large one may be mapped to
		multiple symbols.
		</li>


        <li> Assignment of decoded ADUs to flows in multi-flow configurations:
        when multiple flows are multiplexed over the same FECFRAME instance, a
        problem is to assign a decoded ADU to the right flow (UDP port numbers
        and IP addresses traditionally used to map incoming ADUs to flows are
        not recovered during FEC decoding).        The mapping details are FEC
	scheme dependent and must be 
      defined in the associated document. For instance, with certain FEC 
     schemes, to make it possible, at the
        FECFRAME sending instance, each ADU is prepended with a flow
        identifier (1 byte) during the ADU-to-source-symbols mapping (see
        above).  The flow identifiers are also shared between all FECFRAME
        instances as part of the FEC Framework Configuration Information.

   The ADU Information (ADUI), which includes the flow identifier, length,
   application payload, and padding, is then FEC protected.  Therefore, a
   decoded ADUI contains enough information to assign the ADU to the right
   flow. Note that a FEC scheme may also be restricted to the particular
      case of a single flow over a FECFRAME instance; that would make
      the above mechanism pointless.
		</li>
      </ul>

      <t>
A few aspects are not covered by FECFRAME, namely:
</t>
      <ul spacing="normal">
        <li> <xref target="RFC6363" format="default" sectionFormat="of"
        section="8"/> does not detail any congestion control mechanisms and
        only provides high-level normative requirements. </li>
        <li> The possibility of having feedback from receiver(s) is considered
        out of scope, although such a mechanism may exist within the
        application (e.g., through RTP Control Protocol (RTCP)
        messages). </li>
        <li> Flow adaptation at a FECFRAME sender (e.g., how to set the FEC
        code rate based on transmission conditions) is not detailed, but it
        needs to comply with the congestion control normative requirements
        (see above). </li>
      </ul>
    </section>
    <section numbered="true" toc="default">
      <name>Procedural Overview</name>
      <!-- ====================== -->
      <section anchor="generalProceduralOverview" numbered="true" toc="default">
        <name>General</name>
        <!-- ====================== -->
        <t>
The general considerations of <xref target="RFC6363"
format="default" sectionFormat="of" section="4.1"/> that
are specific to block FEC codes are not repeated here.
</t>
        <t>
With a Sliding Window FEC code, the FEC Source Packet <bcp14>MUST</bcp14>
contain information to identify the position occupied by
the ADU within the source flow in terms specific to the
FEC scheme.
This information is known as the Source FEC Payload ID, and
the FEC scheme is responsible for defining and interpreting it.
</t>
        <t>
With a Sliding Window FEC code, the FEC Repair
Packets <bcp14>MUST</bcp14> contain information that identifies the relationship
between the contained repair payloads and the original source symbols
used during encoding.
This information is known as the Repair FEC Payload ID, and
the FEC scheme is responsible for defining and interpreting it.
</t>
        <t>
The sender operation (<xref target="RFC6363" format="default" sectionFormat="comma" section="4.2"/>)
and receiver operation (<xref target="RFC6363" format="default" sectionFormat="comma" section="4.3"/>) are
both specific to block FEC codes and are therefore omitted below.
The following two sections detail similar operations for Sliding Window
FEC codes.
</t>
      </section>
      <section anchor="senderoperation-convolutional" numbered="true" toc="default">
        <name>Sender Operation with Sliding Window FEC Codes</name>
        <!-- ====================== -->
        <t>
With a Sliding Window FEC scheme, the following operations, illustrated in
<xref target="senderfigure-convolutional"/>
for the generic case (non-RTP repair flows) and in
<xref target="senderfigurertp-convolutional"/>
for the case of RTP repair flows, describe a possible way to generate compliant source and repair flows:
</t>
        <ol spacing="normal" type="1">
          <li>A new ADU is provided by the application.</li>
          <li>The FEC Framework communicates this ADU to the FEC scheme.</li>
          <li>The sliding encoding window is updated by the FEC scheme.
    The ADU-to-source-symbol mapping as well as the encoding window management details
    are both the responsibility of the FEC scheme and <bcp14>MUST</bcp14> be detailed there.
    <xref target="codingwindow-possibleManagement" format="default"/> provides non-normative hints about what
	FEC scheme designers need to consider.</li>
          <li>The Source FEC Payload ID information of the source packet is
    determined by the FEC scheme. If required by the FEC scheme, the
    Source FEC Payload ID is encoded into the Explicit Source FEC
    Payload ID field and returned to the FEC Framework.</li>
          <li>The FEC Framework constructs the FEC Source Packet according to
Figure 6 in <xref target="RFC6363" format="default"/>,
    using the Explicit Source FEC Payload ID
    provided by the FEC scheme if applicable.</li>
          <li>The FEC Source Packet is sent using normal transport-layer procedures.
    This packet is sent using
    the same ADU flow identification information as would have been
    used for the original source packet if the FEC Framework were not
    present (e.g., the source and destination addresses and UDP port numbers on the IP datagram carrying the
    source packet will be the same whether or not the FEC Framework is applied).</li>
          <li>When the FEC Framework needs to send one or several FEC Repair Packets (e.g., according
    to the target code rate), it asks the FEC scheme to create one
    or several repair packet payloads from the current sliding encoding window
    along with their Repair FEC Payload ID.</li>
          <li>The Repair FEC Payload IDs and repair packet payloads are provided back by the
    FEC scheme to the FEC Framework.</li>
          <li>The FEC Framework constructs FEC Repair Packets
    according to Figure 7 in <xref target="RFC6363" format="default"/>, 
    using the FEC Payload IDs and repair packet payloads provided by the FEC scheme.</li>
          <li>The FEC Repair Packets are sent using normal transport-layer procedures.
    The port(s) and multicast group(s) to be used for FEC Repair Packets are defined
    in the FEC Framework Configuration Information.</li>
        </ol>
        <figure anchor="senderfigure-convolutional">
          <name>Sender Operation with Sliding Window FEC Codes</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
+----------------------+
|     Application      |
+----------------------+
           |
           | (1) New Application Data Unit (ADU)
           v 
+---------------------+                           +----------------+
|    FEC Framework    |                           |   FEC Scheme   |
|                     |-------------------------->|                |
|                     | (2) New ADU               |(3) Update of   |
|                     |                           |    encoding    |
|                     |<--------------------------|    window      |
|(5) Construct FEC    | (4) Explicit Source       |                |
|    Source Packet    |     FEC Payload ID(s)     |(7) FEC         |
|                     |<--------------------------|    encoding    |
|(9) Construct FEC    | (8) Repair FEC Payload ID |                |
|    Repair Packet(s) |     + Repair symbol(s)    +----------------+
+---------------------+ 
           | 
           | (6)  FEC Source Packet 
           | (10) FEC Repair Packets
           v 
+----------------------+ 
|  Transport Protocol  |
+----------------------+ 
]]></artwork>
        </figure>
        <figure anchor="senderfigurertp-convolutional">
          <name>Sender Operation with Sliding Window FEC Codes and RTP Repair Flows</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
+----------------------+
|     Application      |
+----------------------+
           |
           | (1) New Application Data Unit (ADU)
           v 
+---------------------+                           +----------------+
|    FEC Framework    |                           |   FEC Scheme   |
|                     |-------------------------->|                |
|                     | (2) New ADU               |(3) Update of   |
|                     |                           |    encoding    |
|                     |<--------------------------|    window      |
|(5) Construct FEC    | (4) Explicit Source       |                |
|    Source Packet    |     FEC Payload ID(s)     |(7) FEC         |
|                     |<--------------------------|    encoding    |
|(9) Construct FEC    | (8) Repair FEC Payload ID |                |
|    Repair Packet(s) |     + Repair symbol(s)    +----------------+
+---------------------+
    |             |
    |(6) Source   |(10) Repair payloads
    |    packets  |
    |      + -- -- -- -- -+
    |      |     RTP      |
    |      +-- -- -- -- --+
    v             v                 
+----------------------+ 
|  Transport Protocol  |
+----------------------+ 
]]></artwork>
        </figure>
      </section>
      <section anchor="receiveroperation-convolutional" numbered="true" toc="default">
        <name>Receiver Operation with Sliding Window FEC Codes</name>
        <!-- ====================== -->
        <t>
With a Sliding Window FEC scheme, the following operations are illustrated in
<xref target="receiverfigure"/> 
for the generic case (non-RTP repair flows) and in
<xref target="receiverfigurertp"/>
for the case of RTP repair flows.
The only differences with respect to block FEC codes lie in steps (4) and (5).
Therefore, this section does not repeat the other steps of
<xref target="RFC6363" format="default" sectionFormat="of" section="4.3"/> ("Receiver Operation").
The new steps (4) and (5) are:
</t>

        <ol type="1" start="4">
          <li> The FEC scheme uses the received FEC Payload IDs (and derived
	FEC Source Payload IDs when the Explicit Source FEC Payload ID field is not used)
	to insert source and repair packets into the decoding window in the right way.
	If at least one source packet is missing and at least one repair packet
        has been received, then FEC decoding is attempted to recover the missing source payloads.
	The FEC scheme determines whether source packets have been lost and whether
	enough repair packets have been received to decode any or all of the missing
	source payloads.</li>

          <li> The FEC scheme returns the received and decoded ADUs to the
	FEC Framework, along with indications of any ADUs that were missing and could
	not be decoded.</li>
        </ol>

        <figure anchor="receiverfigure">
          <name>Receiver Operation with Sliding Window FEC Codes</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
+----------------------+
|     Application      |
+----------------------+
           ^
           |(6) ADUs
           |
+----------------------+                           +----------------+
|    FEC Framework     |                           |   FEC Scheme   |
|                      |<--------------------------|                |
|(2)Extract FEC Payload|(5) ADUs                   |(4) FEC Decoding|
|   IDs and pass IDs & |-------------------------->|                |
|   payloads to FEC    |(3) Explicit Source FEC    +----------------+
|   scheme             |            Payload IDs
+----------------------+    Repair FEC Payload IDs
           ^                Source payloads       
           |                Repair payloads
           |(1) FEC Source
           |    and Repair Packets
+----------------------+ 
|  Transport Protocol  |
+----------------------+
]]></artwork>
        </figure>

        <figure anchor="receiverfigurertp">
          <name>Receiver Operation with Sliding Window FEC Codes and RTP Repair Flows</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
+----------------------+
|     Application      |
+----------------------+
           ^
           |(6) ADUs
           |
+----------------------+                           +----------------+
|    FEC Framework     |                           |   FEC Scheme   |
|                      |<--------------------------|                |
|(2)Extract FEC Payload|(5) ADUs                   |(4) FEC Decoding|
|   IDs and pass IDs & |-------------------------->|                |
|   payloads to FEC    |(3) Explicit Source FEC    +----------------+
|   scheme             |            Payload IDs
+----------------------+    Repair FEC Payload IDs
    ^             ^         Source payloads
    |             |         Repair payloads
    |Source pkts  |Repair payloads
    |             |
+-- |- -- -- -- -- -- -+
|RTP| | RTP Processing | 
|   | +-- -- -- --|-- -+
| +-- -- -- -- -- |--+ |
| | RTP Demux        | |
+-- -- -- -- -- -- -- -+ 
           ^
           |(1) FEC Source and Repair Packets
           |         
+----------------------+ 
|  Transport Protocol  |
+----------------------+
]]></artwork>
        </figure>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Protocol Specification</name>
      <!-- ====================== -->
      <section anchor="generalProtocolSpecification" numbered="true" toc="default">
        <name>General</name>
        <!-- ====================== -->
        <t>
This section discusses the protocol elements for the FEC Framework specific to Sliding Window FEC schemes.
The global formats of source data packets (i.e., <xref target="RFC6363" format="default"/>, Figure 6) and repair data packets (i.e., <xref target="RFC6363" format="default"/>, Figures 7 and 8) remain the same with Sliding Window FEC codes.
They are not repeated here.
</t>
      </section>
      <section anchor="config" numbered="true" toc="default">
        <name>FEC Framework Configuration Information</name>
        <!-- ====================== -->
        <t>
The FEC Framework Configuration Information considerations of <xref
target="RFC6363" format="default" sectionFormat="of" section="5.5"/> equally
apply to this FECFRAME extension and are not repeated here.
</t>
      </section>
      <section anchor="fecscheme" numbered="true" toc="default">
        <name>FEC Scheme Requirements</name>
        <!-- ====================== -->
        <t>
The FEC scheme requirements of <xref target="RFC6363" format="default"
sectionFormat="of" section="5.6"/> mostly apply to this FECFRAME extension and
are not repeated here.  An exception, though, is the "full specification of
the FEC code", item (4), which is specific to block FEC codes.  
In case of a Sliding Window FEC scheme, then the
following item (4-bis) applies:
</t>

<dl newline="true" spacing="normal" indent="4">
  <dt>4-bis.</dt>
  <dd>
    <t>A full specification of the Sliding Window FEC code.
    </t>
    <t>
      This specification <bcp14>MUST</bcp14> precisely define the
      valid FEC-Scheme-Specific Information values, the valid FEC
      Payload ID values, and the valid packet payload sizes (where "packet
      payload" refers to the space within a packet dedicated to carrying
      encoding symbols).
    </t>
    <t>
      Furthermore, given valid values of the FEC-Scheme-Specific Information, a
      valid Repair FEC Payload ID value, a valid packet payload size, and a valid
      encoding window (i.e., a set of source symbols), the specification
      <bcp14>MUST</bcp14> uniquely define the values of the encoding symbol (or
      symbols) to be included in the repair packet payload with the given Repair
      FEC Payload ID value.
            </t>
  </dd>
</dl>
        <t>
Additionally, the FEC scheme associated with a Sliding Window FEC code:
</t>
        <ul spacing="normal">
          <li> <bcp14>MUST</bcp14> define the relationships between ADUs and the associated source symbols (mapping).</li>
          <li> <bcp14>MUST</bcp14> define the management of the encoding window that slides over the set of ADUs.
		<xref target="codingwindow-possibleManagement" format="default"/> provides non-normative hints about what 
      		FEC scheme designers need to consider.</li>
          <li> <bcp14>MUST</bcp14> define the management of the decoding window.
	This usually consists of managing a system of linear equations (for a linear FEC code).</li>
        </ul>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Feedback</name>
      <!-- ====================== -->
      <t>
The discussion in <xref target="RFC6363" format="default" sectionFormat="of"
section="6"/> equally applies to this FECFRAME extension and is not repeated
here.
</t>
    </section>
    <section anchor="TransportProtocols" numbered="true" toc="default">
      <name>Transport Protocols</name>
      <!-- ====================== -->
      <t>
The discussion in <xref target="RFC6363" format="default"
sectionFormat="of" section="7"/> equally applies to this
FECFRAME extension and is not repeated here.
</t>
    </section>
    <section anchor="sec_congestion" numbered="true" toc="default">
      <name>Congestion Control</name>
      <!-- ====================== -->
      <t>
The discussion in <xref target="RFC6363" format="default"
sectionFormat="of" section="8"/> equally applies to this
FECFRAME extension and is not repeated here.
</t>
    </section>
    <section numbered="true" toc="default">
      <name>Security Considerations</name>
      <!-- ====================== -->
      <t>
This FECFRAME extension does not add any new security considerations.  All the
considerations of <xref target="RFC6363" format="default" sectionFormat="of"
section="9"/> apply to this document as well.  However, for the sake of
completeness, the following goal can be added to the list provided in <xref
target="RFC6363" format="default" sectionFormat="of" section="9.1"/> ("Problem
Statement"):
</t>
      <ul spacing="normal">
        <li> Attacks can try to corrupt source flows in order to modify the receiver application's behavior
	(as opposed to just denying service).</li>
      </ul>
    </section>
    <section numbered="true" toc="default">
      <name>Operations and Management Considerations</name>
      <!-- ====================== -->
      <t>
This FECFRAME extension does not add any new Operations and Management Considerations.
All the considerations of <xref target="RFC6363" format="default" sectionFormat="of" section="10"/> apply to this document as well.
</t>
    </section>
    <section anchor="iana" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <!-- ====================== -->
      <t>
This document has no IANA actions.
</t>
      <t>A FEC scheme for use with this FEC Framework is identified via its FEC Encoding ID.
It is subject to IANA registration in the "FEC Framework (FECFRAME) FEC Encoding IDs" registry.
All the rules of <xref target="RFC6363" format="default" sectionFormat="of" section="11" /> apply and are not repeated here.
</t>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6363.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5052.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6364.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6681.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6816.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6865.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8406.xml"/>

      <reference anchor="MBMSTS" target="http://ftp.3gpp.org/specs/html-info/26346.htm">
        <front>
          <title>Multimedia Broadcast/Multicast Service (MBMS); Protocols and codecs</title>
          <seriesInfo name="3GPP TS" value="26.346" />
          <author>
            <organization>3GPP</organization>
          </author>
          <date month="March" year="2009" />
        </front>
      </reference>

      <reference anchor="RFC8681" target="https://www.rfc-editor.org/info/rfc8681">
	  <front>
	    <title>Sliding Window Random Linear Code (RLC) Forward Erasure Correction
	    (FEC) Schemes for FECFRAME</title>
	    <seriesInfo name="RFC" value="8681"/>
	    <seriesInfo name="DOI" value="10.17487/RFC8681"/>
            <author initials="V" surname="Roca" fullname="Vincent Roca">
              <organization/>
            </author>
            <author initials="B" surname="Teibi" fullname="Belkacem Teibi">
              <organization/>
            </author>
	    <date month='January' year='2020'/>
	  </front>
	</reference>

      </references>
    </references>

    <section anchor="codingwindow-possibleManagement" numbered="true" toc="default">
      <name>About Sliding Encoding Window Management (Informational)</name>
      <!-- ====================== -->
      <t>
The FEC Framework does not specify the management of the sliding encoding window, which is the responsibility of the FEC scheme.
This annex only provides a few informational hints.
</t>


      <t>
   Source symbols are added to the sliding encoding window each time a
   new ADU is available at the sender after the ADU-to-source-symbol
   mapping specific to the FEC scheme has been done.
</t>
      <t>
Source symbols are removed from the sliding encoding window. For instance:
      </t>
      <ul spacing="normal">
        <li> After a certain delay, when an "old" ADU of a real-time flow times out.
		The source symbol retention delay in the sliding encoding window should therefore be initialized according to the real-time features of incoming flow(s) when applicable. </li>
        <li> Once the sliding encoding window has reached its maximum size (there is usually an upper limit to the sliding encoding window size).
		In that case, the oldest symbol is removed each time a new source symbol is added. </li>
      </ul>
      <t>
Several considerations can impact the management of this sliding encoding window:
</t>
      <ul spacing="normal">
        <li> At the source flows level: real-time constraints can limit the
	total time during which source symbols can remain in the encoding window. </li>
        <li> At the FEC code level: theoretical or practical limitations (e.g., because of computational complexity) can limit the number of source symbols in the encoding window. </li>
        <li> At the FEC scheme level: signaling and window management are intrinsically related.
		For instance, an encoding window composed of a nonsequential set of source symbols requires appropriate signaling to inform a receiver of the composition of the encoding window, and the associated transmission overhead can limit the maximum encoding window size.
		On the contrary, an encoding window always composed of a sequential set of source symbols simplifies signaling: providing the identity of the first source symbol plus its number is sufficient, which creates a fixed and relatively small transmission overhead.
	</li>
      </ul>
    </section>
    <section numbered="false" toc="default">
      <name>Acknowledgments</name>
      <!-- ====================== -->
      <t>
The authors would like to thank Christer Holmberg, David Black, Gorry
Fairhurst, Emmanuel Lochin, Spencer Dawkins, Ben Campbell, Benjamin Kaduk,
Eric Rescorla, Adam Roach, and Greg Skinner for their valuable feedback on
this document.  This document being an extension of <xref target="RFC6363"
format="default"/>, the authors would also like to thank Mark Watson as the
main author of that RFC.</t>
    </section>

  </back>
</rfc>
