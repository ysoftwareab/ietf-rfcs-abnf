<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" docName="draft-ietf-core-stateless-08" number="8974" ipr="trust200902" updates="7252, 8323" obsoletes=""  submissionType="IETF"
category="std" consensus="true" xml:lang="en" sortRefs="true" symRefs="true" tocInclude="true" tocDepth="3" version="3">

  <!-- xml2rfc v2v3 conversion 3.5.0 -->
  <front>
    <title abbrev="Extended Tokens in CoAP">
      Extended&nbsp;Tokens&nbsp;and&nbsp;Stateless&nbsp;Clients
      in&nbsp;the&nbsp;Constrained&nbsp;Application&nbsp;Protocol&nbsp;(CoAP)
    </title>
    <seriesInfo name="RFC" value="8974"/>
    <author initials="K." surname="Hartke" fullname="Klaus Hartke">
      <organization>Ericsson</organization>
      <address>
        <postal>
          <street>Torshamnsgatan 23</street>
          <city>Stockholm</city>
          <code>16483</code>
          <country>Sweden</country>
        </postal>
        <email>klaus.hartke@ericsson.com</email>
      </address>
    </author>
    <author fullname="Michael C. Richardson" initials="M." surname="Richardson">
      <organization abbrev="Sandelman">Sandelman Software Works</organization>
      <address>
        <email>mcr+ietf@sandelman.ca</email>
        <uri>http://www.sandelman.ca/</uri>
      </address>
    </author>
    <date year="2021" month="January" />
    <workgroup>CoRE Working Group</workgroup>

    <keyword>6tisch</keyword>
    <keyword>minimal-security</keyword>

    <abstract>
      <t>
        This document provides considerations for alleviating Constrained Application Protocol (CoAP) clients and
        intermediaries of keeping per-request state. To facilitate this, this
        document additionally introduces a new, optional CoAP protocol extension
        for extended token lengths.
      </t>
      <t>
        This document updates RFCs 7252 and 8323 with an extended definition of the
        "TKL" field in the CoAP message header.
      </t>
    </abstract>
  </front>
  <middle>

    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>
        The Constrained Application Protocol (CoAP) <xref target="RFC7252" format="default"/> is
        a RESTful application-layer protocol for <xref target="RFC7228" format="default">constrained environments</xref>. In CoAP, clients (or
        intermediaries in the client role) make requests to servers (or
        intermediaries in the server role), which satisfy the requests by
        returning responses.
      </t>
      <t>
        While a request is ongoing, a client typically needs to keep some state that
        it requires for processing the response when that arrives. Identification
        of this state is done in CoAP by means of a token: an
        opaque sequence of bytes that is chosen by the client and included in the CoAP
        request and that is returned by the server verbatim in any resulting CoAP
        response (<xref target="stateful-exchange" format="default"/>).
      </t>
      <figure anchor="stateful-exchange">
        <name>Token as an Identifier for Request State</name>
        <artwork align="center" name="" type="" alt=""><![CDATA[
+-----------------+     request with     +------------+
|        |        |   state identifier   |            |
|        |        |       as token       |            |
|    .-<-+->------|--------------------->|------.     |
|   _|_           |                      |      |     |
|  /   \ stored   |                      |      |     |
|  \___/ state    |                      |      |     |
|    |            |                      |      |     |
|    '->-+-<------|<---------------------|------'     |
|        |        |     response with    |            |
|        v        |   token echoed back  |            |
+-----------------+                      +------------+
      Client                                 Server
]]></artwork>
      </figure>
      <t>
        In some scenarios, it can be beneficial to reduce the amount of state
        that is stored at the client at the cost of increased message sizes. A client can
        opt into this by serializing (parts of) its state into the token itself and then
        recovering this state from the token in the response (<xref target="stateless-exchange" format="default"/>).
      </t>
      <figure anchor="stateless-exchange">
        <name>Token as Serialization of Request State</name>
        <artwork align="center" name="" type="" alt=""><![CDATA[
+-----------------+     request with     +------------+
|        |        |   serialized state   |            |
|        |        |       as token       |            |
|        +--------|=====================>|------.     |
|                 |                      |      |     |
|    look ma,     |                      |      |     |
|    no state!    |                      |      |     |
|                 |                      |      |     |
|        +--------|<=====================|------'     |
|        |        |     response with    |            |
|        v        |   token echoed back  |            |
+-----------------+                      +------------+
      Client                                 Server
]]></artwork>
      </figure>
      <t>
        <xref target="stateless-clients" format="default"/> of this document provides
        considerations for clients becoming "stateless" in this way.
        (The term "stateless" is in quotes here, because it's a bit
        oversimplified. Such clients still need to maintain per-server state and other
        kinds of state. So it would be more accurate to
        just say that the clients are avoiding per-request state.)
      </t>
      <t>
        <xref target="stateless-intermediaries" format="default"/> of this document
        extends the considerations for clients to intermediaries, which
        may want to avoid keeping state for not only the requests they
        send to servers but also the requests they receive from
        clients.
      </t>
      <t>
        The serialization of state into tokens is limited by the fact
        that both <xref target="RFC7252" format="default">CoAP over UDP</xref> and <xref target="RFC8323" format="default">CoAP over reliable transports</xref> restrict
        the maximum token length to 8 bytes. To overcome this
        limitation, <xref target="extended-tokens" format="default"/> of this document
        introduces a CoAP protocol extension for extended token
        lengths.
      </t>
      <t>
         While the use case (avoiding per-request state) and the mechanism
         (extended token lengths) presented in this document are closely
         related, each can be used independently of the other.  Some
         implementations may be able to fit their state in just 8 bytes; some
         implementations may have other use cases for extended token lengths.
      </t>
      <section numbered="true" toc="default">
        <name>Terminology</name>
        <t>
          In this document, the term "stateless" refers to an implementation
          strategy for a client (or intermediary in the client role) that does
          not require it to keep state for the individual requests it sends to a
          server (or intermediary in the server role). The client still needs to
          keep state for each server it communicates with (e.g., for token
          generation, message retransmission, and congestion control).
        </t>
        <t>
	  The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
	  NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
	  "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
	  described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
	  when, and only when, they appear in all capitals, as shown here.
        </t>

      </section>
    </section>

    <section anchor="extended-tokens" numbered="true" toc="default">
      <name>Extended Tokens</name>
      <t>
        This document updates the message formats defined for <xref target="RFC7252" format="default">CoAP over UDP</xref> and <xref target="RFC8323" format="default">CoAP
        over TCP, TLS, and WebSockets</xref> with a new definition of the "TKL"
        field.
      </t>
      <section anchor="tkl-field" numbered="true" toc="default">
        <name>Extended Token Length (TKL) Field</name>
        <t>
          The definition of the "TKL" field is updated as follows:
        </t>
        <dl newline="false" spacing="normal">
          <dt>Token Length (TKL):</dt>
          <dd>
            <t>
              4-bit unsigned integer. A value between 0 and 12, inclusive,
              indicates the length of the variable-length "Token" field in bytes.
              The other three values are reserved for special constructs:
            </t>
            <dl newline="false" spacing="normal" indent="6">
              <dt>13:</dt>
              <dd>
                  An 8-bit unsigned integer directly precedes the "Token" field and
                  indicates the length of the "Token" field minus 13.
                </dd>
              <dt>14:</dt>
              <dd>
                  A 16-bit unsigned integer in network byte order directly precedes the
                  "Token" field and indicates the length of the "Token" field minus
                  269.
                </dd>
              <dt>15:</dt>
              <dd>
                  Reserved. This value <bcp14>MUST NOT</bcp14> be sent and <bcp14>MUST</bcp14> be processed as
                  a message-format error.
                </dd>
            </dl>
          </dd>
        </dl>
        <t>
          All other fields retain their definitions.
        </t>
        <t>
          The updated message formats are illustrated in <xref target="message-formats" format="default"/>.
        </t>
        <t>
          The new definition of the "TKL" field increases the maximum token length that can be represented in a
          message to 65804 bytes. However, the maximum token length that sender and
          recipient implementations support may be shorter. For example, a
          constrained node of <xref target="RFC7228" format="default">Class 1</xref> might
          support extended token lengths only up to 32 bytes.
        </t>
        <t>
          In CoAP over UDP, it is often beneficial to keep CoAP messages small
          enough to avoid IP fragmentation. The maximum practical token length
          may therefore also be influenced by the Path MTU (PMTU). See <xref target="RFC7252"
	  sectionFormat="of" section="4.6" /> for details.
        </t>
      </section>
      <section anchor="discovery" numbered="true" toc="default">
        <name>Discovering Support</name>
        <t>
          Extended token lengths require support from server implementations.
          Support can be discovered by a client implementation in one of two
          ways:
        </t>
        <ul spacing="normal">
          <li>
              Where Capabilities and Settings Messages (CSMs) are available,
              such as in CoAP over TCP, support can be discovered using the
              Extended-Token-Length Capability Option defined in <xref target="capability-option" format="default"/>.
            </li>
          <li>
              Otherwise, such as in CoAP over UDP, support can only be
              discovered by trial and error, as described in <xref target="trial-and-error" format="default"/>.
            </li>
        </ul>
        <section anchor="capability-option" numbered="true" toc="default">
          <name>Extended-Token-Length Capability Option</name>
          <t>
            A server can use the elective Extended-Token-Length Capability
            Option to indicate the maximum token length it can accept in
            requests.
          </t>
          <table anchor="capability-option-definition" align="center">
            <name>The Extended-Token-Length Capability Option</name>
            <thead>
              <tr>
                <th align="right">#</th>
                <th align="left">C</th>
                <th align="left">R</th>
                <th align="left">Applies to</th>
                <th align="left">Name</th>
                <th align="left">Format</th>
                <th align="left">Length</th>
                <th align="left">Base Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="right">6</td>
                <td align="left"/>
                <td align="left"/>
                <td align="left">CSM</td>
                <td align="left">Extended-Token-Length</td>
                <td align="left">uint</td>
                <td align="left">0-3</td>
                <td align="left">8</td>
              </tr>
            </tbody>
          </table>
          <t keepWithPrevious="true">C=Critical, R=Repeatable</t>
          <t>
            As per <xref target="RFC7252" sectionFormat="of" section="3" />, the base value (and the value used
            when this option is not implemented) is 8.
          </t>
          <t>
            The active value of the Extended-Token-Length Option is replaced
            each time the option is sent with a modified value. Its starting
            value is its base value.
          </t>
          <t>
            The option value <bcp14>MUST NOT</bcp14> be less than 8 or greater than 65804. If
            an option value less than 8 is received, the option <bcp14>MUST</bcp14> be ignored.
            If an option value greater than 65804 is received, the option value
            <bcp14>MUST</bcp14> be set to 65804.
          </t>
          <t>
            Any option value greater than 8 implies support for the new
            definition of the "TKL" field specified in <xref target="tkl-field" format="default"/>.
            Indication of support by a server does not oblige a client to
            actually make use of token lengths greater than 8.
          </t>
          <t>
            If a server receives a request with a token of a length greater than what
            it indicated in its Extended-Token-Length Option, it <bcp14>MUST</bcp14> handle the
            request as a message-format error.
          </t>
          <t>
            If a server receives a request with a token of a length less than, or
            equal to, what it indicated in its Extended-Token-Length Option but
            is unwilling or unable to handle the token at that time, it <bcp14>MUST NOT</bcp14>
            handle the request as a message-format error. Instead, it <bcp14>SHOULD</bcp14>
            return a 5.03 (Service Unavailable) response.
          </t>
          <t>
            The Extended-Token-Length Capability Option does not apply to
            responses. The sender of a request is simply expected not to use a
            token of a length greater than it is willing to accept in a
            response.
          </t>
        </section>
        <section anchor="trial-and-error" numbered="true" toc="default">
          <name>Trial and Error</name>
          <t>
            A server implementation that does not support the updated definition of the "TKL"
            field specified in <xref target="tkl-field" format="default"/> will consider a
            request with a "TKL" field value outside the range 0 to 8 to be a message-format error and reject it (<xref target="RFC7252" sectionFormat="of" section="3" />). A client can
            therefore determine support by sending a request with an extended
            token length and checking whether or not it is rejected by the server.
          </t>
          <t>
            In CoAP over UDP, the way a request message is rejected depends on the message type.
            A Confirmable message with a message-format error
            is rejected with a Reset message (<xref target="RFC7252" sectionFormat="of" section="4.2" />). A
            Non-confirmable message with a message-format error is either rejected
            with a Reset message or just silently ignored (<xref target="RFC7252" sectionFormat="of" section="4.3" />). To reliably get a Reset message, it is therefore <bcp14>REQUIRED</bcp14> that clients use a Confirmable
            message for determining support.
          </t>
          <t>
            As per RFC 7252, Reset messages are empty and do not contain a
            token; they only return the Message ID (<xref target="trial-and-error-illustration" format="default"/>). They also do not contain
            any indication of what caused a message-format error. To avoid any
            ambiguity, it is therefore <bcp14>RECOMMENDED</bcp14> that clients use a request
            that has no potential message-format error other than the extended
            token length.
          </t>
          <figure anchor="trial-and-error-illustration">
            <name>A Confirmable Request with an Extended Token Is Rejected with a Reset Message If the Server Does Not Have Support</name>
            <artwork align="center" name="" type="" alt=""><![CDATA[
+-----------------+   request message    +------------+
|        |        |    with extended     |            |
|        |        |     token length     |            |
|    .-<-+->------|--------------------->|------.     |
|   _|_           |                      |      |     |
|  /   \ stored   |                      |      |     |
|  \___/ state    |                      |      |     |
|    |            |                      |      |     |
|    '->-+-<------|<---------------------|------'     |
|        |        |     Reset message    |            |
|        v        |   with only message  |            |
+-----------------+    ID echoed back    +------------+
      Client                                 Server
]]></artwork>
          </figure>
          <t>

	    
            An example of a suitable request is a GET request in a Confirmable  message that
            includes only an If-None-Match option and a token of the greatest length
            that the client intends to use. Any response with the same token
            echoed back indicates that tokens up to that length are supported by
            the server.
          </t>
          <t>
            Since network addresses may change, a client <bcp14>SHOULD NOT</bcp14> assume that extended token
            lengths are supported by a server for an unlimited duration.
            Unless additional information is available, the client should assume that addresses (and therefore extended token lengths) are valid for a minimum of 1800 s and a maximum of 86400 s (1 day).
            A client may use additional forms of input into this determination.
            For instance, a client may assume a server that is in the same subnet as the client has a similar address lifetime as the client.
            The client may use DHCP lease times or Router Advertisements to set the limits.
            For servers that are not local, if the server was looked up using DNS, then the DNS resource record will have a Time To Live (TTL), and the extended token length should be kept for only that amount of time.
          </t>
          <t>
            If a server supports extended token lengths but receives a request
            with a token of a length it is unwilling or unable to handle, it
            <bcp14>MUST NOT</bcp14> reject the message, as that would imply that extended token
            lengths are not supported at all. Instead, if the server cannot
            handle the request at the time, it <bcp14>SHOULD</bcp14> return a 5.03 (Service
            Unavailable) response; if the server will never be able to handle the request
            (e.g., because the token is too large), it <bcp14>SHOULD</bcp14> return a 4.00 (Bad
            Request) response.
          </t>
          <aside>  
	 <t>Design Note: The requirement to return an error response when a
                token cannot be handled might seem somewhat contradictory, as
                returning the error response requires the server also to return the
                token it cannot handle. However,
                processing a request usually involves a number of steps from
                receiving the message to passing it to application logic.
                The idea is that a server implementing this extension
                supports large tokens at least in its first few processing steps, enough to
                return an error response rather than a Reset message.
              </t>
          </aside>
	      <aside>
           <t>Design Note: To prevent the trial-and-error-based discovery from becoming too complicated, no effort is made to indicate the maximum supported
                token length. A client implementation would probably
                already choose the shortest token possible for the task (such as
                being stateless, as described in <xref target="stateless-clients" format="default"/>), so it would probably not be able
                to reduce the length any further anyway should a server
                indicate a lower limit.
              </t>
          </aside>
        </section>
      </section>
      <section anchor="hop-by-hop" numbered="true" toc="default">
        <name>Intermediaries</name>
        <t>
          Tokens are a hop-by-hop feature: if there are one or more
          intermediaries between a client and a server, every token is scoped to
          the exchange between a node in the client role and the node in the
          server role that it is immediately interacting with.
        </t>
        <t>
          When an intermediary receives a request, the only requirement is that
          it echoes the token back in any resulting response. There is no
          requirement or expectation that an intermediary passes a client's
          token on to a server or that an intermediary uses extended token
          lengths itself in its request to satisfy a request with an extended
          token length. Discovery needs to be performed for each hop where extended token lengths are to be used.
        </t>
      </section>
    </section>

    <section anchor="stateless-clients" numbered="true" toc="default">
      <name>Stateless Clients</name>
      <t>
        A client can be alleviated of keeping per-request state as follows:
      </t>
      <ol spacing="normal" type="1"><li>
            The client serializes (parts of) its per-request state into
            a sequence of bytes and sends those bytes as the token of
            its request to the server.
          </li>
        <li>
            The server returns the token verbatim in the response to the
            client, which allows the client to recover the state and
            process the response as if it had kept the state locally.
          </li>
      </ol>
      <t>
        As servers are just expected to return any token verbatim to the
        client, this implementation strategy for clients does not impact the
        interoperability of client and server implementations. However,
        there are a number of significant, nonobvious implications
        (e.g., related to security and other CoAP protocol features)
        that client implementations need take into consideration.
      </t>
      <t>
        The following subsections discuss some of these considerations.
      </t>
      <section anchor="serialized-state" numbered="true" toc="default">
        <name>Serializing Client State</name>
        <t>
          The format of the serialized state is generally an
          implementation detail of the client and opaque to the server.

          However, serialized state information is an attractive target
          for both unwanted nodes (e.g., on-path attackers) and wanted
          nodes (e.g., any configured forward proxy) on the path.

          The serialization format therefore needs to include security
          measures such as the following:
        </t>
        <ul spacing="normal">
          <li>
              A client <bcp14>SHOULD</bcp14> protect the integrity of the state information
              serialized in a token.
            </li>
          <li>
              Even when the integrity of the serialized state is protected, an
              attacker may still replay a response, making the client
              believe it sent the same request twice.

              For this reason, the client <bcp14>SHOULD</bcp14> implement replay
              protection (e.g., by using sequence numbers and a replay
              window).

              For replay protection, integrity protection is <bcp14>REQUIRED</bcp14>.
            </li>
          <li>
              If processing a response without keeping request state is
              sensitive to the time elapsed since sending the request, then the
              client <bcp14>SHOULD</bcp14> include freshness information (e.g., a timestamp) in
              the serialized state and reject any response where the freshness
              information is insufficiently fresh.
            </li>
          <li>
              Information in the serialized state may be privacy
              sensitive.

              A client <bcp14>SHOULD</bcp14> encrypt the serialized state if it
              contains privacy-sensitive information that an attacker
              would not get otherwise.
            </li>
          <li>
              When a client changes the format of the serialized state,
              it <bcp14>SHOULD</bcp14> prevent false interoperability with the previous
              format (e.g., by changing the key used for integrity
              protection or changing a field in the serialized state).
            </li>
        </ul>
      </section>
      <section numbered="true" toc="default">
        <name>Using Extended Tokens</name>
        <t>
          A client that depends on
          support for extended token lengths (<xref target="extended-tokens" format="default"/>)
          from the server to avoid keeping request state needs to perform a
          discovery of support (<xref target="discovery" format="default"/>) before it can be
          stateless.
        </t>
        <t>
          This discovery <bcp14>MUST</bcp14> be performed in a stateful way, i.e.,
          keeping state for the request (<xref target="stateful-discovery" format="default"/>).
          If the client was stateless from the start, and the server does not
          support extended tokens, then no error message could be processed,
          since the state would neither be present at the client nor returned in
          the Reset message (<xref target="stateless-discovery" format="default"/>).
        </t>
        <figure anchor="stateful-discovery">
          <name>Depending on Extended Tokens for Being Stateless First Requires a Successful Stateful Discovery of Support</name>
          <artwork align="center" name="" type="" alt=""><![CDATA[
+-----------------+    dummy request     +------------+
|        |        |    with extended     |            |
|        |        |        token         |            |
|    .-<-+->------|=====================>|------.     |
|   _|_           |                      |      |     |
|  /   \ stored   |                      |      |     |
|  \___/ state    |                      |      |     |
|    |            |                      |      |     |
|    '->-+-<------|<=====================|------'     |
|        |        |     response with    |            |
|        |        |    extended token    |            |
|        |        |      echoed back     |            |
|        |        |                      |            |
|        |        |                      |            |
|        |        |     request with     |            |
|        |        |   serialized state   |            |
|        |        |       as token       |            |
|        +--------|=====================>|------.     |
|                 |                      |      |     |
|    look ma,     |                      |      |     |
|    no state!    |                      |      |     |
|                 |                      |      |     |
|        +--------|<=====================|------'     |
|        |        |     response with    |            |
|        v        |   token echoed back  |            |
+-----------------+                      +------------+
      Client                                 Server
]]></artwork>
        </figure>
        <figure anchor="stateless-discovery">
          <name>Stateless Discovery of Support Does Not Work</name>
          <artwork align="center" name="" type="" alt=""><![CDATA[
+-----------------+    dummy request     +------------+
|        |        |    with extended     |            |
|        |        |        token         |            |
|        +--------|=====================>|------.     |
|                 |                      |      |     |
|                 |                      |      |     |
|                 |                      |      |     |
|                 |                      |      |     |
|              ???|<---------------------|------'     |
|                 |     Reset message    |            |
|                 |   with only message  |            |
+-----------------+    ID echoed back    +------------+
      Client                                 Server
]]></artwork>
        </figure>
        <t>
          In environments where support can be reliably discovered through some
          other means, the discovery of support is <bcp14>OPTIONAL</bcp14>. An example for this
          is the <xref target="I-D.ietf-6tisch-minimal-security" format="default">Constrained
          Join Protocol (CoJP) in a 6TiSCH network</xref>, where support for
          extended tokens is required from all relevant parties.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Transmitting Messages</name>
        <t>
          In <xref target="RFC7252" format="default">CoAP over UDP</xref>, a client has the choice between
          Confirmable and Non-confirmable messages for requests. When using
          Non-confirmable messages, a client does not have to keep any message-exchange state, which can help in the goal of avoiding state. When using
          Confirmable messages, a client needs to keep message-exchange
          state for performing retransmissions and handling Acknowledgement and
          Reset messages, however. Non-confirmable messages are therefore better suited for avoiding state.

          In any case, a client still needs to keep congestion-control state, i.e.,
          maintain state for each node it communicates with and enforce limits
          like NSTART.
        </t>
        <t>
          As per <xref target="RFC7252" sectionFormat="of" section="5.2" />, a client must be prepared to receive a response as a
          piggybacked response, a separate response, or a Non-confirmable response,
          regardless of the message type used for the
          request. A stateless client <bcp14>MUST</bcp14> handle these response types as
          follows:
        </t>
        <ul spacing="normal">
          <li>
              If a piggybacked response passes the checks for token integrity
              and freshness (<xref target="serialized-state" format="default"/>), the client processes the message as
              specified in RFC 7252; otherwise, it processes the acknowledgement
              portion of the message as specified in RFC 7252 and silently
              discards the response portion.
            </li>
          <li>
              If a separate response passes the checks for token integrity and
              freshness, the client processes the message as specified in
              RFC 7252; otherwise, it rejects the message as specified in <xref target="RFC7252" sectionFormat="of" section="4.2" />.
            </li>
          <li>
              If a Non-confirmable response passes the checks for token
              integrity and freshness, the client processes the message
              as specified in RFC 7252; otherwise, it rejects the message as
              specified in <xref target="RFC7252" sectionFormat="of" section="4.3" />.
            </li>
        </ul>
      </section>
    </section>
    <section anchor="stateless-intermediaries" numbered="true" toc="default">
      <name>Stateless Intermediaries</name>
      <t>
        Tokens are a hop-by-hop feature. If a client makes a request to an
        intermediary, that intermediary needs to store the client's token
        (along with the client's transport address) while it makes its own
        request towards the origin server and waits for the
        response. When the intermediary receives the response, it looks up
        the client's token and transport address for the received request and
        sends an appropriate response to the client.
      </t>
      <t>
        An intermediary might want to be "stateless" not only in its role as
        a client but also in its role as a server, i.e., be
        alleviated of storing the client information for
        the requests it receives.
      </t>
      <t>
        Such an intermediary can be implemented by serializing the
        client information along with the request state into the token towards the origin server.
        When the intermediary receives the response, it can recover
        the client information from the token and use it to satisfy the client's
        request; therefore, the intermediary doesn't need to store the information itself.
      </t>
      <t>
        The following subsections discuss some considerations for this approach.
      </t>
      <section numbered="true" toc="default">
        <name>Observing Resources</name>
        <t>
          One drawback of the approach is that an intermediary, without keeping
          request state, is unable to aggregate multiple requests for the same
          target resource, which can significantly reduce efficiency. In
          particular, when clients observe <xref target="RFC7641" format="default"></xref> the
          same resource, aggregating requests is <bcp14>REQUIRED</bcp14> (<xref target="RFC7641" sectionFormat="of" section="3.1" />). This requirement cannot be satisfied without keeping request
          state.
        </t>
        <t>
          Furthermore, an intermediary that does not keep track of the clients
          observing a resource is not able to determine whether these
          clients are still interested in receiving further notifications
          (<xref target="RFC7641" sectionFormat="of" section="3.5" />) or want to cancel an observation (<xref target="RFC7641" sectionFormat="of" section="3.6" />).
        </t>
        <t>
          Therefore, an intermediary <bcp14>MUST NOT</bcp14> include an Observe Option in
          requests it sends without keeping both the request state for the requests it sends and the
          client information for the requests it receives.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Block-Wise Transfers</name>
        <t>
          When using <xref target="RFC7959" format="default">block-wise transfers</xref>, a
          server might not be able to distinguish blocks originating from
          different clients once they have been forwarded by an intermediary.
          Intermediaries need to ensure that this does not lead to inconsistent
          resource state by keeping distinct block-wise request operations on
          the same resource apart, e.g., utilizing the <xref target="I-D.ietf-core-echo-request-tag" format="default">Request-Tag Option</xref>.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Gateway Timeouts</name>
        <t>
          As per <xref target="RFC7252" sectionFormat="of" section="5.7.1" />, an intermediary is <bcp14>REQUIRED</bcp14> to
          return a 5.04 (Gateway Timeout) response if it cannot obtain a
          response within a timeout. However, if an intermediary does not keep
          the client information for the requests it receives, it cannot return
          such a response. Therefore, in this case, the gateway cannot return
          such a response and as such cannot implement such a timeout.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Extended Tokens</name>
        <t>
          A client may make use of extended token lengths in a request to an
          intermediary that wants to be "stateless". This means that such an intermediary
          may have to serialize potentially very large client information into
          its token towards the origin server. The tokens can grow even further
          when it progresses along a chain of intermediaries that all want to be
          "stateless".
        </t>
        <t>
          Intermediaries <bcp14>SHOULD</bcp14> limit the size of client information they are
          serializing into their own tokens. An intermediary can do this, for
          example, by limiting the extended token lengths it accepts from its
          clients (see <xref target="discovery" format="default"/>) or by keeping the client
          information locally when the client information exceeds the limit
          (i.e., not being "stateless").
        </t>
      </section>
    </section>

    <section anchor="security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <section numbered="true" toc="default">
        <name>Extended Tokens</name>
        <t>
          Tokens significantly larger than the 8 bytes specified in RFC 7252
          have implications -- in particular, for nodes with constrained memory size --
          that need to be mitigated. A node in the server role supporting
          extended token lengths may be vulnerable to a denial of service when
          an attacker (either on-path or a malicious client) sends large tokens
          to fill up the memory of the node. Implementations need to be prepared
          to handle such messages.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Stateless Clients and Intermediaries</name>
        <t>
          Transporting the state needed by a client to process a response as
          serialized state information in the token has several significant and
          nonobvious security and privacy implications that need to be
          mitigated; see <xref target="serialized-state" format="default"/> for recommendations.
        </t>
        <t>
          In addition to the format requirements outlined there, implementations
          need to ensure that they are not vulnerable to maliciously crafted,
          delayed, or replayed tokens.
        </t>
        <t>
          It is generally expected that the use of encryption, integrity
          protection, and replay protection for serialized state is
          appropriate.
        </t>
        <t>
          In the absence of integrity and replay protection, an on-path attacker
          or rogue server/intermediary could return a state (either one modified
          in a reply, or an unsolicited one) that could alter the internal state
          of the client.
        </t>
        <t>
          It is for this reason that at least the use of integrity protection on
          the token is always recommended.
        </t>
        <t>
          It may be that in some very specific cases, as a result of a careful
          and detailed analysis of any potential attacks, it is decided that such cryptographic protections do not add value.
          The authors of this document have not found such a use case as yet, but this
          is a local decision.
        </t>
        <t>
          It should further be emphasized that the encrypted state is created by the
          sending node and decrypted by the same node when receiving a
          response.
          The key is not shared with any other system.
          Therefore, the choice of encryption scheme and the generation of the key for
          this system is purely a local matter.
        </t>
        <t>
          When encryption is used, the use of <xref target="RFC3610" format="default">AES-CCM</xref> with a 64-bit tag is recommended,
          combined with a sequence number and a replay window.

          This choice is informed by available hardware acceleration of on
          many constrained systems.
          If a different algorithm is available accelerated on the sender,
          with similar or stronger strength, then it <bcp14>SHOULD</bcp14> be preferred.

          Where privacy of the state is not required, and encryption is not needed, <xref target="RFC6234" format="default">HMAC-SHA-256</xref>, combined with a sequence number
          and a replay window, may be used.
        </t>
        <t>
          This size of the replay window depends upon the number of
          requests that need to be outstanding.  This can be
          determined from the rate at which new ones are made and the
          expected time period during which responses are expected.
        </t>
        <t>
          For instance, given a CoAP MAX_TRANSMIT_WAIT of 93 s (<xref target="RFC7252" sectionFormat="of" section="4.8.2"/>), any request that is not answered within 93 s will
          be considered to have failed.  At a request rate of
          one request per 10 s, at most 10 (ceil(9.3)) requests can be
          outstanding at a time, and any convenient replay window larger than
          20 will work.  As replay windows are often implemented with a
          sliding window and a bit, the use of a 32-bit window would be
          sufficient.
        </t>
        <t>
          For use cases where requests are being relayed from another node,
          the request rate may be estimated by the total link capacity
          allocated for that kind of traffic.  An alternate view would
          consider how many IPv6 Neighbor Cache Entries (NCEs) the system can
          afford to allocate for this use.
        </t>
        <t>
          When using an encryption mode that depends on a nonce, such as
          AES-CCM, repeated use of the same nonce under the same key
          causes the cipher to fail catastrophically.
        </t>
        <t>
          If a nonce is ever used for more than one encryption operation with
          the same key, then the same key stream gets used to encrypt both plaintexts, and the
          confidentiality guarantees are voided. Devices with low-quality entropy
          sources -- as is typical with constrained devices, which incidentally
          happen to be a natural candidate for the stateless mechanism described
          in this document -- need to carefully pick a nonce-generation
          mechanism that provides the above uniqueness guarantee.
        </t>
        <t>
          <xref target="RFC8613"/>, Appendix B.1.1 ("Sender Sequence Number")
          provides a model for how to maintain nonrepeating nonces without
          causing excessive wear of flash memory.
        </t>
      </section>
    </section>

    <section numbered="true" toc="default">
      <name>IANA Considerations</name>
      <section numbered="true" toc="default">
        <name>CoAP Signaling Option Number</name>
        <t>
          The following entry has been added to the "CoAP Signaling Option Numbers"
          registry within the "CoRE Parameters" registry.
        </t>
        <table align="center">
	  <name>CoAP Signaling Option Number</name>
          <thead>
            <tr>
              <th align="left">Applies to</th>
              <th align="right">Number</th>
              <th align="left">Name</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">7.01</td>
              <td align="right">6</td>
              <td align="left">Extended-Token-Length</td>
              <td align="left">RFC 8974</td>
            </tr>
          </tbody>
        </table>
        <t>
        </t>
      </section>
    </section>

  </middle>
  <back>

<displayreference target="I-D.ietf-core-echo-request-tag" to="ECHO-REQUEST-TAG"/>
<displayreference target="I-D.ietf-6tisch-minimal-security" to="6TISCH-MIN-SEC"/>


    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7252.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7641.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7959.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8323.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3610.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6234.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7228.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8613.xml"/>

        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-core-echo-request-tag.xml"/>

        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-6tisch-minimal-security.xml"/>
      </references>
    </references>

    <section anchor="message-formats" numbered="true" toc="default">
      <name>Updated Message Formats</name>
      <t>
        In <xref target="extended-tokens" format="default"/>, this document updates the
        CoAP message formats by specifying a new definition of the "TKL"
        field in the message header. As an alternative presentation of
        this update, this appendix shows the CoAP message formats for
        <xref target="RFC7252" format="default">CoAP over UDP</xref> and <xref target="RFC8323" format="default">CoAP over TCP, TLS, and WebSockets</xref> with
        the new definition applied.
      </t>
      <section numbered="true" toc="default">
        <name>CoAP over UDP</name>
        <artwork align="center" name="" type="" alt=""><![CDATA[
                0   1   2   3   4   5   6   7
              +-------+-------+---------------+
              |       |       |               |
              |  Ver  |   T   |      TKL      |   1 byte
              |       |       |               |
              +-------+-------+---------------+
              |                               |
              |             Code              |   1 byte
              |                               |
              +-------------------------------+
              |                               |
              |                               |
              |                               |
              +-         Message ID          -+   2 bytes
              |                               |
              |                               |
              |                               |
              +-------------------------------+
              \                               \
              /              TKL              /   0-2 bytes
              \          (extended)           \
              +-------------------------------+
              \                               \
              /             Token             /   0-65804 bytes
              \                               \
              +-------------------------------+
              \                               \
              /                               /
              \                               \
              /            Options            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +---------------+---------------+
              |               |               |
              |      15       |       15      |   1 byte (if payload)
              |               |               |
              +---------------+---------------+
              \                               \
              /                               /
              \                               \
              /            Payload            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +-------------------------------+
]]></artwork>
      </section>
      <section numbered="true" toc="default">
        <name>CoAP over TCP/TLS</name>
        <artwork align="center" name="" type="" alt=""><![CDATA[
                0   1   2   3   4   5   6   7
              +---------------+---------------+
              |               |               |
              |      Len      |      TKL      |   1 byte
              |               |               |
              +---------------+---------------+
              \                               \
              /              Len              /   0-4 bytes
              \          (extended)           \
              +-------------------------------+
              |                               |
              |             Code              |   1 byte
              |                               |
              +-------------------------------+
              \                               \
              /              TKL              /   0-2 bytes
              \          (extended)           \
              +-------------------------------+
              \                               \
              /             Token             /   0-65804 bytes
              \                               \
              +-------------------------------+
              \                               \
              /                               /
              \                               \
              /            Options            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +---------------+---------------+
              |               |               |
              |      15       |       15      |   1 byte (if payload)
              |               |               |
              +---------------+---------------+
              \                               \
              /                               /
              \                               \
              /            Payload            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +-------------------------------+
]]></artwork>
      </section>
      <section numbered="true" toc="default">
        <name>CoAP over WebSockets</name>
        <artwork align="center" name="" type="" alt=""><![CDATA[
                0   1   2   3   4   5   6   7
              +---------------+---------------+
              |               |               |
              |       0       |      TKL      |   1 byte
              |               |               |
              +---------------+---------------+
              |                               |
              |             Code              |   1 byte
              |                               |
              +-------------------------------+
              \                               \
              /              TKL              /   0-2 bytes
              \          (extended)           \
              +-------------------------------+
              \                               \
              /             Token             /   0-65804 bytes
              \                               \
              +-------------------------------+
              \                               \
              /                               /
              \                               \
              /            Options            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +---------------+---------------+
              |               |               |
              |      15       |       15      |   1 byte (if payload)
              |               |               |
              +---------------+---------------+
              \                               \
              /                               /
              \                               \
              /            Payload            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +-------------------------------+
]]></artwork>
      </section>
    </section>

    <section numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t>
        This document is based on the requirements of, and work on, "Constrained Join Protocol (CoJP) for 6TiSCH" (January 2020) by <contact fullname="Mališa Vučinić"/>, <contact fullname="Jonathan Simon"/>, <contact fullname="Kris Pister"/>, and
        <contact fullname="Michael Richardson"/>.
      </t>

      <t>
        Thanks to
        <contact fullname="Christian Amsüss"/>,
        <contact fullname="Carsten Bormann"/>, 
        <contact fullname="Roman Danyliw"/>, 
        <contact fullname="Christer Holmberg"/>, 
        <contact fullname="Benjamin Kaduk"/>, 
        <contact fullname="Ari Keränen"/>, 
        <contact fullname="Erik Kline"/>, 
        <contact fullname="Murray Kucherawy"/>, 
        <contact fullname="Warren Kumari"/>, 
        <contact fullname="Barry Leiba"/>, 
        <contact fullname="David Mandelberg"/>, 
        <contact fullname="Dan Romascanu"/>, 
        <contact fullname="Jim Schaad"/>, 
        <contact fullname="Göran Selander"/>, 
        <contact fullname="Mališa Vučinić"/>, 
        <contact fullname="Éric Vyncke"/>,  and
        <contact fullname="Robert Wilton"/>
        for helpful comments and discussions that have shaped the document.
      </t>
      <t>
        Special thanks to <contact fullname="John Mattsson"/> for his contributions to the security considerations of the document, and to <contact fullname="Thomas Fossati"/> for his in-depth review, copious comments, and suggested text.
      </t>
    </section>

  </back>
</rfc>
