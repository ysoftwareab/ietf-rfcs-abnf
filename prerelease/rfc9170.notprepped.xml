<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>



<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-iab-use-it-or-lose-it-04" number="9170" obsoletes="" updates="" submissionType="IAB" category="info" consensus="true" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  

  <front>
    <title abbrev="Use It or Lose It">Long-Term Viability of Protocol Extension Mechanisms</title>
    <seriesInfo name="RFC" value="9170"/>
    <author initials="M." surname="Thomson" fullname="Martin Thomson">

      <address>
        <email>mt@lowentropy.net</email>
      </address>
    </author>
    <author initials="T." surname="Pauly" fullname="Tommy Pauly">

      <address>
        <email>tpauly@apple.com</email>
      </address>
    </author>
    <date year="2021" month="December"/>

<keyword>Extensions</keyword>
<keyword>versions</keyword>
<keyword>grease</keyword>
    <abstract>
      <t>The ability to change protocols depends on exercising the extension
      and version-negotiation mechanisms that support change.  This document
      explores how regular use of new protocol features can ensure that it
      remains possible to deploy changes to a protocol. Examples are given
      where lack of use caused changes to be more difficult or costly.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>A successful protocol <xref target="RFC5218" format="default"/> needs
      to change in ways that allow it to continue to fulfill the changing
      needs of its users.  New use cases, conditions, and constraints on the
      deployment of a protocol can render a protocol that does not change
      obsolete.</t>
      <t>Usage patterns and requirements for a protocol shift over time.  In response,
implementations might adjust usage patterns within the constraints of the
protocol, the protocol could be extended, or a replacement protocol might be
developed.  Experience with Internet-scale protocol deployment shows that each
option comes with different costs.  <xref target="RFC8170" format="default"/> examines the
problem of protocol evolution more broadly.</t>
      <t>An extension point is a mechanism that allows a protocol to be changed or
enhanced.  This document examines the specific conditions that determine whether
protocol maintainers have the ability to design and deploy new or modified
protocols via their specified extension points.  <xref target="implementations" format="default"/> highlights
some historical examples of difficulties in transitions to new protocol
features.  <xref target="use-it" format="default"/> argues that ossified protocols are more difficult to
update and describes how successful protocols make frequent use of new
extensions and code points.  <xref target="other" format="default"/> outlines several additional strategies
that might aid in ensuring that protocol changes remain possible over time.</t>
      <t>The experience that informs this document is predominantly at "higher" layers of
the network stack, in protocols with limited numbers of participants.  Though
similar issues are present in many protocols that operate at scale, the
trade-offs involved with applying some of the suggested techniques can be more
complex when there are many participants, such as at the network layer or in
routing systems.</t>
    </section>
    <section anchor="implementations" numbered="true" toc="default">
      <name>Imperfect Implementations Limit Protocol Evolution</name>

      <t>It can be extremely difficult to deploy a change to a protocol if
      implementations with which the new deployment needs to interoperate do
      not operate predictably.  Variation in how new code points or extensions
      are handled can be the result of bugs in implementation or
      specifications.

      Unpredictability can manifest as errors, crashes, timeouts, abrupt
      termination of sessions, or disappearances of endpoints.

      </t>
      <t>The risk of interoperability problems can in turn make it infeasible
      to deploy certain protocol changes.  If deploying a new code point or
      extension makes an implementation less reliable than others, even if
      only in rare cases, it is far less likely that implementations will
      adopt the change.</t>
      <t>Deploying a change to a protocol could require implementations to fix
      a substantial proportion of the bugs that the change exposes.  This can
      involve a difficult process that includes identifying the cause of these
      errors, finding the responsible implementation(s), coordinating a bug
      fix and release plan, contacting users and/or the operator of affected
      services, and waiting for the fix to be deployed.</t>
      <t>Given the effort involved in fixing problems, the existence of these
      sorts of bugs can outright prevent the deployment of some types of
      protocol changes, especially for protocols involving multiple parties or
      that are considered critical infrastructure (e.g., IP, BGP, DNS, or
      TLS).  It could even be necessary to come up with a new protocol design
      that uses a different method to achieve the same result.</t>
      <t>This document only addresses cases where extensions are not deliberately
blocked.  Some deployments or implementations apply policies that explicitly
prohibit the use of unknown capabilities.  This is especially true of functions
that seek to make security guarantees, like firewalls.</t>
      <t>The set of interoperable features in a protocol is often the subset of its
features that have some value to those implementing and deploying the protocol.
It is not always the case that future extensibility is in that set.</t>
      <section anchor="not-good-enough" numbered="true" toc="default">
        <name>Good Protocol Design Is Not Itself Sufficient</name>
        <t>It is often argued that the careful design of a protocol extension
        point or version-negotiation capability is critical to the freedom
        that it ultimately offers.</t>
        <t>RFC 6709 <xref target="RFC6709" format="default"/> contains a great
        deal of well-considered advice on designing for extensions.  It
        includes the following advice:</t>

<blockquote>
<t>
  This means that, to be useful, a protocol version-negotiation mechanism
  should be simple enough that it can reasonably be assumed that all the
  implementers of the first protocol version at least managed to implement the
  version-negotiation mechanism correctly.
</t>
</blockquote>

<t>There are a number of protocols for which this has proven to be insufficient in
practice.  These protocols have imperfect implementations of these mechanisms.
Mechanisms that aren't used are the ones that fail most often.  The same
paragraph from RFC 6709 acknowledges the existence of this problem but does not
offer any remedy:</t>


<blockquote>
  <t>
    The nature of protocol version-negotiation mechanisms is that, by
    definition, they don't get widespread real-world testing until
    <strong>after</strong> the base protocol has been deployed for a while, and its
    deficiencies have become evident.
  </t>
</blockquote>

        <t>Indeed, basic interoperability is considered critical early in the deployment of
a protocol.  A desire to deploy can result in early focus on a reduced feature
set, which could result in deferring implementation of version-negotiation and
extension mechanisms.  This leads to these mechanisms being particularly
affected by this problem.</t>
      </section>
      <section anchor="disuse" numbered="true" toc="default">
        <name>Disuse Can Hide Problems</name>
        <t>There are many examples of extension points in protocols that have been either
completely unused or their use was so infrequent that they could no longer be
relied upon to function correctly.</t>
        <t><xref target="examples" format="default"/> includes examples of disuse in a number of widely deployed Internet
protocols.</t>
        <t>Even where extension points have multiple valid values, if the set
        of permitted values does not change over time, there is still a risk
        that new values are not tolerated by existing implementations.  If the
        set of values for a particular field of a protocol or the order in which these
        values appear remains fixed over a long period, some
        implementations might not correctly handle a new value when it is
        introduced.  For example, implementations of TLS broke when new values
        of the signature_algorithms extension were introduced.</t>
      </section>
      <section anchor="middleboxes" numbered="true" toc="default">
        <name>Multi-party Interactions and Middleboxes</name>
        <t>One of the key challenges in deploying new features is ensuring compatibility
with all actors that could be involved in the protocol.  Even the most
superficially simple protocols can often involve more actors than is immediately
apparent.</t>
        <t>The design of extension points needs to consider what actions middleboxes
might take in response to a protocol change as well as the effect those actions
could have on the operation of the protocol.</t>
        <t>Deployments of protocol extensions also need to consider the impact
of the changes on entities beyond protocol participants and middleboxes.
Protocol changes can affect the behavior of applications or systems
that don't directly interact with the protocol, such as when a protocol
change modifies the formatting of data delivered to an application.</t>
      </section>
    </section>
    <section anchor="use-it" numbered="true" toc="default">
      <name>Active Use</name>

      <t>The design of a protocol for extensibility and eventual replacement
      <xref target="RFC6709" format="default"/> does not guarantee the ability
      to exercise those options.  The set of features that enable future
      evolution need to be interoperable in the first implementations and
      deployments of the protocol.  Implementation of mechanisms that support
      evolution is necessary to ensure that they remain available for new
      uses, and history has shown this occurs almost exclusively through
      active mechanism use.</t>
      <t>Only by using the extension capabilities of a protocol is the
      availability of that capability assured. "Using" here includes
      specifying, implementing, and deploying capabilities that rely on the
      extension capability.  Protocols that fail to use a mechanism, or a
      protocol that only rarely uses a mechanism, could lead to that mechanism
      being unreliable.</t>
      <t>Implementations that routinely see new values are more likely to
      correctly handle new values.  More frequent changes will improve the
      likelihood that incorrect handling or intolerance is discovered and
      rectified.  The longer an intolerant implementation is deployed, the
      more difficult it is to correct.</t>
      <t>Protocols that routinely add new extensions and code points rarely
      have trouble adding additional ones especially when the handling of new
      versions or extensions are well defined.  The definition of mechanisms
      alone is insufficient; it is the assured implementation and active use
      of those mechanisms that determines their availability.</t>
      <t>What constitutes "active use" can depend greatly on the environment
      in which a protocol is deployed.  The frequency of changes necessary to
      safeguard some mechanisms might be slow enough to attract ossification
      in another protocol deployment, while being excessive in others.</t>
      <section anchor="need-it" numbered="true" toc="default">
        <name>Dependency Is Better</name>
        <t>The easiest way to guarantee that a protocol mechanism is used is
        to make the handling of it critical to an endpoint participating in
        that protocol.  This means that implementations must rely on both the
        existence of extension mechanisms and their continued, repeated
        expansion over time.</t>
        <t>For example, the message format in SMTP relies on header fields for most of its
functions, including the most basic delivery functions.  A deployment of SMTP
cannot avoid including an implementation of header field handling.  In addition
to this, the regularity with which new header fields are defined and used
ensures that deployments frequently encounter header fields that they do not yet
(and may never) understand.  An SMTP implementation therefore needs to be able
to both process header fields that it understands and ignore those that it does
not.</t>
        <t>In this way, implementing the extensibility mechanism is not merely mandated by
the specification, it is crucial to the functioning of a protocol deployment.
Should an implementation fail to correctly implement the mechanism, that failure
would quickly become apparent.</t>
        <t>Caution is advised to avoid assuming that building a dependency on an extension
mechanism is sufficient to ensure availability of that mechanism in the long
term.  If the set of possible uses is narrowly constrained and deployments do
not change over time, implementations might not see new variations or assume a
narrower interpretation of what is possible.  Those implementations might still
exhibit errors when presented with new variations.</t>
      </section>
      <section anchor="version-negotiation" numbered="true" toc="default">
        <name>Version Negotiation</name>
        <t>As noted in <xref target="not-good-enough" format="default"/>,
        protocols that provide version-negotiation mechanisms might not be
        able to test that feature until a new version is deployed.  One
        relatively successful design approach has been to use the protocol
        selection mechanisms built into a lower-layer protocol to select the
        protocol.  This could allow a version-negotiation mechanism to benefit
        from active use of the extension point by other protocols.</t>
        <t>For instance, all published versions of IP contain a version number
        as the four high bits of the first header byte.  However, version
        selection using this field proved to be unsuccessful. Ultimately,
        successful deployment of IPv6 over Ethernet <xref target="RFC2464"
        format="default"/> required a different EtherType from IPv4.  This
        change took advantage of the already diverse usage of EtherType.</t>
        <t>Other examples of this style of design include Application-Layer
        Protocol Negotiation (<xref target="RFC7301" format="default"/>) and
        HTTP content negotiation (<xref section="12" sectionFormat="of"
        target="I-D.ietf-httpbis-semantics" format="default"/>).</t>
        <t>This technique relies on the code point being usable.  For instance,
        the IP protocol number is known to be unreliable and therefore not
        suitable <xref target="NEW-PROTOCOLS" format="default"/>.</t>
      </section>
      <section anchor="grease" numbered="true" toc="default">
        <name>Falsifying Active Use</name>


	<t>"Grease" was originally defined for TLS <xref target="RFC8701"
	format="default"/> but has been adopted by other protocols such as
	QUIC <xref target="RFC9000" format="default"/>.  Grease identifies
	lack of use as an issue (protocol mechanisms "rusting" shut) and
	proposes reserving values for extensions that have no semantic value
	attached.</t>
        <t>The design in <xref target="RFC8701" format="default"/> is aimed at
        the style of negotiation most used in TLS, where one endpoint offers a
        set of options and the other chooses the one that it most prefers from
        those that it supports.  An endpoint that uses grease randomly offers
        options, usually just one, from a set of reserved values.  These
        values are guaranteed to never be assigned real meaning, so its peer
        will never have cause to genuinely select one of these values.</t>
        <t>More generally, greasing is used to refer to any attempt to
        exercise extension points without changing endpoint behavior other
        than to encourage participants to tolerate new or varying values of
        protocol elements.</t>


        <t>The principle that grease operates on is that an implementation
        that is regularly exposed to unknown values is less likely to be
        intolerant of new values when they appear.  This depends largely on
        the assumption that the difficulty of implementing the extension
        mechanism correctly is as easy or easier than implementing code to
        identify and filter out reserved values.  Reserving random or unevenly
        distributed values for this purpose is thought to further discourage
        special treatment.</t>
        <t>Without reserved greasing code points, an implementation can use
        code points from spaces used for private or experimental use if such a
        range exists.  In addition to the risk of triggering participation in
        an unwanted experiment, this can be less effective.  Incorrect
        implementations might still be able to identify these code points and
        ignore them.</t>
        <t>In addition to advertising bogus capabilities, an endpoint might
        also selectively disable noncritical protocol elements to test the
        ability of peers to handle the absence of certain capabilities.</t>
        <t>This style of defensive design is limited because it is only
        superficial.  As greasing only mimics active use of an extension
        point, it only exercises a small part of the mechanisms that support
        extensibility.  More critically, it does not easily translate to all
        forms of extension points.  For instance, highest mutually supported
        version (HMSV) negotiation cannot be greased in this fashion.  Other
        techniques might be necessary for protocols that don't rely on the
        particular style of exchange that is predominant in TLS.</t>
        <t>Grease is deployed with the intent of quickly revealing errors in implementing
the mechanisms it safeguards.  Though it has been effective at revealing
problems in some cases with TLS, the efficacy of greasing isn't proven more
generally.  Where implementations are able to tolerate a non-zero error rate in
their operation, greasing offers a potential option for safeguarding future
extensibility.  However, this relies on there being a sufficient proportion of
participants that are willing to invest the effort and tolerate the risk of
interoperability failures.</t>
      </section>


      <section anchor="ex-active" numbered="true" toc="default">
        <name>Examples of Active Use</name>
        <t>Header fields in email <xref target="RFC5321" format="default"/>,
        HTTP <xref target="I-D.ietf-httpbis-semantics" format="default"/>, and SIP <xref
        target="RFC3261" format="default"/> all derive from the same basic
        design, which amounts to a list of name/value pairs.  There is no
        evidence of significant barriers to deploying header fields with new
        names and semantics in email and HTTP as clients and servers generally
        ignore headers they do not understand or need.  The widespread
        deployment of SIP back-to-back user agents (B2BUAs), which generally
        do not ignore unknown fields, means that new SIP header fields do not
        reliably reach peers.  This does not necessarily cause
        interoperability issues in SIP but rather causes features to remain
        unavailable until the B2BUA is updated.  All three protocols are still
        able to deploy new features reliably, but SIP features are deployed
        more slowly due to the larger number of active participants that need
        to support new features.</t>
        <t>As another example, the attribute-value pairs (AVPs) in Diameter
<xref target="RFC6733" format="default"/> are fundamental to the design of the protocol.  Any use of
Diameter requires exercising the ability to add new AVPs.  This is routinely
done without fear that the new feature might not be successfully deployed.</t>
        <t>These examples show extension points that are heavily used are also being
relatively unaffected by deployment issues preventing addition of new values
for new use cases.</t>
        <t>These examples show that a good design is not required for success.  On the
contrary, success is often despite shortcomings in the design.  For instance,
the shortcomings of HTTP header fields are significant enough that there are
ongoing efforts to improve the syntax <xref target="RFC8941" format="default"/>.</t>
      </section>
      <section anchor="restoring-active-use" numbered="true" toc="default">
        <name>Restoring Active Use</name>
        <t>With enough effort, active use can be used to restore capabilities.</t>
        <t>Extension Mechanisms for DNS (<xref target="RFC6891"
        format="default"/>) was defined to provide extensibility in DNS.
        Intolerance of the extension in DNS servers resulted in a fallback
        method being widely deployed (see <xref section="6.2.2"
        sectionFormat="of" target="RFC6891" format="default"/>).  This
        fallback resulted in EDNS being disabled for affected servers.  Over
        time, greater support for EDNS and increased reliance on it for
        different features motivated a flag day <xref target="DNSFLAGDAY"
        format="default"/> where the workaround was removed.</t>
        <t>The EDNS example shows that effort can be used to restore capabilities.  This is
in part because EDNS was actively used with most resolvers and servers.  It was
therefore possible to force a change to ensure that extension capabilities would
always be available.  However, this required an enormous coordination effort.  A
small number of incompatible servers and the names they serve also became
inaccessible to most clients.</t>
      </section>
    </section>
    <section anchor="other" numbered="true" toc="default">
      <name>Complementary Techniques</name>
      <t>The protections to protocol evolution that come from <xref target="use-it" format="default">active use</xref> can
be improved through the use of other defensive techniques. The techniques listed
here might not prevent ossification on their own, but they can make active use more
effective.</t>


<section anchor="fewer-extension-points" numbered="true" toc="default">
        <name>Fewer Extension Points</name>
        <t>A successful protocol will include many potential types of
        extensions.  Designing multiple types of extension mechanisms, each
        suited to a specific purpose, might leave some extension points less
        heavily used than others.</t>
        <t>Disuse of a specialized extension point might render it unusable.
        In contrast, having a smaller number of extension points with wide
        applicability could improve the use of those extension points.  Use of
        a shared extension point for any purpose can protect rarer or more
        specialized uses.</t>
        <t>Both extensions and core protocol elements use the same extension
        points in protocols like HTTP <xref target="I-D.ietf-httpbis-semantics"
        format="default"/> and DIAMETER <xref target="RFC6733"
        format="default"/>; see <xref target="ex-active"
        format="default"/>.</t>
      </section>
      <section anchor="invariants" numbered="true" toc="default">
        <name>Invariants</name>
        <t>Documenting aspects of the protocol that cannot or will not change as extensions
or new versions are added can be a useful exercise. <xref section="2.2" sectionFormat="of" target="RFC5704" format="default"/>
defines invariants as:</t>
<blockquote>
  <t>
    Invariants are core properties that are consistent across the network and
    do not change over extremely long time-scales.
  </t>
</blockquote>
<t>Understanding what aspects of a protocol are invariant can help guide the
process of identifying those parts of the protocol that might change.
<xref target="RFC8999" format="default"/> and <xref section="9.3" sectionFormat="of" target="RFC8446" format="default"/> are both examples of
documented invariants.</t>
        <t>As a means of protecting extensibility, a declaration of protocol
        invariants is useful only to the extent that protocol participants are
        willing to allow new uses for the protocol.  A protocol that declares
        protocol invariants relies on implementations understanding and
        respecting those invariants.  If active use is not possible for all
        non-invariant parts of the protocol, greasing (<xref target="grease"
        format="default"/>) might be used to improve the chance that
        invariants are respected.</t>
        <t>Protocol invariants need to be clearly and concisely documented.
        Including examples of aspects of the protocol that are not invariant,
        such as <xref target="RFC8999" section="A" format="default"/>, can be
        used to clarify intent.</t>
      </section>
      <section anchor="limiting-participation" numbered="true" toc="default">
        <name>Limiting Participation</name>
        <t>Reducing the number of entities that can participate in a protocol
        or limiting the extent of participation can reduce the number of
        entities that might affect extensibility.  Using TLS or other
        cryptographic tools can therefore reduce the number of entities that
        can influence whether new features are usable.</t>
        <t><xref target="RFC8558" format="default"/> also recommends the use
        of encryption and integrity protection to limit participation.  For
        example, encryption is used by the QUIC protocol <xref
        target="RFC9000" format="default"/> to limit the information that is
        available to middleboxes and integrity protection prevents
        modification.</t>
      </section>
      <section anchor="effective-feedback" numbered="true" toc="default">
        <name>Effective Feedback</name>
        <t>While not a direct means of protecting extensibility mechanisms,
        feedback systems can be important to discovering problems.</t>
        <t>The visibility of errors is critical to the success of techniques like
        grease (see <xref target="grease" format="default"/>).  The grease
        design is most effective if a deployment has a means of detecting and
        reporting errors.  Ignoring errors could allow problems to become
        entrenched.</t>
        <t>Feedback on errors is more important during the development and
        early deployment of a change.  It might also be helpful to disable
        automatic error recovery methods during development.</t>
        <t>Automated feedback systems are important for automated systems, or
        where error recovery is also automated.  For instance, connection
        failures with HTTP alternative services <xref target="RFC7838"
        format="default"/> are not permitted to affect the outcome of
        transactions.  An automated feedback system for capturing failures in
        alternative services is therefore necessary for failures to be
        detected.</t>
        <t>How errors are gathered and reported will depend greatly on the
        nature of the protocol deployment and the entity that receives the
        report.  For instance, end users, developers, and network operations
        each have different requirements for how error reports are created,
        managed, and acted upon.</t>
        <t>Automated delivery of error reports can be critical for rectifying
        deployment errors as early as possible, as seen in <xref
        target="RFC7489" format="default"/> and <xref target="RFC8460"
        format="default"/>.</t>
      </section>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>Many of the problems identified in this document are not the result
      of deliberate actions by an adversary but more the result of mistakes,
      decisions made without sufficient context, or simple neglect, i.e.,
      problems therefore not the result of opposition by an adversary.  In
      response, the recommended measures generally assume that other protocol
      participants will not take deliberate action to prevent protocol
      evolution.</t>
      <t>The use of cryptographic techniques to exclude potential participants is the
only strong measure that the document recommends.  However, authorized protocol
peers are most often responsible for the identified problems, which can mean
that cryptography is insufficient to exclude them.</t>
      <t>The ability to design, implement, and deploy new protocol mechanisms can be
critical to security.  In particular, it is important to be able to replace
cryptographic algorithms over time <xref target="RFC7696" format="default"/>.  For example,
preparing for the replacement of weak hash algorithms was made more difficult
through misuse <xref target="HASH" format="default"/>.</t>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This document has no IANA actions.</t>
    </section>
  </middle>
  <back>

<displayreference target="I-D.ietf-httpbis-semantics" to="HTTP"/>
<displayreference target="I-D.ietf-httpbis-messaging" to="HTTP11"/>
<displayreference target="RFC5218" to="SUCCESS"/>
<displayreference target="RFC8170" to="TRANSITIONS"/>
<displayreference target="RFC6709" to="EXTENSIBILITY"/>
<displayreference target="RFC7301" to="ALPN"/>
<displayreference target="RFC8701" to="GREASE"/>
<displayreference target="RFC9000" to="QUIC"/>
<displayreference target="RFC5321" to="SMTP"/>
<displayreference target="RFC3261" to="SIP"/>
<displayreference target="RFC6733" to="DIAMETER"/>
<displayreference target="RFC8941" to="HTTP-HEADERS"/>
<displayreference target="RFC6891" to="EDNS"/>
<displayreference target="RFC8999" to="QUIC-INVARIANTS"/>
<displayreference target="RFC8558" to="PATH-SIGNALS"/>
<displayreference target="RFC7838" to="ALT-SVC"/>
<displayreference target="RFC7489" to="DMARC"/>
<displayreference target="RFC8460" to="SMTP-TLS-REPORTING"/>
<displayreference target="RFC7696" to="AGILITY"/>
<displayreference target="RFC7208" to="SPF"/>
<displayreference target="RFC3597" to="RRTYPE"/>
<displayreference target="RFC2113" to="RAv4"/>
<displayreference target="RFC2711" to="RAv6"/>
<displayreference target="RFC1157" to="SNMPv1"/>
<displayreference target="RFC0793" to="TCP"/>
<displayreference target="RFC8684" to="MPTCP"/>
<displayreference target="RFC7413" to="TFO"/>
<displayreference target="RFC5246" to="TLS12"/>
<displayreference target="RFC8446" to="TLS13"/>
<displayreference target="RFC6066" to="TLS-EXT"/>

    <references>
      <name>Informative References</name>



      <reference anchor="HASH" target="https://www.cs.columbia.edu/~smb/papers/new-hash.pdf">
        <front>
          <title>Deploying a New Hash Algorithm</title>
          <author initials="S." surname="Bellovin" fullname="Steven M. Bellovin">
            <organization/>
          </author>
          <author initials="E." surname="Rescorla" fullname="Eric M. Rescorla">
            <organization/>
          </author>
          <date year="2006"/>
        </front>
	<refcontent>Proceedings of NDSS</refcontent>
      </reference>



      <reference anchor="SNI" target="https://mailarchive.ietf.org/arch/msg/tls/1t79gzNItZd71DwwoaqcQQ_4Yxc">
        <front>
          <title>[TLS] Accepting that other SNI name types will never work.</title>
          <author initials="A." surname="Langley" fullname="Adam Langley">
            <organization/>
          </author>
          <date year="2016" month="March"/>
        </front>
      </reference>



      <reference anchor="INTOLERANCE" target="https://mailarchive.ietf.org/arch/msg/tls/bOJ2JQc3HjAHFFWCiNTIb0JuMZc">
        <front>
          <title>Re: [TLS] Thoughts on Version Intolerance</title>
          <author initials="H." surname="Kario" fullname="Hubert Kario">
            <organization/>
          </author>
          <date year="2016" month="July"/>
        </front>
      </reference>



      <reference anchor="DNSFLAGDAY" target="https://dnsflagday.net/2019/">
        <front>
          <title>DNS Flag Day 2019</title>
          <author>
            <organization/>
          </author>
          <date year="2019" month="May"/>
        </front>
      </reference>



      <reference anchor="MPTCP-HOW-HARD" target="https://www.usenix.org/conference/nsdi12/technical-sessions/presentation/raiciu">
        <front>
          <title>How Hard Can It Be? Designing and Implementing a Deployable Multipath TCP</title>
          <author initials="C." surname="Raiciu" fullname="Costin Raiciu">
            <organization/>
          </author>
          <author initials="C." surname="Paasch" fullname="Christoph Paasch">
            <organization/>
          </author>
          <author initials="S." surname="Barre" fullname="Sebastien Barre">
            <organization/>
          </author>
          <author initials="A." surname="Ford" fullname="Alan Ford">
            <organization/>
          </author>
          <author initials="M." surname="Honda" fullname="Michio Honda">
            <organization/>
          </author>
          <author initials="F." surname="Duchene" fullname="Fabien Duchene">
            <organization/>
          </author>
          <author initials="O." surname="Bonaventure" fullname="Olivier Bonaventure">
            <organization/>
          </author>
          <author initials="M." surname="Handley" fullname="Mark Handley">
            <organization/>
          </author>
          <date year="2012" month="April"/>
        </front>
      </reference>



<reference anchor='I-D.ietf-httpbis-semantics'>
<front>
<title>HTTP Semantics</title>
<author initials='R' surname='Fielding' fullname='Roy Fielding' role="editor">
<organization />
</author>
<author initials='M' surname='Nottingham' fullname='Mark Nottingham' role="editor">
<organization />
</author>
<author initials='J' surname='Reschke' fullname='Julian Reschke' role="editor">
<organization />
</author>
<date year='2021' month='September' />

</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-semantics-19'/>

</reference>


<reference anchor='I-D.ietf-httpbis-messaging'>
<front>
<title>HTTP/1.1</title>
<author initials='R' surname='Fielding' fullname='Roy Fielding' role="editor"/>
<author initials='M' surname='Nottingham' fullname='Mark Nottingham' role="editor"/>
<author initials='J' surname='Reschke' fullname='Julian Reschke' role="editor"/>
<date year='2021' month='September'/>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-messaging-19'/>
</reference>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5704.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5218.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8170.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6709.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2464.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7301.xml"/>


      <reference anchor="NEW-PROTOCOLS">
        <front>
          <title>On the usability of transport protocols other than TCP: A home gateway and internet path traversal study</title>
          <author fullname="Runa Barik" initials="R." surname="Barik">
            <organization/>
          </author>
          <author fullname="Michael Welzl" initials="M." surname="Welzl">
            <organization/>
          </author>
          <author fullname="Gorry Fairhurst" initials="G." surname="Fairhurst">
            <organization/>
          </author>
          <author fullname="Ahmed Elmokashfi" initials="A." surname="Elmokashfi">
            <organization/>
          </author>
          <author fullname="Thomas Dreibholz" initials="T." surname="Dreibholz">
            <organization/>
          </author>
          <author fullname="Stein Gjessing" initials="S." surname="Gjessing">
            <organization/>
          </author>
          <date month="May" year="2020"/>
        </front>
        <refcontent>Computer Networks, Vol. 173, pp. 107211</refcontent>
        <seriesInfo name="DOI" value="10.1016/j.comnet.2020.107211"/>
      </reference>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8701.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9000.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5321.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3261.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6733.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8941.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6891.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8999.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8558.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7838.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7489.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8460.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7696.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7208.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3597.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1112.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0791.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2113.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2711.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1157.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0793.xml"/>

 
      <reference anchor="EXT-TCP">
        <front>
          <title>Is it still possible to extend TCP?</title>
          <author fullname="Michio Honda" initials="M." surname="Honda">
            <organization/>
          </author>
          <author fullname="Yoshifumi Nishida" initials="Y." surname="Nishida">
            <organization/>
          </author>
          <author fullname="Costin Raiciu" initials="C." surname="Raiciu">
            <organization/>
          </author>
          <author fullname="Adam Greenhalgh" initials="A." surname="Greenhalgh">
            <organization/>
          </author>
          <author fullname="Mark Handley" initials="M." surname="Handley">
            <organization/>
          </author>
          <author fullname="Hideyuki Tokuda" initials="H." surname="Tokuda">
            <organization/>
          </author>
          <date month="November" year="2011"/>

	</front>
        <refcontent>IMC '11: Proceedings of the 2011 ACM SIGCOMM conference on Internet measurement conference</refcontent>

        <seriesInfo name="DOI" value="10.1145/2068816.2068834"/>
      </reference>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8684.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7413.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6066.xml"/>

    </references>
    <section anchor="examples" numbered="true" toc="default">
      <name>Examples</name>
      <t>This appendix contains a brief study of problems in a range of
      Internet protocols at different layers of the stack.</t>
      <section anchor="dns" numbered="true" toc="default">
        <name>DNS</name>

        <t>Ossified DNS code bases and systems resulted in new Resource Record
        Codes (RRCodes) being unusable. A new code point would take years of
        coordination between implementations and deployments before it could
        be relied upon.

	Consequently, use of the TXT record was overloaded in order to avoid
	the effort and delays involved in allocating new code points; this
	approach was used in the Sender Policy Framework <xref
	target="RFC7208" format="default"/> and other protocols.
        
	</t>
        <t>It was not until after the standard mechanism for dealing with new
        RRCodes <xref target="RFC3597" format="default"/> was considered
        widely deployed that new RRCodes could be safely created and used.</t>
      </section>
      <section anchor="HTTP" numbered="true" toc="default">
        <name>HTTP</name>
        <t>HTTP has a number of very effective extension points in addition to
        the aforementioned header fields.  It also has some examples of
        extension points that are so rarely used that it is possible that they
        are not at all usable.</t>
        <t>Extension points in HTTP that might be unwise to use include the
        extension point on each chunk in the chunked transfer coding (<xref
        section="7.1" sectionFormat="of" target="I-D.ietf-httpbis-messaging" format="default"/>),
        the ability to use transfer codings other than the chunked coding, and
        the range unit in a range request (<xref section="14"
        sectionFormat="of" target="I-D.ietf-httpbis-semantics" format="default"/>).</t>
      </section>
      <section anchor="ip" numbered="true" toc="default">
        <name>IP</name>
        <t>The version field in IP was rendered useless when encapsulated over
        Ethernet, requiring a new EtherType with IPv6 <xref target="RFC2464"
        format="default"/>, due in part to Layer 2 devices making
        version-independent assumptions about the structure of the IPv4
        header.</t>
        <t>Protocol identifiers or code points that are reserved for future use
        can be especially problematic.  Reserving values without attributing
        semantics to their use can result in diverse or conflicting semantics
        being attributed without any hope of interoperability.

	An example of this is the 224/3 address space in IPv4 that <xref
	target="RFC0791"/> reserved without assigning any semantics. <xref
	target="RFC1112"/> partially reclaimed that reserved address space for
	use in multicast (224/4), but the remaining address space (240/4) has
	not been successfully reclaimed for any purpose.

	</t>

        <t>For protocols that can use negotiation to attribute semantics to
        values, it is possible that unused code points can be reclaimed for
        active use, though this requires that the negotiation include all
        protocol participants.  For something as fundamental as addressing,
        negotiation is difficult or even impossible, as all nodes on the
        network path plus potential alternative paths would need to be
        involved.</t>
        <t>IP Router Alerts <xref target="RFC2113" format="default"/><xref
        target="RFC2711" format="default"/> use IP options or extension
        headers to indicate that data is intended for consumption by the next-hop 
        router rather than the addressed destination.  In part, the
        deployment of router alerts was unsuccessful due to the realities of
        processing IP packets at line rates, combined with bad assumptions in
        the protocol design about these performance constraints.  However,
        this was not exclusively down to design problems or bugs, as the
        capability was also deliberately blocked at some routers.</t>
      </section>
      <section anchor="snmp" numbered="true" toc="default">
        <name>SNMP</name>
        <t>As a counter example, the first version of the Simple Network Management
Protocol (SNMP) <xref target="RFC1157" format="default"/> states that unparseable or unauthenticated
messages are simply discarded without response:</t>
<blockquote>
            <t>It then verifies the version number of the SNMP message. If
            there is a mismatch, it discards the datagram and performs no
            further actions.</t>
</blockquote>
        <t>When SNMP versions 2, 2c, and 3 came along, older agents did exactly
        what the protocol specifies.  Deployment of new versions was likely
        successful because the handling of newer versions was both clear and
        simple.</t>
      </section>
      <section anchor="tcp" numbered="true" toc="default">
        <name>TCP</name>
        <t>Extension points in TCP <xref target="RFC0793" format="default"/>
        have been rendered difficult to use largely due to middlebox
        interactions; see <xref target="EXT-TCP" format="default"/>.</t>

<t>
For instance, multipath TCP (<xref target="RFC8684" format="default"/>) can
only be deployed opportunistically; see <xref target="MPTCP-HOW-HARD"
format="default"/>. Since MPTCP is a protocol enhancement that doesn’t impair
the connection if it is blocked, network path intolerance of the extension
only results in the multipath functionality becoming unavailable.


</t>
        <t>In comparison, the deployment of TCP Fast Open (<xref
        target="RFC7413" format="default"/>) critically depends on extension
        capability being widely available.  Though very few network paths were
        intolerant of the extension in absolute terms, TCP Fast Open could not
        be deployed as a result.</t>
      </section>
      <section anchor="tls" numbered="true" toc="default">
        <name>TLS</name>
        <t>Transport Layer Security (TLS) <xref target="RFC5246" format="default"/> provides examples of where a
design that is objectively sound fails when incorrectly implemented.  TLS
provides examples of failures in protocol version negotiation and extensibility.</t>
        <t>Version negotiation in TLS 1.2 and earlier uses the "Highest mutually supported
version (HMSV)" scheme exactly as it is described in <xref target="RFC6709" format="default"/>.
However, clients are unable to advertise a new version without causing a
non-trivial proportion of sessions to fail due to bugs in server and middlebox
implementations.</t>
        <t>Intolerance to new TLS versions is so severe <xref target="INTOLERANCE" format="default"/> that TLS 1.3
<xref target="RFC8446" format="default"/> abandoned HMSV version negotiation for a new mechanism.</t>
        <t>The server name indication (SNI) <xref target="RFC6066" format="default"/> in TLS is another
excellent example of the failure of a well-designed extensibility point.  SNI
uses the same technique for extensions that is used successfully in other parts
of the TLS protocol.  The original design of SNI anticipated the ability to
include multiple names of different types.</t>
        <t>SNI was originally defined with just one type of name: a domain name.  No other
type has ever been standardized, though several have been proposed.  Despite an
otherwise exemplary design, SNI is so inconsistently implemented that any hope
for using the extension point it defines has been abandoned <xref target="SNI" format="default"/>.</t>
      </section>
    </section>

    <section numbered="false">
      <name>IAB Members at the Time of Approval
      </name>
      <t>
	Internet Architecture Board members at the time this document was
	approved for publication were:
      </t>
 <ul empty="true" spacing="compact" bare="false">
        <li >
          <t><contact fullname="Jari Arkko"/></t>
        </li>
        <li >
          <t><contact fullname="Deborah Brungard"/></t>
        </li>
        <li>
          <t><contact fullname="Ben Campbell"/></t>
        </li>
        <li >
          <t><contact fullname="Lars Eggert"/></t>
        </li>
        <li>
          <t><contact fullname="Wes Hardaker"/></t>
        </li>
        <li >
          <t><contact fullname="Cullen Jennings"/></t>
        </li>
        <li>
          <t><contact fullname="Mirja Kühlewind"/></t>
        </li>
        <li >
          <t><contact fullname="Zhenbin Li"/></t>
        </li>
        <li>
          <t><contact fullname="Jared Mauch"/></t>
        </li>
        <li >
          <t><contact fullname="Tommy Pauly"/></t>
        </li>
        <li >
          <t><contact fullname="David Schinazi"/></t>
        </li>
        <li>
          <t><contact fullname="Russ White"/></t>
        </li>
        <li >
          <t><contact fullname="Jiankang Yao"/></t>
        </li>
      </ul>
      
</section>
    <section numbered="false" anchor="acknowledgments" toc="default">
      <name>Acknowledgments</name>
      <t><contact fullname="Toerless Eckert"/>, <contact fullname="Wes Hardaker"/>, <contact fullname="Mirja Kühlewind"/>, <contact fullname="Eliot Lear"/>, <contact fullname="Mark Nottingham"/>, and
<contact fullname="Brian Trammell"/> made significant contributions to this document.</t>
    </section>

  </back>

</rfc>
