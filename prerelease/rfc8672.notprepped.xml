<?xml version="1.0" encoding="utf-8"?>
<!-- converted to v3 (xml2rfc v2v3 conversion 2.31.0) -->
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" 
submissionType="independent" 
category="exp" 
ipr="trust200902" 
number="8672" 
docName="draft-sheffer-tls-pinning-ticket-12"
obsoletes="" 
updates="" 
xml:lang="en" 
tocInclude="true" 
sortRefs="true" 
symRefs="true" 
version="3">
  <front>
    <title abbrev="Pinning with Tickets">TLS Server Identity Pinning with Tickets</title>
    <seriesInfo name="RFC" value="8672"/>
    <author initials="Y." surname="Sheffer" fullname="Yaron Sheffer">
      <organization>Intuit</organization>
      <address>
        <email>yaronf.ietf@gmail.com</email>
      </address>
    </author>
    <author initials="D." surname="Migault" fullname="Daniel Migault">
      <organization>Ericsson</organization>
      <address>
        <email>daniel.migault@ericsson.com</email>
      </address>
    </author>
    <date month="October" year="2019"/>
    <area>General</area>
    <keyword>public-key certificates, trust-on-first-use, TOFU</keyword>

    <abstract>
      <t>Misissued public-key certificates can prevent TLS clients from appropriately
authenticating the TLS server. Several alternatives
have been proposed to detect this situation and prevent a client from establishing
a TLS session with a TLS end point authenticated with an illegitimate
public-key certificate. These mechanisms are either not
widely deployed or limited to public web browsing.</t>
      <t>This document proposes experimental extensions to TLS with opaque
pinning tickets as a way to pin the server's identity.
During an initial TLS session,
the server provides an original encrypted pinning ticket.
In subsequent TLS session establishment, upon receipt of the pinning ticket,
the server proves its ability to decrypt the pinning ticket
and thus the ownership of the pinning protection key.
The client can now safely conclude that the TLS session is established
with the same TLS server as the original TLS session.
One of the important properties of this proposal is that
no manual management actions are required.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Misissued public-key certificates can prevent TLS <xref target="RFC8446" format="default"/> clients from
appropriately authenticating the TLS server. This is a significant
risk in the context of the global public key infrastructure (PKI),
and similarly for large-scale
deployments of certificates within enterprises.</t>

      <t>This document proposes experimental extensions to TLS with opaque
pinning tickets as a way to pin the server's identity. The approach
is intended to be easy to implement and deploy, and reuses some of
the ideas behind TLS session resumption <xref target="RFC5077" format="default"/>.</t>

      <t>Ticket pinning is a second-factor server authentication method and is
not proposed as a substitute for the authentication method provided in
the TLS key exchange. More specifically, the client only uses the
pinning identity method after the TLS key exchange is successfully
completed.  In other words, the pinning identity method is only
performed over an authenticated TLS session.  Note that ticket pinning
does not pin certificate information and therefore is truly an
independent second-factor authentication.</t>
      <t>Ticket pinning is a trust-on-first-use (TOFU) mechanism, in that the
first server authentication is only based on PKI certificate validation,
but for any follow-on sessions, the client is further ensuring the
server's identity based on the server's ability to decrypt the ticket,
in addition to normal PKI certificate authentication.</t>
      <t>During initial TLS session establishment, the client requests a pinning
ticket from the server.  Upon receiving the request the server generates
a pinning secret that is expected to be unpredictable for peers other
than the client or the server.  In our case, the pinning secret is
generated from parameters exchanged during the TLS key exchange, so
client and server can generate it locally and independently. The server
constructs the pinning ticket with the necessary information to retrieve
the pinning secret.  The server then encrypts the ticket and returns the
pinning ticket to the client with an associated pinning lifetime.</t>
      <t>The pinning lifetime value indicates for how long the server promises to
retain the server-side ticket-encryption key, which allows it to
complete the protocol exchange correctly and prove its identity. The
server commitment (and ticket lifetime) is typically on the order of
weeks.</t>
      <t>Once the key exchange is completed, and the server is deemed
authenticated, the client generates locally the pinning secret and
caches the server's identifiers to index the pinning secret as well as
the pinning ticket and its associated lifetime.</t>
      <t>When the client reestablishes a new TLS session with the server, it
sends the pinning ticket to the server. Upon receiving it, the server
returns a proof of knowledge of the pinning secret.  Once the key
exchange is completed, and the server has been authenticated, the client
checks the pinning proof returned by the server using the client's
stored pinning secret. If the proof matches, the client can conclude
that the server to which it is currently connecting is, in fact, the correct
server.</t>

      <t>This document only applies to TLS 1.3.
We believe that the
idea can also be retrofitted into earlier versions of the protocol, but
this would require significant changes.
One example is that TLS 1.2 <xref target="RFC5246" format="default"/> and
earlier versions do not provide a generic facility of encrypted
handshake extensions, such as is used here to transport the ticket.</t>
      <t>The main advantages of this protocol over earlier pinning solutions 
are the following:</t>
      <ul spacing="normal">
        <li>The protocol is at the TLS level, and as a result is not restricted to
HTTP at the application level.</li>
        <li>The protocol is robust to changes in server IP address, 
certification authority (CA), and public key.  The
server is characterized by the ownership of the pinning protection key,
which is never provided to the client. Server configuration parameters
such as the CA and the public key may change without affecting the
pinning ticket protocol.</li>
        <li>Once a single parameter is configured (the ticket's lifetime), operation
is fully automated. The server administrator need not bother with the
management of backup certificates or explicit pins.</li>
        <li>For server clusters, we reuse the existing infrastructure <xref target="RFC5077" format="default"/>
where it exists.</li>
        <li>Pinning errors, presumably resulting from man-in-the-middle (MITM) attacks,
can be detected
both by the client and the server. This allows for server-side detection
of MITM attacks using large-scale analytics, and with no need to rely on
clients to explicitly report the error.</li>
      </ul>
      <t>A note on terminology: unlike other solutions in this space, we do not
do "certificate pinning" (or "public key pinning"), since the protocol
is oblivious to the server's certificate. We prefer the term "server
identity pinning" for this new solution.  In our solution, the server
proves its identity by generating a proof that it can read and decrypt
an encrypted ticket. As a result, the identity proof relies on proof of
ownership of the pinning protection key. However, this key is never
exchanged with the client or known by it, and so cannot itself be
pinned.</t>
      <section anchor="conventions-used-in-this-document" numbered="true" toc="default">
        <name>Conventions Used in This Document</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
      <section anchor="scope-of-experimentation" numbered="true" toc="default">
        <name>Scope of Experimentation</name>
        <t>This document describes an experimental extension to the TLS protocol.
This section defines constraints on this experiment and how it can yield useful information, potentially resulting in a standard.</t>
        <t>The protocol is designed so that if the server does not support it, the client and server fall back to a normal TLS exchange,
with the exception of a single PinningTicket extension being initially sent by the client.
In addition, the protocol is designed only to strengthen the validation of the server's identity ("second factor").
As a result, implementation or even protocol errors should not result in
weakened security compared to the normal TLS exchange.
Given these two points, experimentation can be run on the open Internet between consenting client and server implementations.</t>
        <t>The goal of the experiment is to prove that:</t>
        <ul spacing="normal">
          <li>Non-supporting clients and servers are unaffected.</li>
          <li>Connectivity between supporting clients and servers is retained under normal circumstances,
whether the client connects to the server frequently (relative to the ticket's lifetime) or very rarely.</li>
          <li>Enterprise middleboxes do not interrupt such connectivity.</li>
          <li>Misissued certificates and rogue TLS-aware middleboxes do result in broken connectivity,
and these cases are detected on the client and/or server side. Clients and servers can be recovered
even after such events and the normal connectivity restored.</li>
        </ul>
        <t>Following two years of successful deployment, the authors will publish a document that summarizes
the experiment's findings and will resubmit the protocol for
consideration as a Proposed Standard.</t>
      </section>
    </section>
    <section anchor="protocol-overview" numbered="true" toc="default">
      <name>Protocol Overview</name>
      <t>The protocol consists of two phases: the first time a particular client
connects to a server, and subsequent connections.</t>
      <t>This protocol supports full TLS handshakes, as well as 0-RTT handshakes.
Below we present it in the context of a full handshake, but behavior in
0-RTT handshakes should be identical.</t>
      <t>The document presents some similarities with the ticket resumption
mechanism described in <xref target="RFC5077" format="default"/>. However the scope of this document
differs from session resumption mechanisms implemented with <xref target="RFC5077" format="default"/>
or with other mechanisms. Specifically, the pinning ticket does not
carry any state associated with a TLS session and thus cannot be used
for session resumption or client authentication. Instead, the
pinning ticket only contains the encrypted pinning secret.
The pinning ticket is used by the server to prove
its ability to decrypt it, which implies ownership of the pinning
protection key.</t>
      <t><xref target="RFC5077" format="default"/> has been obsoleted 
by <xref target="RFC8446" format="default"/>, and ticket resumption is
now defined by <xref target="RFC8446" sectionFormat="of" section="2.2"  format="default"/>. This document references
<xref target="RFC5077" format="default"/> as an informational document since it contains a more
thorough discussion of stateless ticket resumption, and because
ticket resumption benefits
from significant operational experience with TLS 1.2 that is still
widely deployed at the time of writing.  This experience,
as well as deployment experience, can easily be re-used for identity pinning.</t>
      <t>With TLS 1.3, session resumption is based on a Pre-Shared Key (PSK).
This is orthogonal to this protocol. With TLS 1.3, a TLS session can be
established using PKI and a pinning ticket, and later resumed with PSK.</t>
      <t>However, the protocol described in this document addresses the problem
of misissued certificates. Thus, it is not expected to be used outside a
certificate-based TLS key exchange, such as in PSK. As a result, PSK
handshakes <bcp14>MUST NOT</bcp14> include the extension defined here.</t>
      <section anchor="initial-connection" numbered="true" toc="default">
        <name>Initial Connection</name>
        <t>When a client first connects to a server, it requests a pinning ticket
by sending an empty PinningTicket extension, and receives it as part of
the server's first response, in the returned PinningTicket extension.</t>
        <artwork name="" type="ascii-art" align="left" alt=""><![CDATA[
 Client                                               Server

 ClientHello
   + key_share
   + signature_algorithms
   + PinningTicket         -------->
                                                 ServerHello
                                                 + key_share
                                       {EncryptedExtensions
                                            + PinningTicket}
                                       {CertificateRequest*}
                                              {Certificate*}
                                        {CertificateVerify*}
                           <--------              {Finished}
 {Certificate*}
 {CertificateVerify*}
 {Finished}                -------->
 [Application Data]        <------->      [Application Data]

        *  Indicates optional or situation-dependent
           messages that are not always sent.

        {} Indicates messages protected using keys
           derived from the ephemeral secret.

        [] Indicates messages protected using keys
           derived from the master secret.
]]></artwork>
        <t>If a client supports the PinningTicket extension and does not have any
pinning ticket associated with the server, the exchange is considered as
an initial connection. Other reasons the client may not have a pinning
ticket include the client having flushed its pinning ticket store, or
the committed lifetime of the pinning ticket having expired.</t>
        <t>Upon receipt of the PinningTicket extension, the server computes a
pinning secret (<xref target="pinning-secret" format="default"/>) and sends the pinning ticket
(<xref target="pinning-ticket" format="default"/>) encrypted with the pinning protection key
(<xref target="pinning-ticket-key" format="default"/>).  The pinning ticket is associated with a
lifetime value by which the server assumes the responsibility of
retaining the pinning protection key and being able to decrypt incoming
pinning tickets during the period indicated by the committed lifetime.</t>
        <t>Once the pinning ticket has been generated, the server returns the
pinning ticket and the committed lifetime in a PinningTicket extension
embedded in the EncryptedExtensions message.  We note that a
PinningTicket extension <bcp14>MUST NOT</bcp14> be sent as part of a HelloRetryRequest.</t>
        <t>Upon receiving the pinning ticket, the client <bcp14>MUST NOT</bcp14> accept it until
the key exchange is completed and the server authenticated. If the key
exchange is not completed successfully, the client <bcp14>MUST</bcp14> ignore the
received pinning ticket. Otherwise, the client computes the pinning
secret and <bcp14>SHOULD</bcp14> cache the pinning secret and the pinning ticket for
the duration indicated by the pinning ticket lifetime. The client <bcp14>SHOULD</bcp14>
clean up the cached values at the end of the indicated lifetime.</t>
      </section>
      <section anchor="subsequent-connections" numbered="true" toc="default">
        <name>Subsequent Connections</name>
        <t>When the client initiates a connection to a server it has previously
seen (see <xref target="indexing" format="default"/> on identifying servers), it <bcp14>SHOULD</bcp14> send the
pinning ticket for that server.  The pinning ticket, pinning secret, and
pinning ticket lifetime computed during the establishment of the
previous TLS session are designated in this document as the "original"
ones, to distinguish them from a new ticket that may be generated during
the current session.</t>
        <t>The server <bcp14>MUST</bcp14> extract the original pinning_secret value from the
ticket and <bcp14>MUST</bcp14> respond with a PinningTicket extension, which includes:</t>
        <ul spacing="normal">
          <li>A proof that the server can understand the ticket that was sent by the
client; this proof also binds the pinning ticket to the server's
(current) public key, as well as the ongoing TLS session. The proof is
mandatory and <bcp14>MUST</bcp14> be included if a pinning ticket was sent by the client.</li>
          <li>A fresh pinning ticket. The main reason for refreshing the ticket on
each connection is privacy: to avoid the ticket serving as a fixed
client identifier. While a fresh pinning ticket might be of zero length,
it is <bcp14>RECOMMENDED</bcp14> to include a fresh ticket with a nonzero length with each
response.</li>
        </ul>
        <t>If the server cannot validate the received ticket, that might indicate
an earlier MITM attack on this client. The server <bcp14>MUST</bcp14> then abort the
connection with a handshake_failure alert and <bcp14>SHOULD</bcp14> log this failure.</t>
        <t>The client <bcp14>MUST</bcp14> verify the proof, and if it fails to do so, 
the client <bcp14>MUST</bcp14> issue a
handshake_failure alert and abort the connection (see also
<xref target="client_error" format="default"/>).  It is important that the client does not attempt to
"fall back" by omitting the PinningTicket extension.</t>
        <t>When the connection is successfully set up, i.e., after the Finished
message is verified, the client <bcp14>SHOULD</bcp14> store the new ticket along with
the corresponding pinning_secret, replacing the original ticket.</t>
        <t>Although this is an extension, if the client already has a ticket for a
server, the client <bcp14>MUST</bcp14> interpret a missing PinningTicket extension in
the server's response as an attack, because of the server's prior
commitment to respect the ticket. The client <bcp14>MUST</bcp14> abort the connection
in this case.  See also <xref target="ramp_down" format="default"/> on ramping down support for this
extension.</t>
      </section>
      <section anchor="indexing" numbered="true" toc="default">
        <name>Indexing the Pins</name>

        <t>Each pin is associated with a set of identifiers that include, among
others, hostname, protocol (TLS or DTLS), and port
number.  In other words, the pin for port TCP/443 may be different from
that for DTLS, or from the pin for port TCP/8443. These identifiers are
expected to be relevant to characterize the identity of the server as
well as the establishing TLS session. When a hostname is used, it <bcp14>MUST</bcp14> be
the value sent inside the Server Name Indication (SNI) extension.  This
definition is similar to the concept of a Web Origin <xref target="RFC6454" format="default"/>, but does not assume
the existence of a URL.</t>
        <t>The purpose of ticket pinning is to pin the server identity. As a
result, any information orthogonal to the server's identity <bcp14>MUST NOT</bcp14> be
considered in indexing.  More particularly, IP addresses are ephemeral
and forbidden in SNI, and therefore pins <bcp14>MUST NOT</bcp14> be associated with IP
addresses. Similarly, CA names or public keys associated with server
<bcp14>MUST NOT</bcp14> be used for indexing as they may change over time.</t>
      </section>
    </section>
    <section anchor="message-definitions" numbered="true" toc="default">
      <name>Message Definitions</name>
      <t>This section defines the format of the PinningTicket extension.
We follow the message notation of <xref target="RFC8446" format="default"/>.</t>
      <sourcecode name="" type="c"><![CDATA[
 opaque pinning_ticket<0..2^16-1>;

 opaque pinning_proof<0..2^8-1>;

 struct {
   select (Role) {
     case client:
       pinning_ticket ticket<0..2^16-1>; //omitted on 1st connection

     case server:
       pinning_proof proof<0..2^8-1>; //no proof on 1st connection
       pinning_ticket ticket<0..2^16-1>; //omitted on ramp down
       uint32 lifetime;
   }
} PinningTicketExtension;
]]></sourcecode>
      <dl newline="false" spacing="normal" indent="10">
        <dt>ticket</dt>
        <dd>
  a pinning ticket sent by the client or returned by the server. The
ticket is opaque to the client. The extension <bcp14>MUST</bcp14> contain exactly 0 or
1 tickets.</dd>
        <dt>proof</dt>
        <dd>
  a demonstration by the server that it understands the received ticket
and therefore that it is in possession of the secret that was used to
generate it originally.  The extension <bcp14>MUST</bcp14> contain exactly 0 or 1
proofs.</dd>
        <dt>lifetime</dt>
        <dd>
  the duration (in seconds) that the server commits to accept offered
tickets in the future.</dd>
      </dl>
    </section>
    <section anchor="crypto" numbered="true" toc="default">
      <name>Cryptographic Operations</name>
      <t>This section provides details on the cryptographic operations performed
by the protocol peers.</t>
      <section anchor="pinning-secret" numbered="true" toc="default">
        <name>Pinning Secret</name>
        <t>The pinning secret is generated locally by the client and the server,
which means they must use the same inputs to generate it. This value
must be generated before the ServerHello message is sent, as the server
includes the corresponding pinning ticket in the same flight as the
ServerHello message. In addition, the pinning secret must be
unpredictable to any party other than the client and the server.</t>
        <t>The pinning secret is derived using the Derive-Secret function provided
by TLS 1.3, described in <xref target="RFC8446" sectionFormat="of" section="7.1" format="default"/>.</t>
        <sourcecode name="" type="c"><![CDATA[
pinning secret = Derive-Secret(Handshake Secret, "pinning secret",
         ClientHello...ServerHello)
]]></sourcecode>
      </section>
      <section anchor="pinning-ticket" numbered="true" toc="default">
        <name>Pinning Ticket</name>
        <t>The pinning ticket contains the pinning secret. The pinning ticket is
provided by the client to the server, which decrypts it in order to
extract the pinning secret and responds with a pinning proof.  As a
result, the characteristics of the pinning ticket are:</t>
        <ul spacing="normal">
          <li>Pinning tickets <bcp14>MUST</bcp14> be encrypted and integrity-protected using strong
cryptographic algorithms.</li>
          <li>Pinning tickets <bcp14>MUST</bcp14> be protected with a long-term pinning protection
key.</li>
          <li>Pinning tickets <bcp14>MUST</bcp14> include a pinning protection key ID or serial
number as to enable the pinning protection key to be refreshed.</li>
          <li>The pinning ticket <bcp14>MAY</bcp14> include other information, in addition to the
pinning secret. When additional information is included, a careful
review needs to be performed to evaluate its impact on privacy.</li>
        </ul>

        <t>The pinning ticket's format is not specified by this document, but
a format similar to the one proposed by <xref target="RFC5077" format="default"/>
is <bcp14>RECOMMENDED</bcp14>.</t>
      </section>
      <section anchor="pinning-ticket-key" numbered="true" toc="default">
        <name>Pinning Protection Key</name>
        <t>The pinning protection key is used only by the server and so remains
server implementation specific. <xref target="RFC5077" format="default"/> recommends the use of two
keys, but when using Authenticated Encryption with Associated Data (AEAD) algorithms,
 only a single key is required.</t>

        <t>When a single server terminates TLS for multiple virtual servers using
the SNI mechanism, it is strongly <bcp14>RECOMMENDED</bcp14> that the server use
a separate protection key for each one of them, in order to allow
migrating virtual servers between different servers while keeping
pinning active.</t>
        <t>As noted in <xref target="cluster" format="default"/>, if the server is actually a cluster of
machines, the protection key <bcp14>MUST</bcp14> be synchronized between all the nodes
that accept TLS connections to the same server name.  When <xref target="RFC5077" format="default"/>
is deployed, an easy way to do it is to derive the protection key from
the session-ticket protection key, which is already synchronized. For
example:</t>
        <sourcecode name="" type="c"><![CDATA[
pinning_protection_key = HKDF-Expand(resumption_protection_key,
                              "pinning protection", L)
]]></sourcecode>
        <t>Where resumption_protection_key is the ticket protection key defined in
<xref target="RFC5077" format="default"/>. Both resumption_protection_key and pinning_protection_key
are only used by the server.</t>

        <t>The above solution attempts to minimize code changes related to management of the resumption_protection_key.
The drawback is that this key would be used both to directly encrypt session tickets and to derive
the pinning_protection_key, and such mixed usage of a single key is not in line with cryptographic best practices.
Where possible, it is <bcp14>RECOMMENDED</bcp14> that the resumption_protection_key 
be unrelated to the pinning_protection_key and that they are separately 
shared among the relevant servers.</t>
      </section>
      <section anchor="pinning-proof" numbered="true" toc="default">
        <name>Pinning Proof</name>
        <t>The pinning proof is sent by the server to demonstrate that it has been
able to decrypt the pinning ticket and to retrieve the pinning secret. The
proof must be unpredictable and must not be replayed. Similarly to the
pinning ticket, the pinning proof is sent by the server in the
ServerHello message.  In addition, it must not be possible for a MITM
server with a fake certificate to obtain a pinning proof from the
original server.</t>
        <t>In order to address these requirements, the pinning proof is bound to
the TLS session as well as the public key of the server:</t>
        <sourcecode name="" type="c"><![CDATA[
pinning_proof_secret=Derive-Secret(Handshake Secret, 
             "pinning proof 1", ClientHello...ServerHello)

proof = HMAC(original_pinning_secret, "pinning proof 2" +
             pinning_proof_secret + Hash(server_public_key))
]]></sourcecode>
        <t>where HMAC <xref target="RFC2104" format="default"/> uses the Hash algorithm that was negotiated in
the handshake, and the same hash is also used over the server's public
key. The original_pinning_secret value refers to the secret value
extracted from the ticket sent by the client, to distinguish it from a
new pinning secret value that is possibly computed in the current
exchange.  The server_public_key value is the DER representation of
the public key, specifically the SubjectPublicKeyInfo structure as-is.</t>
      </section>
    </section>
    <section anchor="operational-considerations" numbered="true" toc="default">
      <name>Operational Considerations</name>
      <t>The main motivation behind the current protocol is to enable identity
pinning without the need for manual operations. Manual operations are
susceptible to human error, and in the case of public key pinning, can
easily result in "server bricking": the server becoming inaccessible to
some or all of its users. To achieve this goal, operations described in
identity pinning are only performed within the current TLS session, and
there is no dependence on any TLS configuration parameters such as CA
identity or public keys.  As a result, configuration changes are
unlikely to lead to desynchronized state between the client and the
server.</t>
      <section anchor="cluster" numbered="true" toc="default">
        <name>Protection Key Synchronization</name>
        <t>The only operational requirement when deploying this protocol is that, if
the server is part of a cluster, protection keys (the keys used to
encrypt tickets) <bcp14>MUST</bcp14> be synchronized between all cluster members. The
protocol is designed so that if resumption ticket protection keys
<xref target="RFC5077" format="default"/> are already synchronized between cluster members, nothing
more needs to be done.</t>
        <t>Moreover, synchronization does not need to be instantaneous, e.g.,
protection keys can be distributed a few minutes or hours in advance of
their rollover. In such scenarios, each cluster member <bcp14>MUST</bcp14> be able to
accept tickets protected with a new version of the protection key, even
while it is still using an old version to generate keys. This ensures
that, when a client receives a "new" ticket, it does not next hit a cluster
member that still rejects this ticket.</t>
        <t>Misconfiguration can lead to the server's clock being off by a large
amount of time. Consider a case where a server's clock is misconfigured,
for example, to be 1 year in
the future, and the system is allowed to delete expired keys automatically.
The server will then delete many outstanding keys because they are now
long expired and will end up rejecting valid tickets that are stored
by clients. Such a scenario could make the server
inaccessible to a large number of clients.</t>
        <t>The decision to delete a key should at least consider
the largest value of the ticket lifetime as well as the expected time
desynchronization between the servers of the cluster and the time
difference for distributing the new key among the different servers in
the cluster.</t>
      </section>
      <section anchor="ticket-lifetime" numbered="true" toc="default">
        <name>Ticket Lifetime</name>
        <t>The lifetime of the ticket is a commitment by the server to retain the
ticket's corresponding protection key for this duration, so that the
server can prove to the client that it knows the secret embedded in the
ticket. For production systems, the lifetime <bcp14>SHOULD</bcp14> be between 7 and 31
days.</t>
      </section>
      <section anchor="certificate-renewal" numbered="true" toc="default">
        <name>Certificate Renewal</name>
        <t>The protocol ensures that the client will continue speaking to the
correct server even when the server's certificate is renewed. In this
sense, pinning is not associated with certificates, which is the reason we
designate the protocol described in this document as "server identity
pinning".</t>
        <t>Note that this property is not impacted by the use of the server's
public key in the pinning proof because the scope of the public key
used is only the current TLS session.</t>
      </section>
      <section anchor="certificate-revocation" numbered="true" toc="default">
        <name>Certificate Revocation</name>
        <t>The protocol is orthogonal to certificate validation in the sense that,
if the server's certificate has been revoked or is invalid for some
other reason, the client <bcp14>MUST</bcp14> refuse to connect to it regardless of any
ticket-related behavior.</t>
      </section>
      <section anchor="ramp_down" numbered="true" toc="default">
        <name>Disabling Pinning</name>
        <t>A server implementing this protocol <bcp14>MUST</bcp14> have a "ramp down" mode of
operation where:</t>
        <ul spacing="normal">
          <li>The server continues to accept valid pinning tickets and responds
  correctly with a proof.</li>
          <li>The server does not send back a new pinning ticket.</li>
        </ul>
        <t>After a while, no clients will hold valid tickets, and the
feature may be disabled. Note that clients that do not receive a new
pinning ticket do not necessarily need to remove the original ticket.
Instead, the client may keep using the ticket until its lifetime
expires. However, as detailed in <xref target="privacy" format="default"/>, re-use of a
ticket by the client may result in privacy concerns as the ticket value
may be used to correlate TLS sessions.</t>
        <t>Issuing a new pinning ticket with a shorter lifetime would only delay
the ramp down process, as the shorter lifetime can only affect clients
that actually initiated a new connection. Other clients would still see
the original lifetime for their pinning tickets.</t>
      </section>
      <section anchor="server-compromise" numbered="true" toc="default">
        <name>Server Compromise</name>
        <t>If a server compromise is detected, the pinning protection key <bcp14>MUST</bcp14> be
rotated immediately, but the server <bcp14>MUST</bcp14> still accept valid tickets that
use the old, compromised key.  Clients that still hold old pinning
tickets will remain vulnerable to MITM attacks, but those that connect
to the correct server will immediately receive new tickets protected
with the newly generated pinning protection key.</t>
        <t>The same procedure applies if the pinning protection key is compromised
directly, e.g., if a backup copy is inadvertently made public.</t>
      </section>
      <section anchor="disaster-recovery" numbered="true" toc="default">
        <name>Disaster Recovery</name>
        <t>All web servers in production need to be backed up, so that they can be
recovered if a disaster (including a malicious activity) ever wipes them
out. Backup often includes the certificate and its private key, which
must be backed up securely. The pinning secret, including earlier
versions that are still being accepted, must be backed up regularly.
However since it is only used as an authentication second factor, it
does not require the same level of confidentiality as the server's
private key.</t>
        <t>Readers should note that <xref target="RFC5077" format="default"/> session resumption keys are more
security sensitive and should normally not be backed up, but rather
treated as ephemeral keys. Even when servers derive pinning secrets from
resumption keys (<xref target="pinning-secret" format="default"/>), they <bcp14>MUST NOT</bcp14> back up resumption
keys.</t>
      </section>
    </section>

    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>This section reviews several security aspects related to the proposed
extension.</t>
      <section anchor="trust-on-first-use-tofu-and-mitm-attacks" numbered="true" toc="default">
        <name>Trust-on-First-Use (TOFU) and MITM Attacks</name>
        <t>This protocol is a trust-on-first-use protocol. If a client initially
connects to the "right" server, it will be protected against MITM
attackers for the lifetime of each received ticket. If it connects
regularly (depending, of course, on the server-selected lifetime), it will
stay constantly protected against fake certificates.</t>
        <t>However if it initially connects to an attacker, subsequent connections
to the "right" server will fail. Server operators might want to advise
clients on how to remove corrupted pins, once such large-scale attacks
are detected and remediated.</t>
        <t>The protocol is designed so that it is not vulnerable to an active MITM
attacker who has real-time access to the original server. The pinning
proof includes a hash of the server's public key to ensure the client
that the proof was in fact generated by the server with which it is
initiating the connection.</t>
      </section>
      <section anchor="pervasive-monitoring" numbered="true" toc="default">
        <name>Pervasive Monitoring</name>
        <t>Some organizations, and even some countries, perform pervasive monitoring
on their constituents <xref target="RFC7258" format="default"/>. This often takes the form of
always-active SSL proxies. Because of the TOFU property, this protocol
does not provide any security in such cases.</t>
        <t>Pervasive monitoring may also result in privacy concerns detailed in
<xref target="privacy" format="default"/>.</t>
      </section>
      <section anchor="server_error" numbered="true" toc="default">
        <name>Server-Side Error Detection</name>
        <t>Uniquely, this protocol allows the server to detect clients that present
incorrect tickets and therefore can be assumed to be victims of a MITM
attack. Server operators can use such cases as indications of ongoing
attacks, similarly to fake certificate attacks that took place in a few
countries in the past.</t>
      </section>
      <section anchor="client_policy" numbered="true" toc="default">
        <name>Client Policy and SSL Proxies</name>
        <t>Like it or not, some clients are normally deployed behind an SSL proxy.
Similar to <xref target="RFC7469" format="default"/>, it is acceptable to allow pinning to be
disabled for some hosts according to local policy. For example,
a User Agent (UA) <bcp14>MAY</bcp14>
disable pinning for hosts whose validated certificate chain terminates
at a user-defined trust anchor, rather than a trust anchor built into
the UA (or underlying platform). Moreover, a client <bcp14>MAY</bcp14> accept an empty
PinningTicket extension from such hosts as a valid response.</t>
      </section>
      <section anchor="client_error" numbered="true" toc="default">
        <name>Client-Side Error Behavior</name>

        <t>When a client receives a malformed or empty PinningTicket extension from
a pinned server, it <bcp14>MUST</bcp14> abort the handshake. If the client
retries the request, it <bcp14>MUST NOT</bcp14> omit the
PinningTicket in the retry message. Doing otherwise would expose the client to
trivial fallback attacks, similar to those described in <xref target="RFC7507" format="default"/>.</t>
        <t>However, this rule can negatively impact clients that move from
behind SSL proxies into the open Internet, and vice versa, if the advice
in <xref target="client_policy" format="default"/> is not followed.  Therefore, 
it is <bcp14>RECOMMENDED</bcp14>  that
browser and library vendors provide a documented way to remove stored
pins.</t>
      </section>
      <section anchor="stolen-and-forged-tickets" numbered="true" toc="default">
        <name>Stolen and Forged Tickets</name>
        <t>An attacker gains no benefit from stealing pinning tickets, even in conjunction with other pinning
parameters such as the associated pinning secret, since pinning tickets are used to secure the client
rather than the server.  Similarly, it is useless to forge a ticket for
a particular server.</t>
      </section>
      <section anchor="privacy" numbered="true" toc="default">
        <name>Client Privacy</name>

        <t>This protocol is designed so that an external attacker cannot link 
different requests to a single client, provided the client
requests and receives a fresh ticket upon each connection. This may be
of concern particularly during ramp down, if the server does not provide
a new ticket, and the client reuses the same ticket. To reduce or avoid such
privacy concerns, it is <bcp14>RECOMMENDED</bcp14> for the server to issue a fresh ticket with a
reduced lifetime. This would at least reduce the time period in which
the TLS sessions of the client can be linked. The server <bcp14>MAY</bcp14> also
issue tickets with a zero-second lifetime until it is confident all
tickets are expired.</t>
        <t>On the other hand, the server to which the client is connecting can
easily track the client.  This may be an issue when the client expects
to connect to the server (e.g., a mail server) with multiple identities.
Implementations <bcp14>SHOULD</bcp14> allow the user to opt out of pinning, either in
general or for particular servers.</t>
        <t>This document does not define the exact content of tickets.
Including client-specific information in tickets would raise privacy concerns
and is <bcp14>NOT RECOMMENDED</bcp14>.</t>
      </section>
      <section anchor="ticket-protection-key-management" numbered="true" toc="default">
        <name>Ticket Protection Key Management</name>

           <t>While the ticket format is not mandated by this document, protecting 
the ticket using authenticated encryption is <bcp14>RECOMMENDED</bcp14>. Some of the algorithms
commonly used for authenticated encryption, e.g., Galois/Counter Mode (GCM), are highly
vulnerable to nonce reuse, and this problem is magnified in a cluster
setting.  Therefore, implementations that choose AES-GCM or any AEAD
equivalent <bcp14>MUST</bcp14> adopt
one of these three alternatives:</t>
        <ul spacing="normal">
          <li>Partition the nonce namespace between cluster members and use monotonic
counters on each member, e.g., by setting the nonce to the concatenation
of the cluster member ID and an incremental counter.</li>
          <li>Generate random nonces but avoid the so-called birthday bound, i.e.,
never generate more than the maximum allowed number of encrypted
tickets (2**64 for AES-128-GCM) for the same ticket
pinning protection key.</li>
          <li>An alternative design that has been attributed to Karthik Bhargavan is
as follows.  Start with a 128-bit master key K_master and then for
each encryption, generate a 256-bit random nonce and compute: K =
HKDF(K_master, Nonce || "key"), then N = HKDF(K_master, Nonce ||
"nonce"). Use these values to encrypt the ticket, AES-GCM(K, N,
data). This nonce should then be stored and transmitted with the
ticket.</li>
        </ul>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>The IANA has allocated a TicketPinning extension value in the "TLS
ExtensionType Values" registry.</t>
      <t><xref target="RFC8447" format="default"/> defines the procedure, requirements, and the necessary
information for the IANA to update the "TLS ExtensionType Values"
registry <xref target="TLS-EXT" format="default"/>. The registration procedure
      is "Specification Required" <xref target="RFC8126"/>.</t>

      <t>The TicketPinning extension is registered as follows. (The extension is not
      limited to Private Use, and as such has its first byte in the range
      0-254.)</t>
      <dl>
	<dt>Value:</dt><dd>32</dd>
	<dt>Name:</dt><dd>ticket_pinning</dd>
	<dt>Recommended:</dt><dd>No</dd>
	<dt>TLS 1.3:</dt><dd>CH, EE (to indicate that the extension is present
	in ClientHello and EncryptedExtensions messages)</dd>
      </dl>
    </section>
  </middle>
  <back>
  <displayreference target="I-D.perrin-tls-tack" to="TLS-TACK"/>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8447.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
      </references>
      <references>

        <name>Informative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5077.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6454.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6962.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7258.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7469.xml"/>
        <xi:include
	    href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7507.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8555.xml"/>

        <!-- draft-ietf-draft-perrin-tls-tack-02 expired -->
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-perrin-tls-tack-02.xml"/>

        <reference anchor="Oreo">
          <front>
            <title>Firm Grip Handshakes: A Tool for Bidirectional Vouching</title>
            <author initials="O." surname="Berkman">
              <organization/>
            </author>
            <author initials="B." surname="Pinkas">
              <organization/>
            </author>
            <author initials="M." surname="Yung">
              <organization/>
            </author>
            <date year="2012"/>
          </front>
            <seriesInfo name="Cryptology and Network Security" value="pp. 142-157"/>
        </reference>

        <reference anchor="Netcraft" 
                   target="https://news.netcraft.com/archives/2016/03/30/http-public-key-pinning-youre-doing-it-wrong.html">
          <front>
            <title>HTTP Public Key Pinning: You're doing it wrong!</title>
            <author initials="P." surname="Mutton" fullname="Paul Mutton">
              <organization/>
            </author>
            <date year="2016" month="March"/>
          </front>
        </reference>

        <reference anchor="TLS-EXT" 
                   target="https://www.iana.org/assignments/tls-extensiontype-values/">
          <front>
            <title>TLS Extension Type Value</title>
            <author>
              <organization>IANA</organization>
            </author>
          </front>
        </reference>
      </references>
    </references>
    <section anchor="previous-work" numbered="true" toc="default">
      <name>Previous Work</name>
      <t>The global PKI system relies on the trust of a CA issuing certificates.
As a result, a corrupted trusted CA may issue a certificate for any
organization without the organization's approval (a misissued or "fake"
certificate), and use the certificate to impersonate the organization.
There are many attempts to resolve these weaknesses, including the
Certificate Transparency (CT) protocol <xref target="RFC6962" format="default"/>, 
HTTP Public Key Pinning (HPKP) <xref target="RFC7469" format="default"/>, 
and Trust Assertions for Certificate Keys (TACK) <xref target="I-D.perrin-tls-tack" format="default"/>.</t>
      <t>CT requires
cooperation of a large portion of the hundreds of extant certificate
authorities (CAs) before it can be used "for real", in enforcing mode.
It is noted that the relevant industry forum (CA/Browser Forum) is
indeed pushing for such extensive adoption. However the public nature of CT
often makes it inappropriate for enterprise use because many organizations
are not willing to expose their internal infrastructure publicly.</t>
      <t>TACK has some similarities
to the current proposal, but work on it seems to have stalled.  <xref target="tack" format="default"/>
compares our proposal to TACK.</t>
      <t>HPKP is an IETF standard, but so far has proven hard to deploy. HPKP
pins (fixes) a public key, one of the public keys listed in the
certificate chain.  As a result, HPKP needs to be coordinated with the
certificate management process.  Certificate management impacts HPKP and
thus increases the probability of HPKP failures.  This risk is made even
higher given the fact that, even though work has been done in the 
Automated Certificate Management Environment (ACME)
working group to automate certificate management, in many or even most cases,
certificates are still managed manually.  As a result, HPKP cannot be
completely automated, resulting in error-prone manual configuration. Such
errors could prevent the web server from being accessed by some clients.
In addition, HPKP uses an HTTP header, which makes this solution HTTPS
specific and not generic to TLS. On the other hand, the current document
provides a solution that is independent of the server's certificate
management, and that can be entirely and easily automated. <xref target="hpkp" format="default"/>
compares HPKP to the current document in more detail.</t>
      <t>The ticket pinning proposal augments these mechanisms with a much easier
to implement and deploy solution for server identity pinning, by reusing
some of the ideas behind TLS session resumption.</t>
      <t>This section compares ticket pinning to two earlier proposals, HPKP and TACK.</t>
      <section anchor="hpkp" numbered="true" toc="default">
        <name>Comparison: HPKP</name>
        <t>The current IETF standard for pinning the identity of web servers is 
HPKP <xref target="RFC7469" format="default"/>.</t>
        <t>The main differences between HPKP and the current document are the
following:</t>
        <ul spacing="normal">
          <li>HPKP limits its scope to HTTPS, while the current document considers all
application above TLS.</li>
          <li>HPKP pins the public key of the server (or another public key along the
certificate chain), and as such, is highly dependent on the management of
certificates.  Such dependency increases the potential error surface,
especially as certificate management is not yet largely automated.  The
current proposal, on the other hand, is independent of certificate
management.</li>
          <li>HPKP pins public keys that are public and used for the standard TLS
authentication.  Identity pinning relies on the ownership of the pinning
key, which is not disclosed to the public and not involved in the
standard TLS authentication.  As a result, identity pinning is a
completely independent, second-factor authentication mechanism.</li>
          <li>HPKP relies on a backup key to recover the misissuance of a key.  We
believe such backup mechanisms add excessive complexity and cost.
Reliability of the current mechanism is primarily based on its being
highly automated.</li>
          <li>HPKP relies on the client to report errors to the report-uri.  The
current document does not need any out-of-band mechanism, and the server is
informed automatically. This provides an easier and more reliable health
monitoring.</li>
        </ul>
        <t>On the other hand, HPKP shares the following aspects with identity pinning:</t>
        <ul spacing="normal">
          <li>Both mechanisms provide hard failure.  With HPKP, only the client is
aware of the failure, while with the current proposal both client and
server are informed of the failure.  This provides room for further
mechanisms to automatically recover from such failures.</li>
          <li>Both mechanisms are subject to a server compromise in which users are
provided with an invalid ticket (e.g., a random one) or HTTP header with
a very long lifetime. For identity pinning, this lifetime <bcp14>SHOULD NOT</bcp14> be
longer than 31 days.  In both cases, clients will not be able to
reconnect the server during this lifetime.  With the current proposal,
an attacker needs to compromise the TLS layer, while with HPKP, the
attacker needs to compromise the HTTP server.  Arguably, the TLS-level
compromise is typically more difficult for the attacker.</li>
        </ul>
        <t>Unfortunately HPKP has not seen wide deployment yet.  As of March 2016,
the number of servers using HPKP was less than 3000 <xref target="Netcraft" format="default"/>.  This
may simply be due to inertia, but we believe the main reason is the
interactions between HPKP and manual certificate management that is
needed to implement HPKP for enterprise servers. The penalty for making
mistakes (e.g., being too early or too late to deploy new pins) is that
the server becomes unusable for some of the clients.</t>
        <t>To demonstrate this point, we present a list of the steps involved in
deploying HPKP on a security-sensitive web server.</t>
        <ol spacing="normal" type="1">
          <li>
            <t>Generate two public/private key pairs on a computer that is not the
live server. The second one is the "backup1" key pair.  </t>
            <sourcecode type="bash">
openssl genrsa -out "example.com.key" 2048;

openssl genrsa -out "example.com.backup1.key" 2048;
</sourcecode>
          </li>

          <li>
            <t>Generate hashes for both of the public keys. These will be used in
the HPKP header:  </t>
            <sourcecode type="bash">
openssl rsa -in "example.com.key" -outform der -pubout | \
openssl dgst -sha256 -binary | openssl enc -base64  

openssl rsa -in "example.com.backup1.key" -outform der \
-pubout | openssl dgst -sha256 -binary | openssl enc -base64
</sourcecode>
          </li>
          <li>
            <t>Generate a single CSR (Certificate Signing Request) for the first
key pair, where you include the domain name in the CN (Common Name)
field:  </t>
            <sourcecode type="bash">
openssl req -new -subj "/C=GB/ST=Area/L=Town/O=Org/ \
CN=example.com" -key "example.com.key" -out "example.com.csr"; 
</sourcecode>
          </li>
          <li>Send this CSR to the CA and go though the
dance to prove you own the domain.  The CA will give you a single
certificate that will typically expire within a year or two.</li>
          <li>
            <t>On the live server, upload and set up the first key pair and its
certificate.  At this point, you can add the "Public-Key-Pins" header,
using the two hashes you created in step 2.  </t>
            <t>
Note that only the first key pair has been uploaded to the server so far.</t>
          </li>
          <li>Store the second (backup1) key pair somewhere safe, probably
somewhere encrypted like a password manager.  It won't expire, as it's
just a key pair; it just needs to be ready for when you need to get your
next certificate.</li>
          <li>Time passes -- probably just under a year (if waiting for a
certificate to expire), or maybe sooner if you find that your server has
been compromised, and you need to replace the key pair and certificate.</li>
          <li>Create a new CSR using the "backup1"
key pair, and get a new certificate from your CA.</li>
          <li>Generate a new backup key pair (backup2), get its hash, and store it
in a safe place (again, not on the live server).</li>
          <li>Replace your old certificate and old key pair, update the
"Public-Key-Pins" header to remove the old hash, and add the new
"backup2" key pair.</li>
        </ol>

        <t>Note that in the above steps, both the certificate issuance as well as
the storage of the backup key pair involve manual steps. Even with an
automated CA that runs the ACME protocol <xref target="RFC8555"/>, key backup would be a
challenge to automate.</t>
      </section>
      <section anchor="tack" numbered="true" toc="default">
        <name>Comparison: TACK</name>
        <t>Compared with HPKP, TACK <xref target="I-D.perrin-tls-tack" format="default"/> is more similar
to the current document.  It can even be argued that this document is a
symmetric-cryptography variant of TACK.  That said, there are still a
few significant differences:</t>
        <ul spacing="normal">
          <li>Probably the most important difference is that with TACK, validation of
the server certificate is no longer required, and in fact TACK specifies
it as a "<bcp14>MAY</bcp14>" requirement (<xref target="I-D.perrin-tls-tack" sectionFormat="comma" section="5.3" format="default"/>).  With ticket pinning, certificate
validation by the client remains a <bcp14>MUST</bcp14> requirement, and the ticket acts
only as a second factor. If the pinning secret is compromised, the
server's security is not immediately at risk.</li>
          <li>Both TACK and the current document are mostly orthogonal to the server
certificate as far as their life cycle, and so both can be deployed with
no manual steps.</li>
          <li>TACK uses Elliptic Curve Digital Signature Algorithm 
(ECDSA) to sign the server's public key. This allows
cooperating clients to share server assertions between themselves. This
is an optional TACK feature, and one that cannot be done with pinning
tickets.</li>
          <li>TACK allows multiple servers to share its public keys. Such sharing is
disallowed by the current document.</li>
          <li>TACK does not allow the server to track a particular client, and so
has better privacy properties than the current document.</li>
          <li>TACK has an interesting way to determine the pin's lifetime, setting
it to the time period since the pin was first observed, with a hard
upper bound of 30 days.  The current document makes the lifetime explicit,
which may be more flexible to deploy.  For example, web sites that are
only visited rarely by users may opt for a longer period than other
sites that expect users to visit on a daily basis.</li>
        </ul>
      </section>
    </section>

    <section anchor="acknowledgments" numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>The original idea behind this proposal was published in <xref target="Oreo" format="default"/> by
Moti Yung, Benny Pinkas, and Omer Berkman.  The current protocol is
but a distant relative of the original Oreo protocol, and any errors
are the responsibility of the authors of this document alone.</t>
      <t>We would like to thank Adrian Farrel, Dave Garrett,
Daniel Kahn Gillmor,
Alexey Melnikov,
Yoav Nir,
Eric Rescorla, Benjamin Kaduk, and Rich Salz for their comments on this document.
Special thanks to Craig Francis for contributing the HPKP deployment
script, and to Ralph Holz for several fruitful discussions.</t>
    </section>
  </back>
</rfc>
