<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" xml:lang="en"
     submissionType="IETF" category="std"  consensus="true"
     docName="draft-ietf-oauth-jwsreq-34" number="9101" ipr="trust200902"
     tocInclude="true" tocDepth="3" symRefs="true" sortRefs="true"
     version="3">


  <front>
    <title abbrev="OAuth JAR">The OAuth 2.0 Authorization Framework: JWT-Secured Authorization Request (JAR)</title>

    <seriesInfo name="RFC" value="9101"/>
    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>NAT.Consulting</organization>
      <address>
        <postal>
          <street>Kunitachi</street>
          <region>Tokyo 186-0004</region>

          <extaddr>2-22-17 Naka</extaddr>
          <country>Japan</country>
        </postal>
        <phone>+81-42-580-7401</phone>
        <email>nat@nat.consulting</email>
        <uri>https://nat.sakimura.org/</uri>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>Yubico</organization>
      <address>
        <postal>
          <street>Casilla 177</street>
          <extaddr>Sucursal Talagante</extaddr>
          <city>Talagante</city>
          <region>RM</region>
          <code/>
          <country>Chile</country>
        </postal>
        <phone>+1.202.630.5272</phone>
        <email>rfc9101@ve7jtb.com</email>
        <uri>http://www.thread-safe.com/</uri>
      </address>
    </author>
    <author fullname="Michael B. Jones" surname="Jones" initials="M.">
      <organization>Microsoft</organization>
      <address>
        <postal>
          <street>One Microsoft Way</street>
          <city>Redmond</city>
          <region>Washington</region>
          <code>98052</code>
          <country>United States of America</country>
        </postal>
        <email>mbj@microsoft.com</email>
        <uri>https://self-issued.info/</uri>
      </address>
    </author>
    <date month="August" year="2021"/>
    <area>Security</area>
    <workgroup>OAuth Working Group</workgroup>
    <keyword>Assertion</keyword>
    <keyword>Claim</keyword>
    <keyword>Security Token</keyword>
    <keyword>OAuth</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>
    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>JSON Web Signature</keyword>
    <keyword>JWS</keyword>
    <keyword>JSON Web Encryption</keyword>
    <keyword>JWE</keyword>
    <abstract>
      <t>The authorization request in OAuth 2.0 described in RFC 6749 utilizes
      query parameter serialization, which means that authorization request
      parameters are encoded in the URI of the request and sent through user
      agents such as web browsers.  While it is easy to implement, it means
      that a) the communication through the user agents is not integrity
      protected and thus, the parameters can be tainted, b) the source of
      the communication is not authenticated, and c) the communication
      through the user agents can be monitored.  Because of these weaknesses,
      several attacks to the protocol have now been put forward.</t>
      <t>This document introduces the ability to send request parameters in a
      JSON Web Token (JWT) instead, which allows the request to be signed with
      JSON Web Signature (JWS) and encrypted with JSON Web Encryption (JWE) so
      that the integrity, source authentication, and confidentiality
      properties of the authorization request are attained.  The request can
      be sent by value or by reference.
      </t>
    </abstract>
  </front>
  <middle>
    <section>
      <name>Introduction</name>
      <t>
	  The authorization request in <xref target="RFC6749">OAuth 2.0</xref>
	  utilizes query parameter
      serialization and is typically sent through user agents such as web browsers.
      </t>
      <t>
	  For example, the parameters <tt>response_type</tt>, <tt>client_id</tt>, <tt>state</tt>, and <tt>redirect_uri</tt> are encoded in the URI of the request:
      </t>
<sourcecode type="http-message">
    GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz 
    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1 
    Host: server.example.com
</sourcecode>
      <t>
	  While it is easy to implement,  the encoding in the URI 
	  does not allow application-layer security to be used to
	  provide confidentiality and integrity protection. 
	  While TLS is used to offer communication security 
	  between the client and the user agent as well as the user agent and the
	  authorization server, TLS sessions are terminated in the user agent.
	  In addition, TLS sessions may be terminated 
      prematurely at some middlebox (such as a load balancer). 
      </t>

      <t>
	  As a result, the authorization request of <xref target="RFC6749"/> has
	  shortcomings in that:
      </t>
      <ol spacing="normal" type="(%c)">
        <li>the communication through the user agents is
		not integrity protected, and thus, the parameters can be tainted
		(integrity protection failure);</li>
        <li>the source of the communication is not authenticated  
		(source authentication failure);</li>
        <li>the communication through the user agents can be monitored
		(containment/confidentiality failure). </li>
      </ol>
      <t>
	  Due to these inherent weaknesses, several attacks against the
	  protocol, such as redirection URI rewriting, have been identified.
      </t>
      <t>
	  The use of application-layer security mitigates these issues. 
      </t>
      <t>
      The use of application-layer security allows requests to be prepared by
      a trusted third party so that a client application cannot request more
      permissions than previously agreed upon.
      </t>
      <t>
      Furthermore, passing the request by reference allows the reduction of over-the-wire overhead.
      </t>
      <t>The <xref target="RFC7519">JWT</xref> encoding has been chosen because of:</t>
      <ol spacing="normal" type="(%d)">
        <li>its close relationship with JSON,
        which is used as OAuth's response format </li>
        <li>its developer friendliness due to its textual nature</li>
        <li>its relative compactness compared to XML </li>
        <li>its development status as a Proposed Standard,  along
		with the associated signing and encryption methods
        <xref target="RFC7515"/> <xref target="RFC7516"/></li>
        <li>the relative ease of JWS and JWE compared to XML Signature and Encryption. </li>
      </ol>
      <t>The parameters <tt>request</tt> and <tt>request_uri</tt> are
      introduced as additional authorization request parameters for the <xref
      target="RFC6749">OAuth 2.0</xref> flows. The <tt>request</tt> parameter
      is a <xref target="RFC7519">JSON Web Token (JWT)</xref> whose JWT Claims
      Set holds the JSON-encoded OAuth 2.0 authorization request parameters.
      Note that, in contrast to RFC 7519, the elements of the Claims Set are
      encoded OAuth request parameters <xref target="IANA.OAuth.Parameters"/>,
      supplemented with only a few of the IANA-managed JSON Web Token Claims
      <xref target="IANA.JWT.Claims"/>, in particular, <tt>iss</tt> and
      <tt>aud</tt>.  The JWT in the <tt>request</tt> parameter is integrity
      protected and source authenticated using JWS.
      </t>
      <t>
	  The <xref target="RFC7519">JWT</xref> can be passed to the authorization endpoint by reference,
      in which case the parameter <tt>request_uri</tt> is
      used instead of <tt>request</tt>.</t>
      <t>Using <xref target="RFC7519">JWT</xref> as the request encoding instead of query
      parameters has several advantages:</t>
      <ol spacing="normal" type="(%c)">
        <li>Integrity protection.
		  The request can be signed so that the integrity of the request can be checked.</li>
        <li>Source authentication.
		  The request can be signed so that the signer can be authenticated.</li>
        <li>Confidentiality protection.
		  The request can be encrypted so that end-to-end 
		  confidentiality can be provided even if the TLS connection is 
		  terminated at one point or another (including at and before user agents). </li>
        <li>Collection minimization.  The request can be signed by a trusted
        third party attesting that the authorization request is compliant with
        a certain policy.  For example, a request can be pre-examined by a
        trusted third party to confirm that all the personal data requested is
        strictly necessary to perform the process that the end user asked for;
        the request would then be signed by that trusted third party.  The
        authorization server then examines the signature and shows the
        conformance status to the end user who would have some assurance as to
        the legitimacy of the request when authorizing it.  In some cases, it
        may even be desirable to skip the authorization dialogue under such
        circumstances.
		  </li>
      </ol>
      <t>There are a few cases where request by reference is useful, such as:</t>
      <ol spacing="normal" type="1">
        <li>when it is desirable to reduce the size of a transmitted request.
        The use of application-layer security increases the size of the
        request particularly when public-key cryptography is used. </li>
        <li>when the client does not want to do the application-level
        cryptography.  The authorization server may provide an endpoint to
        accept the authorization request through direct communication with the
        client, so that the client is authenticated and the channel is TLS
        protected. </li>
      </ol>
      <t>This capability is in use by OpenID Connect <xref target="OpenID.Core"/>.</t>
      <section>
        <name>Requirements Language</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
    to be interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/>
    <xref target="RFC8174"/> when, and only when, they appear in all capitals,
    as shown here.
        </t>

      </section>
    </section>
    <section anchor="Terminology">
      <name>Terminology</name>
 
      <t>For the purposes of this specification, the following terms and
      definitions apply in addition to what is defined in 
	  <xref target="RFC6749">OAuth 2.0 Framework</xref>, 
	  <xref target="RFC7515">JSON Web Signature</xref>, and 
	  <xref target="RFC7516">JSON Web Encryption</xref>.</t>
      <section anchor="request_object">
        <name>Request Object</name>
        <t>
	  A Request Object is a <xref target="RFC7519">JSON Web Token
	  (JWT)</xref> whose JWT Claims
	  Set holds the JSON-encoded OAuth 2.0 authorization request
	  parameters.
        </t>
      </section>
      <section anchor="request_uri">
        <name>Request Object URI</name>
 
        <t>A Request Object URI is an absolute URI that references the set of
        parameters comprising an OAuth 2.0 authorization request.  The content
        of the resource referenced by the URI is a <xref
        target="request_object">Request Object</xref>, unless the URI was
        provided to the client by the same authorization server, in which case
        the content is an implementation detail at the discretion of the
        authorization server. The content being a Request Object is to ensure interoperability in
        cases where the provider of the <tt>request_uri</tt> is a separate
        entity from the consumer, such as when a client provides a URI
        referencing a Request Object stored on the client's backend service
        that is made accessible via HTTPS. In the latter case, where the
        authorization server is both provider and consumer of the URI, such as
        when it offers an endpoint that provides a URI in exchange for a
        Request Object, this interoperability concern does not apply.</t>
      </section>
    </section>
    <section anchor="abbreviation">
      <name>Symbols and Abbreviated Terms</name>
      <t>
	The following abbreviations are common to this specification.
      </t>
      <dl newline="false" spacing="normal">
        <dt>JSON:</dt>
        <dd>JavaScript Object Notation</dd>
        <dt>JWT:</dt>
        <dd>JSON Web Token</dd>
        <dt>JWS:</dt>
        <dd>JSON Web Signature</dd>
        <dt>JWE:</dt>
        <dd>JSON Web Encryption</dd>
        <dt>URI:</dt>
        <dd>Uniform Resource Identifier</dd>
        <dt>URL:</dt>
        <dd>Uniform Resource Locator</dd>
      </dl>
    </section>
    <section anchor="authorization_request_object">
      <name>Request Object</name>
      <t>A <xref target="request_object">Request Object</xref> is used to
      provide authorization request parameters for an OAuth 2.0 authorization
      request. It <bcp14>MUST</bcp14> contain all the parameters (including extension
      parameters) used to process the <xref target="RFC6749">OAuth 2.0</xref>
      authorization request except the <tt>request</tt> and
      <tt>request_uri</tt> parameters that are defined in
      this document.
	  The parameters are represented as the JWT Claims of the object.
	  Parameter names and string values <bcp14>MUST</bcp14> be included as JSON strings. 
	  Since Request Objects are handled across domains and potentially 
	  outside of a closed ecosystem, per <xref
	  target="RFC8259" sectionFormat="of" section="8.1"/>, 
	  these JSON strings <bcp14>MUST</bcp14> be encoded using UTF-8 <xref target="RFC3629"/>. 
	  Numerical values <bcp14>MUST</bcp14> be included as JSON numbers. 
	  The Request Object <bcp14>MAY</bcp14> include any extension parameters. 

	  This <xref target="RFC8259">JSON</xref> object constitutes the
      JWT Claims Set defined in <xref target="RFC7519">JWT</xref>.
	  The JWT Claims Set is then signed or signed and encrypted. </t>



      <t>To sign, <xref target="RFC7515">JSON Web Signature (JWS)</xref> is
      used.  The result is a JWS-signed <xref target="RFC7519">JWT</xref>. If
      signed, the Authorization Request Object <bcp14>SHOULD</bcp14> contain
      the Claims <tt>iss</tt> (issuer) and <tt>aud</tt> (audience) as members
      with their semantics being the same as defined in the <xref
      target="RFC7519">JWT</xref> specification.  The value of <tt>aud</tt>
      should be the value of the authorization server (AS) <tt>issuer</tt>, as
      defined in <xref target="RFC8414">RFC 8414</xref>.</t>
      <t>To encrypt, <xref target="RFC7516">JWE</xref> is used. 
	  When both signature and encryption are being applied, 
	  the JWT <bcp14>MUST</bcp14> be signed, then encrypted, as described in
	  <xref target="RFC7519" sectionFormat="of" section="11.2"/>.
	  The result is a Nested JWT, as defined in
	  <xref target="RFC7519"/>.
      </t>



      <t>
	    The client determines the algorithms used to sign and encrypt
	    Request Objects.  The algorithms chosen need to be supported by
	    both the client and the authorization server.  The client can
	    inform the authorization server of the algorithms that it supports
	    in its dynamic client registration metadata <xref
	    target="RFC7591"/>, specifically, the metadata values
	    <tt>request_object_signing_alg</tt>,
	    <tt>request_object_encryption_alg</tt>, and
	    <tt>request_object_encryption_enc</tt>.  Likewise, the
	    authorization server can inform the client of the algorithms that
	    it supports in its authorization server metadata <xref
	    target="RFC8414"/>, specifically, the metadata values
	    <tt>request_object_signing_alg_values_supported</tt>,
	    <tt>request_object_encryption_alg_values_supported</tt>, and
	    <tt>request_object_encryption_enc_values_supported</tt>.
      </t>
      <t>
	    The Request Object <bcp14>MAY</bcp14> be sent by value, as
	    described in <xref target="RequestParameter"/>,
	    or by reference, as described in <xref target="RequestUriParameter"/>.
	    <tt>request</tt> and
	    <tt>request_uri</tt> parameters
	    <bcp14>MUST NOT</bcp14> be included in Request Objects.
      </t>
      <t>
	  A <xref target="request_object">Request Object</xref> has the media
	  type <xref target="RFC2046"/>
	  <tt>application/oauth-authz-req+jwt</tt>.  Note that some existing
	  deployments may alternatively be using the type
	  <tt>application/jwt</tt>.
      </t>

      <t keepWithNext="true">
	      The following is an example of the Claims in
	      a Request Object before base64url <xref target="RFC7515"/> encoding and signing. 
		  Note that it includes the extension parameters
		  <tt>nonce</tt> and <tt>max_age</tt>.
      </t>
<sourcecode type="json"> 
  {
   "iss": "s6BhdRkqt3",
   "aud": "https://server.example.com",
   "response_type": "code id_token",
   "client_id": "s6BhdRkqt3",
   "redirect_uri": "https://client.example.org/cb",
   "scope": "openid",
   "state": "af0ifjsldkj",
   "nonce": "n-0S6_WzA2Mj",
   "max_age": 86400
  }
</sourcecode> 
      <t keepWithNext="true">
	      Signing it with the <tt>RS256</tt> algorithm <xref target="RFC7518"/>
	      results in this Request Object value
	      (with line wraps within values for display purposes only):
      </t>
<sourcecode type="jwt"> 
  eyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ewogICAgImlzcyI6ICJzNkJoZF
  JrcXQzIiwKICAgICJhdWQiOiAiaHR0cHM6Ly9zZXJ2ZXIuZXhhbXBsZS5jb20iLAog
  ICAgInJlc3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsCiAgICAiY2xpZW50X2
  lkIjogInM2QmhkUmtxdDMiLAogICAgInJlZGlyZWN0X3VyaSI6ICJodHRwczovL2Ns
  aWVudC5leGFtcGxlLm9yZy9jYiIsCiAgICAic2NvcGUiOiAib3BlbmlkIiwKICAgIC
  JzdGF0ZSI6ICJhZjBpZmpzbGRraiIsCiAgICAibm9uY2UiOiAibi0wUzZfV3pBMk1q
  IiwKICAgICJtYXhfYWdlIjogODY0MDAKfQ.Nsxa_18VUElVaPjqW_ToI1yrEJ67BgK
  b5xsuZRVqzGkfKrOIX7BCx0biSxYGmjK9KJPctH1OC0iQJwXu5YVY-vnW0_PLJb1C2
  HG-ztVzcnKZC2gE4i0vgQcpkUOCpW3SEYXnyWnKzuKzqSb1wAZALo5f89B_p6QA6j6
  JwBSRvdVsDPdulW8lKxGTbH82czCaQ50rLAg3EYLYaCb4ik4I1zGXE4fvim9FIMs8O
  CMmzwIB5S-ujFfzwFjoyuPEV4hJnoVUmXR_W9typPf846lGwA8h9G9oNTIuX8Ft2jf
  pnZdFmLg3_wr3Wa5q3a-lfbgF3S9H_8nN3j1i7tLR_5Nz-g
</sourcecode> 
      <t keepWithNext="true">
	      The following RSA public key, represented in JSON Web Key (JWK)
	      format, can be used to validate the Request Object signature in
	      this and subsequent Request Object examples (with line wraps
	      within values for display purposes only):
      </t>
<sourcecode type="json"> 
  {
   "kty":"RSA",
   "kid":"k2bdc",
   "n":"x5RbkAZkmpRxia65qRQ1wwSMSxQUnS7gcpVTV_cdHmfmG2ltd2yabEO9XadD8
        pJNZubINPpmgHh3J1aD9WRwS05ucmFq3CfFsluLt13_7oX5yDRSKX7poXmT_5
        ko8k4NJZPMAO8fPToDTH7kHYbONSE2FYa5GZ60CUsFhSonI-dcMDJ0Ary9lxI
        w5k2z4TAdARVWcS7sD07VhlMMshrwsPHBQgTatlkxyIHXbYdtak8fqvNAwr7O
        lVEvM_Ipf5OfmdB8Sd-wjzaBsyP4VhJKoi_qdgSzpC694XZeYPq45Sw-q51iF
        UlcOlTCI7z6jltUtnR6ySn6XDGFnzH5Fe5ypw",
   "e":"AQAB"
  }
</sourcecode> 
    </section>
    <section anchor="authreq">
      <name>Authorization Request</name>
      <t>The client constructs the authorization request URI 
	  by adding the following parameters
	  to the query component of the authorization
      endpoint URI using the <tt>application/x-www-form-urlencoded</tt>
      format:</t>
      <dl newline="true" spacing="normal">
        <dt>request</dt>
        <dd>
	    <bcp14>REQUIRED</bcp14> unless <tt>request_uri</tt>
          is specified. The <xref target="request_object">Request Object</xref> that
          holds authorization request parameters stated in
          <xref target="RFC6749" sectionFormat="of" section="4"/> (OAuth 2.0). 
		  If this parameter is present in the authorization request, 
		  <tt>request_uri</tt> <bcp14>MUST NOT</bcp14> be present. 
		  </dd>
        <dt>request_uri</dt>
        <dd>
	    <bcp14>REQUIRED</bcp14> unless <tt>request</tt>
          is specified. The absolute URI, as defined by <xref
	  target="RFC3986">RFC 3986</xref>, that is the <xref
	  target="request_uri">Request Object URI</xref> referencing the
	  authorization request
          parameters stated in <xref target="RFC6749"
	  sectionFormat="of" section="4"/> (OAuth
          2.0).
		  If this parameter is present in the authorization request, 
		  <tt>request</tt> <bcp14>MUST NOT</bcp14> be present.
		  </dd>
        <dt>client_id</dt>
        <dd>
	    <bcp14>REQUIRED</bcp14>. <xref target="RFC6749">OAuth 2.0</xref>
          <tt>client_id</tt>. The value <bcp14>MUST</bcp14> match the
          <tt>request</tt> or <tt>request_uri</tt>
          <xref target="request_object">Request Object's</xref>
          <tt>client_id</tt>.</dd>
      </dl>
      <t>The client directs the resource owner to the constructed URI
      using an HTTP redirection response or by other means available to it
      via the user agent.</t>
      <t>For example, the client directs the end user's user agent to make the
      following HTTPS request:</t>
<sourcecode type="http-message">
GET /authz?client_id=s6BhdRkqt3&amp;request=eyJhbG..AlMGzw HTTP/1.1
Host: server.example.com
</sourcecode>
      <t keepWithPrevious="true">
		The value for the request parameter is abbreviated 
		for brevity. 
      </t>
      <t>The Authorization Request Object <bcp14>MUST</bcp14> be one of the following: </t>
      <ol spacing="normal" type="(%c)">
        <li>JWS signed </li>
        <li>JWS signed and JWE encrypted</li>
      </ol>
      <t>The client <bcp14>MAY</bcp14> send the parameters included in 
	  the Request Object duplicated in the query parameters as well 
	  for backward compatibility, etc. 
	  However, the authorization server supporting this specification 
	  <bcp14>MUST</bcp14> only use the parameters included in the Request Object. 
      </t>
      <section anchor="RequestParameter">
        <name>Passing a Request Object by Value</name>
        <t>The client sends the authorization request as a 
	  Request Object to the authorization endpoint as the 
	  <tt>request</tt> parameter value.</t>
        <t keepWithNext="true">The following is an example of an
	      authorization request using the <tt>request</tt>
	      parameter
	      (with line wraps within values for display purposes only):
        </t>
<sourcecode type="url">
  https://server.example.com/authorize?client_id=s6BhdRkqt3&amp;
    request=eyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ewogICAgImlzcyI6
    ICJzNkJoZFJrcXQzIiwKICAgICJhdWQiOiAiaHR0cHM6Ly9zZXJ2ZXIuZXhhbXBs
    ZS5jb20iLAogICAgInJlc3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsCiAg
    ICAiY2xpZW50X2lkIjogInM2QmhkUmtxdDMiLAogICAgInJlZGlyZWN0X3VyaSI6
    ICJodHRwczovL2NsaWVudC5leGFtcGxlLm9yZy9jYiIsCiAgICAic2NvcGUiOiAi
    b3BlbmlkIiwKICAgICJzdGF0ZSI6ICJhZjBpZmpzbGRraiIsCiAgICAibm9uY2Ui
    OiAibi0wUzZfV3pBMk1qIiwKICAgICJtYXhfYWdlIjogODY0MDAKfQ.Nsxa_18VU
    ElVaPjqW_ToI1yrEJ67BgKb5xsuZRVqzGkfKrOIX7BCx0biSxYGmjK9KJPctH1OC
    0iQJwXu5YVY-vnW0_PLJb1C2HG-ztVzcnKZC2gE4i0vgQcpkUOCpW3SEYXnyWnKz
    uKzqSb1wAZALo5f89B_p6QA6j6JwBSRvdVsDPdulW8lKxGTbH82czCaQ50rLAg3E
    YLYaCb4ik4I1zGXE4fvim9FIMs8OCMmzwIB5S-ujFfzwFjoyuPEV4hJnoVUmXR_W
    9typPf846lGwA8h9G9oNTIuX8Ft2jfpnZdFmLg3_wr3Wa5q3a-lfbgF3S9H_8nN3
    j1i7tLR_5Nz-g
</sourcecode> 
      </section>
      <section anchor="RequestUriParameter">
        <name>Passing a Request Object by Reference</name>
        <t>
	  The <tt>request_uri</tt> authorization request parameter enables
	  OAuth authorization requests to be passed by reference rather than
	  by value.  This parameter is used identically to the
	  <tt>request</tt> parameter, except that the Request Object value is
	  retrieved from the resource identified by the specified URI rather
	  than passed by value.
        </t>

        <t>
	  The entire Request URI <bcp14>SHOULD NOT</bcp14> exceed 512 ASCII characters.
	  There are two reasons for this restriction: 
        </t>
        <ol spacing="normal" type="1">
          <li>Many phones on the market as of this writing still do not accept
          large payloads.  The restriction is typically either 512 or 1024
          ASCII characters.</li>
          <li>On a slow connection such as a 2G mobile connection, a large URL
          would cause a slow response; therefore, the use of such is not
          advisable from the user-experience point of view.
		  </li>
        </ol>
        <t>
	  The contents of the resource referenced by the <tt>request_uri</tt>
	  <bcp14>MUST</bcp14> be a Request Object and <bcp14>MUST</bcp14> be reachable by the authorization server
	  unless the URI was provided to the client by the authorization server.
	  In the first case, the <tt>request_uri</tt> <bcp14>MUST</bcp14> be
	  an <tt>https</tt> URI,
	  as specified in <xref target="RFC7230"
	  sectionFormat="of" section="2.7.2"/>.
	  In the second case, it <bcp14>MUST</bcp14> be a URN,
	  as specified in <xref target="RFC8141"/>.
        </t>
        <t keepWithNext="true">The following is an example of
	    the contents of a Request Object resource that can be
	    referenced by a <tt>request_uri</tt>
	    (with line wraps within values for display purposes only):</t>
<sourcecode type="jwt"> 
  eyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ewogICAgImlzcyI6ICJzNkJoZF
  JrcXQzIiwKICAgICJhdWQiOiAiaHR0cHM6Ly9zZXJ2ZXIuZXhhbXBsZS5jb20iLAog
  ICAgInJlc3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsCiAgICAiY2xpZW50X2
  lkIjogInM2QmhkUmtxdDMiLAogICAgInJlZGlyZWN0X3VyaSI6ICJodHRwczovL2Ns
  aWVudC5leGFtcGxlLm9yZy9jYiIsCiAgICAic2NvcGUiOiAib3BlbmlkIiwKICAgIC
  JzdGF0ZSI6ICJhZjBpZmpzbGRraiIsCiAgICAibm9uY2UiOiAibi0wUzZfV3pBMk1q
  IiwKICAgICJtYXhfYWdlIjogODY0MDAKfQ.Nsxa_18VUElVaPjqW_ToI1yrEJ67BgK
  b5xsuZRVqzGkfKrOIX7BCx0biSxYGmjK9KJPctH1OC0iQJwXu5YVY-vnW0_PLJb1C2
  HG-ztVzcnKZC2gE4i0vgQcpkUOCpW3SEYXnyWnKzuKzqSb1wAZALo5f89B_p6QA6j6
  JwBSRvdVsDPdulW8lKxGTbH82czCaQ50rLAg3EYLYaCb4ik4I1zGXE4fvim9FIMs8O
  CMmzwIB5S-ujFfzwFjoyuPEV4hJnoVUmXR_W9typPf846lGwA8h9G9oNTIuX8Ft2jf
  pnZdFmLg3_wr3Wa5q3a-lfbgF3S9H_8nN3j1i7tLR_5Nz-g
</sourcecode> 
        <section anchor="CreateRequestUri">
          <name>URI Referencing the Request Object</name>
          <t>
	    The client stores the Request Object resource either
	    locally or remotely at a URI the authorization server can access. 
		Such a facility may be provided by the authorization server 
		or a trusted third party. For example, the authorization server may 
		provide a URL to which the client POSTs the Request Object and 
		obtains the Request URI. 
	    This URI is the Request Object URI, <tt>request_uri</tt>. 
          </t>
          <t>
	    It is possible for the Request Object to include values that 
	    are to be revealed only to the authorization server.
	    As such, the <tt>request_uri</tt> <bcp14>MUST</bcp14> have
	    appropriate entropy for its lifetime
	    so that the URI is not guessable if publicly retrievable.
	    For the guidance, refer to 
	    <xref target="RFC6819" sectionFormat="of" section="5.1.4.2.2"/> and
	    "<xref target="CapURLs" format="title"/>" <xref target="CapURLs"/>.
	    It is <bcp14>RECOMMENDED</bcp14> that the <tt>request_uri</tt> be removed
		after a reasonable timeout
	    unless access control measures are taken.
          </t>
          <t keepWithNext="true">The following is an example
	    of a Request Object URI value
	      (with line wraps within values for display purposes only).
	      In this example, a trusted third-party service hosts the Request Object.
          </t>
<sourcecode type="url"> 
  https://tfp.example.org/request.jwt/
    GkurKxf5T0Y-mnPFCHqWOMiZi4VS138cQO_V7PZHAdM
</sourcecode> 
        </section>
        <section anchor="UseRequestUri">
          <name>Request Using the "request_uri" Request Parameter</name>
          <t>The client sends the authorization request to the
	  authorization endpoint.</t>
          <t keepWithNext="true">The following is an example
	    of an authorization request using the <tt>request_uri</tt> parameter
	    (with line wraps within values for display purposes only):</t>

<sourcecode type="url"> 
  https://server.example.com/authorize?
    client_id=s6BhdRkqt3
    &amp;request_uri=https%3A%2F%2Ftfp.example.org%2Frequest.jwt
    %2FGkurKxf5T0Y-mnPFCHqWOMiZi4VS138cQO_V7PZHAdM
</sourcecode> 
        </section>
        <section anchor="GetRequestUri">
          <name>Authorization Server Fetches Request Object</name>
 
          <t>Upon receipt of the Request, the authorization server
          <bcp14>MUST</bcp14> send an HTTP <tt>GET</tt> request to the
          <tt>request_uri</tt> to retrieve the referenced Request Object
          unless the Request Object is stored in a way so that the server can
          retrieve it through other mechanisms securely and parse it to
          recreate the authorization request parameters.</t>
          <t keepWithNext="true">The following is an example of this fetch
          process.  In this example, a trusted third-party service hosts the
          Request Object.
          </t>

<sourcecode type="http-message"> 
GET /request.jwt/GkurKxf5T0Y-mnPFCHqWOMiZi4VS138cQO_V7PZHAdM HTTP/1.1
Host: tfp.example.org
</sourcecode> 
          <t keepWithNext="true">The following is an example of the fetch
	    response:</t>
<sourcecode type="http-message"> 
  HTTP/1.1 200 OK
  Date: Thu, 20 Aug 2020 23:52:39 GMT
  Server: Apache/2.4.43 (tfp.example.org)
  Content-type: application/oauth-authz-req+jwt
  Content-Length: 797
  Last-Modified: Wed, 19 Aug 2020 23:52:32 GMT

  eyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ewogICAgImlzcyI6ICJzNkJoZF
  JrcXQzIiwKICAgICJhdWQiOiAiaHR0cHM6Ly9zZXJ2ZXIuZXhhbXBsZS5jb20iLAog
  ICAgInJlc3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsCiAgICAiY2xpZW50X2
  lkIjogInM2QmhkUmtxdDMiLAogICAgInJlZGlyZWN0X3VyaSI6ICJodHRwczovL2Ns
  aWVudC5leGFtcGxlLm9yZy9jYiIsCiAgICAic2NvcGUiOiAib3BlbmlkIiwKICAgIC
  JzdGF0ZSI6ICJhZjBpZmpzbGRraiIsCiAgICAibm9uY2UiOiAibi0wUzZfV3pBMk1q
  IiwKICAgICJtYXhfYWdlIjogODY0MDAKfQ.Nsxa_18VUElVaPjqW_ToI1yrEJ67BgK
  b5xsuZRVqzGkfKrOIX7BCx0biSxYGmjK9KJPctH1OC0iQJwXu5YVY-vnW0_PLJb1C2
  HG-ztVzcnKZC2gE4i0vgQcpkUOCpW3SEYXnyWnKzuKzqSb1wAZALo5f89B_p6QA6j6
  JwBSRvdVsDPdulW8lKxGTbH82czCaQ50rLAg3EYLYaCb4ik4I1zGXE4fvim9FIMs8O
  CMmzwIB5S-ujFfzwFjoyuPEV4hJnoVUmXR_W9typPf846lGwA8h9G9oNTIuX8Ft2jf
  pnZdFmLg3_wr3Wa5q3a-lfbgF3S9H_8nN3j1i7tLR_5Nz-g
</sourcecode> 
        </section>
      </section>
    </section>
    <section anchor="JWTRequestValidation">
      <name>Validating JWT-Based Requests</name>
      <section anchor="EncryptedRequestObject">
        <name>JWE Encrypted Request Object</name>
        <t>
	    If the Request Object is encrypted, 
	    the authorization server <bcp14>MUST</bcp14> decrypt the JWT in accordance with
	    the <xref target="RFC7516">JSON Web Encryption</xref> 
	    specification. 
        </t>
        <t>
		The result is a signed Request Object.
        </t>
        <t>
	    If decryption fails, the authorization server <bcp14>MUST</bcp14>
	    return an <tt>invalid_request_object</tt> error to the client in
	    response to the authorization request.
        </t>
      </section>
      <section anchor="SignedRequestObject">
        <name>JWS-Signed Request Object</name>
        <t>
	    The authorization server <bcp14>MUST</bcp14> validate the
	    signature of the JWS-signed <xref target="RFC7515"/> Request
	    Object. If a <tt>kid</tt> Header Parameter is present, the key identified
	    <bcp14>MUST</bcp14> be the key used and <bcp14>MUST</bcp14> be a
	    key associated with the client. The signature <bcp14>MUST</bcp14>
	    be validated using a key associated with the client and the
	    algorithm specified in the <tt>alg</tt> Header Parameter. Algorithm verification <bcp14>MUST</bcp14> be performed, as specified in Sections <xref target="RFC8725" format="default" sectionFormat="bare" section="3.1"></xref> and <xref target="RFC8725" format="default" sectionFormat="bare" section="3.2"></xref> of <xref target="RFC8725"/>. 
        </t>
        <t>
	    If the key is not associated with the client or if signature
	    validation fails, the authorization server <bcp14>MUST</bcp14>
	    return an <tt>invalid_request_object</tt> error to the client in response to the authorization request.
        </t>
      </section>
      <section anchor="RequestParameterValidation">
        <name>Request Parameter Assembly and Validation</name>
        <t>
	    The authorization server <bcp14>MUST</bcp14> extract 
	    the set of authorization request parameters 
	    from the Request Object value.
	    The authorization server <bcp14>MUST</bcp14> only use the 
	    parameters in the Request Object, even if the 
	    same parameter is provided in the query parameter.
	    The client ID values in the <tt>client_id</tt> request parameter
	    and in the Request Object <tt>client_id</tt> claim <bcp14>MUST</bcp14> be identical.
	    The authorization server then validates the request,
	    as specified in <xref target="RFC6749">OAuth 2.0</xref>.
        </t>
        <t>
	    If the Client ID check or the request validation fails, then the
	    authorization server <bcp14>MUST</bcp14> return an error to the
	    client in response to the authorization request, as specified in
	    <xref target="RFC6749" section="5.2" sectionFormat="of"/> (OAuth 2.0).
        </t>
      </section>
    </section>
    <section>
      <name>Authorization Server Response</name>
      <t>The authorization server response is created and sent to the client as in
      <xref target="RFC6749" sectionFormat="of" section="4"/> (OAuth 2.0).</t>
      <t>In addition, this document uses these additional error values:
      </t>
      <dl newline="true" spacing="normal">
        <dt>invalid_request_uri</dt>
        <dd>
	  The <tt>request_uri</tt> in the 
	authorization request returns an error or contains invalid data.</dd>
        <dt>invalid_request_object</dt>
        <dd>
	    The request parameter contains
          an invalid Request Object.</dd>
        <dt>request_not_supported</dt>
        <dd>
		  The authorization server does not support 
		  the use of the <tt>request</tt> parameter.</dd>
        <dt>request_uri_not_supported</dt>
        <dd>
		  The authorization server does not support the use of 
		  the <tt>request_uri</tt> parameter.</dd>
      </dl>
    </section>
    <section anchor="tlsreq">
      <name>TLS Requirements</name>

      <t>
	Client implementations supporting the Request Object URI method 
	<bcp14>MUST</bcp14> support TLS, following  
	<xref target="RFC7525">"Recommendations for Secure Use 
	of Transport Layer Security (TLS) and 
	Datagram Transport Layer Security (DTLS)"</xref>. 
      </t>
      <t>
			To protect against information disclosure and tampering,
			confidentiality protection <bcp14>MUST</bcp14> be applied using TLS with a 
			cipher suite that provides confidentiality and integrity protection.
      </t>
      <t> HTTP clients <bcp14>MUST</bcp14> also verify the TLS server certificate, using
            DNS-ID 
  			<xref target="RFC6125"/>, to avoid man-in-the-middle attacks.
  			  The rules and guidelines defined in
              <xref target="RFC6125"/> apply here, with the following considerations:
      </t>
      <ul spacing="normal">
        <li>
	  Support for DNS-ID identifier type (that is, the dNSName identity
     	  in the subjectAltName extension) is <bcp14>REQUIRED</bcp14>.  Certification
     	  authorities that issue server certificates
	  <bcp14>MUST</bcp14> support
     	  the DNS-ID identifier type, and the DNS-ID identifier type <bcp14>MUST</bcp14>
     	be present in server certificates.</li>
        <li>
     	  DNS names in server certificates <bcp14>MAY</bcp14> contain the
     	wildcard character <tt>*</tt>. </li>

        <li>
     	  Clients <bcp14>MUST NOT</bcp14> use CN-ID identifiers; a Common Name
     	  field (CN field) may be present in the server certificate's subject
     	  name but <bcp14>MUST NOT</bcp14> be used for authentication within
     	  the rules described in <xref target="RFC7525"/>. </li>
        <li>
     	  SRV-ID and URI-ID as described in <xref
	  target="RFC6125" sectionFormat="of" section="6.5"/>
     	  <bcp14>MUST NOT</bcp14> be used for comparison.
     	</li>
      </ul>
    </section>
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <section anchor="OAuthParametersRegistry">
        <name>OAuth Parameters Registration</name>
        <t>Since the Request Object is a JWT, the core JWT claims cannot be
        used for any purpose in the Request Object other than for what JWT
        dictates.  Thus, they have been registered as OAuth
        authorization request parameters to avoid future OAuth extensions
        using them with different meanings.</t>
        <t>This specification adds the following values to the "OAuth
        Parameters" registry <xref target="IANA.OAuth.Parameters"/>
        established by <xref target="RFC6749"/>.</t>
        <dl spacing="compact">
          <dt>Name:</dt><dd><tt>iss</tt></dd>
          <dt>Parameter Usage Location:</dt><dd>authorization request</dd>
          <dt>Change Controller:</dt><dd>IETF</dd>
          <dt>Specification Document(s):</dt><dd>This document and <xref
	  target="RFC7519" sectionFormat="of" section="4.1.1"/>.</dd>
        </dl>

        <dl spacing="compact">
          <dt>Name:</dt><dd><tt>sub</tt></dd>
          <dt>Parameter Usage Location:</dt><dd>authorization request</dd>
          <dt>Change Controller:</dt><dd>IETF</dd>
          <dt>Specification Document(s):</dt><dd>This document and <xref
	  target="RFC7519" sectionFormat="of" section="4.1.2"/>.</dd>
        </dl>

        <dl spacing="compact">
          <dt>Name:</dt><dd><tt>aud</tt></dd>
          <dt>Parameter Usage Location:</dt><dd>authorization request</dd>
          <dt>Change Controller:</dt><dd>IETF</dd>
          <dt>Specification Document(s):</dt><dd>This document and <xref
	  target="RFC7519" sectionFormat="of" section="4.1.3"/>.</dd>
        </dl>

        <dl spacing="compact">
          <dt>Name:</dt><dd><tt>exp</tt></dd>
          <dt>Parameter Usage Location:</dt><dd>authorization request</dd>
          <dt>Change Controller:</dt><dd>IETF</dd>
          <dt>Specification Document(s):</dt><dd>This document and <xref
	  target="RFC7519" sectionFormat="of" section="4.1.4"/>.</dd>
        </dl>

        <dl spacing="compact">
          <dt>Name:</dt><dd><tt>nbf</tt></dd>
          <dt>Parameter Usage Location:</dt><dd>authorization request</dd>
          <dt>Change Controller:</dt><dd>IETF</dd>
          <dt>Specification Document(s):</dt><dd>This document and <xref
	  target="RFC7519" sectionFormat="of" section="4.1.5"/>.</dd>
        </dl>

        <dl spacing="compact">
          <dt>Name:</dt><dd><tt>iat</tt></dd>
          <dt>Parameter Usage Location:</dt><dd>authorization request</dd>
          <dt>Change Controller:</dt><dd>IETF</dd>
          <dt>Specification Document(s):</dt><dd>This document and <xref
	  target="RFC7519" sectionFormat="of" section="4.1.6"/>.</dd>
        </dl>

        <dl spacing="compact">
          <dt>Name:</dt><dd><tt>jti</tt></dd>
          <dt>Parameter Usage Location:</dt><dd>authorization request</dd>
          <dt>Change Controller:</dt><dd>IETF</dd>
          <dt>Specification Document(s):</dt><dd>This document and <xref
	  target="RFC7519" sectionFormat="of" section="4.1.7"/>.</dd>
        </dl>
      </section>
      <section anchor="OAuthAuthorizationServerMetadataRegistry">
        <name>OAuth Authorization Server Metadata Registry</name>
        <t>This specification adds the following value to the "OAuth
        Authorization Server Metadata" registry <xref
        target="IANA.OAuth.Parameters"/> established by <xref
        target="RFC8414"/>.</t>
        <dl spacing="compact">
          <dt>Metadata Name:</dt><dd><tt>require_signed_request_object</tt></dd>
          <dt>Metadata Description:</dt><dd>Indicates where authorization
	  request needs to be protected as Request Object and provided through
	  either <tt>request</tt> or <tt>request_uri parameter</tt>.</dd>
          <dt>Change Controller:</dt><dd>IETF</dd>
          <dt>Specification Document(s):</dt><dd><xref
	  target="require_signed_request_object"/> of this document.</dd>
        </dl>
      </section>
      <section anchor="OAuthDynamicClientRegistrationMetadataRegistry">
        <name>OAuth Dynamic Client Registration Metadata Registry</name>
        <t>This specification adds the following value to the "OAuth Dynamic
        Client Registration Metadata" registry <xref
        target="IANA.OAuth.Parameters"/> established by <xref
        target="RFC7591"/>.</t>
        <dl spacing="compact">
          <dt>Metadata Name:</dt><dd><tt>require_signed_request_object</tt></dd>
          <dt>Metadata Description:</dt><dd>Indicates where authorization
	  request needs to be protected as Request Object and provided through
	  either <tt>request</tt> or <tt>request_uri parameter</tt>. </dd>
          <dt>Change Controller:</dt><dd>IETF</dd>
          <dt>Specification Document(s):</dt><dd><xref target="require_signed_request_object"/> of this document.</dd>
        </dl>
      </section>
      <section anchor="MediaReg">
        <name>Media Type Registration</name>
        <section anchor="MediaContents">
          <name>Registry Contents</name>
          <t>
                    This section registers the
                    <tt>application/oauth-authz-req+jwt</tt>
                    media type <xref target="RFC2046"/> in the "Media Types"
                    registry <xref target="IANA.MediaTypes"/> in the manner
                    described in <xref target="RFC6838"/>. It can be used to
                    indicate that the content is a JWT containing Request
                    Object claims.
          </t>
          <dl spacing="compact">
            <dt>Type name:</dt><dd>application</dd>
            <dt>Subtype name:</dt><dd>oauth-authz-req+jwt</dd>
            <dt>Required parameters:</dt><dd>N/A</dd>
            <dt>Optional parameters:</dt><dd>N/A</dd>
            <dt>Encoding considerations:</dt><dd>binary;
            a Request Object is a JWT;
            JWT values are encoded as a
            series of base64url-encoded values (some of which may be the
            empty string) separated by period (<tt>.</tt>) characters.</dd>
            <dt>Security considerations:</dt><dd>See <xref target="Security"/>
	    of RFC 9101</dd>
            <dt>Interoperability considerations:</dt><dd>N/A</dd>
            <dt>Published specification:</dt><dd><xref
	    target="authorization_request_object"/> of RFC 9101</dd>
            <dt>Applications that use this media type:</dt><dd>Applications
	    that use Request Objects to make an OAuth 2.0 authorization
	    request</dd>
            <dt>Fragment identifier considerations:</dt><dd>N/A</dd>
            <dt>Additional information:</dt><dd>
	    <t><br/></t>
	    <dl spacing="compact">
	      <dt>Deprecated alias names for this type:</dt><dd>N/A</dd>
	      <dt>Magic number(s):</dt><dd>N/A</dd>
	      <dt>File extension(s):</dt><dd>N/A</dd>
	      <dt>Macintosh file type code(s):</dt><dd>N/A</dd>
	    </dl>
            </dd>
            <dt>Person &amp; email address to contact for further
	    information:</dt><dd><br/>Nat Sakimura &lt;nat@nat.consulting&gt;</dd>
            <dt>Intended usage:</dt><dd>COMMON</dd>
            <dt>Restrictions on usage:</dt><dd>none</dd>
            <dt>Author:</dt><dd>Nat Sakimura &lt;nat@nat.consulting&gt;</dd>
            <dt>Change controller:</dt><dd>IETF</dd>
            <dt>Provisional registration?</dt><dd>No</dd>
          </dl>
        </section>
      </section>
    </section>
    <section anchor="Security">
      <name>Security Considerations</name>
      <t>In addition to all the <xref target="RFC6819"> security
      considerations discussed in OAuth 2.0</xref>, the security
      considerations in <xref target="RFC7515"/>, <xref target="RFC7516"/>,
      <xref target="RFC7518"/>, and <xref target="RFC8725"/> need to be
      considered.  Also, there are several academic papers such as <xref
      target="BASIN"/> that provide useful insight into the security
      properties of protocols like OAuth.
      </t>

      <t>
	  In consideration of the above, this document advises taking the
	  following security considerations into account.
      </t>


      <section anchor="alg_choice">
        <name>Choice of Algorithms</name>
        <t>When sending the Authorization Request Object through the
	<tt>request</tt> parameter, it <bcp14>MUST</bcp14> be either
	signed using <xref target="RFC7515">JWS</xref>
	or signed and then encrypted using <xref target="RFC7515">JWS</xref> and
	<xref target="RFC7516">JWE</xref>, respectively,
	with algorithms considered appropriate at the time. </t>
      </section>
      <section anchor="src_authn">
        <name>Request Source Authentication</name>
        <t>
	  The source of the authorization request <bcp14>MUST</bcp14> always be 
	  verified. There are several ways to do it:
        </t>
        <ol spacing="normal" type="(%c)">
          <li>Verifying the JWS Signature of the Request Object.</li>
          <li>Verifying that the symmetric key for the JWE encryption is the
          correct one if the JWE is using symmetric encryption. Note, however,
          that if public key encryption is used, no source authentication is
          enabled by the encryption, as any party can encrypt to the public
          key.</li>
          <li>Verifying the TLS Server Identity of the Request Object URI.
	  In this case, the authorization server <bcp14>MUST</bcp14> know 
	  out-of-band that the client uses the Request Object URI and 
	  only the client is covered by the TLS certificate. 
	  In general, this is not a reliable method. 
	  </li>
          <li>When an authorization server implements a service
	  that returns a Request Object URI in exchange for
	  a Request Object, the authorization
	  server <bcp14>MUST</bcp14> perform client authentication to accept 
	  the Request Object and bind the client identifier 
	  to the Request Object URI it is providing.
	  It <bcp14>MUST</bcp14> validate the signature, per (a).
	  Since the Request Object URI can be replayed, the lifetime 
	  of the Request Object URI <bcp14>MUST</bcp14> be short and preferably 
	  one-time use. The entropy of the Request Object URI 
			<bcp14>MUST</bcp14> be sufficiently large. 
            The adequate shortness of the validity and 
            the entropy of the Request Object URI depends 
            on the risk calculation based on the value  
            of the resource being protected. A general guidance 
            for the validity time would be less than a minute, 
            and the Request Object URI is to include a cryptographic  
            random value of 128 bits or more at the time of the 
            writing of this specification. 
			</li>
          <li>When a trusted third-party service returns a Request Object URI
          in exchange for a Request Object, it <bcp14>MUST</bcp14> validate
          the signature, per (a).  In addition, the authorization server
          <bcp14>MUST</bcp14> be trusted by the third-party service and
          <bcp14>MUST</bcp14> know out-of-band that the client is also trusted by it.
	</li>
        </ol>
      </section>
      <section anchor="explicit_endpoints">
        <name>Explicit Endpoints</name>



        <t>
	      Although this specification does not require them, 
	      research such as <xref target="BASIN"/> points out that 
	      it is a good practice to explicitly state 
	      the intended interaction endpoints and the message 
	      position in the sequence in a tamper-evident 
	      manner so that the intent of the initiator is unambiguous. It
	      is <bcp14>RECOMMENDED</bcp14> by this specification to use this
	      practice for the following endpoints defined in <xref
	      target="RFC6749"/>, <xref target="RFC6750"/>, and <xref
	      target="RFC8414"/>:
        </t>
        <ol spacing="normal" type="(%c)">
          <li>Protected resources (<tt>protected_resources</tt>)</li>
          <li>Authorization endpoint (<tt>authorization_endpoint</tt>)</li>
          <li>Redirection URI (<tt>redirect_uri</tt>)</li>
          <li>Token endpoint (<tt>token_endpoint</tt>)</li>
        </ol>
        <t>
	      Further, if dynamic discovery is used, then this practice also applies
	      to the discovery-related endpoints.
        </t>
        <t>
	      In <xref target="RFC6749"/>, 
	      while the redirection URI is included in the authorization request, others
	      are not. As a result, the same applies to the Authorization
	      Request Object.
        </t>

      </section>
      <section anchor="request_uri_threats">
        <name>Risks Associated with request_uri</name>
        <t>
	        The introduction of <tt>request_uri</tt>
	        introduces several attack possibilities. 
	        Consult the security considerations in
	        <xref target="RFC3986" sectionFormat="of"
		      section="7"/> for more information
		regarding
	        risks associated with URIs.
        </t>
        <section anchor="ddos_on_authz_server">
          <name>DDoS Attack on the Authorization Server</name>
          <t>
	        A set of malicious clients can launch a DoS attack 
	        to the authorization server by pointing the 
	        <tt>request_uri</tt> to a URI
	        that returns extremely large content or is extremely slow to respond. 
	        Under such an attack, the server may use up its resource 
	        and start failing. 
          </t>
          <t>
	        Similarly, a malicious client can specify a 
		<tt>request_uri</tt> value 
		that itself points to an authorization request URI 
		that uses <tt>request_uri</tt> to 
		cause the recursive lookup. 
          </t>
          <t>
	        To prevent such an attack from succeeding, the server should 
	        a) check that the value of the <tt>request_uri</tt> 
	        parameter does not point to an unexpected location, 
	        b) check that the media type of the response is 
	        <tt>application/oauth-authz-req+jwt</tt>,
	        c) implement a timeout for obtaining the content of 
	        <tt>request_uri</tt>, and 
		d) not perform recursive GET on the
		<tt>request_uri</tt>.
          </t>
        </section>
        <section anchor="request_uri_rewrite">
          <name>Request URI Rewrite</name>
          <t>
	        The value of <tt>request_uri</tt> is not signed; 
	        thus, it can be tampered with by a man-in-the-browser attacker. 
	        Several attack possibilities arise because of this. For
		example, 
	        a) an attacker may create another file that the rewritten 
	        URI points to, making it possible to request extra scope, or 
	        b) an attacker may launch a DoS attack on a victim site 
	        by setting the value of <tt>request_uri</tt> 
	        to be that of the victim. 
          </t>
          <t>
	        To prevent such an attack from succeeding, the server should 
	        a) check that the value of the <tt>request_uri</tt> 
	        parameter does not point to an unexpected location, 
	        b) check that the media type of the response is 
	        <tt>application/oauth-authz-req+jwt</tt>, and
	        c) implement a timeout for obtaining the content of 
	        <tt>request_uri</tt>.
          </t>
        </section>
      </section>
      <section anchor="require_signed_request_object">
        <name>Downgrade Attack</name>
        <t>
            Unless the protocol used by the client and the server is locked down to 
            use an OAuth JWT-Secured Authorization Request (JAR), it is possible
	    for an attacker to use RFC 6749 requests 
            to bypass all the protection provided by this specification. 
        </t>
        <t>
	  To prevent this kind of attack, this specification defines new
	  client metadata and server metadata values, both named
	  <tt>require_signed_request_object</tt>, whose values are both
	  booleans.
        </t>
        <t>
            When the value of it as client metadata is <tt>true</tt>, then the
            server <bcp14>MUST</bcp14> reject the authorization request from
            the client that does not conform to this specification.  It
            <bcp14>MUST</bcp14> also reject the request if the Request Object
            uses an <tt>alg</tt> value of <tt>none</tt> when this server
            metadata value is <tt>true</tt>.  If omitted, the default value is
            <tt>false</tt>.
        </t>

        <t>
            When the value of it as server metadata is <tt>true</tt>, then the
            server <bcp14>MUST</bcp14> reject the authorization request from
            any client that does not conform to this specification.  It
            <bcp14>MUST</bcp14> also reject the request if the Request Object
            uses an <tt>alg</tt> value of <tt>none</tt>. If omitted, the
            default value is <tt>false</tt>.
        </t>
	<t>Note that even if <tt>require_signed_request_object</tt> metadata
	values are not present, the client <bcp14>MAY</bcp14> use signed Request Objects,
	provided that there are signing algorithms mutually supported by the
	client and the server.  Use of signing algorithm metadata is described
	in <xref target="authorization_request_object"/>.</t>

      </section>
      <section anchor="tls_sec">
        <name>TLS Security Considerations</name>
        <t>Current security
      considerations can be found in "<xref target="RFC7525" format="title"/>" <xref target="RFC7525"/>.  This 
      supersedes the TLS version recommendations in <xref target="RFC6749">OAuth
        2.0</xref>.</t>
      </section>
      <section anchor="ParameterMismatches">
        <name>Parameter Mismatches</name>
        <t>
	  Given that OAuth parameter values are being sent in two different places,
	  as normal OAuth parameters and as Request Object claims,
	  implementations must guard against attacks that could use mismatching
	  parameter values to obtain unintended outcomes.
	  That is the reason that the two client ID values <bcp14>MUST</bcp14> match,
	  the reason that only the parameter values from the Request Object are to be used,
	  and the reason that neither <tt>request</tt> nor
	  <tt>request_uri</tt> can appear in a Request Object.
        </t>
      </section>
      <section anchor="CrossJWT">
        <name>Cross-JWT Confusion</name>
        <t>
	  As described in <xref target="RFC8725"
	  sectionFormat="of" section="2.8"/>,
	  attackers may attempt to use a JWT issued for one purpose in a context that it was not intended for.
	  The mitigations described for these attacks can be applied to Request Objects.
        </t>
        <t>
	  One way that an attacker might attempt to repurpose a Request Object
	  is to try to use it as a client authentication JWT,
	  as described in <xref target="RFC7523"
	  sectionFormat="of" section="2.2"/>.
	  A simple way to prevent this is to never use the client ID
	  as the <tt>sub</tt> value in a Request Object.
        </t>
        <t>
	  Another way to prevent cross-JWT confusion is to use explicit typing,
	  as described in <xref target="RFC8725"
	  sectionFormat="of" section="3.11"/>.
	  One would explicitly type a Request Object by including a
	  <tt>typ</tt> Header Parameter with the value
	  <tt>oauth-authz-req+jwt</tt>
	  (which is registered in <xref target="MediaContents"/>).
	  Note, however, that requiring explicitly typed Request Objects
	  at existing authorization servers will break most existing deployments,
	  as existing clients are already commonly using untyped Request Objects,
	  especially with OpenID Connect <xref target="OpenID.Core"/>.
	  However, requiring explicit typing would be a good idea
	  for new OAuth deployment profiles where compatibility with existing deployments
	  is not a consideration.
        </t>
<t>
  Finally, yet another way to prevent cross-JWT confusion is to use a key
  management regime in which keys used to sign Request Objects are
  identifiably distinct from those used for other purposes.  Then, if an
  adversary attempts to repurpose the Request Object in another context, a key
  mismatch will occur, thwarting the attack.
</t>
      </section>
    </section>
    <section anchor="Privacy">
      <name>Privacy Considerations</name>

      <t>
			When the client is being granted access to a protected resource 
			containing personal data, both the client 
			and the authorization server need to adhere to 
			Privacy Principles. 
			"<xref target="RFC6973" format="title"/>"
			<xref target="RFC6973" />
			gives excellent guidance on the
			enhancement of protocol design and implementation.  
			The provisions listed in it should be followed. 
      </t>
      <t>
			Most of the provisions would apply to 
			"<xref target="RFC6749" format="title"/>" <xref target="RFC6749"/>
			and "<xref target="RFC6750" format="title"/>" <xref target="RFC6750"/>
			and are not specific to this specification.
			In what follows, only the provisions specific
			to this specification are noted. 
      </t>
      <section anchor="collection_limitation">
        <name>Collection Limitation</name>
        <t>
	When the client is being granted access to a protected resource
	containing personal data, the client <bcp14>SHOULD</bcp14> limit the
	collection of personal data to that which is within the bounds of
	applicable law and strictly necessary for the specified purpose(s).
        </t>
        <t>
	It is often hard for the user to find out if the personal data asked
	for is strictly necessary.  A trusted third-party service can help the
	user by examining the client request, comparing it to the proposed
	processing by the client, and certifying the request. After the
	certification, the client, when making an authorization request, can
	submit an authorization request to the trusted third-party service to
	obtain the Request Object URI.  This process has two steps:
        </t>
        <ol spacing="normal" type="(%d)">
          <li>(Certification Process) The trusted third-party service examines
          the business process of the client and determines what claims they
          need; this is the certification process. Once the client is
          certified, they are issued a client credential to authenticate
          against to push Request Objects to the trusted third-party service
          to get the <tt>request_uri</tt>.</li>
          <li>(Translation Process) The client uses the client credential that
          it got to push the Request Object to the trusted third-party service
          to get the <tt>request_uri</tt>.  The trusted third-party service
          also verifies that the Request Object is consistent with the claims
          that the client is eligible for, per the prior step.
				</li>
        </ol>
        <t>
	Upon receiving such a Request Object URI in the authorization request,
	the authorization server first verifies that the authority portion of
	the Request Object URI is a legitimate one for the trusted third-party
	service.  Then, the authorization server issues an HTTP GET request to
	the Request Object URI.  Upon connecting, the authorization server
	<bcp14>MUST</bcp14> verify that the server identity represented in the
	TLS certificate is legitimate for the Request Object URI.  Then, the
	authorization server can obtain the Request Object, which includes the
	<tt>client_id</tt> representing the client.
        </t>
        <t>
	The Consent screen <bcp14>MUST</bcp14> indicate the client and
	<bcp14>SHOULD</bcp14> indicate that the request has been vetted by the
	trusted third-party service for the adherence to the collection
	limitation principle.
        </t>
      </section>
      <section anchor="disclosure_limitation">
        <name>Disclosure Limitation</name>
        <section anchor="request_disclosure">
          <name>Request Disclosure</name>

          <t>
	    This specification allows extension parameters. 
	    These may include potentially sensitive information. 
	    Since URI query parameters may leak through various 
	    means but most notably through referrer and browser history, 
	    if the authorization request contains a potentially sensitive 
	    parameter, the client <bcp14>SHOULD</bcp14> encrypt
	    the Request Object using <xref target="RFC7516">JWE</xref>.
          </t>

          <t>
	    Where the Request Object URI method is being used, if the Request
	    Object contains personally identifiable or sensitive information,
	    the <tt>request_uri</tt> <bcp14>SHOULD</bcp14> be used only once
	    and have a short validity period, and it <bcp14>MUST</bcp14> have
	    sufficient entropy for the applicable security policies unless the
	    Request Object itself is encrypted using <xref
	    target="RFC7516">JWE</xref>. The adequate shortness of the
	    validity and the entropy of the Request Object URI depends on the
	    risk calculation based on the value of the resource being
	    protected. A general guidance for the validity time would be less
	    than a minute, and the Request Object URI is to include a
	    cryptographic random value of 128 bits or more at the time of the
	    writing of this specification.

          </t>
        </section>
        <section anchor="tracking">
          <name>Tracking Using Request Object URI</name>
          <t>
	    Even if the protected resource does not include
	    personally identifiable information, 
	    it is sometimes possible to identify the user 
	    through the Request Object URI if persistent static per-user
	    Request Object URIs are used. A third party may observe
	    it through browser history, etc. and start correlating 
	    the user's activity using it. 
	    In a way, it is a data disclosure as well and
	    should be avoided. 
          </t>
          <t>
	    Therefore, per-user persistent Request Object URIs should be avoided.
	    Single-use Request Object URIs are one alternative.
          </t>
        </section>
      </section>
    </section>
  </middle>
  <back>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3629.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6125.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6750.xml"/>


        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7515.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7516.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7518.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7519.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8141.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8414.xml"/>



        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7525.xml"/>
      </references>
      <references>

        <name>Informative References</name>




        <reference anchor="IANA.MediaTypes" target="https://www.iana.org/assignments/media-types">
          <front>
            <title>Media Types</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>



        <reference anchor="IANA.OAuth.Parameters" target="https://www.iana.org/assignments/oauth-parameters">
          <front>
            <title>OAuth Parameters</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>



        <reference anchor="IANA.JWT.Claims" target="https://www.iana.org/assignments/jwt">
          <front>
            <title>JSON Web Token (JWT)</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>

        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7591.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6819.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6973.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2046.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6838.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7523.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8725.xml"/>
 
        <reference anchor="OpenID.Core" target="http://openid.net/specs/openid-connect-core-1_0.html">
          <front>
            <title>OpenID Connect Core 1.0 incorporating errata set 1</title>
            <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
              <organization abbrev="NAT Consulting">NAT Consulting</organization>
            </author>
            <author fullname="John Bradley" initials="J." surname="Bradley">
              <organization abbrev="Ping Identity">Ping Identity</organization>
            </author>
            <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
              <organization abbrev="Microsoft">Microsoft</organization>
            </author>
            <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
              <organization abbrev="Google">Google</organization>
            </author>
            <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
              <organization abbrev="Salesforce">Salesforce</organization>
            </author>
            <date day="8" month="November" year="2014"/>
          </front>
	  <refcontent>OpenID Foundation Standards</refcontent>
        </reference>

        <reference anchor="BASIN" target="https://www.cs.ox.ac.uk/people/cas.cremers/downloads/papers/BCM2012-iso9798.pdf">
          <front>
            <title>Provably Repairing the ISO/IEC 9798 Standard for Entity Authentication</title>
            <author fullname="David Basin" initials="D." surname="Basin"/>
            <author fullname="Cas Cremers" initials="C." surname="Cremers"/>
            <author fullname="Simon Meier" initials="S." surname="Meier"/>
            <date month="November" year="2013"/>
          </front>
            <refcontent>Journal of Computer Security - Security and Trust Principles, Volume 21, Issue 6, pp. 817-846</refcontent>

        </reference>


        <reference anchor="CapURLs" target="https://www.w3.org/TR/capability-urls/">
          <front>
            <title>Good Practices for Capability URLs</title>
            <author fullname="Jeni Tennison" initials="J." surname="Tennison" role="editor"/>
            <date day="18" month="February" year="2014"/>
          </front>
            <refcontent>W3C First Public Working Draft</refcontent>
        </reference>

      </references>
    </references>
    <section anchor="Acknowledgements" numbered="false">
      <name>Acknowledgements</name>

    <t>
	    The following people contributed to the creation of this document
	    in the OAuth Working Group and other IETF roles.
	    (Affiliations at the time of the contribution are used.)
      </t>
      <t>
	    <contact fullname="Annabelle Backman"/> (Amazon),
	    <contact fullname="Dirk Balfanz"/> (Google),
	    <contact fullname="Sergey Beryozkin"/>, 
	    <contact fullname="Ben Campbell"/> (as AD),
	    <contact fullname="Brian Campbell"/> (Ping Identity),
	    <contact fullname="Roman Danyliw"/> (as AD),
	    <contact fullname="Martin Duke"/> (as AD),
	    <contact fullname="Vladimir Dzhuvinov"/> (Connect2id),
	    <contact fullname="Lars Eggert"/> (as AD),
	    <contact fullname="Joel Halpern"/> (as GENART),
	    <contact fullname="Benjamin Kaduk"/> (as AD),
	    <contact fullname="Stephen Kent"/> (as SECDIR),
	    <contact fullname="Murray Kucherawy"/> (as AD),
	    <contact fullname="Warren Kumari"/> (as OPSDIR),
	    <contact fullname="Watson Ladd"/> (as SECDIR),
	    <contact fullname="Torsten Lodderstedt"/> (yes.com),
	    <contact fullname="Jim Manico"/>,
	    <contact fullname="James H. Manger"/> (Telstra),
	    <contact fullname="Kathleen Moriarty"/> (as AD),
	    <contact fullname="Axel Nennker"/> (Deutsche Telecom),
	    <contact fullname="John Panzer"/> (Google),
	    <contact fullname="Francesca Palombini"/> (as AD),
	    <contact fullname="David Recordon"/> (Facebook),
	    <contact fullname="Marius Scurtescu"/> (Google),
	    <contact fullname="Luke Shepard"/> (Facebook),
	    <contact fullname="Filip Skokan"/> (Auth0),
	    <contact fullname="Hannes Tschofenig"/> (ARM),
	    <contact fullname="Éric Vyncke"/> (as AD),
	    and
	    <contact fullname="Robert Wilton"/> (as AD).
      </t>
      <t>The following people contributed to creating this document through
      the <xref target="OpenID.Core">OpenID Connect Core 1.0</xref>.</t>
      <t>
	  <contact fullname="Brian Campbell"/> (Ping Identity), <contact
	  fullname="George Fletcher"/> (AOL), <contact fullname="Ryo Itou"/>
	  (Mixi), <contact fullname="Edmund Jay"/> (Illumila), <contact
	  fullname="Breno de Medeiros"/> (Google), <contact fullname="Hideki
	  Nara"/> (TACT), and <contact fullname="Justin Richer"/> (MITRE).
      </t>
    </section>

  </back>
</rfc>
