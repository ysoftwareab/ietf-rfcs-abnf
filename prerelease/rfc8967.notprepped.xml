<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" 
     category="std" 
     number="8967" 
     docName="draft-ietf-babel-hmac-12" 
     ipr="trust200902" 
     obsoletes="7298" 
     updates="" 
     submissionType="IETF" 
     consensus="true" 
     xml:lang="en" 
     tocInclude="true" 
     tocDepth="2" 
     symRefs="true" 
     sortRefs="true" 
     version="3">
  <!-- xml2rfc v2v3 conversion 3.0.0 -->
  <front>
    <title abbrev="MAC Authentication for Babel">MAC Authentication for the
Babel Routing Protocol</title>
    <seriesInfo name="RFC" value="8967"/>
    <author fullname="Clara Dô" initials="C." surname="Dô">
      <organization>IRIF, University of Paris-Diderot</organization>
      <address>
        <postal>
          <city>Paris CEDEX 13</city>
          <code>75205</code>
          <country>France</country>
        </postal>
        <email>clarado_perso@yahoo.fr</email>
      </address>
    </author>
    <author fullname="Weronika Kolodziejak" initials="W." surname="Kolodziejak">
      <organization>IRIF, University of Paris-Diderot</organization>
      <address>
        <postal>
          <city>Paris CEDEX 13</city>
          <code>75205</code>
          <country>France</country>
        </postal>
        <email>weronika.kolodziejak@gmail.com</email>
      </address>
    </author>
    <author fullname="Juliusz Chroboczek" initials="J." surname="Chroboczek">
      <organization>IRIF, University of Paris-Diderot</organization>
      <address>
        <postal>
          <street>Case 7014</street>
          <city>Paris CEDEX 13</city>
          <code>75205</code>
          <country>France</country>
        </postal>
        <email>jch@irif.fr</email>
      </address>
    </author>
    <date month="January" year="2021"/>

<keyword>routing protocol</keyword>
<keyword>authentication</keyword>
<keyword>replay</keyword>
<keyword>replay protection</keyword>

    <abstract>
      <t>This document describes a cryptographic authentication mechanism for
the Babel routing protocol that has provisions for replay avoidance.  This
document obsoletes RFC 7298.</t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>By default, the Babel routing protocol <xref target="RFC8966" format="default"/>
trusts the information contained
in every UDP datagram that it receives on the Babel port.  An attacker can
redirect traffic to itself or to a different node in the network, causing
a variety of potential issues.  In particular, an attacker might:
</t>

      <ul spacing="normal">
        <li>spoof a Babel packet and redirect traffic by announcing a route with
a smaller metric, a larger sequence number, or a longer prefix;</li>
        <li>spoof a malformed packet, which could cause an insufficiently robust
implementation to crash or interfere with the rest of the network;</li>
        <li>replay a previously captured Babel packet, which could cause traffic to
be redirected or otherwise interfere with the network.</li>
      </ul>
      <t>Protecting a Babel network is challenging due to the fact that the
Babel protocol uses both unicast and multicast communication.  One
possible approach, used notably by the Babel over Datagram Transport Layer
Security (DTLS) protocol <xref target="RFC8968" format="default"/>, is to use
unicast communication for all semantically significant communication, and
then use a standard unicast security protocol to protect the Babel
traffic.  In this document, we take the opposite approach: we define
a cryptographic extension to the Babel protocol that is able to protect
both unicast and multicast traffic and thus requires very few changes to
the core protocol.  This document obsoletes <xref target="RFC7298" format="default"/>.</t>
      <section numbered="true" toc="default">
        <name>Applicability</name>
        <t>The protocol defined in this document assumes that all interfaces on
a given link are equally trusted and share a small set of symmetric keys
(usually just one, and two during key rotation).  The protocol is inapplicable
in situations where asymmetric keying is required, where the trust
relationship is partial, or where large numbers of trusted keys are
provisioned on a single link at the same time.</t>
        <t>This protocol supports incremental deployment (where an insecure Babel
network is made secure with no service interruption), and it supports
graceful key rotation (where the set of keys is changed with no service
interruption).</t>

        <t>This protocol does not require synchronised clocks, it does not require
persistently monotonic clocks, and it does not require persistent storage
except for what might be required for storing cryptographic keys.</t>
      </section>
      <section anchor="security-properties" numbered="true" toc="default">
        <name>Assumptions and Security Properties</name>
        <t>The correctness of the protocol relies on the following assumptions:
</t>
        <ul spacing="normal">
          <li>that the Message Authentication Code (MAC) being used is invulnerable
to forgery, i.e., that an attacker is unable to generate a packet with
a correct MAC without access to the secret key;</li>
          <li>that a node never generates the same index or nonce twice over the
lifetime of a key.</li>
        </ul>
        <t>
The first assumption is a property of the MAC being used.  The second
assumption can be met either by using a robust random number generator
<xref target="RFC4086" format="default"/> and sufficiently large indices and nonces, by
using a reliable hardware clock, or by rekeying often enough that
collisions are unlikely.</t>
        <t>If the assumptions above are met, the protocol described in this
document has the following properties:
</t>
        <ul spacing="normal">
          <li>it is invulnerable to spoofing: any Babel packet accepted as authentic
is the exact copy of a packet originally sent by an authorised node;</li>
          <li>locally to a single node, it is invulnerable to replay: if a node has
previously accepted a given packet, then it will never again accept a copy
of this packet or an earlier packet from the same sender;</li>
          <li>among different nodes, it is only vulnerable to immediate replay: if
a node A has accepted an authentic packet from C, then a node B will only
accept a copy of that packet if B has accepted an older packet from C, and
B has received no later packet from C.</li>
        </ul>
        <t>While this protocol makes efforts to mitigate the effects of a denial
of service attack, it does not fully protect against such attacks.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Specification of Requirements</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", 
"<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", 
"<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", 
"<bcp14>NOT RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" 
in this document are to be interpreted as described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
    when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Conceptual Overview of the Protocol</name>
      <t>When a node B sends out a Babel packet through an interface that is
configured for MAC cryptographic protection, it computes one or more MACs
(one per key) that it appends to the packet.  When a node A receives
a packet over an interface that requires MAC cryptographic protection, it
independently computes a set of MACs and compares them to the MACs
appended to the packet; if there is no match, the packet is discarded.</t>

      <t>In order to protect against replay, B maintains a per-interface 32-bit
integer known as the "packet counter" (PC). Whenever B sends a packet
through the interface, it embeds the current value of the PC within the
region of the packet that is protected by the MACs and increases the PC
by at least one.  When A receives the packet, it compares the value of the
PC with the one contained in the previous packet received from B, and
unless it is strictly greater, the packet is discarded.</t>
      <t>By itself, the PC mechanism is not sufficient to protect against
replay.  Consider a peer A that has no information about a peer
B (e.g., because it has recently rebooted).  Suppose that A receives
a packet ostensibly from B carrying a given PC; since A has no information
about B, it has no way to determine whether the packet is freshly
generated or a replay of a previously sent packet.</t>
      <t>In this situation, peer A discards the packet and challenges B to prove that
it knows the MAC key.  It sends a "Challenge Request", a TLV containing
a unique nonce, a value that has never been used before and will never be
used again.  Peer B replies to the Challenge Request with a "Challenge Reply",
a TLV containing a copy of the nonce chosen by A, in a packet protected by
MAC and containing the new value of B's PC.  Since the nonce has never
been used before, B's reply proves B's knowledge of the MAC key and the
freshness of the PC.</t>
      <t>By itself, this mechanism is safe against replay if B never resets its
PC.  In practice, however, this is difficult to ensure, as persistent
storage is prone to failure, and hardware clocks, even when available, are
occasionally reset.  Suppose that B resets its PC to an earlier value and 
sends a packet with a previously used PC n.  Peer A challenges B,
B successfully responds to the challenge, and A accepts the PC equal to
n + 1.  At this point, an attacker C may send a replayed packet
with PC equal to n + 2, which will be accepted by A.</t>
      <t>Another mechanism is needed to protect against this attack.  In this
protocol, every PC is tagged with an "index", an arbitrary string of
octets.  Whenever B resets its PC, or whenever B doesn't know whether its
PC has been reset, it picks an index that it has never used before (either
by drawing it randomly or by using a reliable hardware clock) and starts
sending PCs with that index.  Whenever A detects that B has changed its
index, it challenges B again.</t>
      <t>With this additional mechanism, this protocol is invulnerable to replay
attacks (see <xref target="security-properties" format="default"/>).</t>
    </section>
    <section numbered="true" toc="default">
      <name>Data Structures</name>
      <t>Every Babel node maintains a set of conceptual data structures
described in <xref target="RFC8966" sectionFormat="of" section="3.2"/>.  This protocol
extends these data structures as follows.</t>
      <section anchor="interface-table" numbered="true" toc="default">
        <name>The Interface Table</name>
        <t>Every Babel node maintains an interface table, as described in 
<xref target="RFC8966" sectionFormat="of" section="3.2.3"/>.  Implementations of this protocol <bcp14>MUST</bcp14>
allow each interface to be provisioned with a set of one or more MAC keys
and the associated MAC algorithms (see <xref target="mac-computation" format="default"/>
for suggested algorithms and <xref target="security-considerations" format="default"/> for
suggested methods for key generation).  In order to allow incremental
deployment of this protocol (see <xref target="incremental-deployment" format="default"/>),
implementations <bcp14>SHOULD</bcp14> allow an interface to be configured in a mode in
which it participates in the MAC authentication protocol but accepts
packets that are not authenticated.</t>
        <t>This protocol extends each table entry associated with
an interface on which MAC authentication has been configured with two new
pieces of data:
</t>
        <ul spacing="normal">
          <li> a set of one or more MAC keys, each associated with a given MAC
algorithm;</li>
          <li> a pair (Index, PC), where Index is an arbitrary string of 0 to 32
octets, and PC is a 32-bit (4-octet) integer.</li>
        </ul>
        <t>
We say that an index is fresh when it has never been used before with any
of the keys currently configured on the interface.  The Index field is
initialised to a fresh index, for example, by drawing a random string of
sufficient length (see <xref target="security-considerations" format="default"/> for
suggested sizes), and the PC is initialised to an arbitrary value
(typically 0).</t>
      </section>
      <section numbered="true" toc="default">
        <name>The Neighbour Table</name>
        <t>Every Babel node maintains a neighbour table, as described in
<xref target="RFC8966" sectionFormat="of" section="3.2.4"/>.  This protocol extends each
entry in this table with two new pieces of data:
</t>
        <ul spacing="normal">
          <li> a pair (Index, PC), where Index is a string of 0 to 32 octets, and PC
is a 32-bit (4-octet) integer;</li>
          <li> a Nonce, which is an arbitrary string of 0 to 192 octets, and an
associated challenge expiry timer.</li>
        </ul>
        <t>
The Index and PC are initially undefined, and they are managed as described in
<xref target="packet-reception" format="default"/>.  The Nonce and challenge expiry timer are
initially undefined, and they are used as described in
<xref target="sending-challenges" format="default"/>.</t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Protocol Operation</name>
      <section anchor="mac-computation" numbered="true" toc="default">
        <name>MAC Computation</name>
        <t>A Babel node computes the MAC of a Babel packet as follows.</t>
        <t>First, the node builds a pseudo-header that will participate in MAC
computation but will not be sent.  If the packet is carried over IPv6,
the pseudo-header has the following format:
</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                          Src address                          +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Src port            |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                                                               |
+                                                               +
|                         Dest address                          |
+                                                               +
|                                                               |
+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |           Dest port           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        <t>
If the packet is carried over IPv4, the pseudo-header has the following
format:
</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Src address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Src port            |        Dest address           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |           Dest port           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>

        <t>Fields:
</t>
        <dl newline="false" spacing="normal" indent="14">
          <dt>Src address</dt>
          <dd>The source IP address of the packet.</dd>
          <dt>Src port</dt>
          <dd>The source UDP port number of the packet.</dd>
          <dt>Dest address</dt>
          <dd>The destination IP address of the packet.</dd>
          <dt>Src port</dt>
          <dd>The destination UDP port number of the packet.</dd>
        </dl>
        <t>The node takes the concatenation of the pseudo-header and the Babel
packet including the packet header but excluding the packet trailer (from
octet 0 inclusive up to (Body Length + 4) exclusive) and 
computes a MAC with one of the implemented algorithms.  Every
implementation <bcp14>MUST</bcp14> implement HMAC-SHA256 as defined in
<xref target="RFC6234" format="default"/> and <xref target="RFC2104" sectionFormat="of" section="2"/>,
<bcp14>SHOULD</bcp14> implement keyed BLAKE2s <xref target="RFC7693" format="default"/> with 128-bit (16-octet) digests, and <bcp14>MAY</bcp14> implement
other MAC algorithms.</t>
      </section>
      <section anchor="packet-transmission" numbered="true" toc="default">
        <name>Packet Transmission</name>
        <t>A Babel node might delay actually sending TLVs by a small amount, in
order to aggregate multiple TLVs in a single packet up to the
interface MTU (<xref target="RFC8966" sectionFormat="of" section="4"/>).  For an
interface on which MAC protection is configured, the TLV aggregation
logic <bcp14>MUST</bcp14> take into account the overhead due to PC TLVs (one in each
packet) and MAC TLVs (one per configured key).</t>
        <t>Before sending a packet, the following actions are performed:
</t>
        <ul spacing="normal">
          <li>
           <t>a PC TLV containing the PC and Index associated with the
outgoing interface <bcp14>MUST</bcp14> be appended to the packet body;</t> 
           <ul>
             <li>the PC <bcp14>MUST</bcp14> be
incremented by a strictly positive amount (typically just 1);</li> 
             <li>if the
PC overflows, a fresh index <bcp14>MUST</bcp14> be generated (as defined in
             <xref target="interface-table" format="default"/>); </li>
           </ul>
           <t>a node <bcp14>MUST NOT</bcp14> include multiple PC
           TLVs in a single packet;</t>
          </li>
          <li>for each key configured on the interface, a MAC is computed as
specified in <xref target="mac-computation" format="default"/> and stored in a
MAC TLV that <bcp14>MUST</bcp14> be appended to the packet trailer (see 
<xref target="RFC8966" sectionFormat="of" section="4.2"/>).</li>
        </ul>
      </section>
      <section anchor="packet-reception" numbered="true" toc="default">
        <name>Packet Reception</name>
        <t>When a packet is received on an interface that is configured for MAC
protection, the following steps are performed before the packet is passed
to normal processing:
</t>
        <ul spacing="normal">
          <li>First, the receiver checks whether the trailer of the received packet
carries at least one MAC TLV; if not, the packet <bcp14>MUST</bcp14> be immediately dropped
and processing stops.  Then, for each key configured on the receiving
interface, the receiver computes the MAC of the packet.  It then
compares every generated MAC against every MAC included in the packet;
if there is at least one match, the packet passes the MAC test; if there
is none, the packet <bcp14>MUST</bcp14> be silently dropped and processing stops at this
point.  In order to avoid memory exhaustion attacks, an entry in the
neighbour table <bcp14>MUST NOT</bcp14> be created before the MAC test has passed
successfully.  The MAC of the packet <bcp14>MUST NOT</bcp14> be computed for each MAC
TLV contained in the packet, but only once for each configured key.</li>
          <li>If an entry for the sender does not exist in the neighbour table, it
<bcp14>MAY</bcp14> be created at this point (or, alternatively, its creation can be
delayed until a challenge needs to be sent, see below).</li>
          <li>The packet body is then parsed a first time.  During this "preparse"
phase, the packet body is traversed and all TLVs are ignored except PC,
Challenge Request, and Challenge Reply TLVs.  When a PC TLV is
encountered, the enclosed PC and Index are saved for later processing. If
multiple PCs are found (which should not happen, see
<xref target="packet-transmission" format="default"/>), only the first one is
processed, the remaining ones <bcp14>MUST</bcp14> be silently ignored.  If a Challenge
Request is encountered, a Challenge Reply <bcp14>MUST</bcp14> be scheduled, as described
in <xref target="replying-challenges" format="default"/>.  If a Challenge Reply is
encountered, it is tested for validity as described in
<xref target="receiving-challenges" format="default"/>, and a note is made of the result of
the test.</li>
          <li>The preparse phase above yields two pieces of data: the PC and
Index from the first PC TLV, and a bit indicating whether the packet
contains a successful Challenge Reply.  If the packet does not contain
a PC TLV, the packet <bcp14>MUST</bcp14> be dropped, and processing stops at this point.
If the packet contains a successful Challenge Reply, then the PC and Index
contained in the PC TLV <bcp14>MUST</bcp14> be stored in the neighbour table entry
corresponding to the sender (which already exists in this case), and the
packet is accepted.</li>

          <li>Otherwise, if there is no entry in the neighbour table corresponding to
the sender, or if such an entry exists but contains no Index, or if the
Index it contains is different from the Index contained in the PC TLV,
then a challenge <bcp14>MUST</bcp14> be sent as described in
<xref target="sending-challenges" format="default"/>, the packet <bcp14>MUST</bcp14> be dropped, and
processing stops at this stage.</li>
          <li>At this stage, the packet contains no successful Challenge Reply, and
the Index contained in the PC TLV is equal to the Index in the neighbour
table entry corresponding to the sender.  The receiver compares the
received PC with the PC contained in the neighbour table; if the received
PC is smaller or equal than the PC contained in the neighbour table, the
packet <bcp14>MUST</bcp14> be dropped and processing stops (no challenge is sent in this
case, since the mismatch might be caused by harmless packet reordering on
the link).  Otherwise, the PC contained in the neighbour table entry is
set to the received PC, and the packet is accepted.</li>
        </ul>
        <t>In the algorithm described above, Challenge Requests are processed and
challenges are sent before the (Index, PC) pair is verified against the
neighbour table.  This simplifies the implementation somewhat (the node
may simply schedule outgoing requests as it walks the packet during the
preparse phase) but relies on the rate limiting described in
<xref target="sending-challenges" format="default"/> to avoid sending too many challenges
in response to replayed packets.  As an optimisation, a node <bcp14>MAY</bcp14> ignore
all Challenge Requests contained in a packet except the last one, and it
<bcp14>MAY</bcp14> ignore a Challenge Request in the case where it is contained in
a packet with an Index that matches the one in the neighbour table and
a PC that is smaller or equal to the one contained in the neighbour table.
Since it is still possible to replay a packet with an obsolete Index, the
rate limiting described in <xref target="sending-challenges" format="default"/> is
required even if this optimisation is implemented.</t>
        <t>The same is true of Challenge Replies.  However, since validating
a Challenge Reply has minimal additional cost (it is just a bitwise
comparison of two strings of octets), a similar optimisation for Challenge
Replies is not worthwhile.</t>
        <t>After the packet has been accepted, it is processed as normal, except
that any PC, Challenge Request, and Challenge Reply TLVs that it contains
are silently ignored.</t>
        <section numbered="true" toc="default">
          <name>Challenge Requests and Replies</name>
          <t>During the preparse stage, the receiver might encounter a mismatched
Index, to which it will react by scheduling a Challenge Request.  It might
encounter a Challenge Request TLV, to which it will reply with a Challenge
Reply TLV.  Finally, it might encounter a Challenge Reply TLV, which it
will attempt to match with a previously sent Challenge Request TLV in
order to update the neighbour table entry corresponding to the sender of
the packet.</t>
          <section anchor="sending-challenges" numbered="true" toc="default">
            <name>Sending Challenges</name>
            <t>When it encounters a mismatched Index during the preparse phase, a node
picks a nonce that it has never used with any of the keys currently
configured on the relevant interface, for example, by drawing
a sufficiently large random string of bytes or by consulting a strictly
monotonic hardware clock.  It <bcp14>MUST</bcp14> then store the nonce in the entry of
the neighbour table associated to the neighbour (the entry might need to
be created at this stage), initialise the neighbour's challenge expiry
timer to 30 seconds, and send a Challenge Request TLV to the unicast
address corresponding to the neighbour.</t>
            <t>A node <bcp14>MAY</bcp14> aggregate a Challenge Request with other TLVs; in other
words, if it has already buffered TLVs to be sent to the unicast address
of the neighbour, it <bcp14>MAY</bcp14> send the buffered TLVs in the same packet as the
Challenge Request.  However, it <bcp14>MUST</bcp14> arrange for the Challenge Request to
be sent in a timely manner, as any packets received from that neighbour
will be silently ignored until the challenge completes.</t>
            <t>A node <bcp14>MUST</bcp14> impose a rate limitation to the challenges it sends; the
limit <bcp14>SHOULD</bcp14> default to one Challenge Request every 300 ms and <bcp14>MAY</bcp14> be
configurable.  This rate limiting serves two purposes.  First, since
a challenge may be sent in response to a packet replayed by an attacker,
it limits the number of challenges that an attacker can cause a node to
send.  Second, it limits the number of challenges sent when there are
multiple packets in flight from a single neighbour.</t>
          </section>
          <section anchor="replying-challenges" numbered="true" toc="default">
            <name>Replying to Challenges</name>
            <t>When it encounters a Challenge Request during the preparse phase,
a node constructs a Challenge Reply TLV by copying the Nonce from the
Challenge Request into the Challenge Reply.  It <bcp14>MUST</bcp14> then send the
Challenge Reply to the unicast address from which the Challenge Request
was sent.  A challenge sent to a multicast address <bcp14>MUST</bcp14> be silently ignored.</t>
            <t>A node <bcp14>MAY</bcp14> aggregate a Challenge Reply with other TLVs; in other words,
if it has already buffered TLVs to be sent to the unicast address of the
sender of the Challenge Request, it <bcp14>MAY</bcp14> send the buffered TLVs in the same
packet as the Challenge Reply.  However, it <bcp14>MUST</bcp14> arrange for the Challenge
Reply to be sent in a timely manner (within a few seconds) and <bcp14>SHOULD NOT</bcp14>
send any other packets over the same interface before sending the
Challenge Reply, as those would be dropped by the challenger.</t>
            <t>Since a Challenge Reply might be caused by a replayed Challenge Request,
a node <bcp14>MUST</bcp14> impose a rate limitation to the Challenge Replies it sends;
the limit <bcp14>SHOULD</bcp14> default to one Challenge Reply for each peer every
300 ms and <bcp14>MAY</bcp14> be configurable.</t>
          </section>
          <section anchor="receiving-challenges" numbered="true" toc="default">
            <name>Receiving Challenge Replies</name>
            <t>When it encounters a Challenge Reply during the preparse phase, a node
consults the neighbour table entry corresponding to the neighbour that
sent the Challenge Reply.  If no challenge is in progress, i.e., if
there is no Nonce stored in the neighbour table entry or the challenge
timer has expired, the Challenge Reply <bcp14>MUST</bcp14> be silently ignored, and the
challenge has failed.</t>
            <t>Otherwise, the node compares the Nonce contained in the Challenge Reply
with the Nonce contained in the neighbour table entry.  If the two are
equal (they have the same length and content), then the challenge has
succeeded and the nonce stored in the neighbour table for this neighbour
<bcp14>SHOULD</bcp14> be discarded; otherwise, the challenge has failed (and the nonce is
not discarded).</t>
          </section>
        </section>
      </section>
      <section anchor="expire" numbered="true" toc="default">
        <name>Expiring Per-Neighbour State</name>
        <t>The per-neighbour (Index, PC) pair is maintained in the neighbour
table, and is normally discarded when the neighbour table entry expires.
Implementations <bcp14>MUST</bcp14> ensure that an (Index, PC) pair is discarded within
a finite time since the last time a packet has been accepted.  In
particular, unsuccessful challenges <bcp14>MUST NOT</bcp14> prevent an (Index, PC) pair
from being discarded for unbounded periods of time.</t>
        <t>A possible implementation strategy for implementations that use a Hello
history (Appendix A of <xref target="RFC8966" format="default"/>) is to discard the
(Index, PC) pair whenever the Hello history becomes empty.  Another
implementation strategy is to use a timer that is reset whenever a packet
is accepted and to discard the (Index, PC) pair whenever the timer
expires.  If the latter strategy is used, the timer <bcp14>SHOULD</bcp14> default
to a value of 5 minutes and <bcp14>MAY</bcp14> be configurable.</t>
      </section>
    </section>
    <section anchor="incremental-deployment" numbered="true" toc="default">
      <name>Incremental Deployment and Key Rotation</name>
      <t>In order to perform incremental deployment, the nodes in the network
are first configured in a mode where packets are sent with authentication
but not checked on reception.  Once all the nodes in the network are
configured to send authenticated packets, nodes are reconfigured to reject
unauthenticated packets.</t>
      <t>In order to perform key rotation, the new key is added to all the
nodes. Once this is done, both the old and the new key are sent in all
packets, and packets are accepted if they are properly signed by either of
the keys.  At that point, the old key is removed.</t>
      <t>In order to support the procedures described above, implementations of
this protocol <bcp14>SHOULD</bcp14> support an interface configuration in which packets
are sent authenticated but received packets are accepted without
verification, and they <bcp14>SHOULD</bcp14> allow changing the set of keys associated
with an interface without a restart.</t>
    </section>
    <section numbered="true" toc="default">
      <name>Packet Format</name>
      <section numbered="true" toc="default">
        <name>MAC TLV</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 16   |    Length     |     MAC...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
        <t>Fields:
</t>
        <dl newline="false" spacing="normal" indent="10">
          <dt>Type</dt>
          <dd>Set to 16 to indicate a MAC TLV.</dd>
          <dt>Length</dt>
          <dd>The length of the body, in octets, exclusive of the
Type and Length fields.  The length depends on the MAC algorithm being
used.</dd>
          <dt>MAC</dt>
          <dd>The body contains the MAC of the packet, computed as
described in <xref target="mac-computation" format="default"/>.</dd>
        </dl>
        <t>This TLV is allowed in the packet trailer (see 
<xref target="RFC8966" sectionFormat="of" section="4.2"/>) and <bcp14>MUST</bcp14> be ignored if it is found in the
packet body.</t>
      </section>
      <section numbered="true" toc="default">
        <name>PC TLV</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 17   |    Length     |             PC                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |            Index...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
        <t>Fields:
</t>
        <dl newline="false" spacing="normal" indent="10">
          <dt>Type</dt>
          <dd>Set to 17 to indicate a PC TLV.</dd>
          <dt>Length</dt>
          <dd>The length of the body, in octets, exclusive of the
Type and Length fields.</dd>
          <dt>PC</dt>
          <dd>The Packet Counter (PC), a 32-bit (4-octet) unsigned
integer that is increased with every packet sent over this interface.
A fresh index (as defined in <xref target="interface-table" format="default"/>) <bcp14>MUST</bcp14> be
generated whenever the PC overflows.</dd>
          <dt>Index</dt>
          <dd>The sender's Index, an opaque string of 0 to 32
octets.</dd>
        </dl>
        <t>Indices are limited to a size of 32 octets: a node <bcp14>MUST NOT</bcp14> send a TLV
with an index of size strictly larger than 32 octets, and a node <bcp14>MAY</bcp14>
ignore a PC TLV with an index of length strictly larger than 32 octets.
Indices of length 0 are valid: if a node has reliable stable storage and
the packet counter never overflows, then only one index is necessary, and
the value of length 0 is the canonical choice.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Challenge Request TLV</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 18   |    Length     |     Nonce...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
        <t>Fields:
</t>
        <dl newline="false" spacing="normal" indent="10">
          <dt>Type</dt>
          <dd>Set to 18 to indicate a Challenge Request TLV.</dd>
          <dt>Length</dt>
          <dd>The length of the body, in octets, exclusive of the
Type and Length fields.</dd>
          <dt>Nonce</dt>
          <dd>The nonce uniquely identifying the challenge, an
opaque string of 0 to 192 octets.</dd>
        </dl>
        <t>Nonces are limited to a size of 192 octets: a node <bcp14>MUST NOT</bcp14> send
a Challenge Request TLV with a nonce of size strictly larger than 192
octets, and a node <bcp14>MAY</bcp14> ignore a nonce that is of size strictly larger than
192 octets.  Nonces of length 0 are valid: if a node has reliable stable
storage, then it may use a sequential counter for generating nonces that
get encoded in the minimum number of octets required; the value 0 is then
encoded as the string of length 0.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Challenge Reply TLV</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 19   |    Length     |     Nonce...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork>
        <t>Fields:
</t>
        <dl newline="false" spacing="normal" indent="10">
          <dt>Type</dt>
          <dd>Set to 19 to indicate a Challenge Reply TLV.</dd>
          <dt>Length</dt>
          <dd>The length of the body, in octets, exclusive of the
Type and Length fields.</dd>
          <dt>Nonce</dt>
          <dd>A copy of the nonce contained in the corresponding
Challenge Request.</dd>
        </dl>
      </section>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>This document defines a mechanism that provides basic security
properties for the Babel routing protocol.  The scope of this protocol is
strictly limited: it only provides authentication (we assume that routing
information is not confidential), it only supports symmetric keying, and
it only allows for the use of a small number of symmetric keys on every
link.  Deployments that need more features, e.g., confidentiality or
asymmetric keying, should use a more feature-rich security mechanism such as
the one described in <xref target="RFC8968" format="default"/>.</t>
      <t>This mechanism relies on two assumptions, as described in
<xref target="security-properties" format="default"/>.  First, it assumes that the MAC being used
is invulnerable to forgery (<xref target="RFC6039" sectionFormat="of" section="1.1"/>); at
the time of writing, HMAC-SHA256, which is mandatory to implement
(<xref target="mac-computation" format="default"/>), is believed to be safe against
practical attacks.</t>
      <t>Second, it assumes that indices and nonces are generated uniquely over
the lifetime of a key used for MAC computation (more precisely, indices
must be unique for a given (key, source) pair, and nonces must be unique
for a given (key, source, destination) triple).  This property can be
satisfied either by using a cryptographically secure random number
generator to generate indices and nonces that contain enough entropy
(64-bit values are believed to be large enough for all practical
applications) or by using a reliably monotonic hardware clock.  If
uniqueness cannot be guaranteed (e.g., because a hardware clock has been
reset), then rekeying is necessary.</t>
      <t>The expiry mechanism mandated in <xref target="expire" format="default"/> is required to
prevent an attacker from delaying an authentic packet by an unbounded
amount of time.  If an attacker is able to delay the delivery of a packet
(e.g., because it is located at a Layer 2 switch), then the packet will be
accepted as long as the corresponding (Index, PC) pair is present at the
receiver.  If the attacker is able to cause the (Index, PC) pair to
persist for arbitrary amounts of time (e.g., by repeatedly causing failed
challenges), then it is able to delay the packet by arbitrary amounts of
time, even after the sender has left the network, which could allow it to
redirect or blackhole traffic to destinations previously advertised by the
sender.</t>
      <t>This protocol exposes large numbers of packets and their MACs to an
attacker that is able to capture packets; it is therefore vulnerable to
brute-force attacks.  Keys must be chosen in a manner that makes them
difficult to guess.  Ideally, they should have a length of 32 octets (both
for HMAC-SHA256 and BLAKE2s), and be chosen randomly.  If, for some
reason, it is necessary to derive keys from a human-readable passphrase,
it is recommended to use a key derivation function that hampers dictionary
attacks, such as PBKDF2 <xref target="RFC8018" format="default"/>, bcrypt
<xref target="BCRYPT" format="default"/>, or scrypt <xref target="RFC7914" format="default"/>.  In that case,
only the derived keys should be communicated to the routers; the original
passphrase itself should be kept on the host used to perform the key
generation (e.g., an administrator's secure laptop computer).</t>
      <t>While it is probably not possible to be immune against denial of
service (DoS) attacks in general, this protocol includes a number of
mechanisms designed to mitigate such attacks.  In particular, reception of
a packet with no correct MAC creates no local Babel state
(<xref target="packet-reception" format="default"/>).  Reception of a replayed packet with
correct MAC, on the other hand, causes a challenge to be sent; this is
mitigated somewhat by requiring that challenges be rate limited
(<xref target="sending-challenges" format="default"/>).</t>
      <t>Receiving a replayed packet with an obsolete index causes an entry to
be created in the neighbour table, which, at first sight, makes the
protocol susceptible to resource exhaustion attacks (similarly to the
familiar "TCP SYN Flooding" attack <xref target="RFC4987" format="default"/>).  However,
the MAC computation includes the sender address (<xref target="mac-computation" format="default"/>), 
and thus the amount of storage that an
attacker can force a node to consume is limited by the number of distinct
source addresses used with a single MAC key (see also 
<xref target="RFC8966" sectionFormat="of" section="4"/>, which mandates that the source address is
a link-local IPv6 address or a local IPv4 address).</t>
      <t>In order to make this kind of resource exhaustion attacks less
effective, implementations may use a separate table of uncompleted
challenges that is separate from the neighbour table used by the core
protocol (the data structures described in <xref target="RFC8966" sectionFormat="of" section="3.2"/> are conceptual, and any data structure that yields the
same result may be used).  Implementers might also consider using the fact
that the nonces included in Challenge Requests and Replies can be fairly
large (up to 192 octets), which should in principle allow encoding the
per-challenge state as a secure "cookie" within the nonce itself; note,
however, that any such scheme will need to prevent cookie replay.</t>
    </section>
    <section numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>IANA has allocated the following values in the Babel TLV Types
registry:</t>
      <table align="center">
        <thead>
          <tr>
            <th align="left">Type</th>
            <th align="left">Name</th>
            <th align="left">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">16</td>
            <td align="left">MAC</td>
            <td align="left">RFC 8967</td>
          </tr>
          <tr>
            <td align="left">17</td>
            <td align="left">PC</td>
            <td align="left">RFC 8967</td>
          </tr>
          <tr>
            <td align="left">18</td>
            <td align="left">Challenge Request</td>
            <td align="left">RFC 8967</td>
          </tr>
          <tr>
            <td align="left">19</td>
            <td align="left">Challenge Reply</td>
            <td align="left">RFC 8967</td>
          </tr>
        </tbody>
      </table>
    </section>
  </middle>
  <back>


    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>

        <reference anchor="RFC8966" target="https://www.rfc-editor.org/info/rfc8966">
          <front>
            <title>The Babel Routing Protocol</title>
            <author fullname="Juliusz Chroboczek" initials="J." surname="Chroboczek"/>
            <author fullname="David Schinazi" initials="D." surname="Schinazi"/>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8966"/>
          <seriesInfo name="DOI" value="10.17487/RFC8966"/>
        </reference>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6234.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7693.xml"/>
      </references>
      <references>
        <name>Informational References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7298.xml"/>

   <reference anchor="RFC8968" target="https://www.rfc-editor.org/info/rfc8968">
     <front>
       <title>Babel Routing Protocol over Datagram Transport Layer Security</title>
       <author initials="A" surname="Décimo" fullname="Antonin Décimo">
         <organization />
       </author>
       <author initials="D" surname="Schinazi" fullname="David Schinazi">
         <organization />
       </author>
       <author initials="J" surname="Chroboczek" fullname="Juliusz Chroboczek">
         <organization />
       </author>

       <date month="January" year="2021" />
     </front>
     <seriesInfo name="RFC" value="8968" />
     <seriesInfo name="DOI" value="10.17487/RFC8968"/>

   </reference>


        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6039.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4086.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4987.xml"/>

        <reference anchor="BCRYPT">
          <front>
            <title>A Future-Adaptable Password Scheme</title>
            <author initials="P." surname="Niels" fullname="Niels Provos"/>
            <author initials="D." surname="Mazières" fullname="David Mazières"/>
            <date month="June" year="1999"/>
          </front>
          <refcontent>Proceedings of the FREENIX Track: 1999 USENIX Annual Technical Conference</refcontent>
        </reference>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8018.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7914.xml"/>
      </references>
    </references>

    <section numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>The protocol described in this document is based on the original HMAC
protocol defined by <contact fullname="Denis Ovsienko"/> <xref target="RFC7298" format="default"/>.  
The use of a pseudo-header was suggested by <contact fullname="David Schinazi"/>.  
The use of an index to avoid replay was suggested by <contact fullname="Markus Stenberg"/>.  
The authors are also indebted to <contact fullname="Antonin Décimo"/>, 
<contact fullname="Donald Eastlake"/>, <contact fullname="Toke Høiland-Jørgensen"/>,
<contact fullname="Florian Horn"/>, <contact fullname="Benjamin Kaduk"/>, 
<contact fullname="Dave Taht"/>, and <contact fullname="Martin Vigoureux"/>.</t>
    </section>
  </back>
</rfc>
