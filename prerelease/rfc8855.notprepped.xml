<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" 
category="std" 
consensus="true" 
ipr="trust200902" 
docName="draft-ietf-bfcpbis-rfc4582bis-16" 
number="8855" 
obsoletes="4582" 
updates="" 
submissionType="IETF" 
xml:lang="en" 
tocInclude="true" 
tocDepth="4" 
symRefs="false" 
sortRefs="true" 
version="3">

  <!-- xml2rfc v2v3 conversion 2.35.0 -->
  <front>
    <title abbrev="BFCP">The Binary Floor Control Protocol (BFCP)</title>
    <seriesInfo name="RFC" value="8855" /> 
    <author initials="G." surname="Camarillo" fullname="Gonzalo Camarillo">
      <organization>Ericsson</organization>
      <address>
        <postal>
          <street>Hirsalantie 11</street>
          <code>02420</code><city>Jorvas</city>
          <country>Finland</country>
        </postal>
        <email>gonzalo.camarillo@ericsson.com</email>
      </address>
    </author>

    <author initials="K." surname="Drage" fullname="Keith Drage">
      <address>
        <postal>
        </postal>
        <email>drageke@ntlworld.com</email>
      </address>
    </author>

    <author fullname="Tom Kristensen" initials="T." surname="Kristensen">
      <organization abbrev="Jotron">Jotron AS</organization>
      <address>
        <postal>
          <street>Ringdalskogen 8</street>
          <code>3270</code> <city>Larvik</city>
          <country>Norway</country>
        </postal>
        <email>tom.kristensen@jotron.com, tomkri@ifi.uio.no</email>
      </address>
    </author>

    <author initials="J." surname="Ott" fullname="JÃ¶rg Ott">
      <organization>Technical University Munich</organization>
      <address>
        <postal>
          <street>Boltzmannstrasse 3</street>
          <code>85748</code><city>Garching</city>
          <country>Germany</country>
        </postal>
        <email>ott@in.tum.de</email>
      </address>
    </author>
    <author fullname="Charles Eckel" initials="C." surname="Eckel">
      <organization>Cisco</organization>
      <address>
        <postal>
          <street>707 Tasman Drive</street>
          <city>Milpitas</city>
          <region>California</region>
          <code>95035</code>
          <country>United States of America</country>
        </postal>
        <email>eckelcu@cisco.com</email>
      </address>
    </author>
    <date year="2021" month="January" />
    <area>Real-time Applications and Infrastructure</area>
    <workgroup>BFCPbis Working Group</workgroup>
    <keyword>floor control</keyword>
    <keyword>conference</keyword>
    <abstract>
      <t>Floor control is a means to manage joint or exclusive access to
      shared resources in a (multiparty) conferencing environment. Thereby,
      floor control complements other functions -- such as conference and
      media session setup, conference policy manipulation, and media control
      -- that are realized by other protocols.</t> 
      <t>This document specifies the Binary Floor Control Protocol
      (BFCP). BFCP is used between floor participants and floor control
      servers, and between floor chairs (i.e., moderators) and floor control
      servers.</t> 
      <t>This document obsoletes RFC 4582.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="sec_intro" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Within a conference, some applications need to manage the access to a set of shared resources, such as the right to send media to a particular media session. Floor control enables such applications to provide users with coordinated (shared or exclusive) access to these resources.</t>
      <t>The Requirements for Floor Control Protocol <xref target="RFC4376" format="default"/> list a set of requirements that need to be met by floor control protocols. The Binary Floor Control Protocol (BFCP), which is specified in this document, meets these requirements.</t>
      <t>In addition, BFCP has been designed so that it can be used in low-bandwidth environments. The binary encoding used by BFCP achieves a small message size (when message signatures are not used) that keeps the time it takes to transmit delay-sensitive BFCP messages to a minimum. Delay-sensitive BFCP messages include FloorRequest, FloorRelease, FloorRequestStatus, and ChairAction. It is expected that future extensions to these messages will not increase the size of these messages in a significant way.</t>
      <t>The remainder of this document is organized as follows: <xref
      target="sec_terminology" format="default"/> defines the terminology used
      throughout this document, <xref target="sec_scope" format="default"/>
      discusses the scope of BFCP (i.e., which tasks fall within the scope of
      BFCP and which ones are performed using different mechanisms), <xref
      target="sec_overview" format="default"/> provides a non-normative
      overview of BFCP operation. The subsequent sections provide the
      normative specification of BFCP. <xref target="sec_changes" />
      summarizes changes from <xref target="RFC4582"> RFC 4582</xref>.</t>
    </section>
    <section anchor="sec_terminology" numbered="true" toc="default">
      <name>Terminology</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
	<dl>
	  <dt>Media Participant:</dt> <dd>An entity that has access to the media resources of a conference (e.g., it can receive a media stream). In floor-controlled conferences, a given media participant is typically co-located with a floor participant, but it does not need to be. Third-party floor requests consist of having a floor participant request a floor for a media participant when they are not co-located. The protocol between a floor participant and a media participant (that are not co-located) is outside the scope of this document.</dd>
      <dt>Client:</dt> <dd>A floor participant or a floor chair that communicates with a floor control server using BFCP.</dd>
      <dt>Floor:</dt> <dd>A temporary permission to access or manipulate a specific shared resource or set of resources.</dd>
      <dt>Floor Chair:</dt> <dd>A logical entity that manages one floor (grants, denies, or revokes a floor). An entity that assumes the logical role of a floor chair for a given transaction may assume a different role (e.g., floor participant) for a different transaction. The roles of floor chair and floor participant are defined on a transaction-by-transaction basis. BFCP transactions are defined in <xref target="sec_transactions" format="default"/>.</dd>
      <dt>Floor Control:</dt> <dd>A mechanism that enables applications or users to gain safe and mutually exclusive or non-exclusive input access to the shared object or resource.</dd>
      <dt>Floor Control Server:</dt> <dd>A logical entity that maintains the state of the floor(s), including which floors exists, who the floor chairs are, who holds a floor, etc.  Requests to manipulate a floor are directed at the floor control server. The floor control server of a conference may perform other logical roles (e.g., floor participant) in another conference.</dd>
      <dt>Floor Participant:</dt> <dd>A logical entity that requests floors, and possibly information about them, from a floor control server. An entity that assumes the logical role of a floor participant for a given transaction may assume a different role (e.g., a floor chair) for a different transaction. The roles of floor participant and floor chair are defined on a transaction-by-transaction basis. BFCP transactions are defined in <xref target="sec_transactions" format="default"/>. In floor-controlled conferences, a given floor participant is typically co-located with a media participant, but it does not need to be. Third-party floor requests consist of having a floor participant request a floor for a media participant when they are not co-located.</dd>
      <dt>Participant:</dt> <dd>An entity that acts as a floor participant, as a media participant, or as both.</dd>
      <dt>BFCP Connection:</dt> <dd>A transport association between BFCP entities, used to exchange BFCP messages.</dd>
      <dt>Transaction Failure Window:</dt> <dd>When communicating over an
      unreliable transport, this is some period of time less than or equal to
      T1*2<sup>4</sup> (see <xref target="timers" format="default"/>). For
      reliable transports, this period of time is unbounded.</dd>
	</dl>
    </section>
    <section anchor="sec_scope" numbered="true" toc="default">
      <name>Scope</name>
      <t>As stated earlier, BFCP is a protocol to coordinate access to shared resources in a conference following the requirements defined in <xref target="RFC4376" format="default"/>.  Floor control complements other functions defined in the Centralized Conferencing (XCON) Framework <xref target="RFC5239" format="default"/>. The floor control protocol BFCP defined in this document only specifies a means to arbitrate access to floors.  The rules and constraints for floor arbitration and the results of floor assignments are outside the scope of this document and are defined by other protocols <xref target="RFC5239" format="default"/>.</t>
      <t><xref target="fig_arch" format="default"/> shows the tasks that BFCP can perform.</t>
      <figure anchor="fig_arch">
        <name>Functionality provided by BFCP</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
                           +---------+
                           |  Floor  |
                           |  Chair  |
                           |         |
                           +---------+
                              ^   |
                              |   |
                 Notification |   | Decision
                              |   |
                              |   |
                   Floor      |   v
+-------------+   Request  +---------+              +-------------+
|    Floor    |----------->|  Floor  | Notification |    Floor    |
| Participant |            | Control |------------->| Participant |
|             |<-----------|  Server |              |             |
+-------------+ Granted or +---------+              +-------------+
                  Denied ]]></artwork>
      </figure>
      <t>BFCP provides a means:</t>
      <ul spacing="normal">
        <li>for floor participants to send floor requests to floor control servers.</li>
        <li>for floor control servers to grant or deny requests to access a given resource from floor participants.</li>
        <li>for floor chairs to send floor control servers decisions regarding floor requests.</li>
        <li>for floor control servers to keep floor participants and floor chairs informed about the status of a given floor or a given floor request.</li>
      </ul>
      <t>Even though tasks that do not belong to the previous list are outside the scope of BFCP, some of these out-of-scope tasks relate to floor control and are essential for creating floors and establishing BFCP connections between different entities. In the following subsections, we discuss some of these tasks and mechanisms to perform them.</t>
      <section anchor="sec_scope_creation" numbered="true" toc="default">
        <name>Floor Creation</name>
        <t>The association of a given floor with a resource or a set of resources (e.g., media streams) is out of the scope of BFCP as described in <xref target="RFC5239" format="default"/>. Floor creation and termination are also outside the scope of BFCP; these aspects are handled using the conference control protocol for manipulating the conference object. Consequently, the floor control server needs to stay up to date on changes to the conference object (e.g., when a new floor is created).</t>
        <t>Conference control clients using Centralized Conferencing Manipulation Protocol (CCMP) <xref target="RFC6503" format="default"/> can specify such floor-related settings in the &lt;floor-information&gt; element <xref target="RFC6501" format="default"/> of the to-be created conference object provided in the body of a CCMP confRequest/create message issued to the conference control server.</t>
      </section>
      <section anchor="sec_scope_info" numbered="true" toc="default">
        <name>Obtaining Information to Contact a Floor Control Server</name>
        <t>A client needs a set of data in order to establish a BFCP connection to a floor control server. These data include the transport address of the server, the conference identifier, and a user identifier.</t>
        <t>Clients can obtain this information in different ways. One is to use a Session Description Protocol (SDP) offer/answer <xref target="RFC3264" format="default"/> exchange, which is described in <xref target="RFC8856" format="default"/>. How to establish a connection to a BFCP floor control server is outside the context of an offer/answer exchange when using a reliable transport is described in <xref target="RFC5018" format="default"/>. Other mechanisms are described in the XCON Framework <xref target="RFC5239" format="default"/> (and other related documents). For unreliable transports, the use of an SDP offer/answer exchange is the only specified mechanism.</t>
      </section>
      <section anchor="sec_scope_associations" numbered="true" toc="default">
        <name>Obtaining Floor-Resource Associations</name>
        <t>Floors are associated with resources. For example, a floor that controls who talks at a given time has a particular audio session as its associated resource. Associations between floors and resources are part of the conference object.</t>
        <t>Floor participants and floor chairs need to know which resources are associated with which floors. They can obtain this information by using different mechanisms, such as an SDP offer/answer <xref target="RFC3264" format="default"/> exchange. How to use an SDP offer/answer exchange to obtain these associations is described in <xref target="RFC8856" format="default"/>.</t>

        <aside>
          <t>Note that floor participants perform SDP offer/answer exchanges with the conference focus of the conference. So, the conference focus needs to obtain information about associations between floors and resources in order to be able to provide this information to a floor participant in an SDP offer/answer exchange.</t>
        </aside>
        <t>Other mechanisms for obtaining this information, including discussion of how the information is made available to a (SIP) focus, are described in the XCON Framework <xref target="RFC5239" format="default"/> (and other related documents). According to the conferencing system policies, conference control clients using CCMP <xref target="RFC6503" format="default"/> can modify the floor settings of a conference by issuing CCMP confRequest/update messages providing the specific updates to the &lt;floor-information&gt; element of the target conference object. More information about CCMP and BFCP interaction can be found in <xref target="RFC6504" format="default"/>.</t>
      </section>
      <section anchor="sec_scope_policy" numbered="true" toc="default">
        <name>Privileges of Floor Control</name>
        <t>A participant whose floor request is granted has the right to use the resource or resources associated with the floor that was requested. For example, the participant may have the right to send media over a particular audio stream.</t>
        <t>Nevertheless, holding a floor does not imply that others will not be able to use its associated resources at the same time, even if they do not have the right to do so. Determination of which media participants can actually use the resources in the conference is discussed in the XCON Framework <xref target="RFC5239" format="default"/>.</t>
      </section>
    </section>
    <section anchor="sec_overview" numbered="true" toc="default">
      <name>Overview of Operation</name>
      <t>This section provides a non-normative description of BFCP operations. <xref target="sec_overview_user" format="default"/> describes the interface between floor participants and floor control servers, and <xref target="sec_overview_chair" format="default"/> describes the interface between floor chairs and floor control servers.</t>
      <t>BFCP messages, which use a TLV (Type-Length-Value) binary encoding, consist of a COMMON-HEADER followed by a set of attributes. The COMMON-HEADER contains, among other information, a 32-bit conference identifier. Floor participants, media participants, and floor chairs are identified by 16-bit user identifiers.</t>
      <t>BFCP supports nested attributes (i.e., attributes that contain attributes). These are referred to as grouped attributes.</t>
      <t>There are two types of transactions in BFCP: client-initiated transactions and server-initiated transactions. <xref target="sec_transactions" format="default"/> describes both types of transactions in detail.</t>
      <section anchor="sec_overview_user" numbered="true" toc="default">
        <name>Floor Participant to Floor Control Server Interface</name>
        <t>Floor participants request a floor by sending a FloorRequest message to the floor control server. BFCP supports third-party floor requests. That is, the floor participant sending the floor request need not be co-located with the media participant that will get the floor once the floor request is granted. FloorRequest messages carry the identity of the requester in the User ID field of the COMMON-HEADER, and the identity of the beneficiary of the floor (in third-party floor requests) in a BENEFICIARY-ID attribute.</t>
        <aside>
          <t>Third-party floor requests can be sent, for example, by floor participants that have a BFCP connection to the floor control server but that are not media participants (i.e., they do not handle any media).</t>
        </aside>
        <t>FloorRequest messages identify the floor or floors being requested by carrying their 16-bit floor identifiers in FLOOR-ID attributes. If a FloorRequest message carries more than one floor identifier, the floor control server treats all the floor requests as an atomic package. That is, the floor control server either grants or denies all the floors in the FloorRequest message.</t>
        <t>Floor control servers respond to FloorRequest messages with FloorRequestStatus messages, which provide information about the status of the floor request. The first FloorRequestStatus message is the response to the FloorRequest message from the client, and therefore has the same Transaction ID as the FloorRequest.</t>
        <t>Additionally, the first FloorRequestStatus message carries the Floor Request ID in a FLOOR-REQUEST-INFORMATION attribute. Subsequent FloorRequestStatus messages related to the same floor request will carry the same Floor Request ID. This way, the floor participant can associate them with the appropriate floor request.</t>
        <t>Messages from the floor participant related to a particular floor request also use the same Floor Request ID as the first FloorRequestStatus message from the floor control server.</t>
        <t><xref target="fig_flow1" format="default"/> and <xref target="fig_flow2" format="default"/> show examples of call flows where BFCP is used over a reliable transport. <xref target="app_unrelcallflow" format="default"/> shows the same call flow examples using an unreliable transport.</t>
        <t><xref target="fig_flow1" format="default"/> shows how a floor participant requests a floor, obtains it, and, at a later time, releases it. This figure illustrates the use, among other things, of the Transaction ID and the FLOOR-REQUEST-ID attribute.</t>
        <figure anchor="fig_flow1">
          <name>Requesting and releasing a floor</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
   Floor Participant                                 Floor Control
                                                        Server
           |(1) FloorRequest                               |
           |Transaction ID: 123                            |
           |User ID: 234                                   |
           |FLOOR-ID: 543                                  |
           |---------------------------------------------->|
           |                                               |
           |(2) FloorRequestStatus                         |
           |Transaction ID: 123                            |
           |User ID: 234                                   |
           |FLOOR-REQUEST-INFORMATION                      |
           |      Floor Request ID: 789                    |
           |      OVERALL-REQUEST-STATUS                   |
           |              Request Status: Pending          |
           |      FLOOR-REQUEST-STATUS                     |
           |            Floor ID: 543                      |
           |<----------------------------------------------|
           |                                               |
           |(3) FloorRequestStatus                         |
           |Transaction ID: 0                              |
           |User ID: 234                                   |
           |FLOOR-REQUEST-INFORMATION                      |
           |      Floor Request ID: 789                    |
           |      OVERALL-REQUEST-STATUS                   |
           |              Request Status: Accepted         |
           |              Queue Position: 1st              |
           |      FLOOR-REQUEST-STATUS                     |
           |            Floor ID: 543                      |
           |<----------------------------------------------|
           |                                               |
           |(4) FloorRequestStatus                         |
           |Transaction ID: 0                              |
           |User ID: 234                                   |
           |FLOOR-REQUEST-INFORMATION                      |
           |      Floor Request ID: 789                    |
           |      OVERALL-REQUEST-STATUS                   |
           |              Request Status: Granted          |
           |      FLOOR-REQUEST-STATUS                     |
           |            Floor ID: 543                      |
           |<----------------------------------------------|
           |                                               |
           |(5) FloorRelease                               |
           |Transaction ID: 154                            |
           |User ID: 234                                   |
           |FLOOR-REQUEST-ID: 789                          |
           |---------------------------------------------->|
           |                                               |
           |(6) FloorRequestStatus                         |
           |Transaction ID: 154                            |
           |User ID: 234                                   |
           |FLOOR-REQUEST-INFORMATION                      |
           |      Floor Request ID: 789                    |
           |      OVERALL-REQUEST-STATUS                   |
           |              Request Status: Released         |
           |      FLOOR-REQUEST-STATUS                     |
           |            Floor ID: 543                      |
           |<----------------------------------------------|]]></artwork>
        </figure>
        <t><xref target="fig_flow2" format="default"/> shows how a floor participant requests to be informed on the status of a floor. The first FloorStatus message from the floor control server is the response to the FloorQuery message and, as such, has the same Transaction ID as the FloorQuery message.</t>
        <t>Subsequent FloorStatus messages consist of server-initiated transactions, and therefore their Transaction ID is 0 given this example uses a reliable transport. FloorStatus message (2) indicates that there are currently two floor requests for the floor whose Floor ID is 543. FloorStatus message (3) indicates that the floor requests with Floor Request ID 764 has been granted, and the floor request with Floor Request ID 635 is the first in the queue. FloorStatus message (4) indicates that the floor request with Floor Request ID 635 has been granted.</t>
        <figure anchor="fig_flow2">
          <name>Obtaining status information about a floor</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
   Floor Participant                                 Floor Control
                                                        Server
           |(1) FloorQuery                                 |
           |Transaction ID: 257                            |
           |User ID: 234                                   |
           |FLOOR-ID: 543                                  |
           |---------------------------------------------->|
           |                                               |
           |(2) FloorStatus                                |
           |Transaction ID: 257                            |
           |User ID: 234                                   |
           |FLOOR-ID:543                                   |
           |FLOOR-REQUEST-INFORMATION                      |
           |      Floor Request ID: 764                    |
           |      OVERALL-REQUEST-STATUS                   |
           |              Request Status: Accepted         |
           |              Queue Position: 1st              |
           |      FLOOR-REQUEST-STATUS                     |
           |            Floor ID: 543                      |
           |      BENEFICIARY-INFORMATION                  |
           |                  Beneficiary ID: 124          |
           |FLOOR-REQUEST-INFORMATION                      |
           |      Floor Request ID: 635                    |
           |      OVERALL-REQUEST-STATUS                   |
           |              Request Status: Accepted         |
           |              Queue Position: 2nd              |
           |      FLOOR-REQUEST-STATUS                     |
           |            Floor ID: 543                      |
           |      BENEFICIARY-INFORMATION                  |
           |                  Beneficiary ID: 154          |
           |<----------------------------------------------|
           |                                               |
           |(3) FloorStatus                                |
           |Transaction ID: 0                              |
           |User ID: 234                                   |
           |FLOOR-ID:543                                   |
           |FLOOR-REQUEST-INFORMATION                      |
           |      Floor Request ID: 764                    |
           |      OVERALL-REQUEST-STATUS                   |
           |              Request Status: Granted          |
           |      FLOOR-REQUEST-STATUS                     |
           |            Floor ID: 543                      |
           |      BENEFICIARY-INFORMATION                  |
           |                  Beneficiary ID: 124          |
           |FLOOR-REQUEST-INFORMATION                      |
           |      Floor Request ID: 635                    |
           |      OVERALL-REQUEST-STATUS                   |
           |              Request Status: Accepted         |
           |              Queue Position: 1st              |
           |      FLOOR-REQUEST-STATUS                     |
           |            Floor ID: 543                      |
           |      BENEFICIARY-INFORMATION                  |
           |                  Beneficiary ID: 154          |
           |<----------------------------------------------|
           |                                               |
           |(4) FloorStatus                                |
           |Transaction ID: 0                              |
           |User ID: 234                                   |
           |FLOOR-ID:543                                   |
           |FLOOR-REQUEST-INFORMATION                      |
           |      Floor Request ID: 635                    |
           |      OVERALL-REQUEST-STATUS                   |
           |              Request Status: Granted          |
           |      FLOOR-REQUEST-STATUS                     |
           |            Floor ID: 543                      |
           |      BENEFICIARY-INFORMATION                  |
           |                  Beneficiary ID: 154          |
           |<----------------------------------------------|]]></artwork>
        </figure>
        <t>FloorStatus messages contain information about the floor requests
      they carry. For example, FloorStatus message (4) indicates that the
      floor request with Floor Request ID 635 has as the beneficiary (i.e.,
      the participant that holds the floor when a particular floor request is
      granted) the participant whose User ID is 154. The floor request applies
      only to the floor whose Floor ID is 543. That is, this is not a
      multi-floor floor request.</t>
        <aside>
          <t>A multi-floor floor request applies to more than one floor (e.g., a participant wants to be able to speak and write on the whiteboard at the same time). The floor control server treats a multi-floor floor request as an atomic package. That is, the floor control server either grants the request for all floors or denies the request for all floors.</t>
        </aside>
      </section>
      <section anchor="sec_overview_chair" numbered="true" toc="default">
        <name>Floor Chair to Floor Control Server Interface</name>
        <t><xref target="fig_flow3" format="default"/> shows a floor chair instructing a floor control server to grant a floor.</t>
        <aside>
          <t>Note, however, that although the floor control server needs to take into consideration the instructions received in ChairAction messages (e.g., granting a floor), it does not necessarily need to perform them exactly as requested by the floor chair. The operation that the floor control server performs depends on the ChairAction message and on the internal state of the floor control server.</t>
        </aside>
        <t>For example, a floor chair may send a ChairAction message granting a floor that was requested as part of an atomic floor request operation that involved several floors. Even if the chair responsible for one of the floors instructs the floor control server to grant the floor, the floor control server will not grant it until the chairs responsible for the other floors agree to grant them as well. In another example, a floor chair may instruct the floor control server to grant a floor to a participant. The floor control server needs to revoke the floor from its current holder before granting it to the new participant.</t>
        <t>So, the floor control server is ultimately responsible for keeping a coherent floor state using instructions from floor chairs as input to this state.</t>
        <figure anchor="fig_flow3">
          <name>Chair instructing the floor control server</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
   Floor Chair                                    Floor Control
                                                     Server
        |(1) ChairAction                                |
        |Transaction ID: 769                            |
        |User ID: 357                                   |
        |FLOOR-REQUEST-INFORMATION                      |
        |      Floor Request ID: 635                    |
        |      FLOOR-REQUEST-STATUS                     |
        |            Floor ID: 543                      |
        |            Request Status: Granted            |
        |---------------------------------------------->|
        |                                               |
        |(2) ChairActionAck                             |
        |Transaction ID: 769                            |
        |User ID: 357                                   |
        |<----------------------------------------------|]]></artwork>
        </figure>
      </section>
    </section>
    <section anchor="sec_format" numbered="true" toc="default">
      <name>Packet Format</name>
      <t>BFCP packets consist of a 12-octet COMMON-HEADER followed by attributes. All the protocol values <bcp14>MUST</bcp14> be sent in network byte order.</t>
      <section anchor="sec_format_common" numbered="true" toc="default">
        <name>COMMON-HEADER Format</name>
        <t>The following is the format of the COMMON-HEADER.</t>
        <figure anchor="fig_common">
          <name>COMMON-HEADER format</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Ver |R|F| Res |  Primitive    |        Payload Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Conference ID                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Transaction ID        |            User ID            |
+> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
|  | Fragment Offset (if F is set) | Fragment Length (if F is set) |
+> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|
+---- These fragment fields are never present
      when using reliable transports]]></artwork>
        </figure>
	<dl>
        <dt>Ver:</dt> <dd>This 3-bit field defines the version of BFCP to which this message adheres. This specification defines two versions: 1 and 2. The version field <bcp14>MUST</bcp14> be set to 1 when using BFCP over a reliable transport. The version field <bcp14>MUST</bcp14> be set to 2 when using BFCP over an unreliable transport.  If a floor control server receives a message with an unsupported version field value or a message with a version number that is not permitted with the transport over which it was received, the server <bcp14>MUST</bcp14> indicate it does not support the protocol version by sending an Error message with parameter value 12 (Unsupported Version).  Note that BFCP entities supporting only the <xref target="RFC4582" format="default"/> subset will not support this parameter value.</dd>

        <dt>R:</dt> <dd>The Transaction Responder (R) flag bit has relevance only for use of BFCP over an unreliable transport. When cleared, it indicates that this message is a request initiating a new transaction, and the Transaction ID that follows has been generated for this transaction. When set, it indicates that this message is a response to a previous request, and the Transaction ID that follows is the one associated with that request. When BFCP is used over a reliable transport, the flag has no significance and <bcp14>MUST</bcp14> be cleared by the sender and <bcp14>MUST</bcp14> be ignored by the receiver.</dd>
        <dt>F:</dt> <dd>The Fragmentation (F) flag bit has relevance only for use of BFCP over an unreliable transport. When cleared, the message is not fragmented. When set, it indicates that the message is a fragment of a large, fragmented BFCP message. (The optional fields Fragment Offset and Fragment Length described below are present only if the F flag is set).  When BFCP is used over a reliable transport, the flag has no significance and <bcp14>MUST</bcp14> be cleared by the sender, and the flag <bcp14>MUST</bcp14> be ignored by the receiver. In the latter case, the receiver should also ignore the Fragment Offset and Fragment Length fields when processing the COMMON-HEADER.
</dd>
        <dt>Res:</dt> <dd>The 3 bits in the reserved field <bcp14>MUST</bcp14> be set to zero by the sender of the message and <bcp14>MUST</bcp14> be ignored by the receiver.</dd>
        <dt>Primitive:</dt> <dd>This 8-bit field identifies the main purpose of the
	message. The following primitive values are defined:</dd>
      </dl>

        <table anchor="tab_primitives" align="center">
          <name>BFCP primitives</name>
          <thead>
            <tr>
              <th align="center">Value</th>
              <th align="left">Primitive</th>
              <th align="left">Direction</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">1</td>
              <td align="left">FloorRequest</td>
              <td align="left">P   -&gt;  S</td>
            </tr>
            <tr>
              <td align="center">2</td>
              <td align="left">FloorRelease</td>
              <td align="left">P   -&gt;  S</td>
            </tr>
            <tr>
              <td align="center">3</td>
              <td align="left">FloorRequestQuery</td>
              <td align="left">P   -&gt;  S ; Ch  -&gt;  S</td>
            </tr>
            <tr>
              <td align="center">4</td>
              <td align="left">FloorRequestStatus</td>
              <td align="left">P  &lt;-   S ; Ch &lt;-   S</td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="left">UserQuery</td>
              <td align="left">P   -&gt;  S ; Ch  -&gt;  S</td>
            </tr>
            <tr>
              <td align="center">6</td>
              <td align="left">UserStatus</td>
              <td align="left">P  &lt;-   S ; Ch &lt;-   S</td>
            </tr>
            <tr>
              <td align="center">7</td>
              <td align="left">FloorQuery</td>
              <td align="left">P   -&gt;  S ; Ch  -&gt;  S</td>
            </tr>
            <tr>
              <td align="center">8</td>
              <td align="left">FloorStatus</td>
              <td align="left">P  &lt;-   S ; Ch &lt;-   S</td>
            </tr>
            <tr>
              <td align="center">9</td>
              <td align="left">ChairAction</td>
              <td align="left">            Ch  -&gt;  S</td>
            </tr>
            <tr>
              <td align="center">10</td>
              <td align="left">ChairActionAck</td>
              <td align="left">            Ch &lt;-   S</td>
            </tr>
            <tr>
              <td align="center">11</td>
              <td align="left">Hello</td>
              <td align="left">P   -&gt;  S ; Ch  -&gt;  S</td>
            </tr>
            <tr>
              <td align="center">12</td>
              <td align="left">HelloAck</td>
              <td align="left">P  &lt;-   S ; Ch &lt;-   S</td>
            </tr>
            <tr>
              <td align="center">13</td>
              <td align="left">Error</td>
              <td align="left">P  &lt;-   S ; Ch &lt;-   S</td>
            </tr>
            <tr>
              <td align="center">14</td>
              <td align="left">FloorRequestStatusAck</td>
              <td align="left">P   -&gt;  S ; Ch  -&gt;  S</td>
            </tr>
            <tr>
              <td align="center">15</td>
              <td align="left">FloorStatusAck</td>
              <td align="left">P   -&gt;  S ; Ch  -&gt;  S</td>
            </tr>
            <tr>
              <td align="center">16</td>
              <td align="left">Goodbye</td>
              <td align="left">P   -&gt;  S ; Ch  -&gt;  S ; P  &lt;-   S ; Ch &lt;-   S</td>
            </tr>
            <tr>
              <td align="center">17</td>
              <td align="left">GoodbyeAck</td>
              <td align="left">P   -&gt;  S ; Ch  -&gt;  S ; P  &lt;-   S ; Ch &lt;-   S</td>
            </tr>
          </tbody>
          <tfoot>
            <tr>
              <td align="left" colspan="3"><t>S: Floor Control Server<br/>P: Floor Participant<br/>Ch: Floor Chair</t></td>
            </tr>
          </tfoot>
        </table>
        <t>
        </t>
	<dl>
        <dt>Payload Length:</dt> <dd>This 16-bit field contains the length of
	the message in 4-octet units, excluding the COMMON-HEADER. If a floor
	control server receives a message with an incorrect Payload Length
	field value, the receiving server <bcp14>MUST</bcp14> send an Error
	message with parameter value 13 (Incorrect Message Length) to indicate
	this and then discard the message.  Other entities that receive a
	message with an incorrect length <bcp14>MUST</bcp14> discard the
	message.</dd>
	</dl>
        <aside>
          <t>Note: BFCP is designed to achieve small message size, as explained in <xref target="sec_intro" format="default"/>, and BFCP entities are <bcp14>REQUIRED</bcp14> to keep the BFCP message size smaller than the size limited by the 16-bit Payload Length field. To convey information not strictly related to floor control, other protocols should be used, such as the XCON Framework (cf.&nbsp;<xref target="sec_scope" format="default"/>).</t>
        </aside>
	<dl>
        <dt>Conference ID:</dt> <dd>This 32-bit unsigned integer field identifies the conference to which the message belongs.  It is <bcp14>RECOMMENDED</bcp14> that the conference identifier be randomly chosen.  (Note that the use of predictable conference identifiers in conjunction with a nonsecure transport protocol makes BFCP susceptible to off-path data injection attacks, where an attacker can forge a request or response message.)</dd>
        <dt>Transaction ID:</dt> <dd>This field contains a 16-bit value that allows users to match a given message with its response (see <xref target="sec_transactions" format="default"/>).</dd>
        <dt>User ID:</dt> <dd>This field contains a 16-bit unsigned integer
	that uniquely identifies a participant within a conference.</dd>
	</dl>
        <aside>
          <t>The identity used by a participant in BFCP, which is carried in the User ID field, is generally mapped to the identity used by the same participant in the session establishment protocol (e.g., in SIP). The way this mapping is performed is outside the scope of this specification.</t>
        </aside>
	<dl>
        <dt>Fragment Offset:</dt> <dd>This optional field is present only if the F flag is set and contains a 16-bit value that specifies the number of 4-octet units contained in previous fragments, excluding the COMMON-HEADER.</dd>
        <dt>Fragment Length:</dt> <dd>This optional field is present only if
	the F flag is set and contains a 16-bit value that specifies the
	number of 4-octet units contained in this fragment, excluding the
	COMMON-HEADER.  BFCP entities that receive message fragments that,
	individually or collectively, exceed the Payload Length value
	<bcp14>MUST</bcp14> discard the message.  Additionally, if the
	receiver is a floor control server, it <bcp14>MUST</bcp14> also send an Error message
	with parameter value 13 (Incorrect Message Length)</dd>
	</dl>
      </section>
      <section anchor="sec_format_attributes" numbered="true" toc="default">
        <name>Attribute Format</name>
        <t>BFCP attributes are encoded in TLV (Type-Length-Value) format. Attributes are 32-bit aligned.</t>
        <figure anchor="sec_format_tlv">
          <name>Attribute format</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Type     |M|    Length     |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                                                               |
  /                       Attribute Contents                      /
  /                                                               /
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
        </figure>

	<dl>
        <dt>Type:</dt> <dd><t>This 7-bit field contains the type of the attribute. Each attribute, identified by its type, has a particular format. The attribute formats defined are:</t>
        <dl>
          <dt>Unsigned16:</dt> <dd>The contents of the attribute consist of a 16-bit unsigned integer.</dd>
          <dt>OctetString16:</dt> <dd>The contents of the attribute consist of 16 bits of arbitrary data.</dd>
          <dt>OctetString:</dt> <dd>The contents of the attribute consist of arbitrary data of variable length.</dd>
          <dt>Grouped:</dt> <dd>The contents of the attribute consist of a sequence of attributes.</dd>
        </dl></dd>
      </dl>
        <aside>
          <t>Note that extension attributes defined in the future may define new attribute formats.</t>
        </aside>

        <t>The following attribute types are defined:</t>
        <table anchor="tab_attributes" align="center">
          <name>BFCP attributes</name>
          <thead>
            <tr>
              <th align="center">Type</th>
              <th align="left">Attribute</th>
              <th align="left">Format</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">1</td>
              <td align="left">BENEFICIARY-ID</td>
              <td align="left">Unsigned16</td>
            </tr>
            <tr>
              <td align="center">2</td>
              <td align="left">FLOOR-ID</td>
              <td align="left">Unsigned16</td>
            </tr>
            <tr>
              <td align="center">3</td>
              <td align="left">FLOOR-REQUEST-ID</td>
              <td align="left">Unsigned16</td>
            </tr>
            <tr>
              <td align="center">4</td>
              <td align="left">PRIORITY</td>
              <td align="left">OctetString16</td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="left">REQUEST-STATUS</td>
              <td align="left">OctetString16</td>
            </tr>
            <tr>
              <td align="center">6</td>
              <td align="left">ERROR-CODE</td>
              <td align="left">OctetString</td>
            </tr>
            <tr>
              <td align="center">7</td>
              <td align="left">ERROR-INFO</td>
              <td align="left">OctetString</td>
            </tr>
            <tr>
              <td align="center">8</td>
              <td align="left">PARTICIPANT-PROVIDED-INFO</td>
              <td align="left">OctetString</td>
            </tr>
            <tr>
              <td align="center">9</td>
              <td align="left">STATUS-INFO</td>
              <td align="left">OctetString</td>
            </tr>
            <tr>
              <td align="center">10</td>
              <td align="left">SUPPORTED-ATTRIBUTES</td>
              <td align="left">OctetString</td>
            </tr>
            <tr>
              <td align="center">11</td>
              <td align="left">SUPPORTED-PRIMITIVES</td>
              <td align="left">OctetString</td>
            </tr>
            <tr>
              <td align="center">12</td>
              <td align="left">USER-DISPLAY-NAME</td>
              <td align="left">OctetString</td>
            </tr>
            <tr>
              <td align="center">13</td>
              <td align="left">USER-URI</td>
              <td align="left">OctetString</td>
            </tr>
            <tr>
              <td align="center">14</td>
              <td align="left">BENEFICIARY-INFORMATION</td>
              <td align="left">Grouped</td>
            </tr>
            <tr>
              <td align="center">15</td>
              <td align="left">FLOOR-REQUEST-INFORMATION</td>
              <td align="left">Grouped</td>
            </tr>
            <tr>
              <td align="center">16</td>
              <td align="left">REQUESTED-BY-INFORMATION</td>
              <td align="left">Grouped</td>
            </tr>
            <tr>
              <td align="center">17</td>
              <td align="left">FLOOR-REQUEST-STATUS</td>
              <td align="left">Grouped</td>
            </tr>
            <tr>
              <td align="center">18</td>
              <td align="left">OVERALL-REQUEST-STATUS</td>
              <td align="left">Grouped</td>
            </tr>
          </tbody>
        </table>
	<dl>
        <dt>M:</dt> <dd>The 'M' bit, known as the Mandatory bit, indicates whether support of the attribute is <bcp14>REQUIRED</bcp14>.  If a floor control server receives an unrecognized attribute with the 'M' bit set, the server <bcp14>MUST</bcp14> send an Error message with parameter value 4 (Unknown Mandatory Attribute) to indicate this. The 'M' bit is significant for extension attributes defined in other documents only. All attributes specified in this document <bcp14>MUST</bcp14> be understood by the receiver so that the setting of the 'M' bit is irrelevant for these.  Unrecognized attributes, such as those that might be specified in future extensions, that do not have the 'M' bit set are ignored, but the message is processed.</dd>
        <dt>Length:</dt> <dd>This 8-bit field contains the length of the attribute in octets, excluding any padding defined for specific attributes.  The length of attributes that are not grouped includes the Type, 'M' bit, and Length fields. The Length in grouped attributes is the length of the grouped attribute itself (including Type, 'M' bit, and Length fields) plus the total length (including padding) of all the included attributes.</dd>
        <dt>Attribute Contents:</dt> <dd>The contents of the different
	attributes are defined in the following sections.</dd>
	</dl>

        <section anchor="sec_format_attributes_beneficiaryid" numbered="true" toc="default">
          <name>BENEFICIARY-ID</name>
          <t>The following is the format of the BENEFICIARY-ID attribute.</t>
          <figure anchor="sec_format_beneficiary-id">
            <name>BENEFICIARY-ID format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 0 0 0 1|M|0 0 0 0 0 1 0 0|        Beneficiary ID         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	  <dl>
          <dt>Beneficiary ID:</dt> <dd>This field contains a 16-bit value that
	  uniquely identifies a user within a conference.</dd>
	  </dl>
          <aside>
            <t>Note that although the formats of the Beneficiary ID and of the User ID field in the COMMON-HEADER are similar, their semantics are different. The Beneficiary ID is used in third-party floor requests and to request information about a particular participant.</t>
          </aside>
        </section>
        <section anchor="sec_format_attributes_floorid" numbered="true" toc="default">
          <name>FLOOR-ID</name>
          <t>The following is the format of the FLOOR-ID attribute.</t>
          <figure anchor="sec_format_floor-id">
            <name>FLOOR-ID format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 0 0 1 0|M|0 0 0 0 0 1 0 0|           Floor ID            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	  <dl>
          <dt>Floor ID:</dt> <dd>This field contains a 16-bit value that
	  uniquely identifies a floor within a conference.</dd>
	  </dl>
        </section>
        <section anchor="sec_format_attributes_floorrequestid" numbered="true" toc="default">
          <name>FLOOR-REQUEST-ID</name>
          <t>The following is the format of the FLOOR-REQUEST-ID attribute.</t>
          <figure anchor="sec_format_floor-request-id">
            <name>FLOOR-REQUEST-ID format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 0 0 1 1|M|0 0 0 0 0 1 0 0|       Floor Request ID        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	  <dl>
          <dt>Floor Request ID:</dt> <dd>This field contains a 16-bit value
	  that identifies a floor request at the floor control server.</dd>
	  </dl>
        </section>
        <section anchor="sec_format_attributes_priority" numbered="true" toc="default">
          <name>PRIORITY</name>
          <t>The following is the format of the PRIORITY attribute.</t>
          <figure anchor="sec_format_priority">
            <name>PRIORITY format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 0 1 0 0|M|0 0 0 0 0 1 0 0|Prio |         Reserved        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	  <dl>
          <dt>Prio:</dt> <dd>This field contains a 3-bit Priority value, as
	  shown in <xref target="tab_priority" format="default"/>. Senders
	  <bcp14>SHOULD NOT</bcp14> use values higher than 4 in this
	  field. Receivers <bcp14>MUST</bcp14> treat values higher than 4 as
	  if the value received were 4 (Highest). The default Priority value
	  when the PRIORITY attribute is missing is 2 (Normal).</dd>
	  </dl>
          <table anchor="tab_priority" align="center">
            <name>Priority values</name>
            <thead>
              <tr>
                <th align="center">Value</th>
                <th align="left">Priority</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">0</td>
                <td align="left">Lowest</td>
              </tr>
              <tr>
                <td align="center">1</td>
                <td align="left">Low</td>
              </tr>
              <tr>
                <td align="center">2</td>
                <td align="left">Normal</td>
              </tr>
              <tr>
                <td align="center">3</td>
                <td align="left">High</td>
              </tr>
              <tr>
                <td align="center">4</td>
                <td align="left">Highest</td>
              </tr>
            </tbody>
          </table>
	  <dl>
          <dt>Reserved:</dt> <dd>The 13 bits in the reserved field <bcp14>MUST</bcp14> be set to zero by the sender of the message and <bcp14>MUST</bcp14> be ignored by the receiver.</dd>
	  </dl>
        </section>
        <section anchor="sec_format_attributes_req-status" numbered="true" toc="default">
          <name>REQUEST-STATUS</name>
          <t>The following is the format of the REQUEST-STATUS attribute.</t>
          <figure anchor="sec_format_request-status">
            <name>REQUEST-STATUS format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 0 1 0 1|M|0 0 0 0 0 1 0 0|Request Status |Queue Position |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	<dl>
          <dt>Request Status:</dt> <dd>This 8-bit field contains the status of the request, as described in the following table.</dd></dl>

          <table anchor="tab_requeststatusvalues" align="center">
            <name>Request Status values</name>
            <thead>
              <tr>
                <th align="center">Value</th>
                <th align="left">Status</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">1</td>
                <td align="left">Pending</td>
              </tr>
              <tr>
                <td align="center">2</td>
                <td align="left">Accepted</td>
              </tr>
              <tr>
                <td align="center">3</td>
                <td align="left">Granted</td>
              </tr>
              <tr>
                <td align="center">4</td>
                <td align="left">Denied</td>
              </tr>
              <tr>
                <td align="center">5</td>
                <td align="left">Cancelled</td>
              </tr>
              <tr>
                <td align="center">6</td>
                <td align="left">Released</td>
              </tr>
              <tr>
                <td align="center">7</td>
                <td align="left">Revoked</td>
              </tr>
            </tbody>
          </table>
	  <dl>
          <dt>Queue Position:</dt> <dd>This 8-bit field contains, when
	  applicable, the position of the floor request in the floor request
	  queue at the server. If the Request Status value is different from
	  Accepted, if the floor control server does not implement a floor
	  request queue, or if the floor control server does not want to
	  provide the client with this information, all the bits of this field
	  <bcp14>SHOULD</bcp14> be set to zero.</dd>
	  </dl>
          <t>A floor request is in Pending state if the floor control server needs to contact a floor chair in order to accept the floor request, but has not done it yet. Once the floor control chair accepts the floor request, the floor request is moved to the Accepted state.</t>
        </section>
        <section anchor="sec_format_attributes_error-code" numbered="true" toc="default">
          <name>ERROR-CODE</name>
          <t>The following is the format of the ERROR-CODE attribute.</t>
          <figure anchor="sec_format_error">
            <name>ERROR-CODE format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 0 1 1 0|M|    Length     |  Error Code   |               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
  |                                                               |
  |                     Error Specific Details                    |
  /                                                               /
  /                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                               |            Padding            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	  <dl>
          <dt>Error Code:</dt> <dd>This 8-bit field contains an error code
	  from the following table. If an error code is not recognized by the
	  receiver, then the receiver <bcp14>MUST</bcp14> assume that an error
	  exists, and therefore that the original message that triggered the
	  Error message to be sent is processed, but the nature of the error
	  is unclear.</dd>
	  </dl>

          <table anchor="tab_errorcode" align="center">
            <name>Error Code meaning</name>
            <thead>
              <tr>
                <th align="center">Value</th>
                <th align="left">Meaning</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">1</td>
                <td align="left">Conference Does Not Exist</td>
              </tr>
              <tr>
                <td align="center">2</td>
                <td align="left">User Does Not Exist</td>
              </tr>
              <tr>
                <td align="center">3</td>
                <td align="left">Unknown Primitive</td>
              </tr>
              <tr>
                <td align="center">4</td>
                <td align="left">Unknown Mandatory Attribute</td>
              </tr>
              <tr>
                <td align="center">5</td>
                <td align="left">Unauthorized Operation</td>
              </tr>
              <tr>
                <td align="center">6</td>
                <td align="left">Invalid Floor ID</td>
              </tr>
              <tr>
                <td align="center">7</td>
                <td align="left">Floor Request ID Does Not Exist</td>
              </tr>
              <tr>
                <td align="center">8</td>
                <td align="left">You have Already Reached the Maximum Number of Ongoing Floor Requests for This Floor</td>
              </tr>
              <tr>
                <td align="center">9</td>
                <td align="left">Use TLS</td>
              </tr>
              <tr>
                <td align="center">10</td>
                <td align="left">Unable to Parse Message</td>
              </tr>
              <tr>
                <td align="center">11</td>
                <td align="left">Use DTLS</td>
              </tr>
              <tr>
                <td align="center">12</td>
                <td align="left">Unsupported Version</td>
              </tr>
              <tr>
                <td align="center">13</td>
                <td align="left">Incorrect Message Length</td>
              </tr>
              <tr>
                <td align="center">14</td>
                <td align="left">Generic Error</td>
              </tr>
            </tbody>
          </table>
          <aside>
            <t>Note: The Generic Error error code is intended to be used when an error occurs and the other specific error codes do not apply.</t>
          </aside>
	  <dl>
          <dt>Error Specific Details:</dt> <dd>Present only for certain error codes. In this document, this field is present only for Error Code 4 (Unknown Mandatory Attribute). See <xref target="sec_format_attributes_error-code_specific-4" format="default"/> for its definition.</dd>
          <dt>Padding:</dt> <dd><t>One, two, or three octets of padding added so that the contents of the ERROR-CODE attribute is 32-bit aligned. If the attribute is already 32-bit aligned, no padding is needed.</t>
          <t>The Padding bits <bcp14>MUST</bcp14> be set to zero by the sender and <bcp14>MUST</bcp14> be ignored by the receiver.</t></dd>
	</dl>

          <section anchor="sec_format_attributes_error-code_specific-4" numbered="true" toc="default">
            <name>Error Specific Details for Error Code 4</name>
            <t>The following is the format of the Error Specific Details field for Error Code 4.</t>
            <figure anchor="sec_format_unknown-tlvs">
              <name>Unknown attributes format</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Unknown Type|R| Unknown Type|R| Unknown Type|R| Unknown Type|R|
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  /                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                               | Unknown Type|R| Unknown Type|R|
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Unknown Type|R| Unknown Type|R|
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            </figure>

<dl><dt>Unknown Type:</dt> <dd>These 7-bit fields contain the Types of the attributes (which were present in the message that triggered the Error message) that were unknown to the receiver.</dd>

            <dt>Reserved (R):</dt> <dd>This bit is reserved. It <bcp14>MUST</bcp14> be
	    set to zero by the sender of the message and <bcp14>MUST</bcp14>
	    be ignored by the receiver.</dd>
</dl>
          </section>
        </section>
        <section anchor="sec_format_attributes_error-info" numbered="true" toc="default">
          <name>ERROR-INFO</name>
          <t>The following is the format of the ERROR-INFO attribute.</t>
          <figure anchor="sec_format_error-info">
            <name>ERROR-INFO format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 0 1 1 1|M|    Length     |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                                                               |
  /                             Text                              /
  /                                               +-+-+-+-+-+-+-+-+
  |                                               |    Padding    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
       <dl><dt>Text:</dt> <dd><t>This field contains UTF-8 encoded text <xref target="RFC3629" format="default"/>.</t>
          <t>In some situations, the contents of the Text field may be generated by an automaton. If this automaton has information about the preferred language of the receiver of a particular ERROR-INFO attribute, it <bcp14>MAY</bcp14> use this language to generate the Text field.</t></dd>
          <dt>Padding:</dt> <dd>One, two, or three octets of padding added so
	  that the contents of the ERROR-INFO attribute is 32-bit aligned. The
	  Padding bits <bcp14>MUST</bcp14> be set to zero by the sender and
	  <bcp14>MUST</bcp14> be ignored by the receiver. If the attribute is
	  already 32-bit aligned, no padding is needed.</dd>
       </dl>
        </section>
        <section anchor="sec_format_attributes_human-read-info" numbered="true" toc="default">
          <name>PARTICIPANT-PROVIDED-INFO</name>
          <t>The following is the format of the PARTICIPANT-PROVIDED-INFO attribute.</t>
          <figure anchor="sec_format_human">
            <name>PARTICIPANT-PROVIDED-INFO format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 1 0 0 0|M|    Length     |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                                                               |
  /                             Text                              /
  /                                               +-+-+-+-+-+-+-+-+
  |                                               |    Padding    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>

       <dl><dt>Text:</dt> <dd>This field contains UTF-8 encoded text <xref target="RFC3629" format="default"/>.</dd>
          <dt>Padding:</dt> <dd>One, two, or three octets of padding added so
	  that the contents of the PARTICIPANT-PROVIDED-INFO attribute is
	  32-bit aligned. The Padding bits <bcp14>MUST</bcp14> be set to zero
	  by the sender and <bcp14>MUST</bcp14> be ignored by the receiver. If
	  the attribute is already 32-bit aligned, no padding is needed.</dd>
       </dl>
        </section>
        <section anchor="sec_format_attributes_status-info" numbered="true" toc="default">
          <name>STATUS-INFO</name>
          <t>The following is the format of the STATUS-INFO attribute.</t>
          <figure anchor="sec_format_status">
            <name>STATUS-INFO format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 1 0 0 1|M|    Length     |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                                                               |
  /                             Text                              /
  /                                               +-+-+-+-+-+-+-+-+
  |                                               |    Padding    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
       <dl><dt>Text:</dt> <dd><t>This field contains UTF-8 encoded text <xref target="RFC3629" format="default"/>.</t>
          <t>In some situations, the contents of the Text field may be generated by an automaton. If this automaton has information about the preferred language of the receiver of a particular STATUS-INFO attribute, it <bcp14>MAY</bcp14> use this language to generate the Text field.</t></dd>
          <dt>Padding:</dt> <dd>One, two, or three octets of padding added so
	  that the contents of the STATUS-INFO attribute is 32-bit
	  aligned. The Padding bits <bcp14>MUST</bcp14> be set to zero by the
	  sender and <bcp14>MUST</bcp14> be ignored by the receiver. If the
	  attribute is already 32-bit aligned, no padding is needed.</dd>
       </dl>
        </section>
        <section anchor="sec_format_attributes_supported-tlvs" numbered="true" toc="default">
          <name>SUPPORTED-ATTRIBUTES</name>
          <t>The following is the format of the SUPPORTED-ATTRIBUTES attribute.</t>
          <figure anchor="fig_format_supported-tlvs">
            <name>SUPPORTED-ATTRIBUTES format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 1 0 1 0|M|    Length     | Supp. Attr. |R| Supp. Attr. |R|
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Supp. Attr. |R| Supp. Attr. |R| Supp. Attr. |R| Supp. Attr. |R|
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  /                                                               /
  /                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                               |            Padding            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
        <dl><dt>Supp.&nbsp;Attr.:</dt> <dd>These fields contain the 
BFCP attribute types that are supported by the floor control server.
See <xref target="tab_attributes" format="default"/> for the list
of BFCP attributes.</dd>
          <dt>Reserved (R):</dt> <dd>This bit <bcp14>MUST</bcp14> be set to zero upon transmission and <bcp14>MUST</bcp14> be ignored upon reception.</dd>
          <dt>Padding:</dt> <dd><t>One, two, or three octets of padding added so that the contents of the SUPPORTED-ATTRIBUTES attribute is 32-bit aligned. If the attribute is already 32-bit aligned, no padding is needed.</t>
          <t>The Padding bits <bcp14>MUST</bcp14> be set to zero by the sender
	  and <bcp14>MUST</bcp14> be ignored by the receiver.</t></dd>
	</dl>
        </section>
        <section anchor="sec_format_attributes_supported-reqs" numbered="true" toc="default">
          <name>SUPPORTED-PRIMITIVES</name>
          <t>The following is the format of the SUPPORTED-PRIMITIVES attribute.</t>
          <figure anchor="fig_format_supported-reqs">
            <name>SUPPORTED-PRIMITIVES format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 1 0 1 1|M|    Length     |   Primitive   |   Primitive   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Primitive   |   Primitive   |   Primitive   |   Primitive   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  /                                                               /
  /                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                               |            Padding            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
        <dl><dt>Primitive:</dt> <dd>These fields contain the types of the BFCP messages that are supported by the floor control server. See <xref target="tab_primitives" format="default"/> for the list of BFCP primitives.</dd>
          <dt>Padding:</dt> <dd><t>One, two, or three octets of padding added so that the contents of the SUPPORTED-PRIMITIVES attribute is 32-bit aligned. If the attribute is already 32-bit aligned, no padding is needed.</t>
          <t>The Padding bits <bcp14>MUST</bcp14> be set to zero by the sender
	  and <bcp14>MUST</bcp14> be ignored by the receiver.</t></dd>
	</dl>
        </section>
        <section anchor="sec_format_attributes_user-display-name" numbered="true" toc="default">
          <name>USER-DISPLAY-NAME</name>
          <t>The following is the format of the USER-DISPLAY-NAME attribute.</t>
          <figure anchor="sec_format_user-display">
            <name>USER-DISPLAY-NAME format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 1 1 0 0|M|    Length     |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                                                               |
  /                             Text                              /
  /                                               +-+-+-+-+-+-+-+-+
  |                                               |    Padding    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
        <dl><dt>Text:</dt> <dd>This field contains the UTF-8 encoded name of the user.</dd>
          <dt>Padding:</dt> <dd>One, two, or three octets of padding added so
	  that the contents of the USER-DISPLAY-NAME attribute is 32-bit
	  aligned. The Padding bits <bcp14>MUST</bcp14> be set to zero by the
	  sender and <bcp14>MUST</bcp14> be ignored by the receiver. If the
	  attribute is already 32-bit aligned, no padding is needed.</dd>
	</dl>
        </section>
        <section anchor="sec_format_attributes_user-uri" numbered="true" toc="default">
          <name>USER-URI</name>
          <t>The following is the format of the USER-URI attribute.</t>
          <figure anchor="sec_format_user-uri">
            <name>USER-URI format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 1 1 0 1|M|    Length     |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                                                               |
  /                             Text                              /
  /                                               +-+-+-+-+-+-+-+-+
  |                                               |    Padding    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	  <dl>
          <dt>Text:</dt> <dd>This field contains the UTF-8 encoded user's contact URI, that is, the URI used by the user to set up the resources (e.g., media streams) that are controlled by BFCP. For example, in the context of a conference set up by SIP, the USER-URI attribute would carry the SIP URI of the user.</dd></dl>
          <aside>
            <t>Messages containing a user's URI in a USER-URI attribute also contain the user's User ID. This way, a client receiving such a message can correlate the user's URI (e.g., the SIP URI the user used to join a conference) with the user's User ID.</t>
          </aside>
	<dl>
          <dt>Padding:</dt> <dd>One, two, or three octets of padding added so
	  that the contents of the USER-URI attribute is 32-bit aligned. The
	  Padding bits <bcp14>MUST</bcp14> be set to zero by the sender and
	  <bcp14>MUST</bcp14> be ignored by the receiver. If the attribute is
	  already 32-bit aligned, no padding is needed.</dd>
	</dl>
        </section>
        <section anchor="sec_format_attributes_ben-info" numbered="true" toc="default">
          <name>BENEFICIARY-INFORMATION</name>
          <t>The BENEFICIARY-INFORMATION attribute is a grouped attribute that consists of a header, which is referred to as BENEFICIARY-INFORMATION-HEADER, followed by a sequence of attributes. The following is the format of the BENEFICIARY-INFORMATION-HEADER:</t>
          <figure anchor="fig_format_ben-information-header">
            <name>BENEFICIARY-INFORMATION-HEADER format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 1 1 1 0|M|    Length     |        Beneficiary ID         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	  <dl>
          <dt>Beneficiary ID:</dt> <dd>This field contains a 16-bit value that uniquely identifies a user within a conference.</dd></dl>
          <t>The following is the ABNF (Augmented Backus-Naur Form) <xref
	  target="RFC5234" format="default"/> of the BENEFICIARY-INFORMATION
	  grouped attribute. (EXTENSION-ATTRIBUTE refers to extension
	  attributes that may be defined in the future.)</t>

          <figure anchor="fig_ben-information">
            <name>BENEFICIARY-INFORMATION format</name>
            <sourcecode name="" type="abnf"><![CDATA[
BENEFICIARY-INFORMATION =  BENEFICIARY-INFORMATION-HEADER
                           [USER-DISPLAY-NAME]
                           [USER-URI]
                          *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_format_attributes_floor-req-info" numbered="true" toc="default">
          <name>FLOOR-REQUEST-INFORMATION</name>
          <t>The FLOOR-REQUEST-INFORMATION attribute is a grouped attribute that consists of a header, which is referred to as FLOOR-REQUEST-INFORMATION-HEADER, followed by a sequence of attributes. The following is the format of the FLOOR-REQUEST-INFORMATION-HEADER:</t>
          <figure anchor="fig_format_request-information-header">
            <name>FLOOR-REQUEST-INFORMATION-HEADER format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 0 1 1 1 1|M|    Length     |       Floor Request ID        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	  <dl>
	    <dt>Floor Request ID:</dt> <dd>This field contains a 16-bit value
	    that identifies a floor request at the floor control server.</dd>
	  </dl>
          <t>The following is the ABNF of the FLOOR-REQUEST-INFORMATION
	  grouped attribute. (EXTENSION-ATTRIBUTE refers to extension
	  attributes that may be defined in the future.)</t>
          <figure anchor="fig_floor-request-information">
            <name>FLOOR-REQUEST-INFORMATION format</name>
            <sourcecode name="" type="abnf"><![CDATA[
FLOOR-REQUEST-INFORMATION =   FLOOR-REQUEST-INFORMATION-HEADER
                              [OVERALL-REQUEST-STATUS]     
                            1*FLOOR-REQUEST-STATUS
                              [BENEFICIARY-INFORMATION]
                              [REQUESTED-BY-INFORMATION]
                              [PRIORITY]
                              [PARTICIPANT-PROVIDED-INFO]
                             *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_format_attributes_req-by-info" numbered="true" toc="default">
          <name>REQUESTED-BY-INFORMATION</name>
          <t>The REQUESTED-BY-INFORMATION attribute is a grouped attribute that consists of a header, which is referred to as REQUESTED-BY-INFORMATION-HEADER, followed by a sequence of attributes. The following is the format of the REQUESTED-BY-INFORMATION-HEADER:</t>
          <figure anchor="fig_format_req-by-information-header">
            <name>REQUESTED-BY-INFORMATION-HEADER format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 1 0 0 0 0|M|    Length     |       Requested-by ID         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	  <dl>
          <dt>Requested-by ID:</dt> <dd>This field contains a 16-bit value
	  that uniquely identifies a user within a conference.</dd>
	  </dl>
          <t>The following is the ABNF of the REQUESTED-BY-INFORMATION grouped
	  attribute. (EXTENSION-ATTRIBUTE refers to extension attributes that
	  may be defined in the future.)</t>

          <figure anchor="fig_reqby-information">
            <name>REQUESTED-BY-INFORMATION format</name>
            <sourcecode name="" type="abnf"><![CDATA[
REQUESTED-BY-INFORMATION =  REQUESTED-BY-INFORMATION-HEADER
                            [USER-DISPLAY-NAME]
                            [USER-URI]
                           *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_format_attributes_floor-req-status" numbered="true" toc="default">
          <name>FLOOR-REQUEST-STATUS</name>
          <t>The FLOOR-REQUEST-STATUS attribute is a grouped attribute that consists of a header, which is referred to as FLOOR-REQUEST-STATUS-HEADER, followed by a sequence of attributes. The following is the format of the FLOOR-REQUEST-STATUS-HEADER:</t>
          <figure anchor="fig_format_floor-req-status-header">
            <name>FLOOR-REQUEST-STATUS-HEADER format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 1 0 0 0 1|M|    Length     |           Floor ID            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	  <dl>
          <dt>Floor ID:</dt> <dd>this field contains a 16-bit value that
	  uniquely identifies a floor within a conference.</dd>
	  </dl>
          <t>The following is the ABNF of the FLOOR-REQUEST-STATUS grouped attribute. (EXTENSION-ATTRIBUTE refers to extension attributes that may be defined in the future.)</t>
          <figure anchor="fig_floor-req-status">
            <name>FLOOR-REQUEST-STATUS format</name>
            <sourcecode name="" type="abnf"><![CDATA[
FLOOR-REQUEST-STATUS =  FLOOR-REQUEST-STATUS-HEADER
                        [REQUEST-STATUS]
                        [STATUS-INFO]
                       *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_format_attributes_overall-req-status" numbered="true" toc="default">
          <name>OVERALL-REQUEST-STATUS</name>
          <t>The OVERALL-REQUEST-STATUS attribute is a grouped attribute that consists of a header, which is referred to as OVERALL-REQUEST-STATUS-HEADER, followed by a sequence of attributes. The following is the format of the OVERALL-REQUEST-STATUS-HEADER:</t>
          <figure anchor="fig_format_overall-req-status-header">
            <name>OVERALL-REQUEST-STATUS-HEADER format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0 0 1 0 0 1 0|M|    Length     |       Floor Request ID        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
	<dl>
          <dt>Floor Request ID:</dt> <dd>This field contains a 16-bit value that identifies a floor request at the floor control server.</dd></dl>
          <t>The following is the ABNF of the OVERALL-REQUEST-STATUS grouped attribute. (EXTENSION-ATTRIBUTE refers to extension attributes that may be defined in the future.)</t>
          <figure anchor="fig_overall-req-status">
            <name>OVERALL-REQUEST-STATUS format</name>
            <sourcecode name="" type="abnf"><![CDATA[
OVERALL-REQUEST-STATUS =  OVERALL-REQUEST-STATUS-HEADER
                          [REQUEST-STATUS]
                          [STATUS-INFO]
                         *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
      </section>
      <section anchor="sec_msg_format" numbered="true" toc="default">
        <name>Message Format</name>
        <t>This section contains the normative ABNF (Augmented Backus-Naur Form) <xref target="RFC5234" format="default"/> of the BFCP messages. Extension attributes that may be defined in the future are referred to as EXTENSION-ATTRIBUTE in the ABNF.</t>
        <section anchor="sec_msg_format_FloorRequest" numbered="true" toc="default">
          <name>FloorRequest</name>
          <t>Floor participants request a floor by sending a FloorRequest message to the floor control server. The following is the format of the FloorRequest message:</t>
          <figure anchor="fig_floorequest">
            <name>FloorRequest format</name>
            <sourcecode name="" type="abnf"><![CDATA[
FloorRequest =   COMMON-HEADER
               1*FLOOR-ID
                 [BENEFICIARY-ID]
                 [PARTICIPANT-PROVIDED-INFO]
                 [PRIORITY]
                *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_FloorRelease" numbered="true" toc="default">
          <name>FloorRelease</name>
          <t>Floor participants release a floor by sending a FloorRelease message to the floor control server. Floor participants also use the FloorRelease message to cancel pending floor requests. The following is the format of the FloorRelease message:</t>
          <figure anchor="fig_floorelease">
            <name>FloorRelease format</name>
            <sourcecode name="" type="abnf"><![CDATA[
FloorRelease =  COMMON-HEADER
                FLOOR-REQUEST-ID
               *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_FloorRequestQuery" numbered="true" toc="default">
          <name>FloorRequestQuery</name>
          <t>Floor participants and floor chairs request information about a floor request by sending a FloorRequestQuery message to the floor control server. The following is the format of the FloorRequestQuery message:</t>
          <figure anchor="fig_floorrequestinfo">
            <name>FloorRequestQuery format</name>
            <sourcecode name="" type="abnf"><![CDATA[
FloorRequestQuery =  COMMON-HEADER
                     FLOOR-REQUEST-ID
                    *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_FloorRequestStatus" numbered="true" toc="default">
          <name>FloorRequestStatus</name>
          <t>The floor control server informs floor participants and floor chairs about the status of their floor requests by sending them FloorRequestStatus messages. The following is the format of the FloorRequestStatus message:</t>
          <figure anchor="fig_floorrequeststatus">
            <name>FloorRequestStatus format</name>
            <sourcecode name="" type="abnf"><![CDATA[
FloorRequestStatus =  COMMON-HEADER
                      FLOOR-REQUEST-INFORMATION
                     *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_UserQuery" numbered="true" toc="default">
          <name>UserQuery</name>
          <t>Floor participants and floor chairs request information about a participant and the floor requests related to this participant by sending a UserQuery message to the floor control server. The following is the format of the UserQuery message:</t>
          <figure anchor="fig_userinfowanted">
            <name>UserQuery format</name>
            <sourcecode name="" type="abnf"><![CDATA[
UserQuery =  COMMON-HEADER
             [BENEFICIARY-ID]
            *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_UserStatus" numbered="true" toc="default">
          <name>UserStatus</name>
          <t>The floor control server provides information about participants and their related floor requests to floor participants and floor chairs by sending them UserStatus messages. The following is the format of the UserStatus message:</t>
          <figure anchor="fig_userstatus">
            <name>UserStatus format</name>
            <sourcecode name="" type="abnf"><![CDATA[
UserStatus =  COMMON-HEADER
              [BENEFICIARY-INFORMATION]
             *FLOOR-REQUEST-INFORMATION
             *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_FloorQuery" numbered="true" toc="default">
          <name>FloorQuery</name>
          <t>Floor participants and floor chairs request information about a floor or floors by sending a FloorQuery message to the floor control server. The following is the format of the FloorQuery message:</t>
          <figure anchor="fig_floorinfo">
            <name>FloorQuery format</name>
            <sourcecode name="" type="abnf"><![CDATA[
FloorQuery =  COMMON-HEADER
             *FLOOR-ID
             *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_FloorStatus" numbered="true" toc="default">
          <name>FloorStatus</name>
          <t>The floor control server informs floor participants and floor chairs about the status (e.g., the current holder) of a floor by sending them FloorStatus messages. The following is the format of the FloorStatus message:</t>
          <figure anchor="fig_floorstatus">
            <name>FloorStatus format</name>
            <sourcecode name="" type="abnf"><![CDATA[
FloorStatus =  COMMON-HEADER
              *FLOOR-ID
              *FLOOR-REQUEST-INFORMATION
              *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_ChairAction" numbered="true" toc="default">
          <name>ChairAction</name>
          <t>Floor chairs send instructions to floor control servers by sending them ChairAction messages. The following is the format of the ChairAction message:</t>
          <figure anchor="fig_chairaction">
            <name>ChairAction format</name>
            <sourcecode name="" type="abnf"><![CDATA[
ChairAction =  COMMON-HEADER
               FLOOR-REQUEST-INFORMATION
              *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_ChairActionAck" numbered="true" toc="default">
          <name>ChairActionAck</name>
          <t>Floor control servers confirm that they have accepted a ChairAction message by sending a ChairActionAck message. The following is the format of the ChairActionAck message:</t>
          <figure anchor="fig_chairactionack">
            <name>ChairActionAck format</name>
            <sourcecode name="" type="abnf"><![CDATA[
ChairActionAck =  COMMON-HEADER
                 *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_Hello" numbered="true" toc="default">
          <name>Hello</name>
          <t>Floor participants and floor chairs <bcp14>MAY</bcp14> check the liveness of floor control servers by sending a Hello message.  Additionally, clients communicating with a floor control server over an unreliable transport use the Hello message to initiate communication with the server.  The following is the format of the Hello message:</t>
          <figure anchor="fig_hello">
            <name>Hello format</name>
            <sourcecode name="" type="abnf"><![CDATA[
Hello =  COMMON-HEADER
        *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_HelloAck" numbered="true" toc="default">
          <name>HelloAck</name>
          <t>Floor control servers confirm that they are alive on reception of a Hello message by sending a HelloAck message. The following is the format of the HelloAck message:</t>
          <figure anchor="fig_helloack">
            <name>HelloAck format</name>
            <sourcecode name="" type="abnf"><![CDATA[
HelloAck =  COMMON-HEADER
            SUPPORTED-PRIMITIVES
            SUPPORTED-ATTRIBUTES
           *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section anchor="sec_msg_format_Error" numbered="true" toc="default">
          <name>Error</name>
          <t>Floor control servers inform floor participants and floor chairs about errors processing requests by sending them Error messages. The following is the format of the Error message:</t>
          <figure anchor="fig_error">
            <name>Error format</name>
            <sourcecode name="" type="abnf"><![CDATA[
Error =  COMMON-HEADER
         ERROR-CODE
         [ERROR-INFO]
        *EXTENSION-ATTRIBUTE]]></sourcecode>
          </figure>
        </section>
        <section numbered="true" toc="default">
          <name>FloorRequestStatusAck</name>
          <t>When communicating over an unreliable transport, floor participants and chairs acknowledge the receipt of a subsequent FloorRequestStatus message from the floor control server (cf.&nbsp;<xref target="sec_server_request_subsequent" format="default"/>) by sending a FloorRequestStatusAck message. The following is the format of the FloorRequestStatusAck message:</t>
          <figure anchor="FloorRequestStatusAck">
            <name>FloorRequestStatusAck format</name>
            <sourcecode name="" type="abnf"><![CDATA[
FloorRequestStatusAck =  (COMMON-HEADER)
                        *EXTENSION-ATTRIBUTE ]]></sourcecode>
          </figure>
        </section>
        <section numbered="true" toc="default">
          <name>FloorStatusAck</name>
          <t>When communicating over an unreliable transport, floor participants and chairs acknowledge the receipt of a subsequent FloorStatus message from the floor control server (cf.&nbsp;<xref target="sec_server_floorinfo_subsequent" format="default"/>) by sending a FloorStatusAck message. The following is the format of the FloorStatusAck message:</t>
          <figure anchor="FloorStatusAck">
            <name>FloorStatusAck format</name>
            <sourcecode name="" type="abnf"><![CDATA[
FloorStatusAck =  (COMMON-HEADER)
                 *EXTENSION-ATTRIBUTE ]]></sourcecode>
          </figure>
        </section>
        <section numbered="true" toc="default">
          <name>Goodbye</name>
          <t>BFCP entities communicating over an unreliable transport that wish to dissociate themselves from their remote participant do so through the transmission of a Goodbye. The following is the format of the Goodbye message:</t>
          <figure anchor="Goodbye">
            <name>Goodbye format</name>
            <sourcecode name="" type="abnf"><![CDATA[
Goodbye =  (COMMON-HEADER)
          *EXTENSION-ATTRIBUTE ]]></sourcecode>
          </figure>
        </section>
        <section numbered="true" toc="default">
          <name>GoodbyeAck</name>
          <t>BFCP entities communicating over an unreliable transport acknowledge the receipt of a Goodbye message from a peer. The following is the format of the GoodbyeAck message:</t>
          <figure anchor="GoodbyeAck">
            <name>GoodbyeAck format</name>
            <sourcecode name="" type="abnf"><![CDATA[
GoodbyeAck =  (COMMON-HEADER)
             *EXTENSION-ATTRIBUTE ]]></sourcecode>
          </figure>
        </section>
      </section>
    </section>
    <section anchor="sec_transport" numbered="true" toc="default">
      <name>Transport</name>
      <t>The transport over which BFCP entities exchange messages depends on the information the clients obtain for contacting the floor control server, as described in <xref target="sec_scope_info" format="default"/>. Two transports are supported: TCP, which is appropriate where connectivity is not impeded by network elements such as NAT devices or media relays; and UDP for those deployments where TCP may not be applicable or appropriate.</t>
      <aside>
        <t>Note: In practice, products are configured to try one transport first and then use the other transport as a fallback. Whether TCP or UDP is chosen as underlying transport depends on the type of product and the deployment environment. See <xref target="app_motivation" format="default"/> for additional considerations.</t>
      </aside>
      <section anchor="tcp_transport" numbered="true" toc="default">
        <name>Reliable Transport</name>
        <t>BFCP entities may elect to exchange BFCP messages using TCP connections. TCP provides an in-order reliable delivery of a stream of bytes. Consequently, message framing needs to be implemented in the application layer. BFCP implements application-layer framing using TLV-encoded attributes.</t>
        <t>A client <bcp14>MUST NOT</bcp14> use more than one TCP connection to communicate with a given floor control server within a conference. Nevertheless, if the same physical box handles different clients (e.g., a floor chair and a floor participant), which are identified by different User IDs, a separate connection per client is allowed.</t>
        <t>If a BFCP entity (a client or a floor control server) receives data that cannot be parsed, the entity <bcp14>MUST</bcp14> close the TCP connection, and the connection <bcp14>SHOULD</bcp14> be reestablished. Similarly, if a TCP connection cannot deliver a BFCP message and times out or receives an ICMP port unreachable message mid-connection, the TCP connection <bcp14>SHOULD</bcp14> be reestablished.</t>
        <t>The way connection reestablishment is handled depends on how the client obtains information to contact the floor control server. Once the TCP connection is reestablished, the client <bcp14>MAY</bcp14> resend those messages for which it did not get a response from the floor control server.</t>
        <t>If a floor control server detects that the TCP connection towards one of the floor participants is lost, it is up to the local policy of the floor control server what to do with the pending floor requests of the floor participant. In any case, it is <bcp14>RECOMMENDED</bcp14> that the floor control server keep the floor requests (i.e., that it does not cancel them) while the TCP connection is reestablished.</t>
        <t>If a client wishes to end its BFCP connection with a floor control server, the client closes (i.e., a graceful close) the TCP connection towards the floor control server.  If a floor control server wishes to end its BFCP connection with a client (e.g., the focus of the conference informs the floor control server that the client has been kicked out of the conference), the floor control server closes (i.e., a graceful close) the TCP connection towards the client.</t>
        <t>In cases where a BFCP entity reestablishes a connection due to protocol errors as described above, the entity <bcp14>SHOULD NOT</bcp14> repeatedly reestablish the connection.  Rather, if the same protocol errors persist, the entity <bcp14>MUST</bcp14> cease attempts and <bcp14>SHOULD</bcp14> report the error to the human user and/or log the event.  This does not preclude the entity from reestablishing a connection when facing a different set of errors.  That said, entities <bcp14>MUST</bcp14> avoid overloading the server with reestablishment requests.  A connection <bcp14>MUST NOT</bcp14> be reestablished too frequently.  The frequency is a matter of implementation, but <bcp14>SHOULD NOT</bcp14> be attempted more than once in a 30 second period of time.</t>
      </section>
      <section anchor="udp_transport" numbered="true" toc="default">
        <name>Unreliable Transport</name>
        <t>BFCP entities may elect to exchange BFCP messages using UDP datagrams. UDP is an unreliable transport where neither delivery nor ordering is assured. Each BFCP UDP datagram <bcp14>MUST</bcp14> contain exactly one BFCP message or message fragment. To keep large BFCP messages from being fragmented at the IP layer, the fragmentation of BFCP messages that exceed the path MTU size is performed at the BFCP level. Considerations related to fragmentation are covered in <xref target="fragmentation_handling" format="default"/>. The message format for BFCP messages is the same regardless of whether the messages are sent in UDP datagrams or over a TCP stream.</t>
        <t>Clients <bcp14>MUST</bcp14> announce their presence to the floor control server by sending a Hello message. The floor control server responds to the Hello message with a HelloAck message. The client considers the floor control server as present and available only upon receiving the HelloAck message. The behavior when timers fire, including the determination that a connection is broken, is described in <xref target="timers" format="default"/>.</t>
        <t>As described in <xref target="sec_transactions" format="default"/>, each request sent by a floor participant or chair forms a client transaction that expects an acknowledgement message from the floor control server within a transaction failure window.   Concordantly, messages sent by the floor control server that initiate new transactions (e.g., FloorStatus announcements as part of a FloorQuery subscription) require acknowledgement messages from the floor participant and chair entities to which they were sent.</t>

        <t>If a floor control server receives data that cannot be parsed, the receiving server <bcp14>MUST</bcp14> send an Error message with parameter value 10 (Unable to Parse Message) indicating receipt of a malformed message, given that it is possible to parse the received message to such an extent that an Error message may be built.</t>
        <t>Entities <bcp14>MUST</bcp14> have at most one outstanding request transaction per peer at any one time.  Implicit subscriptions occur for a client-initiated request transaction whose acknowledgement is implied by the first server-initiated response for that transaction, followed by zero of more subsequent server-initiated messages corresponding to the same transaction. An example is a FloorRequest message for which there are potentially multiple responses from the floor control server as it processes intermediate states until a terminal state (e.g., Granted or Denied) is attained. The subsequent changes in state for the request are new transactions whose Transaction ID is determined by the floor control server and whose receipt by the client participant is acknowledged with a FloorRequestStatusAck message.</t>
        <t>By restricting entities to having at most one pending transaction open in a BFCP connection, both the out-of-order receipt of messages as well as the possibility for congestion are mitigated. Additional details regarding congestion control are provided in <xref target="congestion" format="default"/>. 
   If a participant receives a server-initiated request (e.g., a 
   FloorStatus from the floor control server) while waiting for a 
   response to a client-initiated transaction (e.g., the participant 
   sent a FloorRequest and is waiting for a FloorRequestStatus 
   response), then the participant <bcp14>MUST</bcp14> treat the server-initiated 
   request as superseding any response to its client-initiated 
   transaction. 
As the floor control server cannot send a second update to the implicit floor status subscription until the first is acknowledged, ordinality is maintained.</t>
        <t>If a client wishes to end its BFCP connection with a floor control server, it is <bcp14>REQUIRED</bcp14> that the client send a Goodbye message to dissociate itself from any allocated resources. If a floor control server wishes to end its BFCP connection with a client (e.g., the focus of the conference informs the floor control server that the client has been kicked out from the conference), it is <bcp14>REQUIRED</bcp14> that the floor control server send a Goodbye message towards the client.</t>
        <section anchor="congestion" numbered="true" toc="default">
          <name>Congestion Control</name>
          <t>BFCP may be characterized as generating "low data-volume" traffic, per the classification in <xref target="RFC8085" format="default"/>. Nevertheless, it is necessary to ensure that suitable and necessary congestion control mechanisms are used for BFCP over UDP. As described in <xref target="udp_transport" format="default"/>, within the same BFCP connection, every entity -- client or server -- is only allowed to send one request at a time, and await the acknowledging response. This way, at most one datagram is sent per RTT given the message is not lost during transmission. If the message is lost, the request retransmission timer T1 specified in <xref target="timers_retrans" format="default"/> will fire, and the message is retransmitted up to three times, in addition to the original transmission of the message. The default initial interval <bcp14>MUST</bcp14> be set to 500 ms, but is adjusted dynamically as described in <xref target="timers_retrans" format="default"/>.  The interval <bcp14>MUST</bcp14> be doubled after each retransmission attempt. This is similar to the specification of the timer A and its initial value T1 in SIP as described in <xref target="RFC3261" section="17.1.1.2" sectionFormat="of" format="default"/>, except that the value of T1 in this protocol is not fixed from one transaction to another.</t>
        </section>
        <section anchor="icmp" numbered="true" toc="default">
          <name>ICMP Error Handling</name>
          <t>ICMP is not usable when BFCP is running over an unreliable transport
due to risks associated with off-path attacks.  Any ICMP messages associated with BFCP running over an unreliable transport <bcp14>MUST</bcp14> be ignored.</t>
        </section>
        <section anchor="fragmentation_handling" numbered="true" toc="default">
          <name>Fragmentation Handling</name>
          <t>When using UDP, a single BFCP message could be fragmented at the IP layer if its overall size exceeds the path MTU of the network. To avoid this happening at the IP layer, a fragmentation scheme for BFCP is defined below.</t>
          <t>BFCP is designed for achieving small message size, due to the binary encoding as described in <xref target="sec_intro" format="default"/>. The fragmentation scheme is therefore deliberately kept simple and straightforward, since the probability of fragmentation of BFCP messages is small. By design, the fragmentation scheme does not acknowledge individual BFCP message fragments. The whole BFCP message is acknowledged if received completely.</t>
          <t>BFCP entities <bcp14>SHOULD</bcp14> consider the path MTU size
	  available between the sender and the receiver and <bcp14>MAY</bcp14>
	  run MTU discovery, such as described in <xref target="RFC1191"
	  format="default"/>, <xref target="RFC8201" format="default"/>, and <xref target="RFC4821" format="default"/>, for this purpose.</t>
          <t>When transmitting a BFCP message with a size greater than the path MTU, the sender <bcp14>MUST</bcp14> fragment the message into a series of N contiguous data ranges.  The size of each of these N messages <bcp14>MUST</bcp14> be smaller than the path MTU to help prevent fragmentation overlap attacks. The value for N is defined as ceil((message size -- COMMON-HEADER size) / (path MTU size -- COMMON-HEADER size)), where ceil is the integer ceiling function, and the COMMON-HEADER size includes the Fragment Offset and Fragment Length fields.  The sender then creates N BFCP fragment messages (one for each data range) with the same Transaction ID. The size of each of these N messages, with the COMMON-HEADER included, <bcp14>MUST</bcp14> be smaller than the path MTU. The F flag in the COMMON-HEADER in all the fragments is set to indicate fragmentation of the BFCP message.</t>
          <t>For each of these fragments, the Fragment Offset and Fragment Length fields are included in the COMMON-HEADER. The Fragment Offset field denotes the number of 4-octet units contained in the previous fragments, excluding the COMMON-HEADER. The Fragment Length contains the length of the fragment itself, also excluding the COMMON-HEADER. Note that the Payload Length field contains the length of the entire, unfragmented message.</t>
          <t>When a BFCP implementation receives a BFCP message fragment, it <bcp14>MUST</bcp14> buffer the fragment until either it has received the entire BFCP message, or until the Response Retransmission Timer expires. The state machine should handle the BFCP message only after all the fragments of the message have been received.</t>
          <t>If a fragment of a BFCP message is lost, the sender will not receive an acknowledgement for the message. Therefore the sender will retransmit the message with same transaction ID as specified in <xref target="timers" format="default"/>. If the acknowledgement message sent by the receiver is lost, then the entire message will be resent by the sender. The receiver <bcp14>MUST</bcp14> then retransmit the acknowledgement. The receiver <bcp14>MAY</bcp14> discard an incomplete buffer utilizing the Response Retransmission Timer, starting the timer after the receipt of the first fragment.</t>
          <aside>
            <t>A Denial of Service (DoS) attack utilizing the fragmentation scheme described above is mitigated by the fact that the Response Retransmission Timer is started after receipt of the first BFCP message fragment. In addition, the Payload Length field can be compared with the Fragment Offset and Fragment Length fields to verify the message fragments as they arrive. To make DoS attacks with spoofed IP addresses difficult, BFCP entities <bcp14>SHOULD</bcp14> use the cookie exchange mechanism in DTLS <xref target="RFC6347" format="default"/>.</t>
          </aside>
          <t>When deciding the size of the message fragment based on path MTU, the BFCP fragmentation handling should take into account how the DTLS record framing expands the datagram size as described in <xref target="RFC6347" section="4.1.1.1" sectionFormat="of" format="default"/>.</t>
        </section>
        <section anchor="nat_traversal" numbered="true" toc="default">
          <name>NAT Traversal</name>
          <t>One of the key benefits of using UDP for BFCP communication is the ability to leverage the existing NAT traversal infrastructure and strategies deployed to facilitate transport of the media associated with the video conferencing sessions. Depending on the given deployment, this infrastructure typically includes some subset of Interactive Connectivity Establishment (ICE) <xref target="RFC8445" format="default"/>.</t>
          <t>In order to facilitate the initial establishment of NAT bindings, and to maintain those bindings once established, BFCP entities using an unreliable transport are <bcp14>RECOMMENDED</bcp14> to use STUN <xref target="RFC5389" format="default"/> Binding Indication for keepalives, as described for ICE <xref target="RFC8445" format="default"/>. <xref target="RFC5763" section="6.7" sectionFormat="of" format="default"/> provides useful recommendations for middlebox interaction when DTLS is used.</t>
          <aside>
            <t>Note: Since the version number is set to 2 when BFCP is used over an unreliable transport, cf.&nbsp;the Ver field in <xref target="sec_format_common" format="default"/>, it is straightforward to distinguish between STUN and BFCP packets even without checking the STUN magic cookie <xref target="RFC5389" format="default"/>.</t>
          </aside>
          <t>In order to facilitate traversal of BFCP packets through NATs, BFCP entities using an unreliable transport are <bcp14>RECOMMENDED</bcp14> to use symmetric ports for sending and receiving BFCP packets, as recommended for RTP/RTP Control Protocol (RTCP) <xref target="RFC4961" format="default"/>.</t>
        </section>
      </section>
    </section>
    <section anchor="sec_lower-security" numbered="true" toc="default">
      <name>Lower-Layer Security</name>
      <t>BFCP relies on lower-layer security mechanisms to provide replay and integrity protection and confidentiality.  BFCP floor control servers and clients (which include both floor participants and floor chairs) <bcp14>MUST</bcp14> support TLS for transport over TCP <xref target="RFC8446" format="default"/> and <bcp14>MUST</bcp14> support DTLS <xref target="RFC6347" format="default"/> for transport over UDP. Any BFCP entity <bcp14>MAY</bcp14> support other security mechanisms.</t>
      <t>BFCP entities <bcp14>MUST</bcp14> support, at a minimum, the TLS_RSA_WITH_AES_128_CBC_SHA cipher suite <xref target="RFC5246" format="default"/> for backwards compatibility with existing implementations of RFC 4582. In accordance with the recommendations and guidelines in <xref target="RFC7525" format="default"/>, BFCP entities <bcp14>SHOULD</bcp14> support the following cipher suites:</t>
      <ul spacing="normal">
        <li>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</li>
        <li>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</li>
        <li>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</li>
        <li>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</li>
      </ul>
    </section>
    <section anchor="sec_transactions" numbered="true" toc="default">
      <name>Protocol Transactions</name>
      <t>In BFCP, there are two types of transactions: client-initiated transactions and server-initiated transactions.</t>
      <t>Client-initiated transactions consist of a request from a client to a floor control server and a response from the floor control server to the client.</t>
      <t>Server-initiated transactions have different requirements and behavior depending on underlying transport:</t>
      <ul empty="true" spacing="normal">
        <li>When using a reliable transport, server-initiated transactions consist of a single message from a floor control server to a client (notifications). They do not trigger any response.</li>
        <li>When using an unreliable transport, server-initiated transactions consist of a request from a floor control server to a client and a response from the client to the floor control server.</li>
      </ul>
      <t>When using BFCP over an unreliable transport, retransmission timer T1 (see <xref target="timers" format="default"/>) <bcp14>MUST</bcp14> be used for all requests until the transaction is completed.  Note that while T1 varies over time, it remains constant for the duration of a given transaction and is only updated at the completion of a transaction.</t>
      <section anchor="sec_transactions_client" numbered="true" toc="default">
        <name>Client Behavior</name>
        <t>A client starting a client-initiated transaction <bcp14>MUST</bcp14> set the Conference ID in the COMMON-HEADER of the message to the Conference ID for the conference that the client obtained previously.</t>
        <t>The client <bcp14>MUST</bcp14> set the Transaction ID value in the COMMON-HEADER to a number that is different from 0 and that <bcp14>MUST NOT</bcp14> be reused in another message from the client until a response from the server is received for the transaction. The client uses the Transaction ID value to match this message with the response from the floor control server. When using BFCP over an unreliable transport, it is important to choose a Transaction ID value that lets the receiver distinguish the reception of the next message in a sequence of BFCP messages from a retransmission of a previous message. Therefore, BFCP entities using an unreliable transport <bcp14>MUST</bcp14>&nbsp;use monotonically increasing Transaction ID values (except for wrap-around).</t>
        <t>A client receiving a server-initiated transaction over an unreliable transport <bcp14>MUST</bcp14> copy the Transaction ID from the request received from the server into the response.</t>
      </section>
      <section anchor="sec_transactions_server" numbered="true" toc="default">
        <name>Server Behavior</name>
        <t>A floor control server sending a response within a client-initiated transaction <bcp14>MUST</bcp14> copy the Conference ID, the Transaction ID, and the User ID from the request received from the client into the response.</t>
        <t>Server-initiated transactions <bcp14>MUST</bcp14> contain a Transaction ID equal to zero when BFCP is used over a reliable transport. Over an unreliable transport, the Transaction ID shall have the same properties as for client-initiated transactions. The server uses the Transaction ID value to match this message with the response from the floor participant or floor chair.</t>
      </section>
      <section anchor="timers" numbered="true" toc="default">
        <name>Timers</name>
        <t>When BFCP entities are communicating over an unreliable transport, two retransmission timers are employed to help mitigate the loss of datagrams. Retransmission and response caching are not required when BFCP entities communicate over a reliable transport.</t>
        <section anchor="timers_retrans" numbered="true" toc="default">
          <name>Request Retransmission Timer, T1</name>
          <t>T1 is a timer that schedules retransmission of a request until an appropriate response is received or until the maximum number of retransmissions has occurred. The timer is computed using the smoothed round-trip time algorithm defined in <xref target="RFC6298" format="default"/> with an initial retransmission timeout (RTO) value of 500 ms and clock granularity (G) of 100 ms.  In contrast to step 2.4 of <xref target="RFC6298" section="2" sectionFormat="of" format="default"/>, if the computed value of RTO is less than 500 ms, then RTO shall be set to 500 ms.  Timer T1 <bcp14>MUST</bcp14> be adjusted with the reception of a response to each request transmitted in order to compute an accurate RTO value, which is the effective T1 value.  The RTT value R is the time in milliseconds from the time when a request is transmitted to the time the initial response to that request is received.  Responses to retransmitted packets <bcp14>MUST NOT</bcp14> be used to recompute the RTO value, as one cannot determine if a response is to an initial or retransmitted request.  If T1 always expires on the initial transmission of a new request, this would suggest the recommended initial T1 (and RTO) value is too low and <bcp14>SHOULD</bcp14> be increased by doubling the initial values of T1 (and RTO) until T1 does not expire when sending a new request.</t>
          <t>When retransmitting a request, timer T1 is doubled with each retransmission, failing after three unacknowledged retransmission attempts.</t>
          <t>If a valid response is not received for a client- or server-initiated transaction, the implementation <bcp14>MUST</bcp14> consider the BFCP connection as broken. Implementations <bcp14>SHOULD</bcp14> follow the reestablishment procedure described in <xref target="sec_transport" format="default"/>.</t>
        </section>
        <section anchor="timers_cache" numbered="true" toc="default">
          <name>Response Retransmission Timer, T2</name>
          <t>T2 is a timer that, when fired, signals that the BFCP entity can release knowledge of the transaction against which it is running. It is started upon the first transmission of the response to a request and is the only mechanism by which that response is released by the BFCP entity. Any subsequent retransmissions of the same request can be responded to by replaying the cached response, while that value is retained until the timer has fired. Refer to <xref target="fragmentation_handling" format="default"/> for this timer's role in the fragmentation handling scheme.</t>
        </section>
        <section anchor="timers_values" numbered="true" toc="default">
          <name>Timer Values</name>
          <t>The table below defines the different timers required when BFCP entities communicate over an unreliable transport.</t>
          <table anchor="timertable" align="center">
            <name>Timers</name>
            <thead>
              <tr>
                <th align="center">Timer</th>
                <th align="left">Description</th>
                <th align="center">Value/s</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">T1</td>
                <td align="left">Initial request retransmission timer</td>
                <td align="center">0.5 s (initial)</td>
              </tr>
              <tr>
                <td align="center">T2</td>
                <td align="left">Response retransmission timer</td>
                <td align="center">(T1*2<sup>4</sup>)*1.25</td>
              </tr>
            </tbody>
          </table>
          <t>The initial value for T1 is 500 ms, which is an estimate of the RTT for completing the transaction.  Computation of this value follows the procedures described in <xref target="timers_retrans" format="default"/>, which includes exponential backoffs on retransmissions.</t>
          <t>T2 <bcp14>MUST</bcp14> be set such that it encompasses all legal retransmissions per T1 plus a factor to accommodate network latency between BFCP entities, processing delays, etc.</t>
        </section>
      </section>
    </section>
    <section anchor="sec_auth" numbered="true" toc="default">
      <name>Authentication and Authorization</name>
      <t>BFCP clients <bcp14>SHOULD</bcp14> authenticate the floor control server before sending any BFCP message to it or accepting any BFCP message from it. Similarly, floor control servers <bcp14>SHOULD</bcp14> authenticate a client before accepting any BFCP message from it or sending any BFCP message to it.</t>
      <t>If the signaling or control protocol traffic used to set up the conference is authenticated and confidentiality and integrity protected, and the extensions in this document are supported, the BFCP clients <bcp14>MUST</bcp14> authenticate the floor control server, and the floor control servers <bcp14>MUST</bcp14> authenticate the client before communicating as described above. Note that BFCP entities supporting only the <xref target="RFC4582" format="default"/> subset may not comply with this mandatory authentication requirement.</t>
      <t>BFCP supports TLS/DTLS mutual authentication between clients and floor control servers, as specified in <xref target="sec_auth_tls" format="default"/>. This is the <bcp14>RECOMMENDED</bcp14> authentication mechanism in BFCP.</t>
      <t>Note that future extensions may define additional authentication mechanisms.</t>

      <t>In addition to authenticating BFCP messages, floor control servers need to authorize them. On receiving an authenticated BFCP message, the floor control server checks whether the client sending the message is authorized. If the client is not authorized to perform the operation being requested, the floor control server generates an Error message, as described in <xref target="sec_server_error" format="default"/>, with an error code with a value of 5 (Unauthorized Operation). Messages from a client that cannot be authorized <bcp14>MUST NOT</bcp14> be processed further.</t>
      <section anchor="sec_auth_tls" numbered="true" toc="default">
        <name>TLS/DTLS Based Mutual Authentication</name>
        <t>BFCP supports TLS/DTLS based mutual authentication between clients and floor control servers.  If TLS/DTLS is used, an initial integrity-protected channel is <bcp14>REQUIRED</bcp14> between the client and the floor control server that can be used to exchange their certificates (which <bcp14>MAY</bcp14> be self-signed certificates) or, more commonly, the fingerprints of these certificates.   These certificates are used at TLS/DTLS establishment time.</t>
        <aside>
          <t>The implementation of such an integrity-protected channel using SIP and the SDP offer/answer model is described in <xref target="RFC8856" format="default"/>.</t>
        </aside>

        <t>BFCP messages received over an authenticated TLS/DTLS connection are considered authenticated. A floor control server that receives a BFCP message over TCP/UDP (no TLS/DTLS) <bcp14>MAY</bcp14> request the use of TLS/DTLS by generating an Error message, as described in <xref target="sec_server_error" format="default"/>, with an error code with a value of 9 (Use TLS) or a value of 11 (Use DTLS) respectively.   Clients configured to require the use of TLS/DTLS <bcp14>MUST</bcp14> ignore unauthenticated messages.</t>
        <t>Note that future extensions may define additional authentication mechanisms that may not require an initial integrity-protected channel (e.g., authentication based on certificates signed by a certificate authority).</t>
        <t>As described in <xref target="sec_auth" format="default"/>, floor control servers need to perform authorization before processing any message. In particular, the floor control server <bcp14>MUST</bcp14> check that messages arriving over a given authenticated TLS/DTLS connection use an authorized User ID (i.e., a User ID that the user that established the authenticated TLS/DTLS connection is allowed to use).</t>
      </section>
    </section>
    <section anchor="sec_participant" numbered="true" toc="default">
      <name>Floor Participant Operations</name>
      <t>This section specifies how floor participants can perform different operations, such as requesting a floor, using the protocol elements described in earlier sections. <xref target="sec_chair" format="default"/> specifies operations that are specific to floor chairs, such as instructing the floor control server to grant or revoke a floor, and <xref target="sec_client" format="default"/> specifies operations that can be performed by any client (i.e., both floor participants and floor chairs).</t>
      <section anchor="sec_participant_request" numbered="true" toc="default">
        <name>Requesting a Floor</name>
        <t>A floor participant that wishes to request one or more floors does so by sending a FloorRequest message to the floor control server.</t>
        <section anchor="sec_participant_request_send" numbered="true" toc="default">
          <name>Sending a FloorRequest Message</name>
          <t>The ABNF in <xref target="sec_msg_format_FloorRequest" format="default"/> describes the attributes that a FloorRequest message can contain. In addition, the ABNF specifies normatively which of these attributes are mandatory, and which ones are optional.</t>
          <t>The floor participant sets the Conference ID and the Transaction ID in the COMMON-HEADER following the rules given in <xref target="sec_transactions_client" format="default"/>.</t>
          <t>The floor participant sets the User ID in the COMMON-HEADER to the floor participant's identifier.  If the sender of the FloorRequest message (identified by the User ID) is not the participant that would eventually get the floor (i.e., a third-party floor request), the sender <bcp14>SHOULD</bcp14> add a BENEFICIARY-ID attribute to the message identifying the beneficiary of the floor.</t>
          <aside>
            <t>Note that the namespace for both the User ID and the Beneficiary ID is the same. That is, a given participant is identified by a single 16-bit value that can be used in the User ID in the COMMON-HEADER and in several attributes: BENEFICIARY-ID, BENEFICIARY-INFORMATION, and REQUESTED-BY-INFORMATION.</t>
          </aside>
          <t>The floor participant <bcp14>MUST</bcp14> insert at least one FLOOR-ID attribute in the FloorRequest message. If the client inserts more than one FLOOR-ID attribute, the floor control server will treat all the floor requests as an atomic package. That is, the floor control server will either grant or deny all the floors in the FloorRequest message.</t>
          <t>The floor participant may use a PARTICIPANT-PROVIDED-INFO attribute to state the reason why the floor or floors are being requested. The Text field in the PARTICIPANT-PROVIDED-INFO attribute is intended for human consumption.</t>
          <t>The floor participant may request that the server handle the floor request with a certain priority using a PRIORITY attribute.</t>
        </section>
        <section anchor="sec_client_request_response" numbered="true" toc="default">
          <name>Receiving a Response</name>
          <t>A message from the floor control server is considered a response to the FloorRequest message if the message from the floor control server has the same Conference ID, Transaction ID, and User ID as the FloorRequest message, as described in <xref target="sec_transactions_client" format="default"/>. On receiving such a response, the floor participant follows the rules in <xref target="sec_auth" format="default"/> that relate to floor control server authentication.</t>
          <t>The successful processing of a FloorRequest message at the floor control server involves generating one or several FloorRequestStatus messages. The floor participant obtains a Floor Request ID in the Floor Request ID field of a FLOOR-REQUEST-INFORMATION attribute in the first FloorRequestStatus message from the floor control server. Subsequent FloorRequestStatus messages from the floor control server regarding the same floor request will carry the same Floor Request ID in a FLOOR-REQUEST-INFORMATION attribute as the initial FloorRequestStatus message. This way, the floor participant can associate subsequent incoming FloorRequestStatus messages with the ongoing floor request.</t>
          <t>The floor participant obtains information about the status of the floor request in the FLOOR-REQUEST-INFORMATION attribute of each of the FloorRequestStatus messages received from the floor control server. This attribute is a grouped attribute, and as such it includes a number of attributes that provide information about the floor request.</t>
          <t>The OVERALL-REQUEST-STATUS attribute provides information about the overall status of the floor request. If the Request Status value is Granted, all the floors that were requested in the FloorRequest message have been granted. If the Request Status value is Denied, all the floors that were requested in the FloorRequest message have been denied. A floor request is considered to be ongoing while it is in the Pending, Accepted, or Granted states. If the floor request value is unknown, then the response is still processed.  However, no meaningful value can be reported to the user.</t>
          <t>The STATUS-INFO attribute, if present, provides extra information that the floor participant can display to the user.</t>
          <t>The FLOOR-REQUEST-STATUS attributes provide information about the status of the floor request as it relates to a particular floor.  The STATUS-INFO attribute, if present, provides extra information that the floor participant can display to the user.</t>
          <t>The BENEFICIARY-INFORMATION attribute identifies the beneficiary of the floor request in third-party floor requests.  The REQUESTED-BY-INFORMATION attribute need not be present in FloorRequestStatus messages received by the floor participant that requested the floor, as this floor participant is already identified by the User ID in the COMMON-HEADER.</t>
          <t>The PRIORITY attribute, when present, contains the priority that was requested by the generator of the FloorRequest message.</t>
          <t>If the response is an Error message, the floor control server could not process the FloorRequest message for some reason, which is described in the Error message.</t>
        </section>
        <section anchor="sec_recept_frsm" numbered="true" toc="default">
          <name>Reception of a Subsequent FloorRequestStatus Message</name>
          <t>When communicating over an unreliable transport and upon receiving a FloorRequestStatus message from a floor control server, the participant <bcp14>MUST</bcp14> respond with a FloorRequestStatusAck message within the transaction failure window to complete the transaction.</t>
        </section>
      </section>
      <section anchor="sec_participant_cancel" numbered="true" toc="default">
        <name>Cancelling a Floor Request and Releasing a Floor</name>
        <t>A floor participant that wishes to cancel an ongoing floor request does so by sending a FloorRelease message to the floor control server. The FloorRelease message is also used by floor participants that hold a floor and would like to release it.</t>
        <section anchor="sec_participant_cancel_send" numbered="true" toc="default">
          <name>Sending a FloorRelease Message</name>
          <t>The ABNF in <xref target="sec_msg_format_FloorRelease" format="default"/> describes the attributes that a FloorRelease message can contain. In addition, the ABNF specifies normatively which of these attributes are mandatory, and which ones are optional.</t>
          <t>The floor participant sets the Conference ID and the Transaction ID in the COMMON-HEADER following the rules given in <xref target="sec_transactions_client" format="default"/>. The floor participant sets the User ID in the COMMON-HEADER to the floor participant's identifier.</t>
          <aside>
            <t>Note that the FloorRelease message is used to release a floor or floors that were granted and to cancel ongoing floor requests (from the protocol perspective, both are ongoing floor requests). Using the same message in both situations helps resolve the race condition that occurs when the FloorRelease message and the FloorGrant message cross each other on the wire.</t>
          </aside>
          <t>The floor participant uses the FLOOR-REQUEST-ID that was received in the response to the FloorRequest message that the FloorRelease message is cancelling.</t>
          <aside>
            <t>Note that if the floor participant requested several floors as an atomic operation (i.e., in a single FloorRequest message), all the floors are released as an atomic operation as well (i.e., all are released at the same time).</t>
          </aside>
        </section>
        <section anchor="sec_participant_cancel_response" numbered="true" toc="default">
          <name>Receiving a Response</name>
          <t>A message from the floor control server is considered a response to the FloorRelease message if the message from the floor control server has the same Conference ID, Transaction ID, and User ID as the FloorRelease message, as described in <xref target="sec_transactions_client" format="default"/>. On receiving such a response, the floor participant follows the rules in <xref target="sec_auth" format="default"/> that relate to floor control server authentication.</t>
          <t>If the response is a FloorRequestStatus message, the Request Status value in the OVERALL-REQUEST-STATUS attribute (within the FLOOR-REQUEST-INFORMATION grouped attribute) will be Cancelled or Released.</t>
          <t>If the response is an Error message, the floor control server could not process the FloorRequest message for some reason, which is described in the Error message.</t>
          <t>It is possible that the FloorRelease message crosses on the wire with a FloorRequestStatus message from the server with a Request Status different from Cancelled or Released. In any case, such a FloorRequestStatus message will not be a response to the FloorRelease message, as its Transaction ID will not match that of the FloorRelease.</t>
        </section>
      </section>
    </section>
    <section anchor="sec_chair" numbered="true" toc="default">
      <name>Chair Operations</name>
      <t>This section specifies how floor chairs can instruct the floor control server to grant or revoke a floor using the protocol elements described in earlier sections.</t>
      <t>Floor chairs that wish to send instructions to a floor control server do so by sending a ChairAction message.</t>
      <section anchor="sec_chair_send" numbered="true" toc="default">
        <name>Sending a ChairAction Message</name>
        <t>The ABNF in <xref target="sec_msg_format_ChairAction" format="default"/> describes the attributes that a ChairAction message can contain. In addition, the ABNF specifies normatively which of these attributes are mandatory, and which ones are optional.</t>
        <t>The floor chair sets the Conference ID and the Transaction ID in the COMMON-HEADER following the rules given in <xref target="sec_transactions_client" format="default"/>. The floor chair sets the User ID in the COMMON-HEADER to the floor chair's identifier.</t>
        <t>The ChairAction message contains instructions that apply to one or more floors within a particular floor request. The floor or floors are identified by the FLOOR-REQUEST-STATUS attributes and the floor request is identified by the FLOOR-REQUEST-INFORMATION-HEADER, which are carried in the ChairAction message.</t>
        <t>For example, if a floor request consists of two floors that depend on different floor chairs, each floor chair will grant its floor within the floor request. Once both chairs have granted their floor, the floor control server will grant the floor request as a whole. On the other hand, if one of the floor chairs denies its floor, the floor control server will deny the floor request as a whole, regardless of the other floor chair's decision.</t>
        <t>The floor chair provides the new status of the floor request as it relates to a particular floor using a FLOOR-REQUEST-STATUS attribute. If the new status of the floor request is Accepted, the floor chair <bcp14>MAY</bcp14> use the Queue Position field to provide a queue position for the floor request. If the floor chair does not wish to provide a queue position, all the bits of the Queue Position field <bcp14>MUST</bcp14> be set to zero. The floor chair <bcp14>MUST</bcp14> use the Status Revoked to revoke a floor that was granted (i.e., Granted status) and <bcp14>MUST</bcp14> use the Status Denied to reject floor requests in any other status (e.g., Pending and Accepted).</t>
        <t>The floor chair <bcp14>MAY</bcp14> add an OVERALL-REQUEST-STATUS attribute to the ChairAction message to provide a new overall status for the floor request.  If the new overall status of the floor request is Accepted, the floor chair can use the Queue Position field to provide a queue position for the floor request.</t>
        <aside>
          <t>Note that a particular floor control server can implement a different queue for each floor containing all the floor requests that relate to that particular floor, a general queue for all floor requests, or both.  Also note that a floor request can involve several floors and that a ChairAction message can only deal with a subset of these floors (e.g., if a single floor chair is not authorized to manage all the floors).  In this case, the floor control server will combine the instructions received from the different floor chairs in FLOOR-REQUEST-STATUS attributes to come up with the overall status of the floor request.</t>
          <t>Note that, while the action of a floor chair may communicate information in the OVERALL-REQUEST-STATUS attribute, the floor control server may override, modify, or ignore this field's content.</t>
        </aside>
        <t>The floor chair <bcp14>MAY</bcp14> include STATUS-INFO attributes to state the reason why the floor or floors are being accepted, granted, or revoked. The Text in the STATUS-INFO attribute is intended for human consumption.</t>
      </section>
      <section anchor="sec_chair_instruct_response" numbered="true" toc="default">
        <name>Receiving a Response</name>
        <t>A message from the floor control server is considered a response to the ChairAction message if the message from the server has the same Conference ID, Transaction ID, and User ID as the ChairAction message, as described in <xref target="sec_transactions_client" format="default"/>. On receiving such a response, the floor chair follows the rules in <xref target="sec_auth" format="default"/> that relate to floor control server authentication.</t>
        <t>A ChairActionAck message from the floor control server confirms that the floor control server has accepted the ChairAction message. An Error message indicates that the floor control server could not process the ChairAction message for some reason, which is described in the Error message.</t>
      </section>
    </section>
    <section anchor="sec_client" numbered="true" toc="default">
      <name>General Client Operations</name>
      <t>This section specifies operations that can be performed by any client. That is, they are not specific to floor participants or floor chairs. They can be performed by both.</t>
      <section anchor="sec_client_floorinfo" numbered="true" toc="default">
        <name>Requesting Information about Floors</name>
        <t>A client can obtain information about the status of a floor or floors in different ways, which include using BFCP and using out-of-band mechanisms. Clients using BFCP to obtain such information use the procedures described in this section. </t>
        <t>Clients request information about the status of one or several floors by sending a FloorQuery message to the floor control server.</t>
        <section anchor="sec_client_floorinfo_send" numbered="true" toc="default">
          <name>Sending a FloorQuery Message</name>
          <t>The ABNF in <xref target="sec_msg_format_FloorQuery" format="default"/> describes the attributes that a FloorQuery message can contain. In addition, the ABNF specifies normatively which of these attributes are mandatory, and which ones are optional.</t>
          <t>The client sets the Conference ID and the Transaction ID in the COMMON-HEADER following the rules given in <xref target="sec_transactions_client" format="default"/>. The client sets the User ID in the COMMON-HEADER to the client's identifier.</t>
          <t>The client inserts in the message all the Floor IDs it wants to receive information about. The floor control server will send periodic information about all of these floors. If the client does not want to receive information about a particular floor any longer, it sends a new FloorQuery message removing the FLOOR-ID of this floor. If the client does not want to receive information about any floor any longer, it sends a FloorQuery message with no FLOOR-ID attribute.</t>
        </section>
        <section anchor="sec_client_floorinfo_response" numbered="true" toc="default">
          <name>Receiving a Response</name>
          <t>A message from the floor control server is considered a response to the FloorQuery message if the message from the floor control server has the same Conference ID, Transaction ID, and User ID as the FloorQuery message, as described in <xref target="sec_transactions_client" format="default"/>. On receiving such a response, the client follows the rules in <xref target="sec_auth" format="default"/> that relate to floor control server authentication.</t>
          <t>On reception of the FloorQuery message, the floor control server <bcp14>MUST</bcp14> respond with a FloorStatus message or with an Error message. If the response is a FloorStatus message, it will contain information about one of the floors the client requested information about. If the client did not include any FLOOR-ID attribute in its FloorQuery message (i.e., the client does not want to receive information about any floor any longer), the FloorStatus message from the floor control server will not include any FLOOR-ID attribute either. </t>
          <t>FloorStatus messages that carry information about a floor contain a FLOOR-ID attribute that identifies the floor. After this attribute, FloorStatus messages contain information about existing (one or more) floor requests that relate to that floor. The information about each particular floor request is encoded in a FLOOR-REQUEST-INFORMATION attribute. This grouped attribute carries a Floor Request ID that identifies the floor request, followed by a set of attributes that provide information about the floor request.</t>
          <t>After the first FloorStatus, the floor control server will continue sending FloorStatus messages, periodically informing the client about changes on the floors the client requested information about.</t>
        </section>
        <section anchor="sec_recept_fsm" numbered="true" toc="default">
          <name>Reception of a Subsequent FloorStatus Message</name>
          <t>When communicating over an unreliable transport and upon receiving a FloorStatus message from a floor control server, the participant <bcp14>MUST</bcp14> respond with a FloorStatusAck message within the transaction failure window to complete the transaction.</t>
        </section>
      </section>
      <section anchor="sec_client_info" numbered="true" toc="default">
        <name>Requesting Information about Floor Requests</name>
        <t>A client can obtain information about the status of one or several floor requests in different ways, which include using BFCP and using out-of-band mechanisms. Clients using BFCP to obtain such information use the procedures described in this section.</t>
        <t>Clients request information about the current status of a floor request by sending a FloorRequestQuery message to the floor control server.</t>
        <t>Requesting information about a particular floor request is useful in a number of situations. For example, on reception of a FloorRequest message, a floor control server may choose to return FloorRequestStatus messages only when the floor request changes its state (e.g., from Accepted to Granted), but not when the floor request advances in its queue. In this situation, if the user requests it, the floor participant can use a FloorRequestQuery message to poll the floor control server for the status of the floor request.</t>
        <section anchor="sec_client_info_send" numbered="true" toc="default">
          <name>Sending a FloorRequestQuery Message</name>
          <t>The ABNF in <xref target="sec_msg_format_FloorRequestQuery" format="default"/> describes the attributes that a FloorRequestQuery message can contain. In addition, the ABNF specifies normatively which of these attributes are mandatory, and which ones are optional.</t>
          <t>The client sets the Conference ID and the Transaction ID in the COMMON-HEADER following the rules given in <xref target="sec_transactions_client" format="default"/>. The client sets the User ID in the COMMON-HEADER to the client's identifier.</t>
          <t>The client <bcp14>MUST</bcp14> insert a FLOOR-REQUEST-ID attribute that identifies the floor request at the floor control server.</t>
        </section>
        <section anchor="sec_client_info_response" numbered="true" toc="default">
          <name>Receiving a Response</name>
          <t>A message from the floor control server is considered a response to the FloorRequestQuery message if the message from the floor control server has the same Conference ID, Transaction ID, and User ID as the FloorRequestQuery message, as described in <xref target="sec_transactions_client" format="default"/>.  On receiving such a response, the client follows the rules in <xref target="sec_auth" format="default"/> that relate to floor control server authentication.</t>
          <t>If the response is a FloorRequestStatus message, the client obtains information about the status of the FloorRequest the client requested information about in a FLOOR-REQUEST-INFORMATION attribute.</t>
          <t>If the response is an Error message, the floor control server could not process the FloorRequestQuery message for some reason, which is described in the Error message.</t>
        </section>
      </section>
      <section anchor="sec_client_user" numbered="true" toc="default">
        <name>Requesting Information about a User</name>
        <t>A client can obtain information about a participant and the floor requests related to this participant in different ways, which include using BFCP and using out-of-band mechanisms. Clients using BFCP to obtain such information use the procedures described in this section.</t>
        <t>Clients request information about a participant and the floor requests related to this participant by sending a UserQuery message to the floor control server.</t>
        <t>This functionality may be useful for floor chairs or floor participants interested in the display name and the URI of a particular floor participant. In addition, a floor participant may find it useful to request information about itself. For example, a floor participant, after experiencing connectivity problems (e.g., its TCP connection with the floor control server was down for a while and eventually was re-established), may need to request information about all the floor requests associated to itself that still exist.</t>
        <section anchor="sec_client_user_send" numbered="true" toc="default">
          <name>Sending a UserQuery Message</name>
          <t>The ABNF in <xref target="sec_msg_format_UserQuery" format="default"/> describes the attributes that a UserQuery message can contain. In addition, the ABNF specifies normatively which of these attributes are mandatory, and which ones are optional.</t>
          <t>The client sets the Conference ID and the Transaction ID in the COMMON-HEADER following the rules given in <xref target="sec_transactions_client" format="default"/>. The client sets the User ID in the COMMON-HEADER to the client's identifier.</t>
          <t>If the floor participant the client is requesting information about is not the client issuing the UserQuery message (which is identified by the User ID in the COMMON-HEADER of the message), the client <bcp14>MUST</bcp14> insert a BENEFICIARY-ID attribute.</t>
        </section>
        <section anchor="sec_client_user_response" numbered="true" toc="default">
          <name>Receiving a Response</name>
          <t>A message from the floor control server is considered a response to the UserQuery message if the message from the floor control server has the same Conference ID, Transaction ID, and User ID as the UserQuery message, as described in <xref target="sec_transactions_client" format="default"/>.  On receiving such a response, the client follows the rules in <xref target="sec_auth" format="default"/> that relate to floor control server authentication.</t>
          <t>If the response is a UserStatus message, the client obtains information about the floor participant in a BENEFICIARY-INFORMATION grouped attribute and about the status of the floor requests associated with the floor participant in FLOOR-REQUEST-INFORMATION attributes.</t>
          <t>If the response is an Error message, the floor control server could not process the UserQuery message for some reason, which is described in the Error message.</t>
        </section>
      </section>
      <section anchor="sec_client_hello" numbered="true" toc="default">
        <name>Obtaining the Capabilities of a Floor Control Server</name>
        <t>A client that wishes to obtain the capabilities of a floor control server does so by sending a Hello message to the floor control server.</t>
        <section anchor="sec_client_hello_send" numbered="true" toc="default">
          <name>Sending a Hello Message</name>
          <t>The ABNF in <xref target="sec_msg_format_Hello" format="default"/> describes the attributes that a Hello message can contain. In addition, the ABNF specifies normatively which of these attributes are mandatory, and which ones are optional.</t>
          <t>The client sets the Conference ID and the Transaction ID in the COMMON-HEADER following the rules given in <xref target="sec_transactions_client" format="default"/>. The client sets the User ID in the COMMON-HEADER to the client's identifier.</t>
        </section>
        <section anchor="sec_client_hello_responses" numbered="true" toc="default">
          <name>Receiving Responses</name>
          <t>A message from the floor control server is considered a response to the Hello message by the client if the message from the floor control server has the same Conference ID, Transaction ID, and User ID as the Hello message, as described in <xref target="sec_transactions_client" format="default"/>. On receiving such a response, the client follows the rules in <xref target="sec_auth" format="default"/> that relate to floor control server authentication.</t>
          <t>If the response is a HelloAck message, the floor control server could process the Hello message successfully. The SUPPORTED-PRIMITIVES and SUPPORTED-ATTRIBUTES attributes indicate which primitives and attributes, respectively, are supported by the server.</t>
          <t>If the response is an Error message, the floor control server could not process the Hello message for some reason, which is described in the Error message.</t>
        </section>
      </section>
    </section>
    <section anchor="sec_server" numbered="true" toc="default">
      <name>Floor Control Server Operations</name>
      <t>This section specifies how floor control servers can perform different operations, such as granting a floor, using the protocol elements described in earlier sections.</t>

      <t>On reception of a message from a client, the floor control server <bcp14>MUST</bcp14> check whether the value of the primitive is supported.  If it is not, the floor control server <bcp14>MUST</bcp14> send an Error message, as described in <xref target="sec_server_error" format="default"/>, with Error Code 3 (Unknown Primitive).</t>

      <t>On reception of a message from a client, the floor control server <bcp14>MUST</bcp14> check whether the value of the Conference ID matched an existing conference. If it does not, the floor control server <bcp14>MUST</bcp14> send an Error message, as described in <xref target="sec_server_error" format="default"/>, with Error Code 1 (Conference Does Not Exist).</t>
      <t>On reception of a message from a client, the floor control server follows the rules in <xref target="sec_auth" format="default"/> that relate to the authentication of the message.</t>

      <t>On reception of a message from a client, the floor control server <bcp14>MUST</bcp14> check whether it understands all the mandatory ('M' bit set) attributes in the message. If the floor control server does not understand all of them, the floor control server <bcp14>MUST</bcp14> send an Error message, as described in <xref target="sec_server_error" format="default"/>, with Error Code 4 (Unknown Mandatory Attribute). The Error message <bcp14>SHOULD</bcp14> list the attributes that were not understood.</t>
      <section anchor="sec_server_request" numbered="true" toc="default">
        <name>Reception of a FloorRequest Message</name>
        <t>On reception of a FloorRequest message, the floor control server follows the rules in <xref target="sec_auth" format="default"/> that relate to client authentication and authorization. If while processing the FloorRequest message, the floor control server encounters an error, it <bcp14>MUST</bcp14> generate an Error response following the procedures described in <xref target="sec_server_error" format="default"/>.</t>

        <aside>
          <t>BFCP allows floor participants to have several ongoing floor requests for the same floor (e.g., the same floor participant can occupy more than one position in a queue at the same time). A floor control server that only supports a certain number of ongoing floor requests per floor participant (e.g., one) can use Error Code 8 (You have Already Reached the Maximum Number of Ongoing Floor Requests for This Floor) to inform the floor participant.</t>
        </aside>
        <t>When communicating over an unreliable transport and upon receiving a FloorRequest from a participant, the floor control server <bcp14>MUST</bcp14> respond with a FloorRequestStatus message within the transaction failure window to complete the transaction.</t>
        <section anchor="sec_server_request_first" numbered="true" toc="default">
          <name>Generating the First FloorRequestStatus Message</name>
          <t>The successful processing of a FloorRequest message by a floor control server involves generating one or several FloorRequestStatus messages, the first of which <bcp14>SHOULD</bcp14> be generated as soon as possible. If the floor control server cannot accept, grant, or deny the floor request right away (e.g., a decision from a chair is needed), it <bcp14>SHOULD</bcp14> use a Request Status value of Pending in the OVERALL-REQUEST-STATUS attribute (within the FLOOR-REQUEST-INFORMATION grouped attribute) of the first FloorRequestStatus message it generates.</t>
          <aside>
            <t>The policy that a floor control server follows to grant or deny floors is outside the scope of this document. A given floor control server may perform these decisions automatically while another may contact a human acting as a chair every time a decision needs to be made.</t>
          </aside>
          <t>The floor control server <bcp14>MUST</bcp14> copy the Conference ID, the Transaction ID, and the User ID from the FloorRequest into the FloorRequestStatus, as described in <xref target="sec_transactions_server" format="default"/>. Additionally, the floor control server <bcp14>MUST</bcp14> add a FLOOR-REQUEST-INFORMATION grouped attribute to the FloorRequestStatus. The attributes contained in this grouped attribute carry information about the floor request.</t>
          <t>The floor control server <bcp14>MUST</bcp14> assign an identifier that is unique within the conference to this floor request, and <bcp14>MUST</bcp14> insert it in the Floor Request ID field of the FLOOR-REQUEST-INFORMATION attribute. This identifier will be used by the floor participant (or by a chair or chairs) to refer to this specific floor request in the future.</t>
          <t>The floor control server <bcp14>MUST</bcp14> copy the Floor IDs in the FLOOR-ID attributes of the FloorRequest into the FLOOR-REQUEST-STATUS attributes in the FLOOR-REQUEST-INFORMATION grouped attribute. These Floor IDs identify the floors being requested (i.e., the floors associated with this particular floor request).</t>
          <t>The floor control server <bcp14>SHOULD</bcp14> copy (if present) the contents of the BENEFICIARY-ID attribute from the FloorRequest into a BENEFICIARY-INFORMATION attribute inside the FLOOR-REQUEST-INFORMATION grouped attribute. Additionally, the floor control server <bcp14>MAY</bcp14> provide the display name and the URI of the beneficiary in this BENEFICIARY-INFORMATION attribute.</t>
          <t>The floor control server <bcp14>MAY</bcp14> provide information about the requester of the floor in a REQUESTED-BY-INFORMATION attribute inside the FLOOR-REQUEST-INFORMATION grouped attribute.</t>
          <t>The floor control server <bcp14>MAY</bcp14> copy (if present) the PRIORITY attribute from the FloorRequest into the FLOOR-REQUEST-INFORMATION grouped attribute.</t>
          <aside>
            <t>Note that this attribute carries the priority requested by the participant. The priority that the floor control server assigns to the floor request depends on the priority requested by the participant and the rights the participant has according to the policy of the conference. For example, a participant that is only allowed to use the Normal priority may request Highest priority for a floor request. In that case, the floor control server would ignore the priority requested by the participant.</t>
          </aside>
          <t>The floor control server <bcp14>MAY</bcp14> copy (if present) the PARTICIPANT-PROVIDED-INFO attribute from the FloorRequest into the FLOOR-REQUEST-INFORMATION grouped attribute.</t>
        </section>
        <section anchor="sec_server_request_subsequent" numbered="true" toc="default">
          <name>Generation of Subsequent FloorRequestStatus Messages</name>
          <t>A floor request is considered to be ongoing as long as it is not in the Cancelled, Released, or Revoked states. If the OVERALL-REQUEST-STATUS attribute (inside the FLOOR-REQUEST-INFORMATION grouped attribute) of the first FloorRequestStatus message generated by the floor control server did not indicate any of these states, the floor control server will need to send subsequent FloorRequestStatus messages.</t>
          <t>When the status of the floor request changes, the floor control server <bcp14>SHOULD</bcp14> send new FloorRequestStatus messages with the appropriate Request Status. The floor control server <bcp14>MUST</bcp14> add a FLOOR-REQUEST-INFORMATION attribute with a Floor Request ID equal to the one sent in the first FloorRequestStatus message to any new FloorRequestStatus related to the same floor request. (The Floor Request ID identifies the floor request to which the FloorRequestStatus applies.)</t>
          <t>When using BFCP over a reliable transport, the floor control server <bcp14>MUST</bcp14> set the Transaction ID of subsequent FloorRequestStatus messages to zero. When using BFCP over an unreliable transport, the Transaction ID <bcp14>MUST</bcp14> be non-zero and unique in the context of outstanding transactions over an unreliable transport as described in <xref target="sec_transactions" format="default"/>.</t>
          <aside>
            <t>The rate at which the floor control server sends FloorRequestStatus messages is a matter of local policy. A floor control server may choose to send a new FloorRequestStatus message every time the floor request moves in the floor request queue, while another may choose only to send a new FloorRequestStatus message when the floor request is Granted or Denied.</t>
          </aside>
          <t>The floor control server may add a STATUS-INFO attribute to any of the FloorRequestStatus messages it generates to provide extra information about its decisions regarding the floor request (e.g., why it was denied).</t>
          <aside>
            <t>Floor participants and floor chairs may request to be informed about the status of a floor following the procedures in <xref target="sec_client_floorinfo" format="default"/>. If the processing of a floor request changes the status of a floor (e.g., the floor request is granted and consequently the floor has a new holder), the floor control server needs to follow the procedures in <xref target="sec_server_floorinfo" format="default"/> to inform the clients that have requested that information.</t>
          </aside>
          <t>The COMMON-HEADER and the rest of the attributes are the same as in the first FloorRequestStatus message.</t>
          <t>The floor control server can discard the state information about a particular floor request when this reaches a status of Cancelled, Released, or Revoked.</t>
          <t>When communicating over an unreliable transport and a FloorRequestStatusAck message is not received within the transaction failure window, the floor control server <bcp14>MUST</bcp14> retransmit the FloorRequestStatus message according to <xref target="udp_transport" format="default"/>.</t>
        </section>
      </section>
      <section anchor="sec_server_requestinfo" numbered="true" toc="default">
        <name>Reception of a FloorRequestQuery Message</name>
        <t>On reception of a FloorRequestQuery message, the floor control server follows the rules in <xref target="sec_auth" format="default"/> that relate to client authentication and authorization. If while processing the FloorRequestQuery message, the floor control server encounters an error, it <bcp14>MUST</bcp14> generate an Error response following the procedures described in <xref target="sec_server_error" format="default"/>.</t>
        <t>The successful processing of a FloorRequestQuery message by a floor control server involves generating a FloorRequestStatus message, which <bcp14>SHOULD</bcp14> be generated as soon as possible.</t>
        <t>When communicating over an unreliable transport and upon receiving a FloorRequestQuery from a participant, the floor control server <bcp14>MUST</bcp14> respond with a FloorRequestStatus message within the transaction failure window to complete the transaction.</t>
        <t>The floor control server <bcp14>MUST</bcp14> copy the Conference ID, the Transaction ID, and the User ID from the FloorRequestQuery message into the FloorRequestStatus message, as described in <xref target="sec_transactions_server" format="default"/>. Additionally, the floor control server <bcp14>MUST</bcp14> include information about the floor request in the FLOOR-REQUEST-INFORMATION grouped attribute to the FloorRequestStatus.</t>
        <t>The floor control server <bcp14>MUST</bcp14> copy the contents of the FLOOR-REQUEST-ID attribute from the FloorRequestQuery message into the Floor Request ID field of the FLOOR-REQUEST-INFORMATION attribute.</t>
        <t>The floor control server <bcp14>MUST</bcp14> add FLOOR-REQUEST-STATUS attributes to the FLOOR-REQUEST-INFORMATION grouped attribute identifying the floors being requested (i.e., the floors associated with the floor request identified by the FLOOR-REQUEST-ID attribute).</t>
        <t>The floor control server <bcp14>SHOULD</bcp14> add a BENEFICIARY-ID attribute to the FLOOR-REQUEST-INFORMATION grouped attribute identifying the beneficiary of the floor request.  Additionally, the floor control server <bcp14>MAY</bcp14> provide the display name and the URI of the beneficiary in this BENEFICIARY-INFORMATION attribute.</t>
        <t>The floor control server <bcp14>MAY</bcp14> provide information about the requester of the floor in a REQUESTED-BY-INFORMATION attribute inside the FLOOR-REQUEST-INFORMATION grouped attribute.</t>
        <t>The floor control server <bcp14>MAY</bcp14> provide the reason why the floor participant requested the floor in a PARTICIPANT-PROVIDED-INFO.</t>
        <t>The floor control server <bcp14>MAY</bcp14> also add to the FLOOR-REQUEST-INFORMATION grouped attribute a PRIORITY attribute with the Priority value requested for the floor request and a STATUS-INFO attribute with extra information about the floor request.</t>
        <t>The floor control server <bcp14>MUST</bcp14> add an OVERALL-REQUEST-STATUS attribute to the FLOOR-REQUEST-INFORMATION grouped attribute with the current status of the floor request. The floor control server <bcp14>MAY</bcp14> provide information about the status of the floor request as it relates to each of the floors being requested in the FLOOR-REQUEST-STATUS attributes.</t>
      </section>
      <section anchor="sec_server_userinfo" numbered="true" toc="default">
        <name>Reception of a UserQuery Message</name>
        <t>On reception of a UserQuery message, the floor control server follows the rules in <xref target="sec_auth" format="default"/> that relate to client authentication and authorization. If while processing the UserQuery message, the floor control server encounters an error, it <bcp14>MUST</bcp14> generate an Error response following the procedures described in <xref target="sec_server_error" format="default"/>.</t>
        <t>The successful processing of a UserQuery message by a floor control server involves generating a UserStatus message, which <bcp14>SHOULD</bcp14> be generated as soon as possible.</t>
        <t>When communicating over an unreliable transport and upon receiving a UserQuery from a participant, the floor control server <bcp14>MUST</bcp14> respond with a UserStatus message within the transaction failure window to complete the transaction.</t>
        <t>The floor control server <bcp14>MUST</bcp14> copy the Conference ID, the Transaction ID, and the User ID from the UserQuery message into the UserStatus message, as described in <xref target="sec_transactions_server" format="default"/>.</t>
        <t>The sender of the UserQuery message is requesting information about all the floor requests associated with a given participant (i.e., the floor requests where the participant is either the beneficiary or the requester). This participant is identified by a BENEFICIARY-ID attribute or, in the absence of a BENEFICIARY-ID attribute, by a the User ID in the COMMON-HEADER of the UserQuery message.</t>
        <t>The floor control server <bcp14>MUST</bcp14> copy, if present, the contents of the BENEFICIARY-ID attribute from the UserQuery message into a BENEFICIARY-INFORMATION attribute in the UserStatus message. Additionally, the floor control server <bcp14>MAY</bcp14> provide the display name and the URI of the participant about which the UserStatus message provides information in this BENEFICIARY-INFORMATION attribute.</t>
        <t>The floor control server <bcp14>SHOULD</bcp14> add to the UserStatus message a FLOOR-REQUEST-INFORMATION grouped attribute for each floor request related to the participant about which the message provides information (i.e., the floor requests where the participant is either the beneficiary or the requester). For each FLOOR-REQUEST-INFORMATION attribute, the floor control server follows the following steps.</t>
        <t>The floor control server <bcp14>MUST</bcp14> identify the floor request the FLOOR-REQUEST-INFORMATION attribute applies to by filling the Floor Request ID field of the FLOOR-REQUEST-INFORMATION attribute.</t>
        <t>The floor control server <bcp14>MUST</bcp14> add FLOOR-REQUEST-STATUS attributes to the FLOOR-REQUEST-INFORMATION grouped attribute identifying the floors being requested (i.e., the floors associated with the floor request identified by the FLOOR-REQUEST-ID attribute).</t>
        <t>The floor control server <bcp14>SHOULD</bcp14> add a BENEFICIARY-ID attribute to the FLOOR-REQUEST-INFORMATION grouped attribute identifying the beneficiary of the floor request.  Additionally, the floor control server <bcp14>MAY</bcp14> provide the display name and the URI of the beneficiary in this BENEFICIARY-INFORMATION attribute.</t>
        <t>The floor control server <bcp14>MAY</bcp14> provide information about the requester of the floor in a REQUESTED-BY-INFORMATION attribute inside the FLOOR-REQUEST-INFORMATION grouped attribute.</t>
        <t>The floor control server <bcp14>MAY</bcp14> provide the reason why the floor participant requested the floor in a PARTICIPANT-PROVIDED-INFO.</t>
        <t>The floor control server <bcp14>MAY</bcp14> also add to the FLOOR-REQUEST-INFORMATION grouped attribute a PRIORITY attribute with the Priority value requested for the floor request.</t>
        <t>The floor control server <bcp14>MUST</bcp14> include the current status of the floor request in an OVERALL-REQUEST-STATUS attribute to the FLOOR-REQUEST-INFORMATION grouped attribute. The floor control server <bcp14>MAY</bcp14> add a STATUS-INFO attribute with extra information about the floor request.</t>
        <t>The floor control server <bcp14>MAY</bcp14> provide information about the status of the floor request as it relates to each of the floors being requested in the FLOOR-REQUEST-STATUS attributes.</t>
      </section>
      <section anchor="sec_server_release" numbered="true" toc="default">
        <name>Reception of a FloorRelease Message</name>
        <t>On reception of a FloorRelease message, the floor control server follows the rules in <xref target="sec_auth" format="default"/> that relate to client authentication and authorization. If while processing the FloorRelease message, the floor control server encounters an error, it <bcp14>MUST</bcp14> generate an Error response following the procedures described in <xref target="sec_server_error" format="default"/>.</t>
        <t>The successful processing of a FloorRelease message by a floor control server involves generating a FloorRequestStatus message, which <bcp14>SHOULD</bcp14> be generated as soon as possible.</t>
        <t>When communicating over an unreliable transport and upon receiving a FloorRelease from a participant, the floor control server <bcp14>MUST</bcp14> respond with a FloorRequestStatus message within the transaction failure window to complete the transaction.</t>
        <t>The floor control server <bcp14>MUST</bcp14> copy the Conference ID, the Transaction ID, and the User ID from the FloorRelease message into the FloorRequestStatus message, as described in <xref target="sec_transactions_server" format="default"/>.</t>
        <t>The floor control server <bcp14>MUST</bcp14> add a FLOOR-REQUEST-INFORMATION grouped attribute to the FloorRequestStatus. The attributes contained in this grouped attribute carry information about the floor request.</t>
        <t>The FloorRelease message identifies the floor request it applies to using a FLOOR-REQUEST-ID. The floor control server <bcp14>MUST</bcp14> copy the contents of the FLOOR-REQUEST-ID attribute from the FloorRelease message into the Floor Request ID field of the FLOOR-REQUEST-INFORMATION attribute.</t>
        <t>The floor control server <bcp14>MUST</bcp14> identify the floors being released (i.e., the floors associated with the floor request identified by the FLOOR-REQUEST-ID attribute) in FLOOR-REQUEST-STATUS attributes to the FLOOR-REQUEST-INFORMATION grouped attribute.</t>
        <t>The floor control server <bcp14>MUST</bcp14> add an OVERALL-REQUEST-STATUS attribute to the FLOOR-REQUEST-INFORMATION grouped attribute.  The Request Status value <bcp14>SHOULD</bcp14> be Released, if the floor (or floors) had been previously granted, or Cancelled, if the floor (or floors) had not been previously granted.  The floor control server <bcp14>MAY</bcp14> add a STATUS-INFO attribute with extra information about the floor request.</t>
      </section>
      <section anchor="sec_server_floorinfo" numbered="true" toc="default">
        <name>Reception of a FloorQuery Message</name>
        <t>On reception of a FloorQuery message, the floor control server follows the rules in <xref target="sec_auth" format="default"/> that relate to client authentication. If while processing the FloorQuery message, the floor control server encounters an error, it <bcp14>MUST</bcp14> generate an Error response following the procedures described in <xref target="sec_server_error" format="default"/>.</t>
        <t>When communicating over an unreliable transport and upon receiving a FloorQuery from a participant, the floor control server <bcp14>MUST</bcp14> respond with a FloorStatus message within the transaction failure window to complete the transaction.</t>
        <t>A floor control server receiving a FloorQuery message from a client <bcp14>SHOULD</bcp14> keep this client informed about the status of the floors identified by FLOOR-ID attributes in the FloorQuery message. Floor control servers keep clients informed by using FloorStatus messages.</t>
        <t>An individual FloorStatus message carries information about a single floor. So, when a FloorQuery message requests information about more than one floor, the floor control server needs to send separate FloorStatus messages for different floors.</t>
        <t>The information FloorQuery messages carry may depend on the user requesting the information. For example, a chair may be able to receive information about pending requests, while a regular user may not be authorized to do so.</t>
        <section anchor="sec_server_floorinfo_first" numbered="true" toc="default">
          <name>Generation of the First FloorStatus Message</name>
          <t>The successful processing of a FloorQuery message by a floor control server involves generating one or several FloorStatus messages, the first of which <bcp14>SHOULD</bcp14> be generated as soon as possible.</t>
          <t>The floor control server <bcp14>MUST</bcp14> copy the Conference ID, the Transaction ID, and the User ID from the FloorQuery message into the FloorStatus message, as described in <xref target="sec_transactions_server" format="default"/>.</t>
          <t>If the FloorQuery message did not contain any FLOOR-ID attribute, the floor control server sends the FloorStatus message without adding any additional attribute and does not send any subsequent FloorStatus message to the floor participant.</t>
          <t>If the FloorQuery message contained one or more FLOOR-ID attributes, the floor control server chooses one from among them and adds this FLOOR-ID attribute to the FloorStatus message. The floor control server <bcp14>SHOULD</bcp14> add a FLOOR-REQUEST-INFORMATION grouped attribute for each floor request associated to the floor. Each FLOOR-REQUEST-INFORMATION grouped attribute contains a number of attributes that provide information about the floor request. For each FLOOR-REQUEST-INFORMATION attribute, the floor control server follows the following steps.</t>
          <t>The floor control server <bcp14>MUST</bcp14> identify the floor request the FLOOR-REQUEST-INFORMATION attribute applies to by filling the Floor Request ID field of the FLOOR-REQUEST-INFORMATION attribute.</t>
          <t>The floor control server <bcp14>MUST</bcp14> add FLOOR-REQUEST-STATUS attributes to the FLOOR-REQUEST-INFORMATION grouped attribute identifying the floors being requested (i.e., the floors associated with the floor request identified by the FLOOR-REQUEST-ID attribute).</t>
          <t>The floor control server <bcp14>SHOULD</bcp14> add a BENEFICIARY-ID attribute to the FLOOR-REQUEST-INFORMATION grouped attribute identifying the beneficiary of the floor request.  Additionally, the floor control server <bcp14>MAY</bcp14> provide the display name and the URI of the beneficiary in this BENEFICIARY-INFORMATION attribute.</t>
          <t>The floor control server <bcp14>MAY</bcp14> provide information about the requester of the floor in a REQUESTED-BY-INFORMATION attribute inside the FLOOR-REQUEST-INFORMATION grouped attribute.</t>
          <t>The floor control server <bcp14>MAY</bcp14> provide the reason why the floor participant requested the floor in a PARTICIPANT-PROVIDED-INFO.</t>
          <t>The floor control server <bcp14>MAY</bcp14> also add to the FLOOR-REQUEST-INFORMATION grouped attribute a PRIORITY attribute with the Priority value requested for the floor request.</t>
          <t>The floor control server <bcp14>MUST</bcp14> add an OVERALL-REQUEST-STATUS attribute to the FLOOR-REQUEST-INFORMATION grouped attribute with the current status of the floor request. The floor control server <bcp14>MAY</bcp14> add a STATUS-INFO attribute with extra information about the floor request.</t>
          <t>The floor control server <bcp14>MAY</bcp14> provide information about the status of the floor request as it relates to each of the floors being requested in the FLOOR-REQUEST-STATUS attributes.</t>
        </section>
        <section anchor="sec_server_floorinfo_subsequent" numbered="true" toc="default">
          <name>Generation of Subsequent FloorStatus Messages</name>
          <t>If the FloorQuery message carried more than one FLOOR-ID attribute, the floor control server <bcp14>SHOULD</bcp14> generate a FloorStatus message for each of them (except for the FLOOR-ID attribute chosen for the first FloorStatus message) as soon as possible. These FloorStatus messages are generated following the same rules as those for the first FloorStatus message (see <xref target="sec_server_floorinfo_first" format="default"/>), but their Transaction ID is 0 when using a reliable transport and non-zero and unique in the context of outstanding transactions when using an unreliable transport (cf.&nbsp;<xref target="sec_transactions" format="default"/>).</t>
          <t>After generating these messages, the floor control server sends FloorStatus messages, periodically keeping the client informed about all the floors for which the client requested information. The Transaction ID of these messages <bcp14>MUST</bcp14> be 0 when using a reliable transport and non-zero and unique in the context of outstanding transactions when using an unreliable transport (cf.&nbsp;<xref target="sec_transactions" format="default"/>).</t>
          <aside>
            <t>The rate at which the floor control server sends FloorStatus messages is a matter of local policy. A floor control server may choose to send a new FloorStatus message every time a new floor request arrives, while another may choose to only send a new FloorStatus message when a new floor request is Granted.</t>
          </aside>
          <t>When communicating over an unreliable transport and a FloorStatusAck message is not received within the transaction failure window, the floor control server <bcp14>MUST</bcp14> retransmit the FloorStatus message according to <xref target="udp_transport" format="default"/>.</t>
        </section>
      </section>
      <section anchor="sec_server_chairaction" numbered="true" toc="default">
        <name>Reception of a ChairAction Message</name>
        <t>On reception of a ChairAction message, the floor control server follows the rules in <xref target="sec_auth" format="default"/> that relate to client authentication and authorization. If while processing the ChairAction message, the floor control server encounters an error, it <bcp14>MUST</bcp14> generate an Error response following the procedures described in <xref target="sec_server_error" format="default"/>.</t>
        <t>The successful processing of a ChairAction message by a floor control server involves generating a ChairActionAck message, which <bcp14>SHOULD</bcp14> be generated as soon as possible.</t>
        <t>When communicating over an unreliable transport and upon receiving a ChairAction from a chair, the floor control server <bcp14>MUST</bcp14> respond with a ChairActionAck message within the transaction failure window to complete the transaction.</t>
        <t>The floor control server <bcp14>MUST</bcp14> copy the Conference ID, the Transaction ID, and the User ID from the ChairAction message into the ChairActionAck message, as described in <xref target="sec_transactions_server" format="default"/>.</t>
        <t>The floor control server needs to take into consideration the operation requested in the ChairAction message (e.g., granting a floor) but does not necessarily need to perform it as requested by the floor chair. The operation that the floor control server performs depends on the ChairAction message and on the internal state of the floor control server.</t>
        <t>For example, a floor chair may send a ChairAction message granting a floor that was requested as part of an atomic floor request operation that involved several floors. Even if the chair responsible for one of the floors instructs the floor control server to grant the floor, the floor control server will not grant it until the chairs responsible for the other floors agree to grant them as well.</t>
        <t>So, the floor control server is ultimately responsible for keeping a coherent floor state using instructions from floor chairs as input to this state.</t>
        <t>If the new Status in the ChairAction message is Accepted and all the bits of the Queue Position field are zero, the floor chair is requesting that the floor control server assign a queue position (e.g., the last in the queue) to the floor request based on the local policy of the floor control server. (Of course, such a request only applies if the floor control server implements a queue.)</t>
      </section>
      <section anchor="sec_server_helloack" numbered="true" toc="default">
        <name>Reception of a Hello Message</name>
        <t>On reception of a Hello message, the floor control server follows the rules in <xref target="sec_auth" format="default"/> that relate to client authentication. If while processing the Hello message, the floor control server encounters an error, it <bcp14>MUST</bcp14> generate an Error response following the procedures described in <xref target="sec_server_error" format="default"/>.</t>
        <t>If the version of BFCP specified in the version field of the COMMON-HEADER is supported by the floor control server, it <bcp14>MUST</bcp14> respond with the same version number in the HelloAck; this defines the version for all subsequent BFCP messages within this BFCP Connection.</t>
        <t>When communicating over an unreliable transport and upon receiving a Hello from a participant, the floor control server <bcp14>MUST</bcp14> respond with a HelloAck message within the transaction failure window to complete the transaction.</t>
        <t>The successful processing of a Hello message by a floor control server involves generating a HelloAck message, which <bcp14>SHOULD</bcp14> be generated as soon as possible. The floor control server <bcp14>MUST</bcp14> copy the Conference ID, the Transaction ID, and the User ID from the Hello into the HelloAck, as described in <xref target="sec_transactions_server" format="default"/>.</t>
        <t>The floor control server <bcp14>MUST</bcp14> add a SUPPORTED-PRIMITIVES attribute to the HelloAck message listing all the primitives (i.e., BFCP messages) supported by the floor control server.</t>
        <t>The floor control server <bcp14>MUST</bcp14> add a SUPPORTED-ATTRIBUTES attribute to the HelloAck message listing all the attributes supported by the floor control server.</t>
      </section>
      <section anchor="sec_server_error" numbered="true" toc="default">
        <name>Error Message Generation</name>
        <t>Error messages are always sent in response to a previous message from the client as part of a client-initiated transaction. The ABNF in <xref target="sec_msg_format_Error" format="default"/> describes the attributes that an Error message can contain. In addition, the ABNF specifies normatively which of these attributes are mandatory and which ones are optional.</t>
        <t>The floor control server <bcp14>MUST</bcp14> copy the Conference ID, the Transaction ID, and the User ID from the message from the client into the Error message, as described in <xref target="sec_transactions_server" format="default"/>.</t>
        <t>The floor control server <bcp14>MUST</bcp14> add an ERROR-CODE attribute to the Error message. The ERROR-CODE attribute contains an error code from <xref target="tab_errorcode" format="default"/>. Additionally, the floor control server may add an ERROR-INFO attribute with extra information about the error.</t>
      </section>
    </section>
    <section anchor="sec_security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>BFCP uses TLS/DTLS to provide mutual authentication between clients and servers. TLS/DTLS also provides replay and integrity protection and confidentiality.  It is <bcp14>RECOMMENDED</bcp14> that TLS/DTLS with an encryption algorithm according to <xref target="sec_lower-security" format="default"/> always be used.  In cases where signaling/control traffic is properly protected, as described in <xref target="sec_auth" format="default"/>, it is <bcp14>REQUIRED</bcp14> to use a mandated encryption algorithm.  BFCP entities <bcp14>MAY</bcp14> use other security mechanisms to interwork with legacy implementation that do not use TLS/DTLS as long as these mechanisms provide similar security properties.  An example of other mechanisms to effectively secure a nonsecure BFCP connection is IPsec <xref target="RFC4301" format="default"/>.</t>
      <t>The remainder of this section analyzes some of the threats against BFCP and how they are addressed.</t>
      <t>An attacker may attempt to impersonate a client (a floor participant or a floor chair) in order to generate forged floor requests or to grant or deny existing floor requests. Client impersonation is avoided by having servers only accept BFCP messages over authenticated TLS/DTLS connections. The floor control server assumes that attackers cannot hijack the TLS/DTLS connection and, therefore, that messages over the TLS/DTLS connection come from the client that was initially authenticated.</t>
      <t>An attacker may attempt to impersonate a floor control server. A successful attacker would be able to make clients think that they hold a particular floor so that they would try to access a resource (e.g., sending media) without having legitimate rights to access it. Floor control server impersonation is avoided by having servers only accept BFCP messages over authenticated TLS/DTLS connections, as well as ensuring clients only send and accept messages over authenticated TLS/DTLS connections.</t>
      <t>Attackers may attempt to modify messages exchanged by a client and a floor control server. The integrity protection provided by TLS/DTLS connections prevents this attack.</t>
      <t>An attacker may attempt to fetch a valid message sent by a client to a floor control server and replay it over a connection between the attacker and the floor control server. This attack is prevented by having floor control servers check that messages arriving over a given authenticated TLS/DTLS connection use an authorized user ID (i.e., a user ID that the user that established the authenticated TLS/DTLS connection is allowed to use).</t>
      <t>Attackers may attempt to pick messages from the network to get access to confidential information between the floor control server and a client (e.g., why a floor request was denied). TLS/DTLS confidentiality prevents this attack. Therefore, it is <bcp14>REQUIRED</bcp14> that TLS/DTLS be used with an encryption algorithm according to <xref target="sec_lower-security" format="default"/>.</t>
    </section>

    <section anchor="sec_iana" numbered="true" toc="default">
      <name>IANA Considerations</name>

      <t>The IANA has created a registry for BFCP parameters called "The Binary Floor Control Protocol (BFCP) Parameters". This registry has a number of subregistries, which are described in the following sections.</t>
      <section numbered="true" toc="default">
        <name>Attributes Subregistry</name>
        <t>This section establishes the "Attributes" subregistry under the BFCP
	Parameters registry. As per the terminology in RFC 8126 <xref
	target="RFC8126" format="default"/>, the registration policy for BFCP
	attributes is "Specification Required". For the purposes of this
	subregistry, the BFCP attributes for which IANA registration is
	requested <bcp14>MUST</bcp14> be defined by a Standards Track
	RFC. Such an RFC <bcp14>MUST</bcp14> specify the attribute's type,
	name, format, and semantics.</t> 
        <t>For each BFCP attribute, the IANA registers its type, its name, and
	the reference to the RFC where the attribute is defined. The following
	table contains the initial values of this subregistry.</t> 
        <table anchor="tab_iana-attributes" align="center">
          <name>Initial values of the BFCP Attributes subregistry</name>
          <thead>
            <tr>
              <th align="center">Type</th>
              <th align="left">Attribute</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">1</td>
              <td align="left">BENEFICIARY-ID</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">2</td>
              <td align="left">FLOOR-ID</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">3</td>
              <td align="left">FLOOR-REQUEST-ID</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">4</td>
              <td align="left">PRIORITY</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="left">REQUEST-STATUS</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">6</td>
              <td align="left">ERROR-CODE</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">7</td>
              <td align="left">ERROR-INFO</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">8</td>
              <td align="left">PARTICIPANT-PROVIDED-INFO</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">9</td>
              <td align="left">STATUS-INFO</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">10</td>
              <td align="left">SUPPORTED-ATTRIBUTES</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">11</td>
              <td align="left">SUPPORTED-PRIMITIVES</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">12</td>
              <td align="left">USER-DISPLAY-NAME</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">13</td>
              <td align="left">USER-URI</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">14</td>
              <td align="left">BENEFICIARY-INFORMATION</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">15</td>
              <td align="left">FLOOR-REQUEST-INFORMATION</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">16</td>
              <td align="left">REQUESTED-BY-INFORMATION</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">17</td>
              <td align="left">FLOOR-REQUEST-STATUS</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">18</td>
              <td align="left">OVERALL-REQUEST-STATUS</td>
              <td align="left">RFC 8855</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sec_iana_primitive" numbered="true" toc="default">
        <name>Primitives Subregistry</name>

        <t>This section establishes the "Primitives" subregistry under the
	BFCP Parameters registry. As per the terminology in RFC 8126 <xref
	target="RFC8126" format="default"/>, the registration policy for BFCP
	primitives is "Specification Required". For the purposes of this
	subregistry, the BFCP primitives for which IANA registration is
	requested <bcp14>MUST</bcp14> be defined by a Standards Track
	RFC. Such an RFC <bcp14>MUST</bcp14> specify the primitive's value,
	name, format, and semantics.</t> 
        <t>For each BFCP primitive, the IANA registers its value, its name, and the reference to the RFC where the primitive is defined. The following table contains the initial values of this subregistry.</t>
        <table anchor="tab_iana-primitives" align="center">
          <name>Initial values of the BFCP Primitives subregistry</name>
          <thead>
            <tr>
              <th align="center">Value</th>
              <th align="left">Primitive</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">1</td>
              <td align="left">FloorRequest</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">2</td>
              <td align="left">FloorRelease</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">3</td>
              <td align="left">FloorRequestQuery</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">4</td>
              <td align="left">FloorRequestStatus</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="left">UserQuery</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">6</td>
              <td align="left">UserStatus</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">7</td>
              <td align="left">FloorQuery</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">8</td>
              <td align="left">FloorStatus</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">9</td>
              <td align="left">ChairAction</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">10</td>
              <td align="left">ChairActionAck</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">11</td>
              <td align="left">Hello</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">12</td>
              <td align="left">HelloAck</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">13</td>
              <td align="left">Error</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">14</td>
              <td align="left">FloorRequestStatusAck</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">15</td>
              <td align="left">FloorStatusAck</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">16</td>
              <td align="left">Goodbye</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">17</td>
              <td align="left">GoodbyeAck</td>
              <td align="left">RFC 8855</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section numbered="true" toc="default">
        <name>Request Statuses Subregistry</name>
        <t>This section establishes the "Request Statuses" subregistry under the
	BFCP Parameters registry. As per the terminology in RFC 8126 <xref
	target="RFC8126" format="default"/>, the registration policy for BFCP
	request statuses is "Specification Required". For the purposes of
	this subregistry, the BFCP request statuses for which IANA registration
	is requested <bcp14>MUST</bcp14> be defined by a Standards Track
	RFC. Such an RFC <bcp14>MUST</bcp14> specify the value and the
	semantics of the request status.</t> 
        <t>For each BFCP request status, the IANA registers its value, its meaning, and the reference to the RFC where the request status is defined. The following table contains the initial values of this subregistry.</t>
        <table anchor="tab_iana-requeststatusvalues" align="center">
          <name>Initial values of the Request Statuses subregistry</name>
          <thead>
            <tr>
              <th align="center">Value</th>
              <th align="left">Status</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">1</td>
              <td align="left">Pending</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">2</td>
              <td align="left">Accepted</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">3</td>
              <td align="left">Granted</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">4</td>
              <td align="left">Denied</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="left">Cancelled</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">6</td>
              <td align="left">Released</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">7</td>
              <td align="left">Revoked</td>
              <td align="left">RFC 8855</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sec_iana_errorcode" numbered="true" toc="default">
        <name>Error Codes Subregistry</name>

        <t>This section establishes the "Error Codes" subregistry under the BFCP
	Parameters registry. As per the terminology in RFC 8126 <xref
	target="RFC8126" format="default"/>, the registration policy for BFCP
	error codes is "Specification Required". For the purposes of
	this subregistry, the BFCP error codes for which IANA registration is
	requested <bcp14>MUST</bcp14> be defined by a Standards Track
	RFC. Such an RFC <bcp14>MUST</bcp14> specify the value and the
	semantics of the error code, and any Error Specific Details that apply
	to it.</t> 
        <t>For each BFCP primitive, the IANA registers its value, its meaning, and the reference to the RFC where the primitive is defined. The following table contains the initial values of this subregistry.</t>

        <table anchor="tab_iana-errorcode" align="center">
          <name>Initial values of the Error Codes subregistry</name>
          <thead>
            <tr>
              <th align="center">Value</th>
              <th align="left">Meaning</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">1</td>
              <td align="left">Conference Does Not Exist</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">2</td>
              <td align="left">User Does Not Exist</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">3</td>
              <td align="left">Unknown Primitive</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">4</td>
              <td align="left">Unknown Mandatory Attribute</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="left">Unauthorized Operation</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">6</td>
              <td align="left">Invalid Floor ID</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">7</td>
              <td align="left">Floor Request ID Does Not Exist</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">8</td>
              <td align="left">You have Already Reached the Maximum Number 
                               of Ongoing Floor Requests for This Floor</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">9</td>
              <td align="left">Use TLS</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">10</td>
              <td align="left">Unable to Parse Message</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">11</td>
              <td align="left">Use DTLS</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">12</td>
              <td align="left">Unsupported Version</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">13</td>
              <td align="left">Incorrect Message Length</td>
              <td align="left">RFC 8855</td>
            </tr>
            <tr>
              <td align="center">14</td>
              <td align="left">Generic Error</td>
              <td align="left">RFC 8855</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="sec_changes" numbered="true" toc="default">
      <name>Changes from RFC 4582</name>
      <t>The following is the list of technical changes and other non-trivial fixes from <xref target="RFC4582" format="default"/>.</t>
      <section numbered="true" toc="default">
        <name>Extensions for an Unreliable Transport</name>
        <t>The main purpose of this work was to revise the specification to support BFCP over an unreliable transport, resulting in the following changes:</t>
        <ol spacing="normal" type="1">
          <li>
            <t>Overview of Operation (<xref target="sec_overview" format="default"/>):</t>
            <t>
            Changed the description of client-initiated and server-initiated transactions, referring to <xref target="sec_transactions" format="default"/>.</t>
          </li>
          <li>
            <t>COMMON-HEADER Format (<xref target="sec_format_common" format="default"/>):</t>
            <t>
            Ver(sion) field, where the value 2 is used for the extensions for an unreliable transport. Added new R and F flag bits for an unreliable transport. Res(erved) field is now 3 bit. New optional Fragment Offset and Fragment Length fields.</t>
          </li>
          <li>
            <t>New primitives (<xref target="sec_format_common" format="default"/>):</t>
            <t>
            Added four new primitives: FloorRequestStatusAck, FloorStatusAck, Goodbye, and GoodbyeAck.</t>
          </li>
          <li>
            <t>New error codes (<xref target="sec_format_attributes_error-code" format="default"/>):</t>

            <t>
            Added three new error codes: "Unable to Parse Message", "Use DTLS" and "Unsupported Version". Note that two additional error codes were added, see <xref target="sec_changes_other" format="default"/>.</t>
          </li>
          <li>
            <t>ABNF for new primitives (<xref target="sec_msg_format" format="default"/>):</t>
            <t>
            Added new subsections with normative ABNF for the new primitives.</t>
          </li>
          <li>
            <t>Transport split in two (<xref target="sec_transport" format="default"/>):</t>
            <t><xref target="sec_transport" format="default"/> specifying the transport was split in two subsections; <xref target="tcp_transport" format="default"/> for a reliable transport and <xref target="udp_transport" format="default"/> for an unreliable transport. The specification for an unreliable transport, among other issues, deals with reliability, congestion control, fragmentation and ICMP.</t>
          </li>
          <li>
            <t>Mandated DTLS (<xref target="sec_lower-security" format="default"/> and <xref target="sec_auth" format="default"/>):</t>
            <t>
            Mandated DTLS support when transport over UDP is used.</t>
          </li>
          <li>
            <t>Transaction changes (<xref target="sec_transactions" format="default"/>):</t>
            <t>
            Server-initiated transactions over an unreliable transport have non-zero and unique Transaction IDs. Over an unreliable transport, the retransmit timers T1 and T2 described in <xref target="timers" format="default"/> apply.</t>
          </li>
          <li>
            <t>Timely response required (<xref target="timers" format="default"/>, <xref target="sec_client_request_response" format="default"/>, <xref target="sec_participant_cancel_response" format="default"/>, <xref target="sec_chair_instruct_response" format="default"/>, <xref target="sec_client_floorinfo_response" format="default"/>, <xref target="sec_client_info_response" format="default"/>, <xref target="sec_client_user_response" format="default"/>, <xref target="sec_client_hello_responses" format="default"/>, <xref target="sec_recept_frsm" format="default"/> and <xref target="sec_recept_fsm" format="default"/>):</t>
            <t>
            Described that a given response must be sent within the transaction failure window to complete the transaction.</t>
          </li>
          <li>
            <t>Updated IANA Considerations (<xref target="sec_iana" format="default"/>):</t>
            <t>
            Added the new primitives and error codes to <xref target="sec_iana_primitive" format="default"/> and <xref target="sec_iana_errorcode" format="default"/> respectively.</t>
          </li>
          <li>
            <t>Examples over an unreliable transport (<xref target="app_unrelcallflow" format="default"/>):</t>
            <t>
            Added sample interactions over an unreliable transport for the scenarios in <xref target="fig_flow1" format="default"/> and <xref target="fig_flow2" format="default"/> </t>
          </li>
          <li>
            <t>Motivation for an unreliable transport (<xref target="app_motivation" format="default"/>):</t>
            <t>
            Added introduction to and motivation for extending BFCP to support an unreliable transport.</t>
          </li>
        </ol>
      </section>
      <section anchor="sec_changes_other" numbered="true" toc="default">
        <name>Other Changes</name>
        <t>Clarifications and bug fixes:</t>
        <ol spacing="normal" type="1">
          <li> 
            <t>ABNF fixes (<xref target="fig_ben-information" format="default"/>, <xref target="fig_floor-request-information" format="default"/>, <xref target="fig_reqby-information" format="default"/>, <xref target="fig_floor-req-status" format="default"/>, <xref target="fig_overall-req-status" format="default"/>, and the ABNF figures in <xref target="sec_msg_format" format="default"/>):</t>
            <t>
          Although formally correct in  <xref target="RFC4582" format="default"/>, the notation has changed in a number of figures to an equivalent form for clarity, e.g., <tt>s/*1(FLOOR-ID)/[FLOOR-ID]/</tt> in <xref target="fig_floorstatus" format="default"/> and <tt>s/*[XXX]/*(XXX)/</tt> in the other figures.</t>
          </li>
          <li>
            <t>Typo (<xref target="sec_client_hello_responses" format="default"/>):</t>
            <t>
          Changed from SUPPORTED-PRIMITVIES to SUPPORTED-PRIMITIVES in the second paragraph.</t>
          </li>
          <li>
            <t>Corrected attribute type (<xref target="sec_server_request_first" format="default"/>):</t>
            <t>
          Changed from PARTICIPANT-PROVIDED-INFO to PRIORITY attribute in the eighth paragraph, since the note below describes priority and that the last paragraph deals with PARTICIPANT-PROVIDED-INFO.</t>
          </li>
          <li>
            <t>New error codes (<xref target="sec_format_attributes_error-code" format="default"/>):</t>
            <t>
          Added two additional error codes: "Incorrect Message Length" and "Generic Error".</t>
          </li>
          <li>
             <t>New cipher suites (<xref target="sec_lower-security" format="default"/>)</t>
             <t>Additional cipher suites are now specified which should be supported.</t>
          </li>
          <li>
            <t>Assorted clarifications (Across the document):</t>
            <t>
          Language clarifications as a result of reviews. Also, the normative language was tightened where appropriate, i.e. changed from <bcp14>SHOULD</bcp14> strength to <bcp14>MUST</bcp14> in a number of places.</t>
          </li>
        </ol>
      </section>
    </section>
  </middle>
  <back>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6298.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4582.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5018.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6347.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3629.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>

<reference anchor='RFC8856' target="https://www.rfc-editor.org/info/rfc8856">
<front>
<title>Session Description Protocol (SDP) Format for Binary Floor Control
Protocol (BFCP) Streams</title>
<author initials='G' surname='Camarillo' fullname='Gonzalo Camarillo'>
    <organization />
</author>
<author initials='T' surname='Kristensen' fullname='Tom Kristensen'>
    <organization />
</author>
<author initials='C.' surname='Holmberg' fullname='Christer Holmberg'>
    <organization />
</author>
<date month="January" year="2021"/>
</front>
<seriesInfo name="RFC" value="8856"/>
<seriesInfo name="DOI" value="10.17487/RFC8856"/>
</reference>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4961.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5389.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8085.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8445.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3264.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4376.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5239.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3261.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4301.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6501.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6503.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6504.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1191.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8201.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4821.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5763.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6951.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7525.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4380.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6081.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4960.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6544.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-manner-tsvwg-gut-02.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-mmusic-media-path-middleboxes-07.xml"/>

       <reference anchor="IMC05" target="https://www.usenix.org/legacy/event/imc05/tech/full_papers/guha/guha.pdf">
          <front>
            <title>Characterization and Measurement of TCP Traversal through NATs and Firewalls</title>
            <author initials="S" surname="Guha"/>
            <author initials="P" surname="Francis"/>
            <date month="" year="2005"/>
          </front>
        </reference>

        <reference anchor="P2PNAT" target="https://www.usenix.org/legacy/events/usenix05/tech/general/full_papers/ford/ford.pdf">
          <front>
            <title>Peer-to-Peer Communication Across Network Address Translators</title>
            <author initials="B" surname="Ford"/>
            <author initials="P" surname="Srisuresh"/>
            <author initials="D" surname="Kegel"/>
            <date month="April" year="2005"/>
          </front>
        </reference>
      </references>
    </references>
    <section anchor="app_unrelcallflow" numbered="true" toc="default">
      <name>Example Call Flows for BFCP over an Unreliable Transport</name>
      <t>With reference to <xref target="sec_overview_user" format="default"/>, the following figures show representative call flows for requesting and releasing a floor, and obtaining status information about a floor when BFCP is deployed over an unreliable transport. The figures here show a lossless interaction.</t>
      <figure anchor="ReqRelUnrelExample">
        <name>Requesting and releasing a floor</name>
        <artwork align="left" name="" type="" alt=""><![CDATA[
      Floor Participant                                 Floor Control
                                                           Server
              |(1) FloorRequest                               |
              |Transaction Responder: 0                       |
              |Transaction ID: 123                            |
              |User ID: 234                                   |
              |FLOOR-ID: 543                                  |
              |---------------------------------------------->|
              |                                               |
              |(2) FloorRequestStatus                         |
              |Transaction Responder: 1                       |
              |Transaction ID: 123                            |
              |User ID: 234                                   |
              |FLOOR-REQUEST-INFORMATION                      |
              |      Floor Request ID: 789                    |
              |      OVERALL-REQUEST-STATUS                   |
              |              Request Status: Pending          |
              |      FLOOR-REQUEST-STATUS                     |
              |            Floor ID: 543                      |
              |<----------------------------------------------|
              |                                               |
              |(3) FloorRequestStatus                         |
              |Transaction Responder: 0                       |
              |Transaction ID: 124                            |
              |User ID: 234                                   |
              |FLOOR-REQUEST-INFORMATION                      |
              |      Floor Request ID: 789                    |
              |      OVERALL-REQUEST-STATUS                   |
              |              Request Status: Accepted         |
              |              Queue Position: 1st              |
              |      FLOOR-REQUEST-STATUS                     |
              |            Floor ID: 543                      |
              |<----------------------------------------------|
              |                                               |
              |(4) FloorRequestStatusAck                      |
              |Transaction Responder: 1                       |
              |Transaction ID: 124                            |
              |User ID: 234                                   |
              |---------------------------------------------->|
              |                                               |
              |(5) FloorRequestStatus                         |
              |Transaction Responder: 0                       |
              |Transaction ID: 125                            |
              |User ID: 234                                   |
              |FLOOR-REQUEST-INFORMATION                      |
              |      Floor Request ID: 789                    |
              |      OVERALL-REQUEST-STATUS                   |
              |              Request Status: Granted          |
              |      FLOOR-REQUEST-STATUS                     |
              |            Floor ID: 543                      |
              |<----------------------------------------------|
              |                                               |
              |(6) FloorRequestStatusAck                      |
              |Transaction Responder: 1                       |
              |Transaction ID: 125                            |
              |User ID: 234                                   |
              |---------------------------------------------->|
              |                                               |
              |(7) FloorRelease                               |
              |Transaction Responder: 0                       |
              |Transaction ID: 126                            |
              |User ID: 234                                   |
              |FLOOR-REQUEST-ID: 789                          |
              |---------------------------------------------->|
              |                                               |
              |(8) FloorRequestStatus                         |
              |Transaction Responder: 1                       |
              |Transaction ID: 126                            |
              |User ID: 234                                   |
              |FLOOR-REQUEST-INFORMATION                      |
              |      Floor Request ID: 789                    |
              |      OVERALL-REQUEST-STATUS                   |
              |              Request Status: Released         |
              |      FLOOR-REQUEST-STATUS                     |
              |            Floor ID: 543                      |
              |<----------------------------------------------|]]></artwork>
      </figure>

      <t>Note that in <xref target="ReqRelUnrelExample" format="default"/>, the
    FloorRequestStatus message from the floor control server to the floor
    participant is a transaction-closing message as a response to the
    client-initiated transaction with Transaction ID 126. As such, it is not
    followed by a FloorRequestStatusAck message from the floor participant to
    the floor control server.</t>
      <figure anchor="StatusUnrelExample">
        <name>Obtaining status information about a floor</name>
        <artwork align="left" name="" type="" alt=""><![CDATA[
      Floor Participant                                 Floor Control
                                                           Server
              |(1) FloorQuery                                 |
              |Transaction Responder: 0                       |
              |Transaction ID: 257                            |
              |User ID: 234                                   |
              |FLOOR-ID: 543                                  |
              |---------------------------------------------->|
              |                                               |
              |(2) FloorStatus                                |
              |Transaction Responder: 1                       |
              |Transaction ID: 257                            |
              |User ID: 234                                   |
              |FLOOR-ID:543                                   |
              |FLOOR-REQUEST-INFORMATION                      |
              |      Floor Request ID: 764                    |
              |      OVERALL-REQUEST-STATUS                   |
              |              Request Status: Accepted         |
              |              Queue Position: 1st              |
              |      FLOOR-REQUEST-STATUS                     |
              |            Floor ID: 543                      |
              |      BENEFICIARY-INFORMATION                  |
              |                  Beneficiary ID: 124          |
              |FLOOR-REQUEST-INFORMATION                      |
              |      Floor Request ID: 635                    |
              |      OVERALL-REQUEST-STATUS                   |
              |              Request Status: Accepted         |
              |              Queue Position: 2nd              |
              |      FLOOR-REQUEST-STATUS                     |
              |            Floor ID: 543                      |
              |      BENEFICIARY-INFORMATION                  |
              |                  Beneficiary ID: 154          |
              |<----------------------------------------------|
              |                                               |
              |(3) FloorStatus                                |
              |Transaction Responder: 0                       |
              |Transaction ID: 258                            |
              |User ID: 234                                   |
              |FLOOR-ID:543                                   |
              |FLOOR-REQUEST-INFORMATION                      |
              |      Floor Request ID: 764                    |
              |      OVERALL-REQUEST-STATUS                   |
              |              Request Status: Granted          |
              |      FLOOR-REQUEST-STATUS                     |
              |            Floor ID: 543                      |
              |      BENEFICIARY-INFORMATION                  |
              |                  Beneficiary ID: 124          |
              |FLOOR-REQUEST-INFORMATION                      |
              |      Floor Request ID: 635                    |
              |      OVERALL-REQUEST-STATUS                   |
              |              Request Status: Accepted         |
              |              Queue Position: 1st              |
              |      FLOOR-REQUEST-STATUS                     |
              |            Floor ID: 543                      |
              |      BENEFICIARY-INFORMATION                  |
              |                  Beneficiary ID: 154          |
              |<----------------------------------------------|
              |                                               |
              |(4) FloorStatusAck                             |
              |Transaction Responder: 1                       |
              |Transaction ID: 258                            |
              |User ID: 234                                   |
              |---------------------------------------------->|
              |                                               |
              |(5) FloorStatus                                |
              |Transaction Responder: 0                       |
              |Transaction ID: 259                            |
              |User ID: 234                                   |
              |FLOOR-ID:543                                   |
              |FLOOR-REQUEST-INFORMATION                      |
              |      Floor Request ID: 635                    |
              |      OVERALL-REQUEST-STATUS                   |
              |              Request Status: Granted          |
              |      FLOOR-REQUEST-STATUS                     |
              |            Floor ID: 543                      |
              |      BENEFICIARY-INFORMATION                  |
              |                  Beneficiary ID: 154          |
              |<----------------------------------------------|
              |                                               |
              |(6) FloorStatusAck                             |
              |Transaction Responder: 1                       |
              |Transaction ID: 259                            |
              |User ID: 234                                   |
              |---------------------------------------------->|]]></artwork>
      </figure>
    </section>
    <section anchor="app_motivation" numbered="true" toc="default">
      <name>Motivation for Supporting an Unreliable Transport</name>
      <t>This appendix is provided as an aid to understand the background and rationale for adding support for unreliable transport.</t>
      <section anchor="motivation" numbered="true" toc="default">
        <name>Motivation</name>
        <t>In existing video conferencing deployments, BFCP is used to manage the floor for the content sharing associated with the conference. For peer-to-peer scenarios, including business-to-business conferences and point-to-point conferences in general, it is frequently the case that one or both endpoints exist behind a NAT. BFCP roles are negotiated in the offer/answer exchange as specified in <xref target="RFC8856" format="default"/>, resulting in one endpoint being responsible for opening the TCP connection used for the BFCP communication.</t>
        <figure anchor="use_case">
          <name>Use case</name>
          <artwork align="center" name="" type="" alt=""><![CDATA[
             +---------+
             | Network |
             +---------+
      +-----+ /       \ +-----+
      | NAT |/         \| NAT |
      +-----+           +-----+
+----+ /                     \ +----+
|BFCP|/                       \|BFCP|
| UA |                         | UA |
+----+                         +----+]]></artwork>
        </figure>
        <t>The communication session between the video conferencing endpoints typically consists of a number of RTP over UDP media streams for audio and video and a BFCP connection for floor control. Existing deployments are most common in, but not limited to, enterprise networks. In existing deployments, NAT traversal for the RTP streams works using ICE and/or other methods, including those described in <xref target="I-D.ietf-mmusic-media-path-middleboxes" format="default"/>.</t>
        <t>When enhancing an existing SIP-based video conferencing deployment with support for content sharing, the BFCP connection often poses a problem. The reasons for this fall into two general classes. First, there may be a strong preference for UDP-based signaling in general. On high-capacity endpoints (e.g., Public Switched Telephone Network (PSTN) gateways or SIP/H.323 inter-working gateways), TCP can suffer from head-of-line blocking, and it uses many kernel buffers. Network operators view UDP as a way to avoid both of these. Second, the establishment and traversal of the TCP connection involving ephemeral ports, as is typically the case with BFCP over TCP, can be problematic, as described in <xref target="RFC6544" section="A" sectionFormat="of" format="default"/>. A broad study of NAT behavior and peer-to-peer TCP establishment for a comprehensive set of TCP NAT traversal techniques over a wide range of commercial NAT products concluded that it was not possible to establish a TCP connection in 11% of the cases <xref target="IMC05" format="default"/>. The results are worse when focusing on enterprise NATs. A study of hole-punching as a NAT traversal technique across a wide variety of deployed NATs reported consistently higher success rates when using UDP than when using TCP <xref target="P2PNAT" format="default"/>.</t>
        <t>It is worth noting that BFCP over UDP is already being used in real deployments, underlining the necessity to specify a common way to exchange BFCP messages where TCP is not appropriate, to avoid a situation where multiple different and non-interoperable implementations would coexist in the market. The purpose of this document is to extend the standard specification to support unreliable transport in order to facilitate complete interoperability between implementations.</t>
        <section anchor="alternatives" numbered="true" toc="default">
          <name>Alternatives Considered</name>
          <t>In selecting the approach of defining UDP as an alternate transport for BFCP, several alternatives were considered and explored to some degree. Each of these is discussed briefly in the following subsections. In summary, while the alternatives that were not chosen work in a number of scenarios, they are not sufficient, in and of themselves, to address the use case targeted by this document. The last alternative, presented in <xref target="thisextension" format="default"/>, was selected and is specified in this document.</t>
          <t>It is also worth noting that the IETF Transport Area was asked for a way to tunnel TCP over UDP, but at that point there was no consensus on how to achieve that.</t>
          <section anchor="ice_tcp" numbered="true" toc="default">
            <name>ICE TCP</name>
            <t>ICE TCP <xref target="RFC6544" format="default"/> extends ICE to TCP-based media, including the ability to offer a mix of TCP- and UDP-based candidates for a single stream. ICE TCP has, in general, a lower success probability for enabling TCP connectivity without a relay if both of the hosts are behind a NAT (see <xref target="RFC6544" section="A" sectionFormat="of" format="default"/>) than enabling UDP connectivity in the same scenarios. The happens because many of the currently deployed NATs in video conferencing networks do not support the flow of TCP handshake packets seen in the case of TCP simultaneous-open, either because they do not allow incoming TCP SYN packets from an address to which a SYN packet has been sent recently, or because they do not properly process the subsequent SYNACK. Implementing various techniques advocated for candidate collection in <xref target="RFC6544" format="default"/> should increase the success probability, but many of these techniques require support from some network elements (e.g., from the NATs). Such support is not common in enterprise NATs.</t>
          </section>
          <section anchor="teredo" numbered="true" toc="default">
            <name>Teredo</name>
            <t>Teredo <xref target="RFC4380" format="default"/> enables nodes located behind one or more IPv4 NATs to obtain IPv6 connectivity by tunneling packets over UDP.  Teredo extensions <xref target="RFC6081" format="default"/> provide additional capabilities to Teredo, including support for more types of NATs and support for more efficient communication.</t>
            <t>As defined, Teredo could be used to make BFCP work for the video conferencing use cases addressed in this document. However, running the service requires the help of "Teredo servers" and "Teredo relays" <xref target="RFC4380" format="default"/>. These servers and relays generally do not exist in current video conferencing deployments. It also requires IPv6 awareness on the endpoints. It should also be noted that ICMP6, as used with Teredo to complete an initial protocol exchange and confirm that the appropriate NAT bindings have been set up, is not a conventional feature of IPv4 or even IPv6, and some currently deployed IPv6 firewalls discard ICMP messages. As these networks continue to evolve and tackle the transaction to IPv6, Teredo servers and relays may be deployed, making Teredo available as a suitable alternative to BFCP over UDP.</t>
          </section>
          <section anchor="gut" numbered="true" toc="default">
            <name>GUT</name>
            <t>GUT <xref target="I-D.manner-tsvwg-gut" format="default"/>
	    attempts to facilitate tunneling over UDP by encapsulating the
	    native transport protocol and its payload (in general the whole IP
	    payload) within a UDP packet destined to the well-known port
	    GUT_P. Unfortunately, it requires user-space TCP, for which there
	    is not a readily available implementation, and creating one is a
	    large project in itself. This document has expired, and its future is still unclear as it has not yet been adopted by a working group.</t>
          </section>
          <section anchor="upnp_igd" numbered="true" toc="default">
            <name>UPnP IGD</name>
            <t>Universal Plug and Play Internet Gateway Devices (UPnP IGD) sit on the edge of the network, providing connectivity to the Internet for computers internal to the LAN, but do not allow Internet devices to connect to computers on the internal LAN. IGDs enable a computer on an internal LAN to create port mappings on their NAT, through which hosts on the Internet can send data that will be forwarded to the computer on the internal LAN. IGDs may be self-contained hardware devices or may be software components provided within an operating system.</t>
            <t>In considering UPnP IGD, several issues exist. Not all NATs support UPnP, and many that do support it are configured with it turned off by default. NATs are often multilayered, and UPnP does not work well with such NATs. For example, a typical DSL modem acts as a NAT, and the user plugs in a wireless access point behind that, which adds another layer of NAT. The client can discover the first layer of NAT using multicast, but it is harder to figure out how to discover and control NATs in the next layer up.</t>
          </section>
          <section anchor="nat_pmp" numbered="true" toc="default">
            <name>NAT PMP</name>
            <t>The NAT Port Mapping Protocol (NAT PMP) allows a computer in a private network (behind a NAT router) to automatically configure the router to allow parties outside the private network to contact it. NAT PMP runs over UDP. It essentially automates the process of port forwarding. Included in the protocol is a method for retrieving the public IP address of a NAT gateway, thus allowing a client to make this public IP address and port number known to peers that may wish to communicate with it.</t>
            <t>Many NATs do not support PMP. In those that do support it, it has similar issues with negotiation of multilayer NATs as UPnP. Video conferencing is used extensively in enterprise networks, and NAT PMP is not generally available in enterprise-class routers.</t>
          </section>
          <section anchor="sctp_udp" numbered="true" toc="default">
            <name>SCTP</name>
            <t>It would be quite straightforward to specify a BFCP binding for Stream Control Transmission Protocol (SCTP) <xref target="RFC4960" format="default"/>, and then tunnel SCTP over UDP in the use case described in <xref target="motivation" format="default"/>. SCTP is gaining some momentum currently. There was ongoing discussion in the RTCWeb Working Group regarding this approach, which resulted in <xref target="RFC6951" format="default"/>. However, this approach to tunneling over UDP was not mature enough when considered and was not even fully specified.</t>
          </section>
          <section anchor="thisextension" numbered="true" toc="default">
            <name>BFCP over UDP Transport</name>
            <t>To overcome the problems with establishing TCP flows between BFCP entities, an alternative is to define UDP as an alternate transport for BFCP, leveraging the same mechanisms in place for the RTP over UDP media streams for the BFCP communication. When using UDP as the transport, following the guidelines provided in <xref target="RFC8085" format="default"/> is recommended.</t>
            <t>Minor changes to the transaction model have been introduced in that all requests now have an appropriate response to complete the transaction. The requests are sent with a retransmission timer associated with the response to achieve reliability. This alternative does not change the semantics of BFCP. It permits UDP as an alternate transport.</t>

            <t>Existing implementations, in the spirit of the approach detailed in earlier draft versions of this document, have demonstrated that this approach is feasible. Initial compatibility among implementations has been achieved at previous interoperability events. The authors view this extension as a pragmatic solution to an existing deployment challenge. This is the chosen approach, and the extensions are specified in this document.</t>
          </section>
        </section>
      </section>
    </section>
    <section anchor="sec_acks" numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t>The XCON Working Group chairs, <contact fullname="Adam Roach"/> and <contact fullname="Alan Johnston"/>, provided useful ideas for RFC 4582 <xref target="RFC4582" format="default"/>. Additionally, <contact fullname="Xiaotao Wu"/>, <contact fullname="Paul Kyzivat"/>, <contact fullname="Jonathan Rosenberg"/>, <contact fullname="Miguel A.&nbsp;Garcia-Martin"/>, <contact fullname="Mary Barnes"/>, <contact fullname="Ben Campbell"/>, <contact fullname="Dave Morgan"/>, and <contact fullname="Oscar Novo"/> provided useful comments during the work with RFC 4582. The authors also acknowledge contributions to the revision of BFCP for use over an unreliable transport from <contact fullname="Geir Arne Sandbakken"/> who had the initial idea, <contact fullname="Alfred E.&nbsp;Heggestad"/>, <contact fullname="Trond G. Andersen"/>, <contact fullname="Gonzalo Camarillo"/>, <contact fullname="Roni Even"/>, <contact fullname="Lorenzo Miniero"/>, <contact fullname="JÃ¶rg Ott"/>, <contact fullname="Eoin McLeod"/>, <contact fullname="Mark K.&nbsp;Thompson"/>, <contact fullname="Hadriel Kaplan"/>, <contact fullname="Dan Wing"/>, <contact fullname="Cullen Jennings"/>, <contact fullname="David Benham"/>, <contact fullname="Nivedita Melinkeri"/>, <contact fullname="Woo Johnman"/>, <contact fullname="Vijaya Mandava"/>, and <contact fullname="Alan Ford"/>. In the final phase, <contact fullname="Ernst Horvath"/> did a thorough review, revealing issues that needed clarification and changes. Useful and important final reviews were done by <contact fullname="Mary Barnes"/>.  <contact fullname="Paul Jones"/> helped tremendously as editor for changes addressing IESG review comments.</t>
    </section>
  </back>
</rfc>
