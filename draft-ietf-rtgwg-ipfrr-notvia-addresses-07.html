<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>IP Fast Reroute Using Not-via Addresses</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Overview of Not-via Repairs">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Use of Equal Cost Multi-Path">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Use of LFA repairs">
<link href="#rfc.section.3" rel="Chapter" title="3 Not-via Repair Path Computation ">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Computing not-via repairs in routing vector protocols">
<link href="#rfc.section.4" rel="Chapter" title="4 Operation of Repairs">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Node Failure">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Link Failure">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Loop Prevention Under Node Failure">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Multi-homed Prefixes">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Installation of Repair Paths ">
<link href="#rfc.section.5" rel="Chapter" title="5 Compound Failures">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Shared Risk Link Groups">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Use of LFAs with SRLGs ">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Local Area Networks">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Simple LAN Repair">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 LAN Component Repair">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 LAN Repair Using Diagnostics ">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Multiple Independent Failures ">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Looping Repairs">
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 Outline Solution">
<link href="#rfc.section.5.3.3" rel="Chapter" title="5.3.3 Looping Repairs">
<link href="#rfc.section.5.3.3.1" rel="Chapter" title="5.3.3.1 Dropping Looping Packets">
<link href="#rfc.section.5.3.3.2" rel="Chapter" title="5.3.3.2 Computing non-looping Repairs of Repairs">
<link href="#rfc.section.5.3.4" rel="Chapter" title="5.3.4 Mixing LFAs and Not-via">
<link href="#rfc.section.6" rel="Chapter" title="6 Optimizing not-via computations using LFAs">
<link href="#rfc.section.7" rel="Chapter" title="7 Multicast">
<link href="#rfc.section.8" rel="Chapter" title="8 Fast Reroute in an MPLS LDP Network.  ">
<link href="#rfc.section.9" rel="Chapter" title="9 Encapsulation">
<link href="#rfc.section.10" rel="Chapter" title="10 Routing Extensions">
<link href="#rfc.section.11" rel="Chapter" title="11 Incremental Deployment">
<link href="#rfc.section.12" rel="Chapter" title="12 IANA Considerations">
<link href="#rfc.section.13" rel="Chapter" title="13 Security Considerations">
<link href="#rfc.section.14" rel="Chapter" title="14 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="15 References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This draft describes a mechanism that provides fast reroute in an IP network through encapsulation to "not-via" addresses. A single level of encapsulation is used. The mechanism protects unicast, multicast and LDP traffic against link, router and shared risk group failure, regardless of network topology and metrics." />
  <meta name="description" content="This draft describes a mechanism that provides fast reroute in an IP network through encapsulation to "not-via" addresses. A single level of encapsulation is used. The mechanism protects unicast, multicast and LDP traffic against link, router and shared risk group failure, regardless of network topology and metrics." />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">M. Shand</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">S. Bryant</td>
</tr>
<tr>
<td class="left">Intended status: Experimental Protocol</td>
<td class="right">S. Previdi</td>
</tr>
<tr>
<td class="left">Expires: October 22, 2011</td>
<td class="right">Cisco Systems</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">April 20, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">IP Fast Reroute Using Not-via Addresses<br />
  <span class="filename">draft-ietf-rtgwg-ipfrr-notvia-addresses-07</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This draft describes a mechanism that provides fast reroute in an IP network through encapsulation to "not-via" addresses. A single level of encapsulation is used. The mechanism protects unicast, multicast and LDP traffic against link, router and shared risk group failure, regardless of network topology and metrics.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on October 22, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Overview of Not-via Repairs</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Use of Equal Cost Multi-Path</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Use of LFA repairs</a>
</li>
<li>3.   <a href="#rfc.section.3">Not-via Repair Path Computation </a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Computing not-via repairs in routing vector protocols</a>
</li>
<li>4.   <a href="#rfc.section.4">Operation of Repairs</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Node Failure</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Link Failure</a>
</li>
<li>4.2.1.   <a href="#rfc.section.4.2.1">Loop Prevention Under Node Failure</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Multi-homed Prefixes</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Installation of Repair Paths </a>
</li>
<li>5.   <a href="#rfc.section.5">Compound Failures</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Shared Risk Link Groups</a>
</li>
<li>5.1.1.   <a href="#rfc.section.5.1.1">Use of LFAs with SRLGs </a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Local Area Networks</a>
</li>
<li>5.2.1.   <a href="#rfc.section.5.2.1">Simple LAN Repair</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">LAN Component Repair</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">LAN Repair Using Diagnostics </a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Multiple Independent Failures </a>
</li>
<li>5.3.1.   <a href="#rfc.section.5.3.1">Looping Repairs</a>
</li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">Outline Solution</a>
</li>
<li>5.3.3.   <a href="#rfc.section.5.3.3">Looping Repairs</a>
</li>
<li>5.3.3.1.   <a href="#rfc.section.5.3.3.1">Dropping Looping Packets</a>
</li>
<li>5.3.3.2.   <a href="#rfc.section.5.3.3.2">Computing non-looping Repairs of Repairs</a>
</li>
<li>5.3.4.   <a href="#rfc.section.5.3.4">Mixing LFAs and Not-via</a>
</li>
<li>6.   <a href="#rfc.section.6">Optimizing not-via computations using LFAs</a>
</li>
<li>7.   <a href="#rfc.section.7">Multicast</a>
</li>
<li>8.   <a href="#rfc.section.8">Fast Reroute in an MPLS LDP Network.  </a>
</li>
<li>9.   <a href="#rfc.section.9">Encapsulation</a>
</li>
<li>10.   <a href="#rfc.section.10">Routing Extensions</a>
</li>
<li>11.   <a href="#rfc.section.11">Incremental Deployment</a>
</li>
<li>12.   <a href="#rfc.section.12">IANA Considerations</a>
</li>
<li>13.   <a href="#rfc.section.13">Security Considerations</a>
</li>
<li>14.   <a href="#rfc.section.14">Acknowledgements</a>
</li>
<li>15.   <a href="#rfc.references">References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p></p>
<p id="rfc.section.1.p.2">When a link or a router fails, only the neighbors of the failure are initially aware that the failure has occurred. In a network operating IP fast reroute <a href="#RFC5714">[RFC5714]</a>, the routers that are the neighbors of the failure repair the failure. These repairing routers have to steer packets to their destinations despite the fact that most other routers in the network are unaware of the nature and location of the failure.</p>
<p id="rfc.section.1.p.3">A common limitation in most IPFRR mechanisms is an inability to indicate the identity of the failure and to explicitly steer the repaired packet round the failure. The extent to which this limitation affects the repair coverage is topology dependent. The mechanism proposed here is to encapsulate the packet to an address that explicitly identifies the network component that the repair must avoid. This produces a repair mechanism, which, provided the network is not partitioned by the failure, will always achieve a repair.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Overview of Not-via Repairs</h1>
<p id="rfc.section.2.p.1">This section provides a brief overview of the not-via method of IPFRR.</p>
<div id="#rfc.figure.1"></div>
<div id="#fig-repair"></div>
<p></p>
<pre>              A  
              |                Bp is the address to use to get  
              |                  a packet to B not-via P 
              | 
   S----------P----------B. . . . . . . . . .D 
    \         |        Bp^    
     \        |          |  
      \       |          | 
       \      C          | 
        \                | 
         ----------------+ 
           Repair to Bp  
</pre>
<p></p>
<p></p>
<p></p>
<p id="rfc.section.2.p.4">Assume that S has a packet for some destination D that it would normally send via P and B, and that S suspects that P has failed. S encapsulates the packet to Bp. The path from S to Bp is the shortest path from S to B not going via P. If the network contains a path from S to B that does not transit router P, i.e. the network is not partitioned by the failure of P, then the packet will be successfully delivered to B. When the packet addressed to Bp arrives at B, B removes the encapsulation and forwards the repaired packet towards its final destination.</p>
<p id="rfc.section.2.p.5">Note that if the path from B to the final destination includes one or more nodes that are included in the repair path, a packet may back track after the encapsulation is removed. However, because the decapsulating router is always closer to the packet destination than the encapsulating router, the packet will not loop.</p>
<p id="rfc.section.2.p.6">For complete protection, all of P's neighbors will require a not-via address that allows traffic to be directed to them without traversing P.  This is shown in <a href="#fig-notvia-P">Figure 2</a>.</p>
<div id="#rfc.figure.2"></div>
<div id="#fig-notvia-P"></div>
<p></p>
<pre>              A  
              |Ap  
              | 
    Sp      Pa|Pb 
   S----------P----------B 
            Ps|Pc      Bp    
              | 
            Cp| 
              C 
</pre>
<p></p>
<p></p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Use of Equal Cost Multi-Path</h1>
<p></p>
<p id="rfc.section.2.1.p.2">A router can use an equal cost multi-path (ECMP) repair in place of a not-via repair.</p>
<p id="rfc.section.2.1.p.3">A router computing a not-via repair path may subject the repair to ECMP.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> Use of LFA repairs</h1>
<p></p>
<p id="rfc.section.2.2.p.2">The not-via approach provides complete repair coverage and therefore may be used as the sole repair mechanism. There are, however, advantages in using not-via in combination with loop free alternates (LFA) and or downstream paths as documented in <a href="#RFC5286">[RFC5286]</a>.</p>
<p id="rfc.section.2.2.p.3">LFAs are computed on a per destination basis and in general, only a subset of the destinations requiring repair will have a suitable LFA repair. In this case, those destinations which are repairable by LFAs are so repaired and the remainder of the destinations are repaired using the not-via encapsulation. This has the advantage of reducing the volume of traffic that requires encapsulation. On the other hand, the path taken by an LFA repair may be less optimal than that of the equivalent not-via repair for traffic destined to nodes close to the far end of the failure, but may be more optimal for some other traffic. The description in this document assumes that LFAs will be used where available, but the distribution of repairs between the two mechanisms is a local implementation choice.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Not-via Repair Path Computation </h1>
<p></p>
<p id="rfc.section.3.p.2">The not-via repair mechanism requires that all routers on the path from S to B (<a href="#fig-repair">Figure 1</a>) have a route to Bp. They can calculate this by failing node P, running a Shortest Path First Algorithm (SPF), and finding the shortest route to B.</p>
<p id="rfc.section.3.p.3">A router has no simple way of knowing whether it is on the shortest path for any particular repair. It is therefore necessary for every router to calculate the path it would use in the event of any possible router failure. Each router therefore "fails" every router in the network, one at a time, and calculates its own best route to each of the neighbors of that router. In other words, with reference to <a href="#fig-repair">Figure 1</a>, some router X will consider each router in turn to be P, fail P, and then calculate its own route to each of the not-via P addresses advertised by the neighbors of P. i.e. X calculates its route to Sp, Ap, Bp, and Cp, in each case, not via P.</p>
<p id="rfc.section.3.p.4">To calculate the repair paths a router has to calculate n-1 SPFs where n is the number of routers in the network. This is expensive to compute. However, the problem is amenable to a solution in which each router (X) proceeds as follows. X first calculates the base topology with all routers functional and determines its normal path to all not-via addresses. This can be performed as part of the normal SPF computation. For each router P in the topology, X then performs the following actions:-</p>
<p></p>

<ol>
<li>Removes router P from the topology.</li>
<li>Performs an incremental SPF (iSPF) <a href="#ISPF">[ISPF]</a> on the modified topology. The iSPF process involves detaching the sub-tree affected by the removal of router P, and then re-attaching the detached nodes. However, it is not necessary to run the iSPF to completion. It is sufficient to run the iSPF up to the point where all of the nodes advertising not-via P addresses have been re-attached to the SPT, and then terminate it.</li>
<li>Reverts to the base topology.</li>
</ol>

<p>This algorithm is significantly less expensive than a set of full SPFs. Thus, although a router has to calculate the repair paths for n-1 failures, the computational effort is much less than n-1 SPFs.</p>
<p id="rfc.section.3.p.6">Experiments on a selection of real world network topologies with between 40 and 400 nodes suggest that the worst-case computational complexity using the above optimizations is equivalent to performing between 5 and 13 full SPFs. Further optimizations are described in section 6.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Computing not-via repairs in routing vector protocols</h1>
<p></p>
<p id="rfc.section.3.1.p.2">While this document focuses on link state routing protocols, it is equally possible to compute not-via repairs in distance vector (e.g.  RIP) or path vector (e.g. BGP) routing protocols. This can be achieved with very little protocol modification by advertising the not-via address in the normal way, but ensuring that the information about a not-via address Ps is not propagated through the node S. In the case of link protection this simply means that the advertisement from P to S is suppressed, with the result that S and all other nodes compute a route to Ps which doesn't traverse S, as required.</p>
<p id="rfc.section.3.1.p.3">In the case of node protection, where P is the protected node, and N is some neighbor, the advertisement of Np must be suppressed not only across the link N-&gt;P, but also across any link to P. The simplest way of achieving this is for P itself to perform the suppression of any address of the form Xp.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Operation of Repairs</h1>
<p id="rfc.section.4.p.1">This section explains the basic operation of the not-via repair of node and link failure.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Node Failure</h1>
<p></p>
<p id="rfc.section.4.1.p.2">When router P fails (<a href="#fig-notvia-P">Figure 2</a>) S encapsulates any packet that it would send to B via P to Bp, and then sends the encapsulated packet on the shortest path to Bp. S follows the same procedure for routers A and C in <a href="#fig-notvia-P">Figure 2</a>. The packet is decapsulated at the repair target (A, B or C) and then forwarded normally to its destination. The repair target can be determined as part of the normal SPF by recording the "next-next-hop" for each destination in addition to the normal next-hop.</p>
<p id="rfc.section.4.1.p.3">Notice that with this technique only one level of encapsulation is needed, and that it is possible to repair ANY failure regardless of link metrics and any asymmetry that may be present in the network. The only exception to this is where the failure was a single point of failure that partitioned the network, in which case ANY repair is clearly impossible.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Link Failure</h1>
<p id="rfc.section.4.2.p.1">The normal mode of operation of the network would be to assume router failure. However, where some destinations are only reachable through the failed router, it is desirable that an attempt be made to repair to those destinations by assuming that only a link failure has occurred.</p>
<p id="rfc.section.4.2.p.2">To perform a link repair, S encapsulates to Ps (i.e. it instructs the network to deliver the packet to P not-via S). All of the neighbors of S will have calculated a path to Ps in case S itself had failed. S could therefore give the packet to any of its neighbors (except, of course, P). However, S should preferably send the encapsulated packet on the shortest available path to P. This path is calculated by running an SPF with the link SP failed. Note that this may again be an incremental calculation, which can terminate when address Ps has been reattached.</p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#LPUNFsec" id="LPUNFsec">Loop Prevention Under Node Failure</a>
</h1>
<p id="rfc.section.4.2.1.p.1">It is necessary to consider the behavior of IPFRR solutions when a link repair is attempted in the presence of node failure. In its simplest form the not-via IPFRR solution prevents the formation of loops forming as a result of mutual repair, by never providing a repair path for a not-via address. The repair of packets with not-via addresses is considered in more detail in <a href="#MIFsec">Section 5.3</a>. Referring to <a href="#fig-notvia-P">Figure 2</a>, if A was the neighbor of P that was on the link repair path from S to P, and P itself had failed, the repaired packet from S would arrive at A encapsulated to Ps. A would have detected that the AP link had failed and would normally attempt to repair the packet. However, no repair path is provided for any not-via address, and so A would be forced to drop the packet, thus preventing the formation of loop.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Multi-homed Prefixes</h1>
<p></p>
<p id="rfc.section.4.3.p.2">A multi-homed Prefix (MHP) is a prefix that is reachable via more than one router in the network. Some of these may be repairable using LFAs as described in <a href="#RFC5286">[RFC5286]</a>. Only those without such a repair need be considered here.</p>
<p id="rfc.section.4.3.p.3">When IPFRR router S (<a href="#fig-MHP">Figure 3</a>) discovers that P has failed, it needs to send packets addressed to the MHP X, which is normally reachable through P, to an alternate router, which is still able to reach X.</p>
<div id="#rfc.figure.3"></div>
<div id="#fig-MHP"></div>
<p></p>
<pre>   X                          X                          X 
   |                          |                          | 
   |                          |                          | 
   |                Sp        |Pb                        | 
   Z...............S----------P----------B...............Y 
                            Ps|Pc      Bp    
                              | 
                            Cp| 
                              C </pre>
<p></p>
<p></p>
<p id="rfc.section.4.3.p.5">S should choose the closest router that can reach X during the failure as the alternate router. S determines which router to use as the alternate while running the SPF with P failed. This is accomplished by the normal process of re-attaching a leaf node to the core topology (this is sometimes known as a "partial SPF").</p>
<p id="rfc.section.4.3.p.6">First, consider the case where the shortest alternate path to X is via Z. S can reach Z without using the failed router P. However, S cannot just send the packet towards Z, because the other routers in the network will not be aware of the failure of P, and may loop the packet back to S. S therefore encapsulates the packet to Z (using a normal address for Z). When Z receives the encapsulated packet it removes the encapsulation and forwards the packet to X.</p>
<p id="rfc.section.4.3.p.7">Now consider the case where the shortest alternate path to X is via Y, which S reaches via P and B. To reach Y, S must first repair the packet to B using the normal not-via repair mechanism. To do this S encapsulates the packet for X to Bp. When B receives the packet it removes the encapsulation and discovers that the packet is intended for MHP X. The situation now reverts to the previous case, in which the shortest alternate path does not require traversal of the failure.  B therefore follows the algorithm above and encapsulates the packet to Y (using a normal address for Y). Y removes the encapsulation and forwards the packet to X.</p>
<p id="rfc.section.4.3.p.8">It may be that the cost of reaching X using local delivery from the alternate router (i.e. Z or Y) is greater than the cost of reaching X via P. Under those circumstances, the alternate router would normally forward to X via P, which would cause the IPFRR repair to loop. To prevent the repair from looping the alternate router must locally deliver a packet received via a repair encapsulation. This may be specified by using a special address with the above semantics. Note that only one such address is required per node. Notice that using the not-via approach, only one level of encapsulation was needed to repair MHPs to the alternate router.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> Installation of Repair Paths </h1>
<p></p>
<p id="rfc.section.4.4.p.2">The following algorithm is used by node S (<a href="#fig-MHP">Figure 3</a>) to pre- calculate and install repair paths in the FIB, ready for immediate use in the event of a failure. It is assumed that the not-via repair paths have already been calculated as described above.</p>
<p id="rfc.section.4.4.p.3">For each neighbor P, consider all destinations which are reachable via P in the current topology:-</p>
<p></p>

<ol>
<li>For all destinations with an ECMP or LFA repair (as described in <a href="#RFC5286">[RFC5286]</a>) install that repair.</li>
<li>For each destination (DR) that remains, identify in the current topology the next-next-hop (H) (i.e. the neighbor of P that P will use to send the packet to DR). This can be determined during the normal SPF run by recording the additional information. If S has a path to the not-via address Hp (H not via P), install a not-via repair to Hp for the destination DR.</li>
<li>Identify all remaining destinations (M) which can still be reached when node P fails. These will be multi-homed prefixes that are not repairable by LFA, for which the normal attachment node is P, or a router for which P is a single point of failure, and have an alternative attachment point that is reachable after P has failed. One way of determining these destinations would be to run an SPF rooted at S with node P removed, but an implementation may record alternative attachment points during the normal SPF run. In either case, the next best point of attachment can also be determined for use in step (4) below.</li>
<li>For each multi-homed prefix (M) identified in step (3):-<ol style="list-style-type: lower-alpha">
<li>Identify the new attachment node (as shown in <a href="#fig-MHP">Figure 3</a>). This may be:-<ol style="list-style-type: lower-alpha">
<li>Y, where the next hop towards Y is P, or</li>
<li>Z, where the next hop towards Z is not P.</li>
</ol>
<p>If the attachment node is Z, install the repair for M as a tunnel to Z' (where Z' is the address of Z that is used to force local forwarding).</p>
</li>
<li>For the subset of prefixes (M) that remain (having attachment point Y), install the repair path previously installed for destination Y.</li>
</ol>
<p>For each destination (DS) that remains, install a not-via repair to Ps (P not via S). Note, these are destinations for which node P is a single point of failure, and can only be repaired by assuming that the apparent failure of node P was simply a failure of the S-P link. Note that, if available, a downstream path to P may be used for such a repair. This cannot generate a persistent loop in the event of the failure of node P, but if one neighbor of P uses a not-via repair and another uses a downstream path, it is possible for a packet sent on the downstream path to be returned to the sending node inside a not-via encapsulation. Since packets destined to not-via addresses are not repaired, the packet will be dropped after executing a single turn loop.</p>
</li>
</ol>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Compound Failures</h1>
<p id="rfc.section.5.p.1">The following types of failures involve more than one component:</p>
<p></p>

<ol>
<li>Shared Risk Link Groups</li>
<li>Local Area Networks</li>
<li>Multiple Independent Failures</li>
</ol>

<p>The considerations that apply in each of the above situations are described in the following sections.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> Shared Risk Link Groups</h1>
<p id="rfc.section.5.1.p.1">A Shared Risk Link Group (SRLG) is a set of links whose failure can be caused by a single action such as a conduit cut or line card failure. When repairing the failure of a link that is a member of an SRLG, it must be assumed that all the other links that are also members of the SRLG have also failed. Consequently, any repair path must be computed to avoid not just the adjacent link, but also all the links which are members of the same SRLG.</p>
<p id="rfc.section.5.1.p.2">In <a href="#fig-SRLG1">Figure 4</a> below, the links S-P and A-B are both members of SRLG "a". The semantics of the not-via address Ps changes from simply "P not-via the link S-P" to be "P not-via the link S-P or any other link with which S-P shares an SRLG" In <a href="#fig-SRLG1">Figure 4</a> this is the links that are members of SRLG "a". I.e. links S-P and A-B. Since the information about SRLG membership of all links is available in the Link State Database, all nodes computing routes to the not-via address Ps can infer these semantics, and perform the computation by failing all the links in the SRLG when running the iSPF.</p>
<p id="rfc.section.5.1.p.3">Note that it is not necessary for S to consider repairs to any other nodes attached to members of the SRLG (such as B). It is sufficient for S to repair to the other end of the adjacent link (P in this case).</p>
<div id="#rfc.figure.4"></div>
<div id="#fig-SRLG1"></div>
<p></p>
<pre>                a   Ps  
           S----------P---------D 
           |          | 
           |    a     | 
           A----------B 
           |          | 
           |          | 
           C----------E </pre>
<p></p>
<p id="rfc.section.5.1.p.4">In some cases, it may be that the links comprising the SRLG occur in series on the path from S to the destination D, as shown in <a href="#fig-SRLG2">Figure 5</a>. In this case, multiple consecutive repairs may be necessary. S will first repair to Ps, then P will repair to Dp.  In both cases, because the links concerned are members of SRLG "a" the paths are computed to avoid all members of SRLG "a".</p>
<div id="#rfc.figure.5"></div>
<div id="#fig-SRLG2"></div>
<p></p>
<pre>                a   Ps    a   Dp  
           S----------P---------D 
           |          |         | 
           |    a     |         | 
           A----------B         | 
           |          |         | 
           |          |         | 
           C----------E---------F </pre>
<p></p>
<p></p>
<p id="rfc.section.5.1.p.6">While the use of multiple repairs in series introduces some additional overhead, these semantics avoid the potential combinatorial explosion of not-via addresses that could otherwise occur.</p>
<p id="rfc.section.5.1.p.7">Note that although multiple repairs are used, only a single level of encapsulation is required. This is because the first repair packet is decapsulated before the packet is re-encapsulated using the not- via address corresponding to the far side of the next link which is a member of the same SRLG. In some cases the de-capsulation and re- encapsulation takes place (at least notionally) at a single node, while in other cases, these functions may be performed by different nodes. This scenario is illustrated in <a href="#fig-SRLG3">Figure 6</a> below.</p>
<div id="#rfc.figure.6"></div>
<div id="#fig-SRLG3"></div>
<p></p>
<pre>                a   Ps              a  Dg  
           S----------P---------G--------D 
           |          |         |        | 
           |    a     |         |        | 
           A----------B         |        | 
           |          |         |        | 
           |          |         |        | 
           C----------E---------F--------H 
</pre>
<p></p>
<p></p>
<p id="rfc.section.5.1.p.9">In this case, S first encapsulates to Ps, and node P decapsulates the packet and forwards it "native" to G using its normal FIB entry for destination D. G then repairs the packet to Dg.</p>
<p id="rfc.section.5.1.p.10">It can be shown that such multiple repairs can never form a loop because each repair causes the packet to move closer to its destination.</p>
<p id="rfc.section.5.1.p.11">It is often the case that a single link may be a member of multiple SRLGs, and those SRLGs may not be isomorphic. This is illustrated in <a href="#fig-SRLG4">Figure 7</a> below.</p>
<div id="#rfc.figure.7"></div>
<div id="#fig-SRLG4"></div>
<p></p>
<pre>                ab  Ps              a  Dg  
           S----------P---------G--------D 
           |          |         |        | 
           |    a     |         |        | 
           A----------B         |        | 
           |          |         |        | 
           |    b     |         |   b    | 
           C----------E---------F--------H 
           |          | 
           |          | 
           J----------K </pre>
<p></p>
<p id="rfc.section.5.1.p.12">The link SP is a member of SRLGs "a" and "b". When a failure of the link SP is detected, it must be assumed that BOTH SRLGs have failed.  Therefore the not-via path to Ps must be computed by failing all links which are members of SRLG "a" or SRLG "b". I.e. the semantics of Ps is now "P not-via any links which are members of any of the SRLGs of which link SP is a member". This is illustrated in <a href="#fig-SRLG5">Figure 8</a> below.</p>
<div id="#rfc.figure.8"></div>
<div id="#fig-SRLG5"></div>
<p></p>
<pre>                ab  Ps              a  Dg  
           S----/-----P---------G---/----D 
           |          |         |        | 
           |    a     |         |        | 
           A----/-----B         |        | 
           |          |         |        | 
           |    b     |         |   b    | 
           C----/-----E---------F---/----H 
           |          | 
           |          | 
           J----------K </pre>
<p></p>
<p id="rfc.section.5.1.p.13">In this case, the repair path to Ps will be S-A-C-J-K-E-B-P. It may appear that there is no path to D because GD is a member of SRLG "a" and FH is a member of SRLG "b". This is true if BOTH SRLGs "a" and "b" have in fact failed. But that would be an instance of multiple uncorrelated failures which are out of scope for this design. In practice it is likely that there is only a single failure, i.e. either SRLG "a" or SRLG "b" has failed, but not both. These two possibilities are indistinguishable from the point of view of the repairing router S and so it must repair on the assumption that both are unavailable.  However, each link repair is considered independently. The repair to Ps delivers the packet to P which then forwards the packet to G. When the packet arrives at G, if SRLG "a" has failed it will be repaired around the path G-F-H-D. This is illustrated in <a href="#fig-SRLG6">Figure 9</a> below. If, on the other hand, SRLG "b" has failed, link GD will still be available. In this case the packet will be delivered as normal across the link GD.</p>
<div id="#rfc.figure.9"></div>
<div id="#fig-SRLG6"></div>
<p></p>
<pre>                ab  Ps              a  Dg  
           S----/-----P---------G---/----D 
           |          |         |        | 
           |    a     |         |        | 
           A----/-----B         |        | 
           |          |         |        | 
           |    b     |         |   b    | 
           C----------E---------F--------H 
           |          | 
           |          | 
           J----------K </pre>
<p></p>
<p></p>
<p id="rfc.section.5.1.p.15">A repair strategy that assumes the worst-case failure for each link can often result in longer repair paths than necessary. In cases where only a single link fails, rather than the full SRLG, this strategy may occasionally fail to identify a repair even though a viable repair path exists in the network. The use of sub-optimal repair paths is an inevitable consequence of this compromise approach. The failure to identify any repair is a serious deficiency, but is a rare occurrence in a robustly designed network. This problem can be addressed by:-</p>

<ol>
<li>Reporting that the link in question is irreparable, so that the network designer can take appropriate action.</li>
<li>Modifying the design of the network to avoid this possibility.</li>
<li>Using some form of SRLG diagnostic (for example, by running BFD over alternate repair paths) to determine which SRLG member(s) has actually failed and using this information to select an appropriate pre-computed repair path. However, aside from the complexity of performing the diagnostics, this requires multiple not-via addresses per interface, which has poor scaling properties.</li>
<li>Using the mechanism described in <a href="#MIFsec">Section 5.3</a>
</li>
</ol>
<h1 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> Use of LFAs with SRLGs </h1>
<p id="rfc.section.5.1.1.p.1">Section 4.1 above describes the repair of links which are members of one or more SRLGs. LFAs can be used for the repair of such links provided that any other link with which S-P shares an SRLG is avoided when computing the LFA. This is described for the simple case of "local-SRLGs" in <a href="#RFC5286">[RFC5286]</a>.</p>
<p></p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Local Area Networks</h1>
<p id="rfc.section.5.2.p.1">LANs are a special type of SRLG and are solved using the SRLG mechanisms outlined above. With all SRLGs there is a trade-off between the sophistication of the fault detection and the size of the SRLG.  Protecting against link failure of the LAN link(s) is relatively straightforward, but as with all fast reroute mechanisms, the problem becomes more complex when it is desired to protect against the possibility of failure of the nodes attached to the LAN as well as the LAN itself.</p>
<div id="#rfc.figure.10"></div>
<div id="#fig-LAN1"></div>
<p></p>
<pre>                        +--------------Q------C 
                        |                          
                        | 
                        | 
      A--------S-------(N)-------------P------B 
                        |                            
                        |       
                        |                             
                        +--------------R------D </pre>
<p></p>
<p></p>
<p id="rfc.section.5.2.p.3">Consider the LAN shown in <a href="#fig-LAN1">Figure 10</a>. For connectivity purposes, we consider that the LAN is represented by the pseudonode (N). To provide IPFRR protection, S must run a connectivity check to each of its protected LAN adjacencies P, Q, and R, using, for example BFD <a href="#RFC5880">[RFC5880]</a>.</p>
<p id="rfc.section.5.2.p.4">When S discovers that it has lost connectivity to P, it is unsure whether the failure is:</p>
<p></p>

<ul>
<li>its own interface to the LAN,</li>
<li>the LAN itself,</li>
<li>the LAN interface of P,</li>
<li>the node P.</li>
</ul>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> Simple LAN Repair</h1>
<p id="rfc.section.5.2.1.p.1">A simple approach to LAN repair is to consider the LAN and all of its connected routers as a single SRLG. Thus, the address P not via the LAN (Pl) would require P to be reached not-via any router connected to the LAN. This is shown in <a href="#fig-LAN2">Figure 11</a>.</p>
<div id="#rfc.figure.11"></div>
<div id="#fig-LAN2"></div>
<p></p>
<pre>                                    Ql       Cl 
                        +-------------Q--------C 
                        |              Qc 
                        | 
       As       Sl      |           Pl       Bl 
      A--------S-------(N)------------P--------B 
             Sa         |              Pb      
                        |       
                        |           Rl       Dl  
                        +-------------R--------D 
                                       Rd   
  </pre>
<p></p>
<p></p>
<p id="rfc.section.5.2.1.p.3">In this case, when S detected that P had failed it would send traffic reached via P and B to B not-via the LAN or any router attached to the LAN (i.e. to Bl). Any destination only reachable through P would be addressed to P not-via the LAN or any router attached to the LAN (except of course P).</p>
<p id="rfc.section.5.2.1.p.4">Whilst this approach is simple, it assumes that a large portion of the network adjacent to the failure has also failed. This will result in the use of sub-optimal repair paths and in some cases the inability to identify a viable repair.</p>
<p></p>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> LAN Component Repair</h1>
<p></p>
<p id="rfc.section.5.2.2.p.2">In this approach, possible failures are considered at a finer granularity, but without the use of diagnostics to identify the specific component that has failed. Because S is unable to diagnose the failure it must repair traffic sent through P and B, to B not- via P,N (i.e. not via P and not via N), on the conservative assumption that both the entire LAN and P have failed. Destinations for which P is a single point of failure must as usual be sent to P using an address that avoids the interface by which P is reached from S, i.e. to P not-via N. Similarly for routers Q and R.</p>
<p id="rfc.section.5.2.2.p.3">Notice that each router that is connected to a LAN must, as usual, advertise one not-via address for each neighbor. In addition, each router on the LAN must advertise an extra address not via the pseudonode (N).</p>
<p id="rfc.section.5.2.2.p.4">Notice also that each neighbor of a router connected to a LAN must advertise two not-via addresses, the usual one not via the neighbor and an additional one, not via either the neighbor or the pseudonode. The required set of LAN address assignments is shown in <a href="#fig-LAN3">Figure 12</a> below. Each router on the LAN, and each of its neighbors, is advertising exactly one address more than it would otherwise have advertised if this degree of connectivity had been achieved using point-to-point links.</p>
<div id="#rfc.figure.12"></div>
<div id="#fig-LAN3"></div>
<p></p>
<pre>                                  Qs Qp Qc    Cqn 
                        +--------------Q---------C 
                        |         Qr Qn        Cq  
                        | 
       Asn   Sa Sp Sq   |         Ps Pq Pb    Bpn 
      A--------S-------(N)-------------P---------B        
       As       Sr Sn   |         Pr Pn        Bp 
                        |       
                        |         Rs Rp Pd    Drn   
                        +--------------R---------D 
                                  Rq Rn        Dr </pre>
<p></p>
<h1 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> LAN Repair Using Diagnostics </h1>
<p id="rfc.section.5.2.3.p.1">A more specific LAN repair can be undertaken by using diagnostics. In order to explicitly diagnose the failed network component, S correlates the connectivity reports from P and one or more of the other routers on the LAN, in this case, Q and R. If it lost connectivity to P alone, it could deduce that the LAN was still functioning and that the fault lay with either P, or the interface connecting P to the LAN. It would then repair to B not via P (and P not-via N for destinations for which P is a single point of failure) in the usual way. If S lost connectivity to more than one router on the LAN, it could conclude that the fault lay only with the LAN, and could repair to P, Q and R not-via N, again in the usual way.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#MIFsec" id="MIFsec">Multiple Independent Failures </a>
</h1>
<p id="rfc.section.5.3.p.1">IPFRR repair of multiple simultaneous failures which are not members of a known SRLG is complicated by the problem that the use of multiple concurrent repairs may result in looping repair paths.  As described in <a href="#LPUNFsec">Section 4.2.1</a>, the simplest method of preventing such loops, is to ensure that packets addressed to a not-via address are not repaired but instead are dropped. It is possible that a network may experience multiple simultaneous failures.  This may be due to simple statistical effects, but the more likely cause is unanticipated SRLGs. When multiple failures which are not part of an anticipated group are detected, repairs are abandoned and the network reverts to normal convergence. Although safe, this approach is somewhat draconian, since there are many circumstances were multiple repairs do not induce loops.</p>
<p id="rfc.section.5.3.p.2">This section describes the properties of multiple unrelated failures and proposes some methods that may be used to address this problem.</p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> Looping Repairs</h1>
<p id="rfc.section.5.3.1.p.1">Let us assume that the repair mechanism is based on solely on not-via repairs. LFA or downstream routes may be incorporated, and will be dealt with later.</p>
<div id="#rfc.figure.13"></div>
<div id="#GenMF"></div>
<p></p>
<pre>           A------//------B------------D
          /                \
         /                  \
        F                    G
         \                  /                 
          \                /
           X------//------Y



</pre>
<p></p>
<p id="rfc.section.5.3.1.p.3">The essential case is as illustrated in <a href="#GenMF">Figure 13</a>. Note that depending on the repair case under consideration, there may be paths present in <a href="#GenMF">Figure 13</a>, that are in addition to those shown in the figure. For example there may be paths between A and B, and/or between X and Y. These paths are omitted for graphical clarity.</p>
<p id="rfc.section.5.3.1.p.4">There are three cases to consider:</p>
<div id="#rfc.figure.14"></div>
<div id="#ConCatMF"></div>
<p></p>

<p></p>
<pre>    A------//------B------------X------//------Y------D
    |              |            |              |
    |              |            |              |
    M--------------+            N--------------+

</pre>
<ul class="empty">
<li>1) Consider the general case of a pair of protected links A-B and X-Y as shown in the network fragment shown <a href="#GenMF">Figure 13</a>. If the repair path for A-B does not traverse X-Y and the repair path for X-Y does not traverse A-B, this case is completely safe and will not cause looping or packet loss.</li>
<li>A more common variation of this case is shown in <a href="#ConCatMF">Figure 14</a>, which shows two failures in different parts of the network in which a packet from A to D traverses two concatenated repairs.</li>
<li>
<li>
<li>
<li>2) In <a href="#GenMF">Figure 13</a>, the repair for A-B traverses X-Y, but the repair for X-Y does not traverse A-B.  This case occurs when the not-via path from A to B traverses link X-Y, but the not-via path from X to Y traverses some path not shown in <a href="#GenMF">Figure 13</a>. Without the multi-failure mechanism described in this section the repaired packet for A-B would be dropped when it reached X-Y, since the repair of repaired packets would be forbidden. However, if this packet were allowed to be repaired, the path to D would be complete and no harm would be done, although two levels of encapsulation would be required.</li>
<li>3) The repair for A-B traverses X-Y AND the repair for X-Y traverses A-B. In this case unrestricted repair would result in looping packets and increasing levels of encapsulation.</li>
</ul>

<p> The challenge in applying IPFRR to a network that is undergoing multiple failures is, therefore, to identify which of these cases exist in the network and react accordingly.</p>
<h1 id="rfc.section.5.3.2">
<a href="#rfc.section.5.3.2">5.3.2.</a> Outline Solution</h1>
<p id="rfc.section.5.3.2.p.1">When A is computing the not-via repair path for A-B (i.e. the path for packets addressed to Ba, read as "B not-via A") it is aware of the list of nodes which this path traverses. This can be recorded by a simple addition to the SPF process, and the not-via addresses associated with each forward link can be determined. If the path were A, F, X, Y, G, B, (<a href="#GenMF">Figure 13</a>) the list of not-via addresses would be: Fa, Xf, Yx, Gy, Bg. Under standard not-via operation, A would populate its FIB such that all normal addresses normally reachable via A-B would be encapsulated to Ba when A-B fails, but traffic addressed to any not-via address arriving at A would be dropped. The new procedure modifies this such that any traffic for a not-via address normally reachable over A-B is also encapsulated to Ba unless the not-via address is one of those previously identified as being on the path to Ba, for example Yx, in which case the packet is dropped.</p>
<p id="rfc.section.5.3.2.p.2">The above procedure allows cases 1 and 2 above to be repaired, while preventing the loop which would result from case 3.</p>
<p id="rfc.section.5.3.2.p.3">Note that this is accomplished by pre-computing the required FIB entries, and does not require any detailed packet inspection. The same result could be achieved by checking for multiple levels of encapsulation and dropping any attempt to triple encapsulate.  However, this would require more detailed inspection of the packet, and causes difficulties when more than 2 &#8220;simultaneous&#8221; failures are contemplated.</p>
<p id="rfc.section.5.3.2.p.4">So far we have permitted benign repairs to coexist, albeit sometimes requiring multiple encapsulation. Note that in many cases there will be no performance impact since unless both failures are on the same node, the two encapsulations or two decapsulations will be performed at different nodes. There is however the issue of the MTU impact of multiple encapsulations.</p>
<p id="rfc.section.5.3.2.p.5">In the following sub-section we consider the various strategies that may be applied to case 3 - mutual repairs that would loop.</p>
<h1 id="rfc.section.5.3.3">
<a href="#rfc.section.5.3.3">5.3.3.</a> Looping Repairs</h1>
<p id="rfc.section.5.3.3.p.1">In case 3, the simplest approach is to simply not install repairs for repair paths that might loop. In this case, although the potentially looping traffic is dropped, the traffic is not repaired.  If we assume that a hold-down is applied before reconvergence in case the link failure was just a short glitch, and if a loop free convergence mechanism further delays convergence, then the traffic will be dropped for an extended period. In these circumstances it would be better to &#8220;abandon all hope&#8221; (AAH) <a href="#I-D.ietf-rtgwg-ordered-fib">[I-D.ietf-rtgwg-ordered-fib]</a> (Appendix A) and immediately invoke normal re-convergence.</p>
<p id="rfc.section.5.3.3.p.2">Note that it is not sufficient to expedite the issuance of an LSP reporting the failure, since this may be treated as a permitted simultaneous failure by the ordered FIB (oFIB) algorithm <a href="#I-D.ietf-rtgwg-ordered-fib">[I-D.ietf-rtgwg-ordered-fib]</a>. It is therefore necessary to explicitly trigger an oFIB AAH.</p>
<h1 id="rfc.section.5.3.3.1">
<a href="#rfc.section.5.3.3.1">5.3.3.1.</a> Dropping Looping Packets</h1>
<p id="rfc.section.5.3.3.1.p.1">One approach to case 3 is to allow the repair, and to experimentally discover the incompatibility of the repairs if and when they occur. With this method we permit the repair in case 3 and trigger AAH when a packet drop count on the not-via address has been incremented. Alternatively, it is possible to wait until the LSP describing the change is issued normally (i.e. when X announces the failure of X-Y). When the repairing node A, which has precomputed that X-Y failures are mutually incompatible with its own repairs receives this LSP it can then issue the AAH. This has the disadvantage that it does not overcome the hold-down delay, but it requires no &#8220;data-driven&#8221; operation, and it still has the required effect of abandoning the oFIB which is probably the longer of the delays (although with signalled oFIB this should be sub-second).</p>
<p id="rfc.section.5.3.3.1.p.2">Whilst both of the experimental approaches described above are feasible, they tend to induce AAH in the presence of otherwise feasible repairs, and they are contrary to the philosophy of repair pre-determination that has been applied to existing IPFRR solutions.</p>
<h1 id="rfc.section.5.3.3.2">
<a href="#rfc.section.5.3.3.2">5.3.3.2.</a> Computing non-looping Repairs of Repairs</h1>
<p id="rfc.section.5.3.3.2.p.1">An alternative approach to simply dropping the looping packets, or to detecting the loop after it has occurred, is to use secondary SRLGs. With a link state routing protocol it is possible to precompute the incompatibility of the repairs in advance and to compute an alternative SRLG repair path. Although this does considerably increase the computational complexity it may be possible to compute repair paths that avoid the need to simply drop the offending packets.</p>
<p id="rfc.section.5.3.3.2.p.2">This approach requires us to identify the mutually incompatible failures, and advertise them as &#8220;secondary SRLGs&#8221;.  When computing the repair paths for the affected not-via addresses these links are simultaneously failed. Note that the assumed simultaneous failure and resulting repair path only applies to the repair path computed for the conflicting not-via addresses, and is not used for normal addresses. This implies that although there will be a longer repair path when there is more than one failure, if there is a single failure the repair path length will be "normal".</p>
<p id="rfc.section.5.3.3.2.p.3">Ideally we would wish to only invoke secondary SRLG computation when we are sure that the repair paths are mutually incompatible.  Consider the case of node A in <a href="#GenMF">Figure 13</a>. A first identifies that the repair path for A-B is via F-X-Y-G-B. It then explores this path determining the repair path for each link in the path. Thus, for example, it performs a check at X by running an SPF rooted at X with the X-Y link removed to determine whether A-B is indeed on X's repair path for packets addressed to Yx.</p>
<p id="rfc.section.5.3.3.2.p.4">Some optimizations are possible in this calculation, which appears at first sight to be order hk (where h is the average hop length of repair paths and k is the average number of neighbours of a router). When A is computing its set of repair paths, it does so for all its k neighbours. In each case it identifies a list of node pairs traversed by each repair. These lists may often have one or more node pairs in common, so the actual number of link failures which require investigation is the union of these sets.  It is then necessary to run an SPF rooted at the first node of each pair (the first node because the pairings are ordered representing the direction of the path), with the link to the second node removed. This SPF, while not an incremental, can be terminated as soon as the not-via address is reached. For example, when running the SPF rooted at X, with the link X-Y removed, the SPF can be terminated when Yx is reached. Once the path has been found, the path is checked to determine if it traverses any of A&#8217;s links in the direction away from A. Note that, because the node pair XY may exist in the list for more than one of A&#8217;s links (i.e. it lies on more than one repair path), it is necessary to identify the correct list, and hence link which has a mutually looping repair path. That link of A is then advertised by A as a secondary SRLG paired with the link X-Y. Also note that X will be running this algorithm as well, and will identify that XY is paired with A-B and so advertise it. This could perhaps be used as a further check.</p>
<p id="rfc.section.5.3.3.2.p.5">The ordering of the pairs in the lists is important. i.e. X-Y and Y-X are dealt with separately. If and only if the repairs are mutually incompatible, we need to advertise the pair of links as a secondary SRLG, and then ALL nodes compute repair paths around both failures using an additional not-via address with the semantics not-via A-B AND not-via X-Y.</p>
<p id="rfc.section.5.3.3.2.p.6">A further possibility is that because we are going to the trouble of advertising these SRLG sets, we could also advertise the new repair path and only get the nodes on that path to perform the necessary computation. Note also that once we have reached Q space with respect to the two failures we need no longer continue the computation, so we only need to notify the nodes on the path that are not in Q-space.</p>
<p id="rfc.section.5.3.3.2.p.7">One cause of mutually looping repair paths is the existence of nodes with only two links, or sections of the network which are only bi-connected. In these cases, repair is clearly impossible &#8211; the failure of both links partitions the network. It would be advantageous to be able to identify these cases, and inhibit the fruitless advertisement of the secondary SRLG information.  This could be achieved by the node detecting the requirement for a secondary SRLG, first running the not-via computation with both links removed. If this does not result in a path, it is clear that the network would be partitioned by such a failure, and so no advertisement is required.</p>
<h1 id="rfc.section.5.3.4">
<a href="#rfc.section.5.3.4">5.3.4.</a> Mixing LFAs and Not-via</h1>
<p id="rfc.section.5.3.4.p.1">So far in this section we have assumed that all repairs use not-via tunnels. However, in practise we may wish to use LFAs or downstream routes where available. This complicates the issue, because their use results in packets which are being repaired, but NOT addressed to not-via addresses. If BOTH links are using downstream routes there is no possibility of looping, since it is impossible to have a pair of nodes which are both downstream of each other <a href="#RFC5286">[RFC5286]</a>.</p>
<p id="rfc.section.5.3.4.p.2">Loops can however occur when LFAs are used. An obvious example is the well known node repair problem with LFAs <a href="#RFC5286">[RFC5286]</a>. If one link is using a downstream route, while the other is using a not-via tunnel, the potential mechanism described above would work provided it were possible to determine the nodes on the path of the downstream route. Some methods of computing downstream routes do not provide this path information. If the path information is however available, the link using a downstream route will have a discard FIB entry for the not-via address of the other link. The consequence is that potentially looping packets will be discarded when they attempt to cross this link.</p>
<p id="rfc.section.5.3.4.p.3">In the case where the mutual repairs are both using not-via repairs, the loop will be broken when the packet arrives at the second failure. However packets are unconditionally repaired by means of a downstream routes, and thus when the mutual pair consists of a downstream route and a not-via repair, the looping packet will only be dropped when it gets back to the first failure. i.e. it will execute a single turn of the loop before being dropped.</p>
<p id="rfc.section.5.3.4.p.4">There is a further complication with downstream routes, since although the path may be computed to the far side of the failure, the packet may &#8220;peel off&#8221; to its destination before reaching the far side of the failure. In this case it may traverse some other link which has failed and was not accounted for on the computed path. If the A-B repair (Figure 1) is a downstream route and the X-Y repair is a not-via repair, we can have the situation where the X-Y repair packets encapsulated to Yx follow a path which attempts to traverse A-B. If the A-B repair path for &#8220;normal&#8221; addresses is a downstream route, it cannot be assumed that the repair path for packets addressed to Yx can be sent to the same neighbour. This is because the validity of a downstream route must be ascertained in the topology represented by Yx, i.e.  that with the link X-Y failed. This is not the same topology that was used for the normal downstream calculation, and use of the normal downstream route for the encapsulated packets may result in an undetected loop. If it is computationally feasible to check the downstream route in this topology (i.e. for any not-via address Qp which traverses A-B we must perform the downstream calculation for that not-via address in the topology with link Q-P failed.), then the downstream repair for Yx can safely be used. These packets cannot re-visit X-Y, since by definition they will avoid that link.  Alternatively, the packet could be always repaired in a not-via tunnel. i.e. even though the normal repair for traffic traversing A-B would be to use a downstream route, we could insist that such traffic addressed to a not-via address must use a tunnel to Ba. Such a tunnel would only be installed for an address Qp if it were established that it did not traverse Q-P (using the rules described above).</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Optimizing not-via computations using LFAs</h1>
<p id="rfc.section.6.p.1">If repairing node S has an LFA to the repair endpoint it is not necessary for any router to perform the incremental SPF with the link SP removed in order to compute the route to the not-via address Ps. This is because the correct routes will already have been computed as a result of the SPF on the base topology. Node S can signal this condition to all other routers by including a bit in its LSP or LSA associated with each LFA protected link. Routers computing not-via routes can then omit the running of the iSPF for links with this bit set.</p>
<p id="rfc.section.6.p.2">When running the iSPF for a particular link AB, the calculating router first checks whether the link AB is present in the existing SPT.  If the link is not present in the SPT, no further work is required. This check is a normal part of the iSPF computation.</p>
<p id="rfc.section.6.p.3">If the link is present in the SPT, this optimization introduces a further check to determine whether the link is marked as protected by an LFA in the direction in which the link appears in the SPT. If so the iSPF need not be performed. For example, if the link appears in the SPT in the direction A-&gt;B and A has indicated that the link AB is protected by an LFA no further action is required for this link.</p>
<p id="rfc.section.6.p.4">If the receipt of this information is delayed, the correct operation of the protocol is not compromised provided that the necessity to perform a not-via computation is re-evaluated whenever new information arrives.</p>
<p id="rfc.section.6.p.5">This optimization is not particularly beneficial to nodes close to the repair since, as has been observed above, the computation for nodes on the LFA path is trivial. However, for nodes upstream of the link SP for which S-P is in the path to P, there is a significant reduction in the computation required.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Multicast</h1>
<p id="rfc.section.7.p.1">Multicast traffic can be repaired in a similar way to unicast. The multicast forwarder is able to use the not-via address to which the multicast packet was addressed as an indication of the expected receive interface and hence to correctly run the required RPF check.</p>
<p id="rfc.section.7.p.2">In some cases, all the destinations, including the repair endpoint, are repairable by an LFA. In this case, all unicast traffic may be repaired without encapsulation. Multicast traffic still requires encapsulation, but for the nodes on the LFA repair path the computation of the not-via forwarding entry is unnecessary since, by definition, their normal path to the repair endpoint is not via the failure.</p>
<p id="rfc.section.7.p.3">A more complete description of multicast operation is for further study.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Fast Reroute in an MPLS LDP Network.  </h1>
<p id="rfc.section.8.p.1">Not-via addresses are IP addresses and LDP <a href="#RFC5036">[RFC5036]</a> will distribute labels for them in the usual way. The not-via repair mechanism may therefore be used to provide fast re-route in an MPLS network by first pushing the label which the repair endpoint uses to forward the packet, and then pushing the label corresponding to the not-via address needed to effect the repair.  Referring once again to <a href="#fig-repair">Figure 1</a>, if S has a packet destined for D that it must reach via P and B, S first pushes B's label for D. S then pushes the label that its next hop to Bp needs to reach Bp.</p>
<p id="rfc.section.8.p.2">Note that in an MPLS LDP network it is necessary for S to have the repair endpoint's label for the destination. When S is effecting a link repair it already has this. In the case of a node repair, S either needs to set up a directed LDP session with each of its neighbor's neighbors, or it needs to use the next-next hop label distribution mechanism proposed in <a href="#I-D.shen-mpls-ldp-nnhop-label">[I-D.shen-mpls-ldp-nnhop-label]</a>.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Encapsulation</h1>
<p id="rfc.section.9.p.1">Any IETF specified IP in IP encapsulation may be used to carry a not-via repair. IP in IP <a href="#RFC2003">[RFC2003]</a>, GRE <a href="#RFC1701">[RFC1701]</a> and L2TPv3 <a href="#RFC3931">[RFC3931]</a>, all have the necessary and sufficient properties. The requirement is that both the encapsulating router and the router to which the encapsulated packet is addressed have a common ability to process the chosen encapsulation type. When an MPLS LDP network is being protected, the encapsulation would normally be an additional MPLS label. In an MPLS enabled IP network an MPLS label may be used in place of an IP in IP encapsulation in the case above.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> Routing Extensions</h1>
<p id="rfc.section.10.p.1">IPFRR requires IGP extensions. Each IPFRR router that is directly connected to a protected network component must advertise a not-via address for that component. This must be advertised in such a way that the association between the protected component (link, router or SRLG) and the not-via address can be determined by the other routers in the network.</p>
<p id="rfc.section.10.p.2">It is necessary that not-via capable routers advertise in the IGP that they will calculate not-via routes.</p>
<p id="rfc.section.10.p.3">It is necessary for routers to advertise the type of encapsulation that they support (MPLS, GRE, L2TPv3 etc). However, the deployment of mixed IP encapsulation types within a network is discouraged.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> Incremental Deployment</h1>
<p id="rfc.section.11.p.1">Incremental deployment is supported by excluding routers that are not calculating not-via routes (as indicated by their capability information flooded with their link state information) from the base topology used for the computation of repair paths. In that way repairs may be steered around islands of routers that are not IPFRR capable. Routers that are protecting a network component need to have the capability to encapsulate and decapsulate packets. However, routers that are on the repair path only need to be capable of calculating not-via paths and including the not-via addresses in their FIB i.e. these routers do not need any changes to their forwarding mechanism.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> IANA Considerations</h1>
<p id="rfc.section.12.p.1">There are no IANA considerations that arise from this draft.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> Security Considerations</h1>
<p id="rfc.section.13.p.1">The repair endpoints present vulnerability in that they might be used as a method of disguising the delivery of a packet to a point in the network. The primary method of protection should be through the use of a private address space for the not-via addresses. These addresses must not be advertised outside the area, and should be filtered at the network entry points. In addition, a mechanism might be developed that allowed the use of the mild security available through the use of a key <a href="#RFC1701">[RFC1701]</a> <a href="#RFC3931">[RFC3931]</a>. With the deployment of such mechanisms, the repair endpoints would not increase the security risk beyond that of existing IP tunnel mechanisms. An attacker may attempt to overload a router by addressing an excessive traffic load to the de-capsulation endpoint. Typically, routers take a 50% performance penalty in decapsulating a packet. The attacker could not be certain that the router would be impacted, and the extremely high volume of traffic needed, would easily be detected as an anomaly. If an attacker were able to influence the availability of a link, they could cause the network to invoke the not-via repair mechanism. A network protected by not-via IPFRR is less vulnerable to such an attack than a network that undertook a full convergence in response to a link up/down event.</p>
<p></p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> Acknowledgements</h1>
<p id="rfc.section.14.p.1">The authors would like to acknowledge contributions made by Alia Atlas and John Harper.</p>
<h1 id="rfc.references">
<a href="#rfc.references">15.</a> References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC5880">[RFC5880]</b></td>
<td class="top">
<a>Katz, D.</a> and <a>D. Ward</a>, "<a href="http://tools.ietf.org/html/rfc5880">Bidirectional Forwarding Detection (BFD)</a>", RFC 5880, June 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1701">[RFC1701]</b></td>
<td class="top">
<a href="mailto:stan@netsmiths.com" title="NetSmiths, Ltd.">Hanks, S.</a>, <a href="mailto:tli@cisco.com" title="cisco Systems, Inc.">Li, T.</a>, <a href="mailto:dino@cisco.com" title="cisco Systems, Inc.">Farinacci, D.</a> and <a href="mailto:pst@cisco.com" title="cisco Systems, Inc.">P. Traina</a>, "<a href="http://tools.ietf.org/html/rfc1701">Generic Routing Encapsulation (GRE)</a>", RFC 1701, October 1994.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5714">[RFC5714]</b></td>
<td class="top">
<a>Shand, M.</a> and <a>S. Bryant</a>, "<a href="http://tools.ietf.org/html/rfc5714">IP Fast Reroute Framework</a>", RFC 5714, January 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2003">[RFC2003]</b></td>
<td class="top">
<a href="mailto:perk@watson.ibm.com" title="Room H3-D34">Perkins, C.</a>, "<a href="http://tools.ietf.org/html/rfc2003">IP Encapsulation within IP</a>", RFC 2003, October 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3931">[RFC3931]</b></td>
<td class="top">
<a>Lau, J.</a>, <a>Townsley, M.</a> and <a>I. Goyret</a>, "<a href="http://tools.ietf.org/html/rfc3931">Layer Two Tunneling Protocol - Version 3 (L2TPv3)</a>", RFC 3931, March 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5036">[RFC5036]</b></td>
<td class="top">
<a>Andersson, L.</a>, <a>Minei, I.</a> and <a>B. Thomas</a>, "<a href="http://tools.ietf.org/html/rfc5036">LDP Specification</a>", RFC 5036, October 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5286">[RFC5286]</b></td>
<td class="top">
<a>Atlas, A.</a> and <a>A. Zinin</a>, "<a href="http://tools.ietf.org/html/rfc5286">Basic Specification for IP Fast Reroute: Loop-Free Alternates</a>", RFC 5286, September 2008.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.shen-mpls-ldp-nnhop-label">[I-D.shen-mpls-ldp-nnhop-label]</b></td>
<td class="top">
<a>Shen, N</a>, "<a href="http://tools.ietf.org/html/draft-shen-mpls-ldp-nnhop-label-02">Discovering LDP Next-Nexthop Labels</a>", Internet-Draft draft-shen-mpls-ldp-nnhop-label-02, May 2005.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-rtgwg-ordered-fib">[I-D.ietf-rtgwg-ordered-fib]</b></td>
<td class="top">
<a>Shand, M</a>, <a>Bryant, S</a>, <a>Previdi, S</a> and <a>C Filsfils</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtgwg-ordered-fib-05">Loop-free convergence using oFIB</a>", Internet-Draft draft-ietf-rtgwg-ordered-fib-05, April 2011.</td>
</tr>
<tr>
<td class="reference"><b id="ISPF">[ISPF]</b></td>
<td class="top">
<a title="BBN">McQuillan, J.</a>, <a title="BBN">Richer, I.</a> and <a title="BBN">E. Rosen</a>, "<a>ARPANET Routing Algorithm Improvements"</a>", BBN Technical Report 3803, 1978.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Shand</span> 
	  <span class="n hidden">
		<span class="family-name">Shand</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco Systems</span>
	<span class="adr">
	  <span>250, Longwater Avenue.</span>

	  <span class="vcardline">
		<span class="locality">Reading</span>,  
		<span class="region">Berks</span> 
		<span class="code">RG2 6GB</span>
	  </span>
	  <span class="country-name vcardline">UK</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mshand@cisco.com">mshand@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Stewart Bryant</span> 
	  <span class="n hidden">
		<span class="family-name">Bryant</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco Systems</span>
	<span class="adr">
	  <span>250, Longwater Avenue.</span>

	  <span class="vcardline">
		<span class="locality">Reading</span>,  
		<span class="region">Berks</span> 
		<span class="code">RG2 6GB</span>
	  </span>
	  <span class="country-name vcardline">UK</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:stbryant@cisco.com">stbryant@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Stefano Previdi</span> 
	  <span class="n hidden">
		<span class="family-name">Previdi</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco Systems</span>
	<span class="adr">
	  <span>Via Del Serafico, 200</span>

	  <span class="vcardline">
		<span class="locality">00142 Rome</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Italy</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:sprevidi@cisco.com">sprevidi@cisco.com</a></span>

  </address>
</div>

</body>
</html>