<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Architecture and API Requirements for RTC Web</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Overview">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Advertisement Proposal Model">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Offer Answer Model">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Use Cases">
<link href="#rfc.section.1.3.1" rel="Chapter" title="1.3.1 Facebook ">
<link href="#rfc.section.1.3.2" rel="Chapter" title="1.3.2 Webex">
<link href="#rfc.section.1.3.3" rel="Chapter" title="1.3.3 Amazon">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Requirements">
<link href="#rfc.section.4" rel="Chapter" title="4 Connection API">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Session API">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Session Example Incoming">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Session Example Outgoing">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Connection API">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Audio Video API ">
<link href="#rfc.section.5" rel="Chapter" title="5 IANA Considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Attack Model">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Media Security">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Signaling Security">
<link href="#rfc.section.7" rel="Chapter" title="7 Legacy VoIP Interoperability">
<link href="#rfc.section.8" rel="Chapter" title="8 Acknowledgement">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="Internet browsers and other software applications are enabling support for real time interactive voice and video. This draft outlines a set of IETF protocols that can be used for this purpose and describes the overall architecture. It also identifies the requirements for an application programming interface to control these protocols." />
  <meta name="description" content="Internet browsers and other software applications are enabling support for real time interactive voice and video. This draft outlines a set of IETF protocols that can be used for this purpose and describes the overall architecture. It also identifies the requirements for an application programming interface to control these protocols." />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">C. Jennings</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Cisco</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">March 08, 2011</td>
</tr>
<tr>
<td class="left">Expires: September 09, 2011</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Architecture and API Requirements for RTC Web<br />
  <span class="filename">draft-jennings-rtcweb-api-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>Internet browsers and other software applications are enabling support for real time interactive voice and video. This draft outlines a set of IETF protocols that can be used for this purpose and describes the overall architecture. It also identifies the requirements for an application programming interface to control these protocols.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 09, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<p>This document may not be modified, and derivative works of it may not be created, and it may not be published except as an Internet-Draft.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Overview</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Advertisement Proposal Model</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Offer Answer Model</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Use Cases</a>
</li>
<li>1.3.1.   <a href="#rfc.section.1.3.1">Facebook </a>
</li>
<li>1.3.2.   <a href="#rfc.section.1.3.2">Webex</a>
</li>
<li>1.3.3.   <a href="#rfc.section.1.3.3">Amazon</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">Requirements</a>
</li>
<li>4.   <a href="#rfc.section.4">Connection API</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Session API</a>
</li>
<li>4.1.1.   <a href="#rfc.section.4.1.1">Session Example Incoming</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">Session Example Outgoing</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Connection API</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Audio Video API </a>
</li>
<li>5.   <a href="#rfc.section.5">IANA Considerations</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">Attack Model</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Media Security</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Signaling Security</a>
</li>
<li>7.   <a href="#rfc.section.7">Legacy VoIP Interoperability</a>
</li>
<li>8.   <a href="#rfc.section.8">Acknowledgement</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<li>9.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Overview</h1>
<p id="rfc.section.1.p.1">This draft describes two models of how this would work, which are referred to as the advertisement proposal (AdProp) model and the offer answer (OffAns) model. Both of these models are useful in various situations, and they involve very similar code development efforts. This draft proposes an API and protocol set standardization that supports both models. </p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Advertisement Proposal Model</h1>
<p id="rfc.section.1.1.p.1">The AdProp model standardizes a way to send media between two browsers and standardizes an API in the browser, such that browser-based applications can find out the media capabilities of the browser and can tell the browser what media streams to send and receive. We use the term "browser app" to refer to a program that is running in the browser and using HTML, CSS, and JavaScript to control the browser. It is assumed that the browser app could communicate with the web server using existing approaches, and that the web server communicates with a SIP server as a way of federating to other websites or connecting to legacy VoIP systems. There are many different ways this model could be used, but the diagram below covers a fairly complex case that most other cases end up being a subset of.  More use cases are discussed in section XXX.</p>
<div id="#rfc.figure.1"></div>
<pre>
      +-----------+             +-----------+
      |   Web/    |             |   Web/    |
      |   SIP     |     SIP     |   SIP     | 
      |           |-------------|           |
      |  Server   |             |  Server   |
      |           |             |           |
      +-----------+             +-----------+
            /                           \
           /                             \   Proprietary over
          /                               \  HTTP/Websockets
         /                                 \
        /  Proprietary over                 \
       /   HTTP/Websockets                   \
      /                                       \
 +-----------+                           +-----------+
 |JS/HTML/CSS|                           |JS/HTML/CSS|
 +-----------+                           +-----------+
Add ^      |Prop                         Add ^     | Prop
    |      v                                 |     v
 +-----------+                           +-----------+
 |           |                           |           |
 |           |                           |           |
 |  Browser  | ------------------------- |  Browser  |
 |           |        ICE + SRTP         |           |
 |           |                           |           |
 +-----------+                           +-----------+
</pre>
<p id="rfc.section.1.1.p.2">The API for this model has two distinct phases. First there is a Connection API that allows the browser app to use ICE to form a connection to the other browsers. This API assumes that the browser applications will be able to exchange ICE candidates lists by some out-of-band means -- most likely involving passing them up to the web servers over HTTP. The second stage is referred to as the AVT API.  This API allows the browser apps to discover which codecs and capabilities the browser supports. It then allows the browser app to control which media streams the browser will send and receive. The browser describes its range of capabilities in an advertisement object. The browser app requests that a particular set of media streams be set up in a proposal to the browser. This is done as an atomic request which is either accepted or not. Partial acceptance has proven to be very difficult to deal with in the implementation of existing systems. The general overview and advantage of the AdProp model is discussed in <a href="#I-D.peterson-sipcore-advprop">draft-peterson-sipcore-advprop</a> <cite title="NONE">[I-D.peterson-sipcore-advprop]</cite>.</p>
<p id="rfc.section.1.1.p.3">The model above shows SIP as the protocol between the two web servers, but the API proposed would also work using Jingle or H.323 as the federation signaling protocol. It would also be possible to implement the processing of SIP messages in the JavaScript in the browser application and then somehow tunnel the SIP messaging between the clients. XMPP over websockets has been proposed for this. The architecture and API in this draft would support all of these possibilities.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Offer Answer Model</h1>
<p id="rfc.section.1.2.p.1">The OffAns model standardizes a way to send media between the browsers, but it also selects an existing signaling protocol to negotiate and set up the media. The browser app would indicate to the browser that it wished to form a communication session with another entity, and then the browser would take care of the rest. A typical model for this is show below.</p>
<div id="#rfc.figure.2"></div>
<pre>
+------+   +------+         +------+   +------+
| Web  |   | SIP  |   SIP   | SIP  |   | Web  |
| Serv |   | Serv |---------| Serv |   | Serv |   
+------+   +------+         +------+   +------+ 
   |         /                 \           |
   |HTTP    /               SIP \          | HTTP
   |       /                     \         |
   |      /SIP                    \        |
   |     /                         \       |
   |    /                           \      |
   |   /                             \     |
 +-----------+                     +-----------+
 |JS/HTML/CSS|                     |JS/HTML/CSS|
 +-----------+                     +-----------+
 +-----------+                     +-----------+
 |           |                     |           |
 |           |                     |           |
 |  Browser  |---------------------|  Browser  |
 |           |      ICE + SRTP     |           |
 |           |                     |           |
 +-----------+                     +-----------+
</pre>
<p id="rfc.section.1.2.p.2">The major goal for this API is to be extremely simple to use in enabling a website for voice and video. On an iPhone today, one can simply put a tel URL on the web page and the iPhone can call it. That is a simple approach that web developers like and use. Since standards are involved, this proposal will have to be more complex. The API defines an HTML session element that can be used like a source element inside of an audio or video element. It also provides a JavaScript API to control the session and replace the user interface.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Use Cases</h1>
<h1 id="rfc.section.1.3.1">
<a href="#rfc.section.1.3.1">1.3.1.</a> Facebook </h1>
<p id="rfc.section.1.3.1.p.1">Consider the case of a social networking site that allows IM between users and wants to also allow voice and video between them, but does not need to federate with others. The case could easily use the AdProp model. Assuming that it was only supported on browsers meeting a certain minimum functionality and it always uses the same capabilities, there is no need to even negotiate or share the advertisements between the two browsers. The browser app simply sets up the connection to the far end, and then uses a proposal for the media steam that is always the same.</p>
<div id="#rfc.figure.3"></div>
<pre>
          +-----------+
          |   Web     |
          |           | 
          |           |
          |  Server   | 
          |           |
          +-----------+ 
              /    \
             /      \   Proprietary over
            /        \  HTTP/Websockets
           /          \
          /            \
         /              \
        /                \
 +-----------+          +-----------+
 |JS/HTML/CSS|          |JS/HTML/CSS|
 +-----------+          +-----------+
Add ^      |Prop         Add ^     | Prop
    |      v              |     v
 +-----------+          +-----------+
 |           |          |           |
 |           |          |           |
 |  Browser  |----------|  Browser  |
 |           | ICE+RTP  |           |
 |           |          |           |
 +-----------+          +-----------+</pre>
<h1 id="rfc.section.1.3.2">
<a href="#rfc.section.1.3.2">1.3.2.</a> Webex</h1>
<p id="rfc.section.1.3.2.p.1">TBD</p>
<h1 id="rfc.section.1.3.3">
<a href="#rfc.section.1.3.3">1.3.3.</a> Amazon</h1>
<p id="rfc.section.1.3.3.p.1">Consider the case of a website that supports searching and displays advertisements related to the search. In this case clicking on the advertisement could directly connect the user with a sales agent at the company associated with the advertisement.</p>
<div id="#rfc.figure.4"></div>
<pre>
+------+            +------+   
| Web  |            | SIP  |   
| Serv |            | Serv |
+------+            +------+ 
   |                /    |     
   |HTTP           /     |       
   |              /      |       
   |             /SIP    |       
   |            /        |        
   |           /         |        
   |          /          | SIP         
 +-----------+           |      
 |JS/HTML/CSS|           |            
 +-----------+           |            
 +-----------+           |           
 |           |          +-------+               
 |           |          | Video |         
 |  Browser  |----------| Phone |
 |           | ICE+SRTP |       |      
 |           |          +-------+        
 +-----------+                          </pre>
<p id="rfc.section.1.3.3.p.2">In this sort of case the people operating the web server do not need to deploy anything special to display the advertisement, and the company associated with the advertisement can use its existing call center, assuming it meets the legacy VoIP requirements outlined in section XXX.</p>
<p id="rfc.section.1.3.3.p.3">The security issue of a browser sending a SIP packet to a device that does not meet the same origin policy is discussed in the section XXX, but the brief preview of the solution is that the SIP messages can use CORS REF much like a HTTP does.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Terminology</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Requirements</h1>
<p id="rfc.section.3.p.1">The section defines the set of protocols and selected subset profiles of these protocols that a browser would need to implement, and forms the requirements for the API to control these protocols. At a high level we split this into connection management, transports for real time media such as audio and video, transports for non media data, codecs support, and signaling protocols.</p>
<p id="rfc.section.3.p.2">All of the data plane sessions are set up using ICE [REF] or ICE-Lite for security reasons, discussed in section XXX. Devices that could be deployed behind NATs, such as a web browser, are REQUIRED to support ICE while other devices that always deploy on public addresses can do ICE-Lite. The only mode of ICE REQUIRED is aggressive. Real time media is transported over RTP REF or SRTP [REF]. Support for multicast RTP is OPTIONAL. To support ICE, implementation needs to be able to do STUN REF and TURN REF. In addition, there is a strong interest to define a TURN-like protocol that looks like HTTP to intermediaries, so that media can be tunneled over HTTP. Support RTCPMUX REF is REQUIRED. RTP keep alive is done using RTCP as described in REF. The API needs to allow the DSCP REF for each RTP or media stream to be set. The API needs to allow the browser app to observer and control the SSRC values in the RTP.</p>
<p id="rfc.section.3.p.3">Open Issue: There is a desire to be able to pass non media type data directly between browsers. For example, an application such as Second Life or gaming application may wish to pass small chunks of data such as player position with stringent real time requirements. There are several proposals for how to do this. The session would be set up using ICE, just as with RTP. One proposal is just to use a thin shim on top of UDP or DTLS to demux the packets from other packets such as RTP on the same connection. Another proposal is DTLS over DCCP over UDP with some appropriate congestion control scheme chosen for DCCP. Another proposal is to define a data codec to carry the data in RTP.</p>
<p id="rfc.section.3.p.4">The mandatory to implement audio codecs are: PCMA, PCMU, telephone-event, and opus [REF]. The API needs to support the following OPTIONAL codecs: G729, G722, G7221, G723, AMR, AMR-WB, iLBC, L16 and opus. PCMU and PMCA codecs are REQUIRED to support 1 channel with a rate of 8000 and a ptime of 20. The mandatory to implement video codecs are: &lt;to be chosen by working group - leading candidates for consideration are H.264-AVC and VP8&gt;. The minimum profile and resolutions supported by the mandatory to implement video codecs are TBD. The API needs to support the following OPTIONAL codecs: H263-2000, H264, H264-SVC, raw and VP8.</p>
<p id="rfc.section.3.p.5">The signaling protocol selected here is SIP though very little overall architecture would change if the WG decided to use Jingle REF instead of SIP. The browser needs to implement the subset of SIP REF3261,3263,3264 and is required to support registration, invite, ack, cancel, bye, and update. Support for the following features is OPTIONAL: INVITES without an offer, re-invite, forking, S/MIME and sips. Support for the following is REQUIRED: sip over TLS, outbound proxy, 3xx redirects, early media, multipart mine REF 5621, update, identity 4916 &amp; 4471, rport REF 3581, SIP keep alive as described in 5626.</p>
<p id="rfc.section.3.p.6">Open Issue: define a TURN like protocol to tunnel RTP over HTTP</p>
<p id="rfc.section.3.p.7">Open Issues: define a RTP mux protocol to multiplex RTP on top of a single UDP port. Would likely use SSRC as the demux code point.</p>
<p id="rfc.section.3.p.8">Open Issue: Mandatory to implement video codec(s) and minimum profile.</p>
<p id="rfc.section.3.p.9">Open Issue: Mandatory to implement audio codecs.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Connection API</h1>
<p id="rfc.section.4.p.1">It is expected this section will be removed from this draft and moved to a W3C draft but it is provided for reference at this point. The straw man API are many things including adequate error handling. The API would likely end up using exceptions for many things. </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Session API</h1>
<p id="rfc.section.4.1.p.1">The session element can be used anywhere in HTML that the source element could be used. Fundamentally, this is an alternative way of setting up a source for an audio or video element.</p>
<p id="rfc.section.4.1.p.2">Categories: None</p>
<p id="rfc.section.4.1.p.3">Contexts in which this element can be used: same as source element</p>
<p id="rfc.section.4.1.p.4">Content model: Empty</p>
<p id="rfc.section.4.1.p.5">Content attributes:</p>

<dl>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>src:</dt>
<dd style="margin-left: 8">URL to destination to create session with.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>aor:</dt>
<dd style="margin-left: 8">Address of Record that identifies this user.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>credential:</dt>
<dd style="margin-left: 8">Password or credential for the specified AOR.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>proxy:</dt>
<dd style="margin-left: 8">URL for outbound proxy.</dd>
</dl>
<p id="rfc.section.4.1.p.6">DOM interface:</p>
<div id="#rfc.figure.5"></div>
<pre>
interface Session : HTMLElement {

  attribute double volume; // control speaker volume
  attribute boolean mute; // control microphone
  attribute boolean sendVideo; // control camera 

  attribute DOMObject videoPane;
  attribute DOMString aorUrl;
  attribute DOMString credential;
  attribute DOMString outboundProxyURL;
  readonly attribute DOMString remoteName;
  readonly attribute boolean secure; 

  readonly attribute DOMString registrationState;
  // noRegistrar, registering, registered, registrationFailed
  attribute Function onRegisterStateChange;

  void open( in DOMString url ); // tel or SIP URL 
  void close();
  void accept( boolean accept );

  readonly attribute DOMString sessionState; 
  // noSession, openingSession, acceptingSession,
  // inSession, closingSession
  attribute Function onSessionStateChange;

  boolean sendKeyPress( in DOMString key ); // send DTMF or KPML 
  attribute Function onReceiveKeyPress;
};</pre>
<p></p>
<p id="rfc.section.4.1.p.8">If the session will be able to display video, the DOM object for a video tag must be provided in the videoPane parameter of the constructor. If an aorUrl is provided, the session will attempt to register for incoming calls at the server using the provided credentials. If an outbound proxy is provided, all signaling for this session will use that proxy. The progress of the registration can be tracked with the onRegisterStateChange callback. The registrationState attribute will be a string with one of the following values: noRegistrar, registering, registered, or registrationFailed.</p>
<p id="rfc.section.4.1.p.9">Open Issue: need to decide how to handle credentials and if they will be in the JavaScript. Similar issues for TURN server credentials.  </p>
<p id="rfc.section.4.1.p.10">To make a call, the open session method is called and the session state will change to "opening session".</p>
<p id="rfc.section.4.1.p.11">Events:</p>
<p id="rfc.section.4.1.p.12">Exceptions:</p>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> Session Example Incoming</h1>
<p id="rfc.section.4.1.1.p.1">The following HTML snippet would display a video pane with a user interface such that when the user clicked, it would create an audio video session by making a SIP call to "sales@example.com".</p>
<div id="#rfc.figure.6"></div>
<pre>
&lt;video width='320' height='240' &gt;
  &lt;session src="sip:sales@example.com" &gt;
&lt;/video&gt;</pre>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> Session Example Outgoing</h1>
<p id="rfc.section.4.1.2.p.1">The following HTML snippet would register to receive calls to the address "sip:fluffy@example.com". Furthermore it would use an outbound SIP proxy at sip.example.com.</p>
<div id="#rfc.figure.7"></div>
<pre>
&lt;video width='320' height='240' &gt;
  &lt;session  aor="sip:fluffy@example.com" 
            credential="password" 
            proxy="sip:sip.example.com" &gt;
&lt;/video&gt;</pre>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Connection API</h1>
<p></p>
<div id="#rfc.figure.8"></div>
<pre>
[NoInterfaceObject]
interface IceCandidate {
 DOMString foundation;
 unsigned short component-id; // always 1 ?
 DOMString transport; // udp 
 unsigned long priority;
 DOMString type; // host, srflx, prflx, relay 
 DOMString addressFamily; // v4 v6 
 DOMString connectionAddress; // v4 or v6 ip address 
 unsigned short port; 
};

[NoInterfaceObject]
interface IceCandidateList {
 IceCandidate  candiate[];
 DOMString icePassword;
 DOMString iceUFragment; 
};

[NoInterfaceObject]
interface RelayServer {
  DOMString type; // stun turn 
};

[NoInterfaceObject]
interface StunServer : RelayServer {
  DOMString ip; 
};

[NoInterfaceObject]
interface TurnServer : RelayServer {
  DOMString ip; 
  DOMString username;
  DOMString password;
};

[Constructor(in optional RelayServer relayServers[])]
interface Connection {
  attribute int keepAlivetime; // default 30 seconds 

  attribute RelayServer relayServers[]

  readonly attribute IceCandidateList candidateList;

  readonly attribute IceCandidate connectionNearEnd;
  readonly attribute IceCandidate connectionFarEnd;

  void open( IceCandidateList addressList );

  readonly attribute DOMString state;
  // creating,ready,connecting,open,closed

  attribute Function onready;
  attribute Function onopen;

  void send(in DOMString data);
  attribute Function onmessage; // implements MessageEvent interface 
  attribute Function onerror;

  void close();
  attribute Function onclose;
};</pre>
<p id="rfc.section.4.2.p.2">The general usage for a browser that had a stun server at 192.0.2.1 would be to create a connection, wait for ICE to gather candidates and the state to change to ready, then send the ICE candidates list to the far side as shown in the following code.</p>
<p id="rfc.section.4.2.p.3">Open Issue: Need to add more into this so that an application can understand what is going on and get information to provide status and debug problems as well as statistics. Also may need parameters to change the algorithm. </p>
<div id="#rfc.figure.9"></div>
<pre>
 myConn = new Connection( [ {type:"stun",ip:"192.0.2.1"} ] );
 myConn.onready = function() {
   myCandidates = myConn.candidateList;
   // send myCandidates to far side
 }   </pre>
<p id="rfc.section.4.2.p.4">Open issue: add text around setter calling function if in that state when set. </p>
<p id="rfc.section.4.2.p.5">Later when the far side has sent its candidate list to this side, the browser app calls open to start opening the connection to the other side. Once the connection is open, the browser app can start sending and receiving data.</p>
<div id="#rfc.figure.10"></div>
<pre> 
 myConn.open( farSideCandidateList );
 myConn.onOpen = function() {
   // can start sending data for far side
   myConn.send( "Hello" );
 }
 myConn.onmessage = function(e) {
   alert "Received data:" + e.data;
 }</pre>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Audio Video API </h1>
<p id="rfc.section.4.3.p.1">Note this section is far from complete and is more just a sketch to get the flavor of the interface.</p>
<div id="#rfc.figure.11"></div>
<pre>
interface Advertisement {
  CodecAd codecs[];
  boolean rtcpMux; // default true
  boolean rtpMux; // default true 
  boolean srtp; // default true 
  DOMString protocols[]; 
  // RTP/AVP, RTP/AVPF, UDP/TLS/RTP/SAVP, UDP/TLS/RTP/SAPF 
  srtpSuites[]; // AES_CM_128_HMAC_SHA1_32
};

interface CodecAd{
  string mediaType; 
  int clockRate; 
  float minBandwidth; // kbps 
  float maxBandwidth; // kbps 
  boolean canReceive;
  boolean canSend;
  boolean supportDscp;
};

interface TelEventDataCodecAd {
  int supportCodes[]; // defaults to 0-11 if not present 
};

interface AudioCodecAd : CodecAd {
 int maxPacketTime; // ms 
};

interface IlbcAudioCodecAd : AudioCodecAd {
 int modeList []; 
}

interface G729AudioCodecAd : AudioCodecAd {
  boolean vadSupported;
};

interface G711uAudioCodecAd : AudioCodecAd {
  // G.711 PCMU must be 1 channel at rate of 8000 
};

interface G711aAudioCodecAd : AudioCodecAd {
  // G.711 PCMA must be 1 channel at rate of 8000 
};

interface L16AudioCodecAd : AudioCodecAd {
  int rates[];
  int channels[];
  DOMString emphasis[];
  DOMString channel-order[];
};

interface AMRAudioCodecAd : AudioCodecAd {
 DOMString modeSet; 
 // bunch more needed here 
};

interface VideoCodecAd : CodecAd {
 float maxFramerate; // fps 
 int clockRate; 
 int minXsize; int maxXsize;
 int minYsize; int maxYsixe;
 float minPar; float maxPar; float parList[];
 float minSar; float maxSar; float sarList[];
};

interface VP8CodecAd : VideoCodecAd {
   int versions[];
};

interface H264CodecAd : VideoCodecAd {
  unsigned short profile-levls[];
  unsigned short max-recv-level;
  int max-mbps;
  int max-smbps; 
  int max-fs; 
  int max-cpb; 
  int max-dpb;  
  int max-br;
  boolean redundant-pic-cap;
  DOMString sprop-parameter-sets;
  DOMString sprop-level-parameter-sets;
  boolean use-level-src-parameter-sets;
  boolean in-band-parameter-sets;
  boolean level-asymmetry-allowed;
  int packetization-modes[];
  int sprop-interleaving-depth;
  int sprop-deint-buf-req;
  long deint-buf-cap;
  int sprop-init-buf-time; 
 // int sprop-init-buf-time; 
  long max-rcmd-nalu-size; 
  int sar-understood; 
  int sar-supported;
};


interface Proposal {
  StreamProp streams[];
};


interface StreamProp {
  string mediaType; 
  int clockRate; 
  float minBandwidth; // kbps 
  float maxBandwidth; // kbps 
  boolean canReceive; // default true 
  boolean canSend; // default true 

  DOMString fingerprint; // RFC4572
  int pTime;
  DOMString protocol; 
  // RTP/AVP, RTP/AVPF, UDP/TLS/RTP/SAVP, UDP/TLS/RTP/SAPF 
  long ssrc; 
  int dscp;
  DOMString srtpSuites;
  int srtpKdr;
  boolean srtpUnencryptedRtcp;
  boolean srtpUnauthenticated;
  DOMString srtpFecOrder; //FEC_SRTP, "SRTP_FEC"
  int srtpLifetime; // log base 2 of max packets with one kety
  DOMString srtpKeys[];
  int srtpMki[]; // MKI corresponding to srtpKeys at same index 
};

interface VideoProp : StreamProp {
  int sizex; 
  int sizey;
  float sar;  
  float frameRate; 
};

interface AudioProp : StreamProp {
  int pTime; // ms 
};

interface Stats {
   StreamStats steam[];
};

interface StreamStats {
  // TODO RTCP stats
};

interface AVT {
  attribute Connection connection;
  readonly attribute Advertisement advertisement;
  readonly attribute Advertisement advertisementNoVideo;

  attribute DOMObject camera;
  attribute DOMObject mic;
  attribute HTMLVideoElement videoPane; 

  readonly attribute Stats stats; 
 
  readonly attribute Proposal proposal; 
  boolean setProposal( Proposal newProp );
};</pre>
<p id="rfc.section.4.3.p.2">Using this interface is fairly simple. First an AVT object is loaded and bound to an existing Connection object. It is also bound to cameras, microphones, and speakers, Then the current advertisement can be retried.</p>
<p id="rfc.section.4.3.p.3">Open Issue: The SRTP keying should not be per stream. </p>
<div id="#rfc.figure.12"></div>
<pre>
var myAvt = org.w3c.device.load("device", "AVT", "1");

myAvt.connection = myConn; // the ICE formed connection
myAvt.camera = org.w3c.device.load("device", "camera", "1");
myAvt.mic = org.w3c.device.load("device", "mic", "1");
myAVT.videoPane = document.getElementById("myVideo");

mdAdv = myAvt.advertisement;</pre>
<p id="rfc.section.4.3.p.4">Open Issues: What's the best way to get an AVT object? How to get the other devices and wire them up to the AVT object?</p>
<p id="rfc.section.4.3.p.5">Assume that the browser supports VP8 video at 720P and G.711. The myAvt object might look like:</p>
<div id="#rfc.figure.13"></div>
<pre>
{
   "codecs" :  [ 
      {
          "mediaType" : "PCMU",
          "clockRate": "8000",
          "maxPacketTime" : "60"
      },
      {
          "mediaType" : "PCMA",
          "clockRate": "8000",
          "maxPacketTime" : "60"
      },
      {
            "mediaType" : "VP8",
            "clockRate" : "90000",
            "maxXsize" : ""1440,
            "maxYsize" : "720",
            "parList" :  [ "1.0" ],
            "versions" : [ "1" ]
       } ],
   "protocols" : ["RTP/AVP", "RTP/AVPF" ]
};</pre>
<p id="rfc.section.4.3.p.6">Then, based on some knowledge about what the far end browser supports, the system would decide that it wants to use PCMU with VP8 at a QCIF resolution and 15fps. After forming a connection to the far end and waiting for the connection object to be in the ready state, it would construct the following proposal object and then send that proposal to the AVT systems as shown in the code below. Assuming the proposal is acceptable, the setProposal returns true and (returns false if it is not).</p>
<div id="#rfc.figure.14"></div>
<pre>
var proposal = {
  "streams" : [ 
      {
        "mediaType" : "VP8",
        "clockRate: : "90000", 
        "protcol" : "RTP/AVP",
        "sizex" : "176",
        "sizey" : "144",
        "sar" : "1.0",
        "frameRate" : "15", 
        "version" : "1"
      },
      {
        "mediaType" : "PCMU",
        "clockRate: : "8000", 
        "pTime" : "20",
        "protcol" : "RTP/AVP"
      } ]
};


if ( myAvt.setProposal( proposal ) ) {
   // it worked
}</pre>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> IANA Considerations</h1>
<p id="rfc.section.5.p.1">This document does not require any action of IANA.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Security Considerations</h1>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> Attack Model</h1>
<p id="rfc.section.6.1.p.1">This architecture involves all the normal security consideration and attack models of HTTP, SIP and RTP but introduces yet another key issue. The assumption is that a user may browse to the attacker's website. The other assumption is that the browser is behind a firewall, and inside that firewall there are devices that would not have appropriate security models for the internet. For example, there could be SIP gateways that if sent an invite to call a 1-900 number would do so with no authentication or authorization. Whatever HTML/CS/Javascript is downloaded must not be able to send arbitrary packets to hosts behind the firewall or send SIP or RTP to devices that do not consent to communicate with the browser.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> Media Security</h1>
<p id="rfc.section.6.2.p.1">The browser MUST enforce the constraint that no RTP or other media is sent to a given destination unless that destination completes an ICE connectivity check and proves it knows the secret generated by the browser. The browser must keep a list of locations it has attempted to contact with ICE in the previous 30 seconds and not contact any locations that have previously failed.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> Signaling Security</h1>
<p id="rfc.section.6.3.p.1">The browser stops unwanted SIP signaling by using CORS REF. The same CORS headers used for HTTP will be added to the SIP signaling.  Before the browser sends SIP signaling, it will preflight the SIP messaging using a SIP OPTIONS message. This is done the same ways CORS can preflight check an HTTP request.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Legacy VoIP Interoperability</h1>
<p id="rfc.section.7.p.1">There is no way to meet all the security requirements and maintain comparability with all legacy VoIP equipment. This draft tries to minimize the impedance mismatch. The requirements here would allow interoperability with legacy VoIP equipment as long as that equipment either directly supported, or was fronted by an SBC that supported, the following: SIP CORS extension, ICE or ICE-Lite, codecs from the mandatory to implement set, supported SIP invites containing an offer, and supported DTMF over RTP with telephone events.</p>
<p id="rfc.section.7.p.2">A substantial fraction of VoIP equipment does all of this except for the CORS extensions. The item most commonly lacking is ICE-Lite but that is becoming increasingly prevalent, particularly on devices designed to sit on the edge of a domain and connect to remote UAs that may be behind NATs. For an edge device that was willing to receive SIP call from others, implementing the CORS is pretty trivial. When the UAS receives a SIP options request with an Origin header, it checks whether the header field value is on the white list, and if it is then the UAS copies the value to the Access-Control-Allow-Origin header field value in the response. For many situations the white list would be everything, while for others it would be just the list of websites that are expected to originate calls to this SIP device.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Acknowledgement</h1>
<p id="rfc.section.8.p.1">Thanks to Joe Hildebrand, Matt Miller, Matthew Kaufman, Eric Rescorla and Lyndsay Campbell for their review, comments and contributed ideas.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table><tbody><tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr></tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="I-D.peterson-sipcore-advprop">[I-D.peterson-sipcore-advprop]</b></td>
<td class="top">
<a>Peterson, J</a> and <a>C Jennings</a>, "<a href="http://tools.ietf.org/html/draft-peterson-sipcore-advprop-00">The Advertisement/Proposal Model of Session Description</a>", Internet-Draft draft-peterson-sipcore-advprop-00, February 2010.</td>
</tr></tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Cullen Jennings</span> 
	  <span class="n hidden">
		<span class="family-name">Jennings</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco</span>
	<span class="adr">
	  <span>170 West Tasman Drive</span>

	  <span class="vcardline">
		<span class="locality">San Jose</span>,  
		<span class="region">CA</span> 
		<span class="code">95134</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +1 408 421-9990</span>

<span class="vcardline">EMail: <a href="mailto:fluffy@cisco.com">fluffy@cisco.com</a></span>

  </address>
</div>

</body>
</html>