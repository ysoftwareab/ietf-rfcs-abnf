<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Domain Name Assertions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Domain Name Assertions">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Internet Engineering Task Force</td><td class="header">R. Barnes</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">BBN Technologies</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">August 19, 2010</td></tr>
<tr><td class="header">Expires: February 20, 2011</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Domain Name Assertions<br />draft-barnes-xmpp-dna-00.txt</h1>

<h3>Abstract</h3>

<p>Many Internet applications allow service delegation via the DNS.
      However, in the absence of DNSSEC, these delegations are
      unauthenticated, so clients have to authenticate the delegate as if he
      were the original service. This situation causes several operational
      problems. This document describes a mechanism for clients to discover
      and validate information that authenticates DNS-based service
      delegations, without relying on the global deployment of DNSSEC.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on February 20, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#term-sec">2.</a>&nbsp;
Terminology<br />
<a href="#general-sec">3.</a>&nbsp;
General Procedure<br />
<a href="#discovery-sec">4.</a>&nbsp;
Authenticator Discovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">4.1.</a>&nbsp;
DNS-Based Discovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">4.2.</a>&nbsp;
Security-Protocol Discovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">4.3.</a>&nbsp;
Application-Layer Discovery<br />
<a href="#validation-sec">5.</a>&nbsp;
Authenticator Formats and Validation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">5.1.</a>&nbsp;
Attribute Certificate<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">5.2.</a>&nbsp;
DNSSEC External Trust Anchor<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">5.3.</a>&nbsp;
PKIX Certificate with SRVName<br />
<a href="#acknowledgements-sec">6.</a>&nbsp;
Acknowledgements<br />
<a href="#security-sec">7.</a>&nbsp;
Security Considerations<br />
<a href="#iana-sec">8.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">9.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">9.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">9.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Many Internet applications use the DNS for service discovery and
      delegation. The most long-standing example of this usage of the DNS is
      of course the use of MX records to discover mail servers <a class='info' href='#RFC0974'>[11]<span> (</span><span class='info'>Partridge, C., &ldquo;Mail routing and the domain system,&rdquo; January&nbsp;1986.</span><span>)</span></a>. That pattern has been re-used with modern
      services, having been generalized through the introduction of SRV
      records and the Dynamic Delegation Discovery System (DDDS) <a class='info' href='#RFC2782'>[1]<span> (</span><span class='info'>Gulbrandsen, A., Vixie, P., and L. Esibov, &ldquo;A DNS RR for specifying the location of services (DNS SRV),&rdquo; February&nbsp;2000.</span><span>)</span></a><a class='info' href='#RFC3401'>[2]<span> (</span><span class='info'>Mealling, M., &ldquo;Dynamic Delegation Discovery System (DDDS) Part One: The Comprehensive DDDS,&rdquo; October&nbsp;2002.</span><span>)</span></a>. For example,
      XMPP and SIP services are found using SRV records <a class='info' href='#RFC3920'>[12]<span> (</span><span class='info'>Saint-Andre, P., Ed., &ldquo;Extensible Messaging and Presence Protocol (XMPP): Core,&rdquo; October&nbsp;2004.</span><span>)</span></a><a class='info' href='#RFC3263'>[13]<span> (</span><span class='info'>Rosenberg, J. and H. Schulzrinne, &ldquo;Session Initiation Protocol (SIP): Locating SIP Servers,&rdquo; June&nbsp;2002.</span><span>)</span></a>, while LoST and
      HELD services use NAPTR records (i.e., they use DDDS) <a class='info' href='#RFC5222'>[14]<span> (</span><span class='info'>Hardie, T., Newton, A., Schulzrinne, H., and H. Tschofenig, &ldquo;LoST: A Location-to-Service Translation Protocol,&rdquo; August&nbsp;2008.</span><span>)</span></a><a class='info' href='#I-D.ietf-geopriv-http-location-delivery'>[15]<span> (</span><span class='info'>Barnes, M., Winterbottom, J., Thomson, M., and B. Stark, &ldquo;HTTP Enabled Location Delivery (HELD),&rdquo; August&nbsp;2009.</span><span>)</span></a>.
</p>
<p>Because these records direct a client from one domain to another (an
      "source" name to a "target" name), they can create challenges for server
      authentication. When the client ultimately connects to a remote
      endpoint, should the client expect it to authenticate as the source or
      the target? The answer to this question has important operational
      impact, especially in situations where the source and target domains are
      operated by different entities.
</p>
<p>If the client cannot verify that the DNS records involved in the
      delegation are authentic, then these records cannot be trusted. Since
      spoofed delegation records could be used to point the client to an
      attacker's server (e.g., to insert a man-in-the-middle), the client must
      require the server to authenticate as the source domain.
</p>
<p>For example: Let us assume that a company called Example.com wishes
      to offload responsibility for its corporate instant messaging service
      ("im.example.com") to a hosting provider called Apps.Example.Net using
      XMPP. The company sets up DNS service location records that point
      im.example.com at apps.example.net:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>_xmpp-client._tcp.im.example.com. 90 IN SRV 0 0 5222 apps.example.net
_xmpp-server._tcp.im.example.com. 90 IN SRV 0 0 5269 apps.example.net</pre></div>
<p>
</p>
<p>When a user juliet@example.com attempts to log in to the IM service
      at im.example.com, her client discovers apps.example.net and resolves
      that name to an IP address and port. However, Juliet wants to be sure
      that the connection is encrypted using Transport Layer Security <a class='info' href='#RFC5246'>[3]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a> so her client checks the certificate offered by
      the XMPP service at the resolved IP address and port.
</p>
<p>Her client expects the server identity in the certificate to be
      "im.example.com" (or perhaps "*.example.com"). But what if the identity
      is, instead, "apps.example.net" or "*.example.net"? Now her client will
      need to prompt Juliet to accept this certificate mismatch either
      temporarily or permanently. Because such security warnings are unnerving
      to end users, the owners of the company would prefer that the IM service
      offer a certificate with an identity of "im.example.com". Unfortunately,
      the IM server software used by the hosting provider probably needs
      runtime access to the private key associated with the certificate. This
      makes both the security personnel at Example.com and the lawyers at
      Apps.Hosting.Net uncomfortable.
</p>
<p>If the delegation records in question are authenticated, then the
      client can verify that the service has indeed been delegated to the
      target domain, and can authenticate the server as the target. This
      authentication can be provided with DNSSEC <a class='info' href='#RFC4033'>[4]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;DNS Security Introduction and Requirements,&rdquo; March&nbsp;2005.</span><span>)</span></a>, but only if the signatures on the delegation
      records chain back to a key that the client accepts as a trust anchor
      (ideally, the root key). In the current DNSSEC deployment environment,
      only a few domains have full chains back to the root, and there is no
      general agreement on trust anchors other than the root.
</p>
<p>This document discusses an intermediate solution for authenticating
      DNS delegation records in situations where DNSSEC cannot be used. We
      define a general process that clients can use to determine whether to
      use the source or target domain as the identifier that a server must
      authenticate, then consider some specific techniques for accomplishing
      this general procedure and their practical trade-offs.
</p>
<a name="term-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>[5]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<p>This document uses the word "delegation" to encompass several
      different mechanisms for delegating services from one name to another
      using the DNS, including MX records, SRV records, and the DDDS. These
      mechanisms delegate services from one DNS name to another. We call the
      name being delegated the "source name" or "source domain" and the
      recipient of the delegation and the recipient of the delegation the
      "target" name or domain. We do not distinguish the case where the output
      of the delegation may be something other than a domain name (e.g., a
      URI), as can happen in DDDS.
</p>
<p>We generally consider these delegations in the form of a single
      record; in cases where multiple delegations are chained together (as can
      happen in DDDS), the techniques here may be repeated.
</p>
<p>Delegation records will be authenticated using signed data objects,
      which we generally refer to as "authenticators". Clients find these data
      objects using an "authenticator discovery" process based on the source 
      domain whose services they are seeking.
</p>
<a name="general-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
General Procedure</h3>

<p>When a client seeks to connect to a service that is located using DNS
      delegation records, it needs to be able to authenticate the validity of
      these records so that it knows whether to authenticate the located
      server as the source or target domain. The general process for
      discovering and authenticating a delegation is as follows:
</p>
<p></p>
<ol class="text">
<li>The client retrieves the delegation record (e.g., MX, SRV,
          NAPTR).
</li>
<li>If the delegation record is protected by DNSSEC, chaining back to
          one of the client's trust anchors, then the client matches the
          server's authenticated identity against the target name for the
          delegation.
</li>
<li>The client queries for an authenticator for the delegation
          record.
</li>
<li>If an authenticator is present, the client validates that it
          corresponds to the delegation record and that it is issued by a
          trusted authority.
</li>
<li>If the authenticator is present and valid, the client matches the
          server's authenticated identity against the target name for the
          delegation.
</li>
<li>Otherwise, the client matches against the source name for the
          delegation.
</li>
</ol>

<p>The specific procedures for authenticator discovery and validation
      are discussed in <a class='info' href='#discovery-sec'>Section&nbsp;4<span> (</span><span class='info'>Authenticator Discovery</span><span>)</span></a> and <a class='info' href='#validation-sec'>Section&nbsp;5<span> (</span><span class='info'>Authenticator Formats and Validation</span><span>)</span></a>.
</p>
<p>Note that this procedure smoothly degrades as DNSSEC becomes more
      widely available. Technically speaking, DNSSEC signatures could be
      considered as a form of authenticator, but because of the importance of
      transition for this mechanism (and because of some conceptual
      differences from other authenticators), the procedure above accommodates
      with a specific "short cut".
</p>
<a name="discovery-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Authenticator Discovery</h3>

<p>To allow clients to authenticators delegation records, there needs to
      be a way for them to gain access to the signed objects or
      "authenticators" that attest to the delegation. There are basically
      three points in the connection process where an authenticator can be
      provided:
</p>
<p></p>
<ol class="text">
<li>Before connection establishment, as part of the DNS
</li>
<li>During connection establishment, as part of the security
          protocol
</li>
<li>After connection establishment, as part of the application
</li>
</ol>

<p>In the below sections, we outline how authenticators can be provided
      in each of these cases, and discuss their relative merits.
</p>
<p>
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
DNS-Based Discovery</h3>

<p>Since all of the below authenticator formats are based on digital
        certificates, source domain operators can publish them using DNS CERT
        records <a class='info' href='#RFC4398'>[6]<span> (</span><span class='info'>Josefsson, S., &ldquo;Storing Certificates in the Domain Name System (DNS),&rdquo; March&nbsp;2006.</span><span>)</span></a> under a well-known name related
        to the source name. For example, if im.example.com is delegating its
        XMPP services to apps.example.net, and authenticating with an X.509
        certificate (to be obtained from a URL), it would provision the
        following records:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>_xmpp-client._tcp.im.example.com. 90 IN SRV 0 0 5222 apps.example.net
_dna._xmpp-client._tcp.im.example.com. 90 IN CERT 4 12345 5
                                       http://example.com/im.crt

_xmpp-server._tcp.im.example.com. 90 IN SRV 0 0 5269 apps.example.net
_dna._xmpp-server._tcp.im.example.com. 90 IN CERT 4 12345 5
                                       http://example.com/im.crt</pre></div>
<p>
</p>
<p>A client can then construct the name for the delegation (the source 
        name) using any technique defined by the delegation mechanism, then
        append the reserved label "_dna" to find the authenticator for the
        delegation. (As a simplification, one might also consider simply
        provisioning the CERT record under the same name as the delegation
        record. The _dna label is useful, however, to distinguish these
        certificates from certificates used for other purposes.)
</p>
<p>This discovery mechanism has the benefit of directness.
        Authenticators have to ultimately originate with the source domain,
        since that is the domain that is authoritative for the delegation. In
        the other two cases below, the authenticator has to be provided to the
        target server, who then provides it to the client, while in this case,
        the client can simply receive the authenticator directly from the
        source domain.
</p>
<p>Likewise, this technique is very general. It is completely agnostic
        to the type of security protocol or application protocol being used,
        and requires no changes to either protocol. It also applies without
        modification to all the different record types that can be used for
        delegation.
</p>
<p>One challenge for this technique, as for the application-layer
        discovery discussed below, is the question of how the source domain
        can present a certificate chain to help the client validate the
        authenticator. It may be possible to address this challenge by
        including multiple CERT records under the same domain name. These
        certificate can either be considered as an unordered list, leaving the
        client to assemble them together into a certificate chain, or as an
        sequence ordered by the preference values in the records.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Security-Protocol Discovery</h3>

<p>Security protocols already have syntax for endpoints to provide
        authentication credentials of enough different types to cover the
        different authenticator formats discussed below. However, providing
        these authenticators as part of the establishment of a secure channel
        is generally not practical.
</p>
<p>For example, at the time of session establishment, a server
        typically has to provide authentication credentials before it knows
        what identity the client is expecting, so a server that hosts many
        domains would need to have a single certificate that covers all
        possible delegations pointing to it. In addition to creating very
        large credentials, such credentials would need to be re-issued
        whenever a delegation changed. A server would thus need effectively
        the same credential as if it were simply authenticating the source 
        domain of the delegation, with the same operational issues, negating
        any benefit to authenticating the delegation.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Application-Layer Discovery</h3>

<p>Several applications include mechanisms for protocol endpoints to
        challenge one another for authentication credentials. In XMPP, for
        example, one endpoint can issue a &lt;challenge&gt; stanza indicating
        what sort of proof is desired, and the other endpoint can reply with a
        &lt;response&gt; stanza containing the required authenticator. HTTP
        uses the WWW-Authenticate and Authorization headers in a similar
        way.
</p>
<p>In order to use this mechanisms to authenticate a delegated
        service, the client would need to provisionally accept the credentials
        presented by the server in the security protocol. It would also have
        to make sure that no other protocol interactions occur before the
        authenticator has been received and validated.
</p>
<p>The main benefit of handling delegation authentication at the
        application layer is that protocol interactions can be very rich.
        Applications that incorporate the SASL framework (such as XMPP) can
        benefit from the security semantics that it provides <a class='info' href='#RFC4422'>[7]<span> (</span><span class='info'>Melnikov, A. and K. Zeilenga, &ldquo;Simple Authentication and Security Layer (SASL),&rdquo; June&nbsp;2006.</span><span>)</span></a>. The obvious challenge, however, is that each
        application that wishes to benefit from authenticated delegations will
        have to have its own extension to carry authenticators. In addition,
        the requirement to provisionally accept a secure connection could
        impose additional complexity and resource requirements on the
        client.
</p>
<a name="validation-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Authenticator Formats and Validation</h3>

<p>An authenticator is a signed object that attests to the validity of a
      given delegation by presenting a version of it that is signed by the
      source domain. In this section we discuss three possible forms that such
      an authenticator can take, and their relative merits.
</p>
<p>In evaluating these authenticator formats, it's important to keep in
      mind a few requirements. An authenticator must have two basic parts, a
      representation of the delegation that is being authenticated, and
      signature over that representation that can be verified using a private
      key bound to the source domain. It is important that the signature
      attesting to the validity be from the source domain, since the source 
      domain is the entity making the delegation. If another entity were to
      attest the delegation by presenting an authenticator under its
      signature, then there would be a need to verify that it was authorized
      to do so by the source domain.
</p>
<p>In addition to these structural requirements, there is a practical
      requirement that the issuance and revocation of authenticators should
      not be difficult using current certificate management software and
      practices. Some particular usability questions that will come up are
      whether a single authenticator can be used for multiple services, and
      whether an authenticator can be applied to all the different kinds of
      delegation records.
</p>
<p>The basic security assumption for all of the below formats is that
      the source domain operator has a certificate that binds the source 
      domain name to a public key, and that this certificate chains up to a
      trust anchor recognized by the client. We will refer to this certificate
      as the source domain's "authentication certificate" below. In general,
      when we mention a name in a certificate, we allow for this name to be
      provided either as a Common Name or a dNSName Subject Alternative Name
      (the latter being preferred, but the former included for backward
      compatibility).
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Attribute Certificate</h3>

<p>Format: An attribute certificate using the format specified in
        [draft-ietf-xmpp-dna]. The delegation is encoded in the relationship
        between the subject and the issuer, and in the service field of the
        certificate. The issuer is the source, the subject is the target, and
        the OID in the service field specifies the service being delegated.
        The signature over the delegation is the signature on the
        certificate.
</p>
<p>Validation: The client validates the attribute certificate using
        the public key in the source domain's authentication certificate, then
        validates the authentication certificate.
</p>
<p>Revocation: No direct revocation, only expiration of the attribute
        cert or revocation of the authentication cert.
</p>
<p>Evaluation: This mechanism is fairly straightforward to implement
        with current commercially-available domain certificates, since
        attribute certs are issued by end-entity certificates from a PKI. With
        current libraries, however, support for attribute certificates is
        limited relative to public-key certificates and DNSSEC signatures (the
        other two cryptographic techniques used in this document); both the
        source domain and the client would need to be able to process
        attribute certificates.
</p>
<p>Using attribute certificates also imposes some limits on the re-use
        of certificates. Becase the service being delegated is encoded in the
        certificate, each service delegated requires a different certificate.
        In addition, while this approach is well-suited for SRV records, it is
        not clear how it would work for other types of delegation.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
DNSSEC External Trust Anchor</h3>

<p>Format: The original domain's authentication certificate and an
        RRSIG record over the delegation record or an RR set containing it,
        using the private key corresponding to the public key in the
        authentication certificate. The delegation is encoded in the
        delegation record, and the signature over the delegation is the RRSIG
        record.
</p>
<p>Validation: The client validates that the RRSIG has a valid DNSSEC
        signature over the delegation record or RR set using the public key in
        the source domain's authentication certificate, then validates the
        authentication certificate.
</p>
<p>Revocation: Removal of the RRSIG record (or removal of the
        delegation record from the RR set), or revocation of the
        authentication certificate.
</p>
<p>Evaluation: As with the DNS-based discovery approach described
        above, the use of external trust anchors has the benefit of
        generality. Because the delegation is not re-encoded in any way (e.g.,
        by being transcribed into a certificate), the signature can be applied
        to any type of record, and no semantics are added or lost. The same
        key and certificate can be used for several different RRSIGs or
        delegations. Issusing authenticators of this type only requires the
        source domain to have an end-entity certificate, not a CA
        certificate.
</p>
<p>The major challenge for this approach is figuring out how it
        integrates with operational practices, in particular with regard to
        certificate management and DNS operations. Using certificates as
        DNSSEC external trust anchors requires that the key pair used to
        construct the RRSIG also be included in the source domain's public key
        certificat. This should not be a problem, since the subject of a
        certificate can choose the key that is included. Note that this
        requirement doesn't necessarily mean that the key pair needs to be
        used for anything other than DNSSEC; the source domain could obtain
        separate certificates for other purposes (e.g., HTTPS).
</p>
<p>The other operational concern arises with regard to the requirement
        that the client be able to validate an RRSIG record, effectively
        managing the set of DNSSEC trust anchors. In particular, because of
        this need for local trust anchor management, the client cannot make
        use of any DNSSEC support in the DNS infrastructure, e.g., validating
        resolvers. As long as the client can retrieve the proper RRSIG record,
        however, the process should work. (That request can of course be
        routed through the normal DNS system, resolvers and all.)
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
PKIX Certificate with SRVName</h3>

<p>Format of the authenticator: X.509 certificate containing an
        SRVName Subject Alternative Name <a class='info' href='#RFC5280'>[8]<span> (</span><span class='info'>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; May&nbsp;2008.</span><span>)</span></a><a class='info' href='#RFC4985'>[9]<span> (</span><span class='info'>Santesson, S., &ldquo;Internet X.509 Public Key Infrastructure Subject Alternative Name for Expression of Service Name,&rdquo; August&nbsp;2007.</span><span>)</span></a>, issued by the source domain. The delegation
        is encoded in the issuer and SRVName in the certificate. The source 
        domain is encoded in both the issuer's name and in the SRVName (which
        thus must both have the same name), and the target domain is encoded
        in the subject's name. The SRVName also contains an indication of the
        service being delegated.
</p>
<p>Validation: The client verifies that the service and names in the
        certificate matche the service and names in the delegation, then
        validates the certificate following the normal X.509 validation
        algortihm.
</p>
<p>Revocation: Normal X.509 revocation.
</p>
<p>Evaluation: Using SRVName as a mechanism for authenticating
        delegations leads to several deployment challenges. Because the
        certificate needs to be issued by the source domain, the source domain
        will need to have a CA certificate; CA certificates are commonly much
        more costly than end-entity certificates. Certificates can be re-used,
        with a different SRVName for each service being delegated, but they
        clearly cannot be used for any delegation method that uses a record
        type other than SRV.
</p>
<a name="acknowledgements-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgements</h3>

<p>We would like to thank Joe Hildebrand and Sean Turner for first
      articulating the problem of authenticating delegated services, in the
      context of XMPP, and Peter Saint-Andre for helping generalize that
      discussion.
</p>
<a name="security-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>This document defines a mechanism for authenticating DNS-based
      delegations in support of authentication based on domain names. This
      functionality can be provided using DNSSEC, but that requires that all
      the parents of the delegated domain support DNSSEC as well as the
      delegating domain itself. The mechanisms discussed in this document
      provide a transitional step that allows the authenticity of DNS records
      to be rooted in an alternative hierarchy, namely a hierarchy of X.509
      certificates. Since this mechanism is intended to be transitional, it
      includes a specific provision that prevents its use when DNSSEC is
      available.
</p>
<a name="iana-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>This document currently makes no request of IANA. If DNS_based
      discovery is used, then this document will register the label "_dna" to
      be used for discovering certificates.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2782">[1]</a></td>
<td class="author-text"><a href="mailto:arnt@troll.no">Gulbrandsen, A.</a>, Vixie, P., and <a href="mailto:levone@microsoft.com">L. Esibov</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2782">A DNS RR for specifying the location of services (DNS SRV)</a>,&rdquo; RFC&nbsp;2782, February&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2782.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3401">[2]</a></td>
<td class="author-text">Mealling, M., &ldquo;<a href="http://tools.ietf.org/html/rfc3401">Dynamic Delegation Discovery System (DDDS) Part One: The Comprehensive DDDS</a>,&rdquo; RFC&nbsp;3401, October&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3401.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5246">[3]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>,&rdquo; RFC&nbsp;5246, August&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4033">[4]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4033">DNS Security Introduction and Requirements</a>,&rdquo; RFC&nbsp;4033, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4033.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[5]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4398">[6]</a></td>
<td class="author-text">Josefsson, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4398">Storing Certificates in the Domain Name System (DNS)</a>,&rdquo; RFC&nbsp;4398, March&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4398.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4422">[7]</a></td>
<td class="author-text">Melnikov, A. and K. Zeilenga, &ldquo;<a href="http://tools.ietf.org/html/rfc4422">Simple Authentication and Security Layer (SASL)</a>,&rdquo; RFC&nbsp;4422, June&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4422.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5280">[8]</a></td>
<td class="author-text">Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;5280, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5280.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4985">[9]</a></td>
<td class="author-text">Santesson, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4985">Internet X.509 Public Key Infrastructure Subject Alternative Name for Expression of Service Name</a>,&rdquo; RFC&nbsp;4985, August&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4985.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-xmpp-dna">[10]</a></td>
<td class="author-text">Lindberg, J. and S. Farrell, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-xmpp-dna-00.txt">Domain Name Assertions</a>,&rdquo; draft-ietf-xmpp-dna-00 (work in progress), January&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-xmpp-dna-00.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC0974">[11]</a></td>
<td class="author-text">Partridge, C., &ldquo;<a href="http://tools.ietf.org/html/rfc974">Mail routing and the domain system</a>,&rdquo; RFC&nbsp;974, January&nbsp;1986 (<a href="http://www.rfc-editor.org/rfc/rfc974.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3920">[12]</a></td>
<td class="author-text"><a href="mailto:stpeter@jabber.org">Saint-Andre, P., Ed.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3920">Extensible Messaging and Presence Protocol (XMPP): Core</a>,&rdquo; RFC&nbsp;3920, October&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3920.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3920.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3920.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3263">[13]</a></td>
<td class="author-text">Rosenberg, J. and H. Schulzrinne, &ldquo;<a href="http://tools.ietf.org/html/rfc3263">Session Initiation Protocol (SIP): Locating SIP Servers</a>,&rdquo; RFC&nbsp;3263, June&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3263.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5222">[14]</a></td>
<td class="author-text">Hardie, T., Newton, A., Schulzrinne, H., and H. Tschofenig, &ldquo;<a href="http://tools.ietf.org/html/rfc5222">LoST: A Location-to-Service Translation Protocol</a>,&rdquo; RFC&nbsp;5222, August&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5222.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-geopriv-http-location-delivery">[15]</a></td>
<td class="author-text">Barnes, M., Winterbottom, J., Thomson, M., and B. Stark, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-geopriv-http-location-delivery-16.txt">HTTP Enabled Location Delivery (HELD)</a>,&rdquo; draft-ietf-geopriv-http-location-delivery-16 (work in progress), August&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-geopriv-http-location-delivery-16.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Richard Barnes</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">BBN Technologies</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">9861 Broken Land Pkwy, Suite 400</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Columbia, MD  21046</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 410 290 6169</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:rbarnes@bbn.com">rbarnes@bbn.com</a></td></tr>
</table>
</body></html>
