<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Coupled Multipath-Aware Congestion Control</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Coupled Multipath-Aware Congestion Control">
<meta name="keywords" content="multipath tcp congestion control">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Internet Engineering Task Force</td><td class="header">C. Raiciu</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">M. Handley</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">D. Wischik</td></tr>
<tr><td class="header">Expires: January 7, 2011</td><td class="header">University College London</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">July 06, 2010</td></tr>
</table></td></tr></table>
<h1><br />Coupled Multipath-Aware Congestion Control<br />draft-ietf-mptcp-congestion-00</h1>

<h3>Abstract</h3>

<p>Often endpoints are connected by multiple paths, but communications are 
usually restricted to a single path per connection. Resource usage within the network 
would be more efficient were it possible for these multiple paths to be used concurrently. 
Multipath TCP is a proposal to achieve multipath transport in TCP.
</p>
<p>New congestion control algorithms are needed for multipath transport protocols 
such as Multipath TCP, as single path algorithms have a series of issues in the multipath context. 
One of the prominent problems is that running existing algorithms such 
as TCP New Reno independently on each path would give the multipath flow 
more than its fair share at a bottleneck link traversed by more than one of its subflows. 
Further, it is desirable that 
a source with multiple paths available will transfer more traffic using the least congested of the paths, 
hence achieving resource pooling. This would increase the overall utilization of the network and also its 
robustness to failure.
</p>
<p>This document presents a congestion control algorithm which couples the congestion control
algorithms running on different subflows by linking their increase functions, and dynamically controls 
the overall aggresiveness of the multipath flow. The result is a practical algorithm
that is fair to TCP at bottlenecks while moving traffic away from congested links. 
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on January 7, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Requirements Language<br />
<a href="#sec_intro">2.</a>&nbsp;
Introduction<br />
<a href="#sec_cc">3.</a>&nbsp;
Coupled Congestion Control Algorithm<br />
<a href="#anchor2">4.</a>&nbsp;
Implementation Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec_impl_packet">4.1.</a>&nbsp;
Implementation Considerations when CWND is Expressed in Packets<br />
<a href="#anchor3">5.</a>&nbsp;
Discussion<br />
<a href="#sec_security">6.</a>&nbsp;
Security Considerations<br />
<a href="#Acknowledgements">7.</a>&nbsp;
Acknowledgements<br />
<a href="#IANA">8.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">9.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">9.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">9.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<a name="sec_intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Introduction</h3>

<p>Multipath TCP (MPTCP, <a class='info' href='#I-D.ford-mptcp-multiaddressed'>[I&#8209;D.ford&#8209;mptcp&#8209;multiaddressed]<span> (</span><span class='info'>Ford, A., Raiciu, C., Handley, M., and S. Barre, &ldquo;TCP Extensions for Multipath Operation with Multiple Addresses,&rdquo; July&nbsp;2009.</span><span>)</span></a>) is a set of extensions to regular TCP 
<a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> that allows one TCP connection to be spread across multiple paths. MPTCP distributes load 
through the creation of separate "subflows" across potentially disjoint paths.
</p>
<p>How should congestion control be performed for multipath TCP? First, each subflow must have its own
congestion control state (i.e. cwnd) so that capacity on that path is matched by offered load. 
The simplest way to achieve this goal is to simply run TCP New Reno congestion control <a class='info' href='#RFC5681'>[RFC5681]<span> (</span><span class='info'>Allman, M., Paxson, V., and E. Blanton, &ldquo;TCP Congestion Control,&rdquo; September&nbsp;2009.</span><span>)</span></a> 
on each subflow. However this solution is unsatisfactory as it gives the multipath flow an unfair share
when the paths taken by its different subflows share a common bottleneck.
</p>
<p>Bottleneck fairness is just one requirement multipath congestion control should meet. The 
following three goals capture the desirable properties of a practical multipath congestion control algorithm:
</p>
<ul class="text">
<li>Goal 1 (Improve Throughput) A multipath flow should perform at least as well as a single path flow would on the best 
of the paths available to it. 
</li>
<li>Goal 2 (Do no harm) A multipath flow should not take up more capacity on any one of its paths than if it was a single
path flow using only that route. This guarantees it will not unduly harm other flows. 
</li>
<li>Goal 3 (Balance congestion) A multipath flow should move as much traffic as possible off its most congested paths, 
subject to meeting the first two goals.
</li>
</ul><p>

</p>
<p>Goals 1 and 2 together ensure fairness at the bottleneck. Goal 3 captures the concept of resource pooling 
<a class='info' href='#WISCHIK'>[WISCHIK]<span> (</span><span class='info'>Wischik, D., Handley, M., and M. Bagnulo Braun, &ldquo;The Resource Pooling Principle,&rdquo; October&nbsp;2008.</span><span>)</span></a>: if each multipath flow sends more data through its least congested path, the traffic in the
network will move away from congested areas. This improves robustness and overall throughput, among other things. 
The way to achieve resource pooling is to effectively "couple" the congestion control loops for 
the different subflows. 

</p>
<p>We propose an algorithm that couples only the additive increase function of the subflows,
and uses unmodified TCP New Reno behavior in case of a drop. The algorithm relies on the traditional
TCP mechanisms to detect drops, to retransmit data, etc.
</p>
<p>Detecting shared bottlenecks reliably is quite difficult, but is just one part of a bigger question.
This bigger question is how much bandwidth a multipath user should use in total, even if there is no shared
bottleneck.
</p>
<p>Our solution sets the multipath flow's aggregate bandwidth to be the same bandwidth a regular
TCP flow would get on the best path available to the multipath flow. To estimate the bandwidth of a
regular TCP flow, the multipath flow estimates loss rates and round trip times and computes the target 
rate. Then it adjusts the overall aggresiveness (parameter alpha) to achieve the desired rate. 

</p>
<p>We note that in cases with low statistical multiplexing (where
the multipath flow influences the loss rates on the path) the multipath throughput will be strictly
higher than a single TCP would get on any of the paths. In particular, if using two idle paths, 
multipath throughput will be sum of the two paths' throughput.
</p>
<p>This algorithm ensures bottleneck fairness and fairness in the broader, network sense. 
We acknowledge that current TCP fairness criteria are far from
ideal, but a multipath TCP needs to be deployable in the current 
Internet. If needed, new fairness criteria can be implemented by 
the same algorithm we propose by appropriately scaling the overall aggressiveness.
</p>
<p>It is intended that the algorithm presented here can be applied to other multipath transport protocols, 
such as alternative multipath extensions to TCP, or indeed any other congestion-aware transport protocols. However, 
for the purposes of example this document will, where appropriate, refer to the MPTCP protocol.
</p>
<p>It is foreseeable that different congestion controllers will be implemented for Multipath transport, 
each aiming to achieve different properties in the resource pooling/fairness/stability design space. In 
particular, solutions that give better resource pooling may be proposed. This algorithm is conservative 
from this point of view, sacrificing resource pooling for stability.
</p>
<a name="sec_cc"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Coupled Congestion Control Algorithm</h3>

<p>The algorithm we present only applies to the increase phase of the congestion avoidance 
state specifying how the window inflates upon receiving an ack. 
The slow start, fast retransmit, and fast 
recovery algorithms, as well as the multiplicative decrease of the congestion avoidance state
 are the same as in TCP <a class='info' href='#RFC5681'>[RFC5681]<span> (</span><span class='info'>Allman, M., Paxson, V., and E. Blanton, &ldquo;TCP Congestion Control,&rdquo; September&nbsp;2009.</span><span>)</span></a>.
</p>
<p>Let cwnd_i be the congestion window on the subflow i. Let tot_cwnd be the sum of the congestion windows of all
subflows in the connection.
Let p_i, rtt_i and mss_i be the loss rate, 
round trip time (i.e. smoothed round trip time estimate) 
and maximum segment size on subflow i. 
</p>
<p>We assume throughout this document that the congestion window is maintained 
in bytes, unless otherwise specified. We briefly describe the algorithm for
packet-based implementations of cwnd in section <a class='info' href='#sec_impl_packet'>Section&nbsp;4.1<span> (</span><span class='info'>Implementation Considerations when CWND is Expressed in Packets</span><span>)</span></a>. 

</p>
<p>Our proposed "Linked Increases" algorithm MUST:
</p>
<ul class="text">
<li>For each ack received on subflow i, increase cwnd_i by min (alpha*bytes_acked*mss_i/tot_cwnd , bytes_acked*mss_i/cwnd_i )
</li>
</ul><p>

</p>
<p>The increase formula takes the minimum between the computed increase for the multipath 
subflow (first argument to min), and the increase TCP would get in the same scenario (the second argument).
In this way, we ensure that any multipath subflow cannot be more aggressive than a TCP flow in the same circumstances,
hence achieving goal 2 (do no harm).

</p>
<p>"alpha" is a parameter of the algorithm that describes the aggresiveness of the multipath flow.
To meet Goal 1 (improve throughput), the value of alpha 
is chosen such that the aggregate throughput of the multipath flow is equal to the rate a TCP flow would get if it ran on 
the best path. 
</p>
<p>To get an intuition of what the algorithm is trying to do, let's take the case where all the 
subflows have the same round trip time and MSS. In this case the algorithm will grow the total 
window by approximately alpha*MSS per RTT. 
This increase is distributed to the individual flows according to their instantaneous window size. 
Subflow i will increase by alpha*cwnd_i/tot_cwnd segments per RTT.
</p>
<p>Note that, as in standard TCP, when tot_cwnd is large the increase may be 0. In this case 
the increase MUST be set to 1. We discuss how to implement this formula in 
practice in the next section. 
</p>
<p>We assume appropriate byte counting (ABC, <a class='info' href='#RFC3465'>[RFC3465]<span> (</span><span class='info'>Allman, M., &ldquo;TCP Congestion Control with Appropriate Byte Counting (ABC),&rdquo; February&nbsp;2003.</span><span>)</span></a>) is used, 
hence the bytes_acked variable records the number of bytes newly acknowledged. If ABC is not used, bytes_acked 
SHOULD be set to mss_i.
</p>
<p>To compute tot_cwnd, it is an easy mistake to sum up cwnd_i across all subflows: when a flow is in fast retransmit,
its cwnd is typically inflated and no longer represents the real congestion window. The correct behavior is to use 
the ssthresh value for flows in fast retransmit whe computing tot_cwnd. To cater for connections that are app limited,
the computation should consider the minimum between flight_size_i and cwnd_i, and flight_size_i and ssthresh_i where 
appropriate.

</p>
<p>The total throughput of a multipath flow depends on the value of alpha and the loss rates, maximum segment sizes 
and round trip times of its paths. Since we require
that the total throughput is no worse than the throughput a single TCP would get on the best path, it is 
impossible to choose a-priori a single value of alpha that achieves the desired throughput in every ocasion. Hence, alpha
must be computed for each multipath flow, based on the observed properties of the paths. 
</p>
<p>
The formula to compute alpha is:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
	                                         2
	                           cwnd_i * mss_i
	                      max ---------------
			       i           2
			              rtt_i
	  alpha = tot_cwnd * -------------------------
	                    /      cwnd_i * mss_i \ 2
	                    | sum ----------------|
			    \  i        rtt_i     /

</pre></div>
<p>The formula is derived by equalizing the rate of the multipath flow with the 
rate of a TCP running on the best path, and solving for alpha.

</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Implementation Considerations</h3>

<p>
  The formula for alpha above implies that alpha is a floating point value. This would require 
performing costly floating point operations whenever an ACK is received, Further, in many kernels
floating point operations are disabled. There is an easy way to approximate the above calculations
using integer arithmetic. 

</p>
<p>Let alpha_scale be an integer. When computing alpha, use alpha_scale * tot_cwnd instead of tot_cwnd, and
do all the operations in integer arithmetic. 
</p>
<p>Then, scale down the increase per ack by alpha_scale. The algorithm is:
</p>
<ul class="text">
<li>For each ack received on subflow i, increase cwnd_i by min ( alpha*bytes_acked*mss_i/tot_cwnd/alpha_scale , bytes_acked*mss_i/cwnd_i )
</li>
</ul><p>

</p>
<p>
Observe that the error in computing the numerator or the
denominator in the formula for alpha are quite small, as both the mss and cwnd are typically much larger than the RTT
(measured in ms). Then, alpha scale denotes the precision we want for computing alpha.

</p>
<p>With these two changes, all the operations can now be done using integer arithmetic. We propose alpha_scale be 
a small power of two, to allow using faster shift operations instead of multiplication and division. 
Our experiments show that using alpha_scale=512 works well in a wide range of scenarios. 
Increasing alpha_scale increases precision, but also increases the risk of overflow when computing alpha. 
Using 64bit operations would solve this issue. Another option is to dynamically adjust alpha_scale when 
computing alpha; in this way we avoid overflow and
obtain maximum precision.

</p>
<p>
It is possible to implement our algorithm by calculating tot_cwnd on each ack, however this would be costly
especially when the number of subflows is large. To avoid this overhead the implementation MAY choose to 
 maintain a new per connection state variable called tot_cwnd. If it does so, the implementation will update 
tot_cwnd value whenever the individual subflows' windows are updated.
Updating only requires one more addition 
or subtraction operation compared to the regular, per subflow congestion control code, so its performance impact 
should be minimal. 
</p>
<p>Computing alpha per ack is also costly. We propose alpha be a per connection variable, 
computed whenever there is a drop and once per RTT otherwise. More specifically, let cwnd_new be the
new value of the congestion window after it is inflated or after a drop. 
Update alpha only if cwnd_i/mss_i != cwnd_new_i/mss_i. 

</p>
<p>In certain cases with small RTTs, computing alpha can still be expensive. We observe that if RTTs were constant, 
it is sufficient to compute alpha once per drop, as alpha does not change between drops (the insight here is that 
cwnd_i/cwnd_j = constant as long as both windows increase). Experimental 
results show that even if round trip times are
not constant, using average round trip time instead of instantaneous round trip time 
gives good precision for computing alpha. Hence, it is possible to compute  
alpha only once per drop according to the formula above, by replacing rtt_i with rtt_avg_i. 

</p>
<p>If using average round trip time, rtt_avg_i will be computed by sampling 
the rtt_i whenever the window can accomodate one more packet, i.e.
when cwnd / mss &lt; (cwnd+increase)/mss. The samples are averaged once per sawtooth into rtt_avg_i. 
This sampling ensures that there is no sampling bias for larger windows.
</p>
<p>Given tot_cwnd and alpha, the congestion control algorithm is run for each subflow 
independently, with similar complexity to the standard TCP increase code
<a class='info' href='#RFC5681'>[RFC5681]<span> (</span><span class='info'>Allman, M., Paxson, V., and E. Blanton, &ldquo;TCP Congestion Control,&rdquo; September&nbsp;2009.</span><span>)</span></a>. 
</p>
<a name="sec_impl_packet"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Implementation Considerations when CWND is Expressed in Packets</h3>

<p>When the congestion control algorithm maintains cwnd in packets rather than bytes, 
the code to compute tot_cwnd remains unchanged. 
</p>
<p>To compute the increase when an ack is received, the implementation for multipath
congestion control is a simple extension of the TCP New Reno code.  
In TCP New Reno cwnd_cnt is an additional state variable that tracks the number of 
bytes acked since the last cwnd increment; cwnd is incremented only 
when cwnd_cnt > cwnd; then cwnd_cnt is set to 0. 
</p>
<p>In the multipath case, cwnd_cnt_i is maintained for each 
subflow as above, and cwnd_i is increased by 1 when 
cwnd_cnt_i > alpha_scale * tot_cwnd / alpha . 

</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Discussion</h3>

<p>To achieve perfect resource pooling, one must couple both increase and decrease of congestion windows across subflows,
as in <a class='info' href='#KELLY'>[KELLY]<span> (</span><span class='info'>Kelly, F. and T. Voice, &ldquo;Stability of end-to-end algorithms for joint routing and rate control,&rdquo; 2005.</span><span>)</span></a>. Yet this tends to exhibit "flappiness": when the paths have similar levels of 
congestion, the congestion controller will tend to allocate all the window to one random subflow, and allocate zero window
to the other subflows. The controller will perform random flips between these stable points. This doesn't seem desirable 
in general, and is particularly bad when the achieved rates depend on the RTT (as in the current Internet): in such a case,
the resulting rate with fluctuate unpredictably depending on which state the controller is in, hence violating Goal 1. 
</p>
<p>By only coupling increases our proposal removes flappiness but also reduces the extent of 
resource pooling the protocol achieves.

The algorithm will allocate window to the subflows such that p_i * cwnd_i = constant, for all i. Thus, 
when the loss rates of the subflows are equal, each subflow will get an equal window, removing flappiness.  
When the loss rates differ, progressively more window will be allocated to the flow with the lower loss rate. 
In contrast, perfect resource pooling requires that all the window should be allocated on the path with the lowest
loss rate.

</p>
<a name="sec_security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p>None.
</p>
<p>Detailed security analysis for the Multipath TCP protocol itself is included in <a class='info' href='#I-D.ford-mptcp-multiaddressed'>[I&#8209;D.ford&#8209;mptcp&#8209;multiaddressed]<span> (</span><span class='info'>Ford, A., Raiciu, C., Handley, M., and S. Barre, &ldquo;TCP Extensions for Multipath Operation with Multiple Addresses,&rdquo; July&nbsp;2009.</span><span>)</span></a> and [REF]
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Acknowledgements</h3>

<p>The authors are supported by Trilogy (http://www.trilogy-project.org), a research project (ICT-216372) partially funded by the European Community under its Seventh Framework Program.  The views expressed here are those of the author(s) only.  The European Commission is not liable for any use that may be made of the information in this document.
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>None.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ford-mptcp-multiaddressed">[I-D.ford-mptcp-multiaddressed]</a></td>
<td class="author-text">Ford, A., Raiciu, C., Handley, M., and S. Barre, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ford-mptcp-multiaddressed-01.txt">TCP Extensions for Multipath Operation with Multiple Addresses</a>,&rdquo; draft-ford-mptcp-multiaddressed-01 (work in progress), July&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ford-mptcp-multiaddressed-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="KELLY">[KELLY]</a></td>
<td class="author-text">Kelly, F. and T. Voice, &ldquo;<a href="http://portal.acm.org/citation.cfm?id=1064415">Stability of end-to-end algorithms for joint routing and rate control</a>,&rdquo; ACM SIGCOMM CCR&nbsp;vol. 35 num. 2, pp. 5-12, 2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0793">[RFC0793]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>,&rdquo; STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc793.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3465">[RFC3465]</a></td>
<td class="author-text">Allman, M., &ldquo;<a href="http://tools.ietf.org/html/rfc3465">TCP Congestion Control with Appropriate Byte Counting (ABC)</a>,&rdquo; RFC&nbsp;3465, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3465.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5681">[RFC5681]</a></td>
<td class="author-text">Allman, M., Paxson, V., and E. Blanton, &ldquo;<a href="http://tools.ietf.org/html/rfc5681">TCP Congestion Control</a>,&rdquo; RFC&nbsp;5681, September&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5681.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="WISCHIK">[WISCHIK]</a></td>
<td class="author-text">Wischik, D., Handley, M., and M. Bagnulo Braun, &ldquo;<a href="http://ccr.sigcomm.org/online/files/p47-handleyA4.pdf">The Resource Pooling Principle</a>,&rdquo; ACM SIGCOMM CCR&nbsp;vol. 38 num. 5, pp. 47-52, October&nbsp;2008.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Costin Raiciu</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University College London</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Gower Street</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">London  WC1E 6BT</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:c.raiciu@cs.ucl.ac.uk">c.raiciu@cs.ucl.ac.uk</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mark Handley</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University College London</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Gower Street</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">London  WC1E 6BT</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:m.handley@cs.ucl.ac.uk">m.handley@cs.ucl.ac.uk</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Damon Wischik</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University College London</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Gower Street</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">London  WC1E 6BT</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:d.wischik@cs.ucl.ac.uk">d.wischik@cs.ucl.ac.uk</a></td></tr>
</table>
</body></html>
