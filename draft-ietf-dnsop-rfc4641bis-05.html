<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>DNSSEC Operational Practices, Version 2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="DNSSEC Operational Practices, Version 2">
<meta name="keywords" content="DNSSEC, operational">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">DNSOP</td><td class="header">O. Kolkman</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">NLnet Labs</td></tr>
<tr><td class="header">Obsoletes: <a href='http://tools.ietf.org/html/rfc2541'>2541</a> (if&nbsp;approved)</td><td class="header">October 21, 2010</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">&nbsp;</td></tr>
<tr><td class="header">Expires: April 24, 2011</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />DNSSEC Operational Practices, Version 2<br />draft-ietf-dnsop-rfc4641bis-05</h1>

<h3>Abstract</h3>

<p>
	This document describes a set of practices for operating the
	DNS with security extensions (DNSSEC).  The target audience is
	zone administrators deploying DNSSEC.
      
</p>
<p>
	The document discusses operational aspects of using keys and
	signatures in the DNS. It discusses issues of key generation,
	key storage, signature generation, key rollover, and related
	policies.
      
</p>
<p>
        [When approved] This document obsoletes RFC 4641 as it covers more
        operational ground and gives more up-to-date requirements with
        respect to key sizes and the DNSSEC operations.
      
</p>
<h3>Status of This Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on April 24, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<p>
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
The Use of the Term 'key'<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Time Definitions<br />
<a href="#trustchain">2.</a>&nbsp;
Keeping the Chain of Trust Intact<br />
<a href="#keys">3.</a>&nbsp;
Keys Generation and Storage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#zsk-ksk-motivation">3.1.</a>&nbsp;
Operational Motivation for Zone Signing and Key Signing Keys<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#zsk-ksk-practicalites">3.2.</a>&nbsp;
Practical
						 Consequences of KSK and ZSK Separation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.2.1.</a>&nbsp;
Rolling a KSK that is not a trust-anchor<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rolling-ksk-ta">3.2.2.</a>&nbsp;
Rolling a KSK that is a trust-anchor<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SEP-practicalites">3.2.3.</a>&nbsp;
The use of the SEP flag<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#key_lifetime">3.3.</a>&nbsp;
Key Effectivity Period<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.4.</a>&nbsp;
Cryptographic Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#key algorithm">3.4.1.</a>&nbsp;
Key Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#key sizes">3.4.2.</a>&nbsp;
Key Sizes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.4.3.</a>&nbsp;
Private Key Storage<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.4.4.</a>&nbsp;
Key Generation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.4.5.</a>&nbsp;
Differentiation for 'High-Level' Zones?<br />
<a href="#sigs_keyrolls_policies">4.</a>&nbsp;
Signature Generation, Key Rollover, and Related Policies<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#keyroll">4.1.</a>&nbsp;
Key Rollovers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ZSK-Roll">4.1.1.</a>&nbsp;
Zone Signing Key Rollovers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pre-pub-zsk">4.1.1.1.</a>&nbsp;
Pre-Publish Zone Signing Key Rollover<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dub-sig-zsk">4.1.1.2.</a>&nbsp;
Double Signature Zone Signing Key Rollover<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#zsk-pro-con">4.1.1.3.</a>&nbsp;
Pros and Cons of the Schemes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ksk-rollover">4.1.2.</a>&nbsp;
Key Signing Key Rollovers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#5011KSK">4.1.2.1.</a>&nbsp;
Special Considerations for RFC5011 KSK rollover<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#diff_zsk_ksk">4.1.3.</a>&nbsp;
Difference Between ZSK and KSK Rollovers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#STSrollover">4.1.4.</a>&nbsp;
Rollover for a Single Type Signing Key rollover<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#KAR">4.1.5.</a>&nbsp;
Algorithm rollovers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NSEC-NSEC3">4.1.5.1.</a>&nbsp;
NSEC to NSEC3 algorithm rollover<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SingleTypeAlg">4.1.5.2.</a>&nbsp;
Single Type Signing Scheme Algorithm Rollover<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#5011style">4.1.5.3.</a>&nbsp;
Algorithm rollover, RFC5011 style<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#5011andSingleType">4.1.5.4.</a>&nbsp;
Single Signing Type, RFC5011 style rollovers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#autokeyroll">4.1.6.</a>&nbsp;
Considerations for Automated Key Rollovers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#emergency">4.2.</a>&nbsp;
Planning for Emergency Key Rollover<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.2.1.</a>&nbsp;
KSK Compromise<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.2.1.1.</a>&nbsp;
Keeping the Chain of Trust Intact<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.2.1.2.</a>&nbsp;
Breaking the Chain of Trust<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.2.2.</a>&nbsp;
ZSK Compromise<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.2.3.</a>&nbsp;
Compromises of Keys Anchored in Resolvers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#parents">4.3.</a>&nbsp;
Parent Policies<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.3.1.</a>&nbsp;
Initial Key Exchanges and Parental Policies Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">4.3.2.</a>&nbsp;
Storing Keys or Hashes?<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#lame">4.3.3.</a>&nbsp;
Security Lameness<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DSvalidity">4.3.4.</a>&nbsp;
DS Signature Validity Period<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#changing-operators">4.3.5.</a>&nbsp;
Changing DNS Operators<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#non_cooperating_registrars">4.3.5.1.</a>&nbsp;
Cooperationg DNS operators<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">4.3.5.2.</a>&nbsp;
Non Cooperationg DNS Operators<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#time">4.4.</a>&nbsp;
Time in DNSSEC<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#time_considerations">4.4.1.</a>&nbsp;
Time Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sigval">4.4.2.</a>&nbsp;
Signature Validation Periods<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">4.4.2.1.</a>&nbsp;
Maximum Value<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">4.4.2.2.</a>&nbsp;
Minimum Value<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">4.4.2.3.</a>&nbsp;
Differentiation between RR sets<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">4.4.2.4.</a>&nbsp;
Other timing parameters in a zone<br />
<a href="#nsec_nsec3">5.</a>&nbsp;
Next Record type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">5.1.</a>&nbsp;
Differences between  NSEC and NSEC3<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">5.2.</a>&nbsp;
NSEC or NSEC3<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">5.3.</a>&nbsp;
NSEC3 parameters<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">5.3.1.</a>&nbsp;
NSEC3 Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">5.3.2.</a>&nbsp;
NSEC3 Iterations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">5.3.3.</a>&nbsp;
NSEC3 Salt<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#opt-out">5.3.4.</a>&nbsp;
Opt-out<br />
<a href="#anchor27">6.</a>&nbsp;
Security Considerations<br />
<a href="#anchor28">7.</a>&nbsp;
IANA considerations<br />
<a href="#anchor29">8.</a>&nbsp;
Contributors and Acknowledgments<br />
<a href="#rfc.references1">9.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">9.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">9.2.</a>&nbsp;
Informative References<br />
<a href="#terminology">Appendix&nbsp;A.</a>&nbsp;
Terminology<br />
<a href="#typography">Appendix&nbsp;B.</a>&nbsp;
Typographic Conventions<br />
<a href="#AlgoFigures">Appendix&nbsp;C.</a>&nbsp;
Transition Figures for Special Case Algorithm Rollovers<br />
<a href="#DED">Appendix&nbsp;D.</a>&nbsp;
Document Editing History<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">D.1.</a>&nbsp;
draft-ietf-dnsop-rfc4641-00<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">D.2.</a>&nbsp;
version 0->1<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">D.3.</a>&nbsp;
version 1->2<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">D.4.</a>&nbsp;
version 2->3<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">D.5.</a>&nbsp;
version 3->4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">D.6.</a>&nbsp;
version 4->5<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">D.7.</a>&nbsp;
Subversion infromation<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
    This document describes how to run a DNS Security (DNSSEC)-enabled
    environment. It is intended for operators who have knowledge of
    the DNS (see <a class='info' href='#RFC1034'>RFC 1034<span> (</span><span class='info'>Mockapetris, P., &ldquo;Domain names - concepts and facilities,&rdquo; November&nbsp;1987.</span><span>)</span></a> [1] and <a class='info' href='#RFC1035'>RFC 1035<span> (</span><span class='info'>Mockapetris, P., &ldquo;Domain names - implementation and specification,&rdquo; November&nbsp;1987.</span><span>)</span></a> [2]) and want to deploy DNSSEC (<a class='info' href='#RFC4033'>RFC 4033<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;DNS Security Introduction and Requirements,&rdquo; March&nbsp;2005.</span><span>)</span></a> [3], <a class='info' href='#RFC4034'>RFC
    4034<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Resource Records for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a> [4], and <a class='info' href='#RFC4035'>RFC 4035<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a> [5]). The
    focus of the document is on serving authoritative DNS information
    and is aimed at zone owners, name server operators, registries,
    registrars and registrants. It assumes that there is no direct
    relation between those entities and the operators of validating
    recursive name servers (validators).
  
</p>
<p>
    During workshops and early operational deployment, operators and
    system administrators have gained experience about operating the
    DNS with security extensions (DNSSEC).  This document translates
    these experiences into a set of practices for zone
    administrators. At the time of writing -the root has just been
    signed and the first secure delegations are provisioned- there
    exists relatively little experience with DNSSEC in production
    environments below the TLD level; this document should therefore
    explicitly not be seen as representing 'Best Current Practices'.
    Instead, it describes the decisions that should be made when
    deploying DNSSEC, gives the choices available for each one, and
    provides some operational guidelines The document does not give
    strong recommendations, that may be subject for a future version
    of this document. [OK: This is really a straw-man and causes a
    difference in tone that I believe was the instruction of the WG
    during the IETF 77 meeting. The document could be made much
    shorter when particular recommendations are made? Is there a
    general consensus that we should currently not make particular
    recommendations?]
  
</p>
<p>
    The procedures herein are focused on the maintenance of signed
    zones (i.e., signing and publishing zones on authoritative
    servers). It is intended that maintenance of zones such as
    re-signing or key rollovers be transparent to any verifying
    clients.
  
</p>
<p>
    The structure of this document is as follows. In <a class='info' href='#trustchain'>Section&nbsp;2<span> (</span><span class='info'>Keeping the Chain of Trust Intact</span><span>)</span></a>, we discuss the importance of keeping the
    "chain of trust" intact.  Aspects of key generation and storage of
    keys are discussed in <a class='info' href='#keys'>Section&nbsp;3<span> (</span><span class='info'>Keys Generation and Storage</span><span>)</span></a>; the focus in
    this section is mainly on the security of the private part of the key(s).  <a class='info' href='#sigs_keyrolls_policies'>Section&nbsp;4<span> (</span><span class='info'>Signature Generation, Key Rollover, and Related Policies</span><span>)</span></a> describes considerations
    concerning the public part of the keys. Since these public keys
    appear in the DNS one has to take into account all kinds of timing
    issues, which are discussed in <a class='info' href='#time'>Section&nbsp;4.4<span> (</span><span class='info'>Time in DNSSEC</span><span>)</span></a>. <a class='info' href='#keyroll'>Section&nbsp;4.1<span> (</span><span class='info'>Key Rollovers</span><span>)</span></a> and <a class='info' href='#emergency'>Section&nbsp;4.2<span> (</span><span class='info'>Planning for Emergency Key Rollover</span><span>)</span></a> deal with the
    rollover, or replacement, of keys. Finally, <a class='info' href='#parents'>Section&nbsp;4.3<span> (</span><span class='info'>Parent Policies</span><span>)</span></a> discusses considerations on how parents deal
    with their children's public keys in order to maintain chains of
    trust.
  
</p>
<p>
    The typographic conventions used in this document are explained in
    <a class='info' href='#typography'>Appendix&nbsp;B<span> (</span><span class='info'>Typographic Conventions</span><span>)</span></a>.
  
</p>
<p>
    Since this is a document with operational suggestions and there
    are no protocol specifications, the <a class='info' href='#RFC2119'>RFC
    2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [6] language does not apply.
  
</p>
<p>
    This document [OK: when approved] obsoletes <a class='info' href='#RFC4641'>RFC 4641<span> (</span><span class='info'>Kolkman, O. and R. Gieben, &ldquo;DNSSEC Operational Practices,&rdquo; September&nbsp;2006.</span><span>)</span></a> [14].
  
</p>
<p>
    [OK: Editorial comments and questions are indicated by square
    brackets and editor innitials]
  
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
The Use of the Term 'key'</h3>

<p>
      It is assumed that the reader is familiar with the concept of
      asymmetric keys on which DNSSEC is based (public key
      cryptography <a class='info' href='#RFC4949'>RFC4949<span> (</span><span class='info'>Shirey, R., &ldquo;Internet Security Glossary, Version 2,&rdquo; August&nbsp;2007.</span><span>)</span></a> [15]). Therefore,
      this document will use the term 'key' rather loosely. Where it
      is written that 'a key is used to sign data' it is assumed that
      the reader understands that it is the private part of the key
      pair that is used for signing. It is also assumed that the
      reader understands that the public part of the key pair is
      published in the DNSKEY Resource Record and that it is the
      public part that is used in key exchanges.
    
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Time Definitions</h3>

<p>
      In this document, we will be using a number of time-related
      terms. The following definitions apply:
    
</p>
<p>
      </p>
<ul class="text">
<li>
	  "Signature validity period" The period that a signature is
	  valid.  It starts at the time specified in the signature
	  inception field of the RRSIG RR and ends at the time
	  specified in the expiration field of the RRSIG RR.
	
</li>
<li>
	  "Signature publication period" Time after which a signature
	  (made with a specific key) is replaced with a new signature
	  (made with the same key) or removed. This replacement takes place by
	  publishing the relevant RRSIG in the master zone file.
	  After one stops publishing an RRSIG in a zone, it may take a
	  while before the RRSIG has expired from caches and has
	  actually been removed from the DNS.
	
</li>
<li>
	  "Key effectivity period" The period during which a key pair
	  is expected to be effective. It is defined as the
	  time between the first inception time stamp and the last
	  expiration date of any signature made with this key,
	  regardless of any discontinuity in the use of the key.  The
	  key effectivity period can span multiple signature validity
	  periods.
	
</li>
<li>
	  "Maximum/Minimum Zone Time to Live (TTL)" The maximum or
	  minimum value of the TTLs from the complete set of RRs in a
	  zone. Note that the minimum TTL is not the same as the
	  MINIMUM field in the SOA RR. See <a class='info' href='#RFC2308'>RFC2308<span> (</span><span class='info'>Andrews, M., &ldquo;Negative Caching of DNS Queries (DNS NCACHE),&rdquo; March&nbsp;1998.</span><span>)</span></a> [9]
	  for more information.
	
</li>
</ul><p>
    
</p>
<a name="trustchain"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Keeping the Chain of Trust Intact</h3>

<p>
	Maintaining a valid chain of trust is important because broken
	chains of trust will result in data being marked as Bogus (as
	defined in <a class='info' href='#RFC4033'>RFC4033<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;DNS Security Introduction and Requirements,&rdquo; March&nbsp;2005.</span><span>)</span></a> [3] Section 5),
	which may cause entire (sub)domains to become invisible to
	verifying clients. The administrators of secured zones need to
	realize that to verifying clients their zone is, part of a
	chain of trust.
	
</p>
<p>
	  As mentioned in the introduction, the procedures herein are
	  intended to ensure that maintenance of zones, such as re-signing or
	  key rollovers, will be transparent to the verifying clients on the
	  Internet.
	
</p>
<p>
	Administrators of secured zones will need to keep in mind that data
	published on an authoritative primary server will not be
	immediately seen by verifying clients; it may take some time for
	the data to be transferred to other (secondary) authoritative
	nameservers and clients may be fetching data from caching
	non-authoritative servers. In this light, note that
	the time for a zone transfer from master to slave can be negligible when
        using NOTIFY <a class='info' href='#RFC1996'>[8]<span> (</span><span class='info'>Vixie, P., &ldquo;A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY),&rdquo; August&nbsp;1996.</span><span>)</span></a> and incremental transfer
        (IXFR) <a class='info' href='#RFC1995'>[7]<span> (</span><span class='info'>Ohta, M., &ldquo;Incremental Zone Transfer in DNS,&rdquo; August&nbsp;1996.</span><span>)</span></a>.  It increases when full zone
        transfers (AXFR) are used in combination
        with NOTIFY.  It increases even more if you rely on full zone
        transfers based on only the SOA timing parameters for refresh.
	
</p>
<p>
	  For the verifying clients, it is important that data from
	  secured zones can be used to build chains of trust
	  regardless of whether the data came directly from an
	  authoritative server, a caching nameserver, or some middle
	  box. Only by carefully using the available timing parameters
	  can a zone administrator ensure that the data necessary for
	  verification can be obtained.
	
</p>
<p>
	  The responsibility for maintaining the chain of trust is
	  shared by administrators of secured zones in the chain of
	  trust.  This is most obvious in the case of a 'key
	  compromise' when a trade-off must be made  between maintaining a valid
	  chain of trust and replacing the compromised keys as soon as
	  possible.  Then zone administrators will have
	  to decide, between keeping the chain of trust
	  intact - thereby allowing for attacks with the compromised
	  key - or deliberately breaking the chain of trust and making
	  secured subdomains invisible to security-aware
	  resolvers. (Also see <a class='info' href='#emergency'>Section&nbsp;4.2<span> (</span><span class='info'>Planning for Emergency Key Rollover</span><span>)</span></a>.)

	
</p>
<a name="keys"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Keys Generation and Storage</h3>

<p>
    This section describes a number of considerations with respect to
    the use of keys. For the design of a operational procedure for key
    generation and storage the a number of decisions need to be made:
    </p>
<ul class="text">
<li>
	Does one differentiate between Zone Signing and Key Signing
	Keys or is the use of one type of key sufficient?
      
</li>
<li>
	Are Key Signing Keys (likely to be) in use as Trust Anchors?
      
</li>
<li>
	What are the timing parameters that are allowed by the
	operational requirements?
      
</li>
<li>
	What are the cryptographic parameters that fit the operational
	need?
      
</li>
</ul><p>
    The following section discusses  the considerations that need to be taken into account
    when making those choices.
  
</p>
<a name="zsk-ksk-motivation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Operational Motivation for Zone Signing and Key Signing Keys</h3>

<p>
      The DNSSEC validation protocol does not distinguish between
      different types of DNSKEYs. The motivations to differentiate
      between keys are purely operational; validators will not make a
      distinction.
    
</p>
<p>
      For operational reasons, described below, it is possible to
      designate one or more keys as Key Signing Keys (KSKs). These
      keys will only sign the apex DNSKEY RRSet in a zone. Other keys
      can be used to sign all the RRSets in a zone that require
      signatures. They are referred to as Zone Signing Keys (ZSKs). In
      case the differentiation between KSK and ZSK is not made we talk
      about a Single Type signing scheme.
    
</p>
<p>
      If the two functions are separated then, for almost any method
      of key management and zone signing, the KSK is used less
      frequently than the ZSK. Once a key set is signed with the KSK,
      all the keys in the key set can be used as ZSKs.  If there has
      been an event that increases the risk that a ZSK is compromised
      it can be simply dropped from the key set. The new key set is
      then re-signed with the KSK.
    
</p>
<p>
      Changing a key that is a a secure entry point (SEP) for a zone
      can be relatively expensive as it involves interaction with 3rd
      parties: When a key is only pointed to by a DS record in the
      parent zone, one needs to complete the interaction with the
      responsible registry and wait for the updated DS record to
      appear in the DNS.  In the case where a key is configured as a
      trust-anchor one has to wait until one has sufficient confidence
      that all trust anchors have been replaced. In fact, it may be
      that one is not able to reach the complete user-base with
      information about the key rollover.
    
</p>
<p>
      There is also a risk that keys are compromised through theft or
      loss. For keys that are installed on file-systems of nameservers
      that are connected to the network (e.g. for dynamic updates)
      that risk is relatively high. Where keys are stored on Hardware
      Security Modules (HSMs) or stored off-line, such risk is
      relatively low. By separating the KSK and ZSK functionality
      these risks can be managed while making the tradeoff against the
      costs involved. For example, a KSK can be stored off-line or
      with more limitation on access control than ZSKs which need to
      be readily available for operational purposes such as the
      addition or deletion of zone data. For example, a KSK stored on
      a smartcard, that is kept in a safe, combined with a ZSK stored
      on a filesystem accessible by operators for daily routine may
      provide more operational flexibility and higher computational
      performance than a single key (with combined KSK and ZSK
      functionality) stored on an HSM.
    
</p>
<p>
      Finally there is a risk of cryptanalysis of the key material.
      The costs of such analysis are correlated to the length of the
      key. However, cryptanalysis arguments provide no strong
      motivation for a KSK/ZSK split. Suppose one differentiates
      between a KSK and a ZSK whereby the KSK effectivity period is X
      times the ZSK effectivity period. Then, in order for the
      resistance to cryptanalysis to be the same for the KSK and the
      ZSK, the KSK needs to be X times stronger than the ZSK. Since
      for all practical purposes X will somewhere of the order of 10
      to 100, the associated key sizes will vary only about a byte in
      size for symmetric keys. When translated to asymmetric keys, is
      still too insignificant a size difference to warrant a
      key-split; it only marginally affects the r packet size and
      signing speed.
    
</p>
<p>
      The arguments for differentiation between the ZSK and KSK are
      weakest when:
      </p>
<ul class="text">
<li>
	  the exposure to risk is low (e.g. when keys are stored on
	  HSMs);
	
</li>
<li>
	  one can be certain that a key is not used as a
	  trust-anchor; 
	
</li>
<li>
	  maintenance of the various keys cannot be performed
	  through tools (is prone to human error); and
	
</li>
<li> 
	  the interaction through the registrar-registry
	  provisioning chain -- in particular the timely appearance
	  of a new DS record in the parent zone in emergency
	  situations -- is predictable.
	
</li>
</ul><p>
      If the above holds then the costs of the operational
      complexity of a KSK-ZSK split may outweigh the costs of
      operational flexibility and choosing  a single type signing
      scheme is a reasonable option. In other cases we advise
      that the separation between KSKs and ZSKs is made and that the
      SEP flag is exclusively set on KSKs.
    
</p>
<a name="zsk-ksk-practicalites"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Practical
						 Consequences of KSK and ZSK Separation</h3>

<p>
      Given the assumption that for KSKs the SEP flag is set, the
      KSK can be distinguished from a ZSK by examining the flag
      field in the DNSKEY RR: If the flag field is an odd number the RR
      is a KSK; otherwise it is a ZSK.
    
</p>
<p>
      The Zone Signing Key can be used to sign all the data in
      a zone on a regular basis. When a Zone Signing Key is to be
      rolled, no interaction with the parent is needed.  This
      allows for signature validity periods on the order
      of days.
    
</p>
<p>
      The Key Signing Key is only to be used to sign the DNSKEY RRs
      in a zone. If a Key Signing Key is to be rolled, there will be
      interactions with parties other than the zone administrator.
      If there is a parent zone, these can include the registry of
      the parent zone or administrators of verifying resolvers that
      have the particular key configured as secure entry points. In
      the latter case, everyone relying on the trust anchor needs to
      roll over to the new key, a process that may be subject to
      stability costs if automated trust-anchor rollover mechanisms
      (such as e.g. <a class='info' href='#RFC5011'>RFC5011<span> (</span><span class='info'>StJohns, M., &ldquo;Automated Updates of DNS Security (DNSSEC) Trust Anchors,&rdquo; September&nbsp;2007.</span><span>)</span></a> [16]) are not
      in place.  Hence, the key effectivity period of these keys can
      and should be made much longer.
    
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
Rolling a KSK that is not a trust-anchor</h3>

<p>
	There are 3 schools of thought on rolling a KSK that is not a
	trust anchor:
	</p>
<ul class="text">
<li> 
	    It should be done frequently and regularly (possibly every
	    few months) so that a key rollover remains an operational
	    routine.
	  
</li>
<li> 
	    It should be done frequently but irregularly. Frequently
	    meaning every few months, again based on the argument that
	    a rollover is a practiced and common operational
	    routine, and irregular meaning with a large jitter, so that
	    3rd parties do not start to rely on the key and will not
	    be tempted to configure it as a trust-anchor.
	  
</li>
<li>
	    It should only be done when it is known or strongly
	    suspected that the key can be or has been compromised.
	    
	  
</li>
</ul><p>
	There is no widespread agreement on which of these three
	schools of thought is better for different deployments of
	DNSSEC.  There is a stability cost every time a non-anchor KSK
	is rolled over, but it is possibly low if the communication
	between the child and the parent is good.  On the other hand,
	the only completely effective way to tell if the communication
	is good is to test it periodically.  Thus, rolling a KSK with
	a parent is only done for two reasons: to test and verify the
	rolling system to prepare for an emergency, and in the case of
	(preventing) an actual emergency.
      
</p>
<p>      
	Finally, in most cases a zone owner cannot be fully certain
	that the zone's KSK is not in use as a trust-anchor
	somewhere. While the configuration of trust-anchors is not the
	responsibility of the zone owner there may be stability costs
	for the validator administrator that (wrongfully) configured
	the trust-anchor when the zone owner roles a KSK.
      
</p>
<a name="rolling-ksk-ta"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
Rolling a KSK that is a trust-anchor</h3>

<p>
	The same operational concerns apply to the rollover of KSKs
	that are used as trust-anchors: if a trust anchor replacement
	is done incorrectly, the entire domain that the trust anchor
	covers will become bogus until the trust anchor is corrected.
      
</p>
<p>
	In a large number of cases it will be safe to work from the
	assumption that one's keys are not in use as trust-anchors. If
	a zone owner publishes a "DNSSEC Signing Policy and Practice
	Statement" <a class='info' href='#I-D.ietf-dnsop-dnssec-dps-framework'>[25]<span> (</span><span class='info'>Ljunggren, F., Eklund-Lowinder, A., and T. Okubo, &ldquo;DNSSEC Policy &amp; Practice Statement Framework,&rdquo; July&nbsp;2010.</span><span>)</span></a> that should be explicit about the fact whether the
	existence of trust anchors will be taken into account in any
	way or not. There may be cases where local policies enforce
	the configuration of trust-anchors on zones which are mission
	critical (e.g. in enterprises where the trust-anchor for the
	enterprise domain is configured in the enterprise's validator)
	It is expected that the zone owners are aware of such
	circumstances.
      
</p>
<p>
	One can argue that because of the difficulty of getting all
	users of a trust anchor to replace an old trust anchor with a
	new one, a KSK that is a trust anchor should never be rolled
	unless it is known or strongly suspected that the key has been
	compromised.  In other words the costs of a KSK rollover are
	prohibitively high because some users cannot be reached.
      
</p>
<p>
	However, the "operational habit" argument also applies to
	trust anchor reconfiguration at the clients' validators. If a
	short key effectivity period is used and the trust anchor
	configuration has to be revisited on a regular basis, the odds
	that the configuration tends to be forgotten is smaller. In
	fact, the costs for those users can be minimized by automating
	the rollover <a class='info' href='#RFC5011'>RFC5011<span> (</span><span class='info'>StJohns, M., &ldquo;Automated Updates of DNS Security (DNSSEC) Trust Anchors,&rdquo; September&nbsp;2007.</span><span>)</span></a> [16] and by
	rolling the key regularly (and advertising such) so that the
	operators of recursive nameservers will put the appropriate
	mechanism in place to deal with these stability costs, or, in
	other words, budget for these costs instead of incurring them
	unexpectedly.
      
</p>
<p>
	It is therefore recommended, to roll KSKs that are likely to
	be used as trust-anchors, on a regular basis if and only if
	those rollovers can be tracked using standardized
	(e.g. RFC5011) mechanisms.
      
</p>
<a name="SEP-practicalites"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.3"></a><h3>3.2.3.&nbsp;
The use of the SEP flag</h3>

<p>
	The so-called Secure Entry Point (SEP) <a class='info' href='#RFC4035'>[5]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a>
	flag can be used to distinguish between keys that are intended
	to be used as the secure entry point into the zone when building
	chains of trust, e.g they are (to be) pointed to by parental DS
	RRs or configured as a trust-anchor.
      
</p>
<p>
	While the SEP flag does not play any role in the failure it is
	used in practice for operational purposes such as for the
	rollover mechanism described in <a class='info' href='#RFC5011'>RFC5011<span> (</span><span class='info'>StJohns, M., &ldquo;Automated Updates of DNS Security (DNSSEC) Trust Anchors,&rdquo; September&nbsp;2007.</span><span>)</span></a> [16]. The common convention is to
	set the SEP flag on any key that is used for key exchanges
	with the parent and/or potentially used for configuration as a
	trust anchor. Therefore it is recommended that the SEP flag is
	set on KSKs and not on ZSKs, while in those cases where a
	distinction between KSK and ZSK is not made (i.e. for a Single
	Type signing scheme) it is recommended that the SEP flag is
	set on all keys.
      
</p>
<p>
	Note that signing tools may assume a KSK/ZSK split and use the
	(non) presence of the SEP flag to determine which key is to be
	used for signing zone data; these tools may get confused when
	a single type signing scheme is used.	
      
</p>
<a name="key_lifetime"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Key Effectivity Period</h3>

<p> 
      In general the available key length sets an upper limit on the
      Key Effectivity Period. For all practical purposes it is
      sufficient to define the Key Effectivity Period based on purely
      operational requirements and match the key length to that value.
      Ignoring the operational perspective, a reasonable effectivity
      period for KSKs that have corresponding DS records in the parent
      zone is of the order of 2 decades or longer.  That is, if one
      does not plan to test the rollover procedure, the key should be
      effective essentially forever, and only rolled over in case of
      emergency.
    
</p>
<p>
      When one chooses for a regular key-rollover, a reasonable key
      effectivity period for KSKs that have a parent zone is 13
      months, with the intent to replace them after 12 months. As
      argued above, this annual rollover gives operational practice of
      rollovers for both the zone and validator
      administrators. Besides, in most environments a year is a
      time-span that is easily planned and communicated.
    
</p>
<p>
      Where keys are stored on on-line systems and the exposure to
      various threats of compromise is fairly high, an intended key
      effectivity period of a month is reasonable for Zone Signing
      Keys.
    
</p>
<p>
      Although key effectivity periods can be made very short -as in a few
      minutes-  when replacing keys one has to take into account the
      considerations from <a class='info' href='#time'>Section&nbsp;4.4<span> (</span><span class='info'>Time in DNSSEC</span><span>)</span></a> and <a class='info' href='#keyroll'>Section&nbsp;4.1<span> (</span><span class='info'>Key Rollovers</span><span>)</span></a>.
    
</p>
<p>
      The motivation for having the ZSK's effectivity period shorter
      than the KSK's effectivity period is rooted in the operational
      consideration that it is more likely that operators have more
      frequent read access to the ZSK than to the KSK. If ZSK's are
      maintained on cryptographic Hardware Security Modules (HSM) than
      the motivation to have different key effectivity periods is
      weakend.
    
</p>
<p>
     In fact, if the risk of loss, theft or other compromise is the
     same for a zone and key signing key there is little reason to
     choose different effectivity periods for ZSKs and KSKs. And when
     the split between ZSKs and KSKs is not made, the argument is
     redundant.
    
</p>
<p>
      There are certainly cases (e.g. where the the costs and risk of
      compromise, and the costs and risks involved with having to
      perform an emergency roll are also low) that the use of a single
      type signing scheme with a long key effectivity period is a good
      choice.
    
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Cryptographic Considerations</h3>

<a name="key algorithm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
Key Algorithm</h3>

<p>
	There are currently two types of signature algorithms that can
	be used in DNSSEC: RSA and DSA. Both are fully specified in many
	freely-available documents, and both are widely considered to be
	patent-free. The creation of signatures with RSA and DSA takes
	roughly the same time, but DSA is about ten times slower for
	signature verification.
      
</p>
<p>
	We suggest the use of RSA/SHA-256 as the preferred signature
	algorithms and RSA/SHA-1 as an alternative.  Both have
	advantages and disadvantages.  RSA/SHA-1 has been deployed for
	many years, while RSA/SHA-256 has only begun to be deployed.
	On the other hand, it is expected that if effective attacks on
	either algorithm appear, they will appear for RSA/SHA-1
	first.  RSA/MD5 should not be considered for use because
	RSA/MD5 will very likely be the first common-use signature
	algorithm to have an effective attack.
      
</p>
<p>
	At the time of publication, it is known that the SHA-1 hash
	has cryptanalysis issues and work is in progress on addressing
	them. We recommend the use of public key algorithms based on
	hashes stronger than SHA-1 (e.g., SHA-256) as soon as these
	algorithms are available in implementations (see <a class='info' href='#RFC5702'>RFC5702<span> (</span><span class='info'>Jansen, J., &ldquo;Use of SHA-2 Algorithms with RSA in DNSKEY and RRSIG Resource Records for DNSSEC,&rdquo; October&nbsp;2009.</span><span>)</span></a> [23] and <a class='info' href='#RFC4509'>RFC4509<span> (</span><span class='info'>Hardaker, W., &ldquo;Use of SHA-256 in DNSSEC Delegation Signer (DS) Resource Records (RRs),&rdquo; May&nbsp;2006.</span><span>)</span></a> [20]).
      
</p>
<a name="key sizes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
Key Sizes</h3>

<p>
	DNSSEC signing keys should be large enough to avoid all known
	cryptographic attacks during the effectivity period of the key.  To date,
	despite huge efforts, no one has broken a regular 1024-bit key;
	in fact, the best completed attack is estimated to be the
	equivalent of a 700-bit key.  An attacker breaking a 1024-bit
	signing key would need to expend phenomenal amounts of networked
	computing power in a way that would not be detected in order to
	break a single key.  Because of this, it is estimated that most
	zones can safely use 1024-bit keys for at least the next ten
	years. (A 1024-bit asymmetric key has an approximate equivalent
	strength of a symmetric 80-bit key.)
      
</p>
<p>
	Owners of keys that are used as extremely high value trust
	anchors, or non-anchor keys that may be difficult to roll
	over, may want to use lengths longer than 1024 bits.
	Typically, the next larger key size used is 2048 bits, which
	has the approximate equivalent strength of a symmetric 112-bit
	key (e.g. <a class='info' href='#RFC3766'>RFC3766<span> (</span><span class='info'>Orman, H. and P. Hoffman, &ldquo;Determining Strengths For Public Keys Used For Exchanging Symmetric Keys,&rdquo; April&nbsp;2004.</span><span>)</span></a> [12]). In a standard
	CPU, it takes about four times as long to sign or verify with
	a 2048-bit key as it does with a 1024-bit key.
      
</p>
<p>
	Another way to decide on the size of key to use is to remember
	that the effort it takes for an attacker to break a
	1024-bit key is the same regardless of how the key is used.  If
	an attacker has the capability of breaking a 1024-bit DNSSEC
	key, he also has the capability of breaking one of the many
	1024-bit TLS trust anchor keys that are currently installed in web
	browsers.  If the value of a DNSSEC key is lower to the attacker
	than the value of a TLS trust anchor, the attacker will use the
	resources to attack the latter.
      
</p>
<p>
	It is possible that there will be an unexpected improvement in the
	ability for attackers to break keys, and that such an attack
	would make it feasible to break 1024-bit keys but not 2048-bit
	keys.  If such an improvement happens, it is likely that there
	will be a huge amount of publicity, particularly because of the
	large number of 1024-bit TLS trust anchors build into popular
	web browsers. At that time, all 1024-bit keys (both ones with
	parent zones and ones that are trust anchors) can be rolled over
	and replaced with larger keys.
      
</p>
<p>
	Earlier documents (including the previous version of this
	document) urged the use of longer keys in situations where a
	particular key was "heavily used".  That advice may have been
	true 15 years ago, but it is not true today when using RSA or
	DSA algorithms and keys of 1024 bits or higher.
      
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3"></a><h3>3.4.3.&nbsp;
Private Key Storage</h3>

<p>
	It is recommended that, where possible, zone private keys and
	the zone file master copy that is to be signed be kept and used
	in off-line, non-network-connected, physically secure machines
	only.  Periodically, an application can be run to add
	authentication to a zone by adding RRSIG and NSEC/NSEC3 RRs.  Then the
	augmented file can be transferred.
      
</p>
<p>
	When relying on dynamic update <a class='info' href='#RFC3007'>[10]<span> (</span><span class='info'>Wellington, B., &ldquo;Secure Domain Name System (DNS) Dynamic Update,&rdquo; November&nbsp;2000.</span><span>)</span></a> to
	manage a signed zone, be aware that at least one private key
	of the zone will have to reside on the master server (or
	reside on an HSM to which the server has access).  This key is
	only as secure as the amount of exposure the server receives
	to unknown clients and the security of the host.  Although not
	mandatory, one could administer a zone using a "hidden master"
	scheme that minimize the risk. In this arrangement the master
	that processes the dynamic updates is unavailable from general
	hosts on the Internet; it is not listed in the NS RRSet,
	although its name appears in the SOA RRs MNAME field.  The
	nameservers in the NS RRSet are able to receive zone updates
	through IXFR, AXFR, or an out-of-band distribution mechanism,
	possibly in combination with NOTIFY or another mechanism to
	trigger zone replication.
      
</p>
<p>
	The ideal situation is to have a one-way information flow to
	the network to avoid the possibility of tampering from the
	network.  Keeping the zone master on-line on the network
	and simply cycling it through an off-line signer does not do
	this.  The on-line version could still be tampered with if the
	host it resides on is compromised.  For maximum security, the
	master copy of the zone file should be off-net and should not
	be updated based on an unsecured network mediated
	communication.
      
</p>
<p>
	The ideal situation may not be achievable because of economic
	tradeoffs between risks and costs.  For instance, keeping a
	zone file off-line is not practical and will increase the
	costs of operating a DNS zone. So in practice the machines on
	which zone files are maintained will be connected to a
	network. Operators are advised to take security measures to
	shield unauthorized access to the master copy in order to
	prevent modification of DNS data before its signed.
      
</p>
<p>
	Similarly the choice for storing a private key in a HSM will
	be influenced by a tradeoff between various concerns:
      
	</p>
<ul class="text">
<li> 
	    The risks that an unauthorized person has unnoticed
	    read-access to the private key
	  
</li>
<li>
	    The remaining window of opportunity for the attacker.
	  
</li>
<li>
	    The economic impact of the possible attacks (for a TLD
	    that impact will typically be higher than for an
	    individual users).
	  
</li>
<li>
	    The costs of rolling the (compromised) keys. (The
	    costs of roling a ZSK is lowest and the costs of rolling a
	    KSK that is in wide use as a trust anchor is highest.)
	  
</li>
<li>
	    The costs of buying and maintaining an HSM.
	  
</li>
</ul><p>
	
	
      
</p>
<p>
	For dynamically updated secured zones <a class='info' href='#RFC3007'>[10]<span> (</span><span class='info'>Wellington, B., &ldquo;Secure Domain Name System (DNS) Dynamic Update,&rdquo; November&nbsp;2000.</span><span>)</span></a>, both the master copy and the private key
	that is used to update signatures on updated RRs will need to
	be on-line.
      
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4"></a><h3>3.4.4.&nbsp;
Key Generation</h3>

<p>
	Careful generation of all keys is a sometimes overlooked but
	is an absolutely essential element in any cryptographically
	secure system.  The strongest algorithms used with the longest
	keys are still of no use if an adversary can guess enough to
	lower the size of the likely key space so that it can be
	exhaustively searched.  Technical suggestions for the
	generation of random keys will be found in <a class='info' href='#RFC4086'>RFC 4086<span> (</span><span class='info'>Eastlake, D., Schiller, J., and S. Crocker, &ldquo;Randomness Requirements for Security,&rdquo; June&nbsp;2005.</span><span>)</span></a> [13] and <a class='info' href='#NIST-SP-800-90'>NIST SP 800-900<span> (</span><span class='info'>Barker, E. and J. Kelsey, &ldquo;Recommendation for Random Number Generation Using 	    Deterministic Random Bit Generators (Revised),&rdquo; March&nbsp;2007.</span><span>)</span></a> [19]. In particular,
	one should carefully assess whether the random number
	generator used during key generation adheres to these
	suggestions.
      
</p>
<p>
	Keys with a long effectivity period are particularly sensitive
	as they will represent a more valuable target and be subject
	to attack for a longer time than short-period keys.  It is
	strongly recommended that long-term key generation occur
	off-line in a manner isolated from the network via an air gap
	or, at a minimum, high-level secure hardware.
      
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5"></a><h3>3.4.5.&nbsp;
Differentiation for 'High-Level' Zones?</h3>

<p>
	In an earlier version of this document (<a class='info' href='#RFC4641'>RFC4641<span> (</span><span class='info'>Kolkman, O. and R. Gieben, &ldquo;DNSSEC Operational Practices,&rdquo; September&nbsp;2006.</span><span>)</span></a> [14]) we made a differentiation
	between key lengths for  KSKs used for zones that are high in the DNS hierarchy
	and those for KSKs used low down.
      
</p>
<p>
	This distinction is now considered not relevant. Longer key
	lengths for keys higher in te hierarchy are not useful because
	the cryptographic guidance is that everyone should use keys that
	no one can break. Also, it is impossible to judge which zones
	are more or less valuable to an attacker. An attack can only
	take place if the key compromise goes unnoticed and the attacker
	can act as a man-in-the-middle (MITM). For example if example.com is
	compromised and the attacker forges answers for
	somebank.example.com. and sends them out during an MITM, when the attack
	is discovered it will be simple to prove that example.com has been
	compromised and the KSK will be rolled.  Designing  a long-term
	successful attack is difficult for keys at any level.
      
</p>
<a name="sigs_keyrolls_policies"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Signature Generation, Key Rollover, and Related Policies</h3>

<a name="keyroll"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Key Rollovers</h3>

<p>
	Regardless of whether a zone uses periodic key rollovers in
	order to practice for emergencies, or only rolls over keys in
	an emergency, key rollovers are a fact of life when using
	DNSSEC.  Zone administrators who are in the process of rolling
	their keys have to take into account that data published in
	previous versions of their zone still lives in caches. When
	deploying DNSSEC, this becomes an important consideration;
	ignoring data that may be in caches may lead to loss of
	service for clients.
      
</p>
<p>
	The most pressing example of this occurs when zone material
	signed with an old key is being validated by a resolver that
	does not have the old zone key cached. If the old key is no
	longer present in the current zone, this validation fails,
	marking the data "Bogus".  Alternatively, an attempt could be
	made to validate data that is signed with a new key against an
	old key that lives in a local cache, also resulting in data
	being marked "Bogus".
      
</p>
<a name="ZSK-Roll"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
Zone Signing Key Rollovers</h3>

<p>
	  If the choice for splitting zone and key signing keys has
	  been made than those two types of keys can be rolled
	  separately and zone signing keys can be rolled without taking
	  into account DS records from the parent or the configuration
	  of such a key as trust-anchor.
	
</p>
<p> 
	  For "Zone Signing Key rollovers", there are two ways to make
	  sure that during the rollover data still cached can be
	  verified with the new key sets or newly generated signatures
	  can be verified with the keys still in caches. One schema,
	  described in <a class='info' href='#dub-sig-zsk'>Section&nbsp;4.1.1.2<span> (</span><span class='info'>Double Signature Zone Signing Key Rollover</span><span>)</span></a>, uses double
	  signatures; the other uses key pre-publication (<a class='info' href='#pre-pub-zsk'>Section&nbsp;4.1.1.1<span> (</span><span class='info'>Pre-Publish Zone Signing Key Rollover</span><span>)</span></a>). The pros, cons, and
	  recommendations are described in <a class='info' href='#zsk-pro-con'>Section&nbsp;4.1.1.3<span> (</span><span class='info'>Pros and Cons of the Schemes</span><span>)</span></a>.
	
</p>
<a name="pre-pub-zsk"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1.1"></a><h3>4.1.1.1.&nbsp;
Pre-Publish Zone Signing Key Rollover</h3>

<p>
	    This section shows how to perform a ZSK rollover without
	    the need to sign all the data in a zone twice -- the
	    "pre-publish key rollover". This method has advantages in
	    the case of a key compromise. If the old key is
	    compromised, the new key has already been distributed in
	    the DNS. The zone administrator is then able to quickly
	    switch to the new key and remove the compromised key from
	    the zone.  Another major advantage is that the zone size
	    does not double, as is the case with the double signature
	    ZSK rollover.
	  
</p>
<p>
	    <br /><hr class="insert" />
<a name="pre-publish-key-rollover-fig"></a>

<p>
		Pre-publish key rollover involves four stages as follows:
	      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 ----------------------------------------------------------
  initial            new DNSKEY          new RRSIGs
 ----------------------------------------------------------
  SOA0               SOA1                SOA2
  RRSIG_Z_10(SOA)    RRSIG_Z_10(SOA)     RRSIG_Z_11(SOA)

  DNSKEY_K_1         DNSKEY_K_1          DNSKEY_K_1
  DNSKEY_Z_10        DNSKEY_Z_10         DNSKEY_Z_10
                     DNSKEY_Z_11         DNSKEY_Z_11
  RRSIG_K_1(DNSKEY)  RRSIG_K_1(DNSKEY)   RRSIG_K_1(DNSKEY)
  RRSIG_Z_10(DNSKEY) RRSIG_Z_10(DNSKEY)  RRSIG_Z_11(DNSKEY)
 ------------------------------------------------------------

 ------------------------------------------------------------
   DNSKEY removal
 ------------------------------------------------------------
  SOA3
  RRSIG_Z_11(SOA)

  DNSKEY_K_1
  DNSKEY_Z_11

  RRSIG_K_1(DNSKEY)
  RRSIG_Z_11(DNSKEY)
 ------------------------------------------------------------

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Pre-Publish Key Rollover&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

	  

<p>
	    </p>
<blockquote class="text"><dl>
<dt>initial:</dt>
<dd> Initial version of the zone: DNSKEY_K_1
	      is the Key Signing Key. DNSKEY_Z_10 is used to sign all
	      the data of the zone, the Zone Signing Key.
	      
</dd>
<dt>new DNSKEY:</dt>
<dd> DNSKEY_Z_11 is introduced into
	      the key set. Note that no signatures are generated with
	      this key yet, but this does not secure against brute
	      force attacks on the public key.  The minimum duration
	      of this pre-roll phase is the time it takes for the
	      data to propagate to the authoritative servers plus
	      TTL value of the key set.
	      
	      
</dd>
<dt>new RRSIGs:</dt>
<dd> At the "new RRSIGs" stage (SOA serial
	      2), DNSKEY_Z_11 is used to sign the data in the zone
	      exclusively  (i.e., all the signatures from DNSKEY_Z_10 are
	      removed from the zone). DNSKEY_Z_10 remains published in
	      the key set. This way data that was loaded into caches
	      from version 1 of the zone can still be verified with
	      key sets fetched from version 2 of the zone.
	      The minimum time that the key set including DNSKEY_Z_10
	      is to be published is the time that it takes for
	      zone data from the previous version of the zone to
	      expire from old caches, i.e., the time it takes for
	      this zone to propagate to all authoritative servers
	      plus the Maximum Zone TTL value of any of the data
	      in the previous version of the zone.
	      
</dd>
<dt>DNSKEY removal:</dt>
<dd> DNSKEY_Z_10 is removed from the
	      zone. The key set, now only containing DNSKEY_K_1 and
	      DNSKEY_Z_11, is re-signed with the DNSKEY_K_1 and DNSKEY_Z_11.

	      
</dd>
</dl></blockquote><p>
	  
</p>
<p> The above scheme can be simplified by always
	  publishing the "future" key immediately after the rollover.
	  The scheme would look as follows (we show two rollovers); the
	  future key is introduced in "new DNSKEY" as DNSKEY_Z_12 and again
	  a newer one, numbered 13, in "new DNSKEY (II)":

	  
</p>
<p>

	    <br /><hr class="insert" />
<a name="Pre-publish-two-rolovers-fig"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    initial             new RRSIGs          new DNSKEY
   -----------------------------------------------------------------
    SOA0                SOA1                SOA2
    RRSIG_Z_10(SOA)     RRSIG_Z_11(SOA)     RRSIG_Z_11(SOA)

    DNSKEY_K_1          DNSKEY_K_1          DNSKEY_K_1
    DNSKEY_Z_10         DNSKEY_Z_10         DNSKEY_Z_11
    DNSKEY_Z_11         DNSKEY_Z_11         DNSKEY_Z_12
    RRSIG_K_1(DNSKEY)   RRSIG_K_1 (DNSKEY)  RRSIG_K_1(DNSKEY)
    RRSIG_Z_10(DNSKEY)  RRSIG_Z_11(DNSKEY)  RRSIG_Z_11(DNSKEY)
    ----------------------------------------------------------------

    ----------------------------------------------------------------
    new RRSIGs (II)        new DNSKEY (II)
    ----------------------------------------------------------------
    SOA3                   SOA4
    RRSIG_Z_12(SOA)        RRSIG_Z_12(SOA)

    DNSKEY_K_1             DNSKEY_K_1
    DNSKEY_Z_11            DNSKEY_Z_12
    DNSKEY_Z_12            DNSKEY_Z_13
    RRSIG_K_1(DNSKEY)      RRSIG_K_1(DNSKEY)
    RRSIG_Z_12(DNSKEY)     RRSIG_Z_12(DNSKEY)
    ----------------------------------------------------------------

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Pre-Publish Zone Signing Key Rollover, Showing Two Rollovers&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

	  

<p> 
	    Note that the key introduced in the "new DNSKEY" phase is not
	    used for production yet; the private key can thus be
	    stored in a physically secure manner and does not need to
	    be 'fetched' every time a zone needs to be signed.
	    
	  
</p>
<a name="dub-sig-zsk"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1.2"></a><h3>4.1.1.2.&nbsp;
Double Signature Zone Signing Key Rollover</h3>

<p>This section shows how to perform a ZSK key rollover
	    using the double zone data signature scheme, aptly named
	    "double signature rollover".
	    
</p>
<p>During the "new DNSKEY" stage the new version of the zone
	    file will need to propagate to all authoritative servers
	    and the data that exists in (distant) caches will need to
	    expire, requiring at least the Maximum Zone TTL.

	    
</p><br /><hr class="insert" />
<a name="double-sig-zsk-roll-fig"></a>

<p>

        Double signature ZSK rollover involves three stages
        as follows:

            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   ----------------------------------------------------------------
   initial             new DNSKEY         DNSKEY removal
   ----------------------------------------------------------------
   SOA0                SOA1               SOA2
   RRSIG_Z_10(SOA)     RRSIG_Z_10(SOA)    RRSIG_Z_11(SOA)
                       RRSIG_Z_11(SOA)
   DNSKEY_K_1          DNSKEY_K_1         DNSKEY_K_1
   DNSKEY_Z_10         DNSKEY_Z_10        DNSKEY_Z_11
                       DNSKEY_Z_11
   RRSIG_K_1(DNSKEY)   RRSIG_K_1(DNSKEY)  RRSIG_K_1(DNSKEY)
   RRSIG_Z_10(DNSKEY)  RRSIG_Z_10(DNSKEY) RRSIG_Z_11(DNSKEY)
                       RRSIG_Z_11(DNSKEY)
   ----------------------------------------------------------------

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Double Signature Zone Signing Key Rollover
&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p></p>
<blockquote class="text"><dl>
<dt>initial:</dt>
<dd> Initial Version
	    of the zone: DNSKEY_K_1 is the Key Signing Key. DNSKEY_Z_10 is used
	    to sign all the data of the zone, the
	    Zone Signing Key.
	    
</dd>
<dt>new DNSKEY:</dt>
<dd> At the "New DNSKEY" stage (SOA
	    serial 1) DNSKEY_Z_11 is introduced into the key set and
	    all the data in the zone is signed with DNSKEY_Z_10 and
	    DNSKEY_Z_11. The rollover period will need to continue
	    until all data from version 0 of the zone has expired from
	    remote caches. This will take at least the Maximum Zone
	    TTL of version 0 of the zone.

	    
</dd>
<dt>DNSKEY removal:</dt>
<dd> DNSKEY_Z_10 is removed from the
	    zone. All the signatures from DNSKEY_Z_10 are removed from
	    the zone. The key set, now only containing DNSKEY_Z_11, is
	    re-signed with DNSKEY_K_1 and DNSKEY_Z_11.
</dd>
</dl></blockquote><p>

	    
</p>
<p> At every instance, RRSIGs from the previous version of
	    the zone can be verified with the DNSKEY RRSet from the
	    current version and the other way around. The data from
	    the current version can be verified with the data from the
	    previous version of the zone. The duration of the "new DNSKEY"
	    phase and the period between rollovers should be at least
	    the Maximum Zone TTL.

	    
</p>
<p>Making sure that the "new DNSKEY" phase lasts until the
	    signature expiration time of the data in the initial version  of the
	    zone is recommended. This way all caches are cleared of the old
	    signatures.  However, this duration could be
	    considerably longer than the Maximum Zone TTL, making the
	    rollover a lengthy procedure.
	    
</p>
<p>Note that in this example we assumed that the zone was
	    not modified during the rollover. New data can be
	    introduced in the zone as long as it is signed with both
	    keys.
	    
</p>
<a name="zsk-pro-con"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1.3"></a><h3>4.1.1.3.&nbsp;
Pros and Cons of the Schemes</h3>

<p>
	      </p>
<blockquote class="text"><dl>
<dt>Pre-publish key rollover:</dt>
<dd>
		  This rollover does not involve signing the zone data
		  twice. Instead, before the actual rollover, the
		  new key is published in the key set and thus is
		  available for cryptanalysis attacks. A small
		  disadvantage is that this process requires four
		  steps. Also the pre-publish scheme involves more
		  parental work when used for KSK rollovers as
		  explained in <a class='info' href='#diff_zsk_ksk'>Section&nbsp;4.1.3<span> (</span><span class='info'>Difference Between ZSK and KSK Rollovers</span><span>)</span></a>.
		
</dd>
<dt>Double signature ZSK rollover:</dt>
<dd>
		  The drawback of this signing scheme is that during the
		  rollover the number of signatures in your zone doubles;
		  this may be prohibitive if you have very big zones. An
		  advantage is that it only requires three steps.

		
</dd>
</dl></blockquote><p>
	    
</p>
<a name="ksk-rollover"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Key Signing Key Rollovers</h3>

<p> 
	    For the rollover of a Key Signing Key, the same
	    considerations as for the rollover of a Zone Signing Key
	    apply. However, we can use a double signature scheme to
	    guarantee that old data (only the apex key set) in caches
	    can be verified with a new key set and vice versa.  Since
	    only the key set is signed with a KSK, zone size
	    considerations do not apply.
	  
</p>
<p>
	    <br /><hr class="insert" />
<a name="double-sig-ksk-roll-fig"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
---------------------------------------------------------------------
 initial           new DNSKEY         DS change    DNSKEY removal
---------------------------------------------------------------------
Parent:
 SOA0              --------&gt;          SOA1            --------&gt;
 RRSIG_par(SOA)    --------&gt;          RRSIG_par(SOA)  --------&gt;
 DS_K_1            --------&gt;          DS_K_2          --------&gt;
 RRSIG_par(DS)     --------&gt;          RRSIG_par(DS)   --------&gt;



Child:
 SOA0               SOA1               --------&gt;   SOA2
 RRSIG_Z_10(SOA)    RRSIG_Z_10(SOA)    --------&gt;   RRSIG_Z_10(SOA)
                                       --------&gt;
 DNSKEY_K_1         DNSKEY_K_1         --------&gt;   DNSKEY_K_2
                    DNSKEY_K_2         --------&gt;
 DNSKEY_Z_10        DNSKEY_Z_10        --------&gt;   DNSKEY_Z_10
 RRSIG_K_1(DNSKEY)  RRSIG_K_1 (DNSKEY) --------&gt;   RRSIG_K_2(DNSKEY)
                    RRSIG_K_2 (DNSKEY) --------&gt;
 RRSIG_Z_10(DNSKEY) RRSIG_Z_10(DNSKEY) --------&gt;   RRSIG_Z_10(DNSKEY)
---------------------------------------------------------------------
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Stages of Deployment for a Double Signature Key 
							    Signing Key Rollover&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

	  

<p>
	    </p>
<blockquote class="text"><dl>
<dt>initial:</dt>
<dd>
		Initial version of the zone.  The parental DS points
		to DNSKEY_K_1. Before the rollover starts, the child
		will have to verify what the TTL is of the DS RR that
		points to DNSKEY_K_1 -- it is needed during the
		rollover and we refer to the value as TTL_DS.
	      
</dd>
<dt>new DNSKEY:</dt>
<dd>
		During the "new DNSKEY" phase, the zone administrator
		generates a second KSK, DNSKEY_K_2. The key is provided
		to the parent, and the child will have to wait until a
		new DS RR has been generated that points to
		DNSKEY_K_2. After that DS RR has been published on all
		servers authoritative for the parent's zone, the zone
		administrator has to wait at least TTL_DS to make sure
		that the old DS RR has expired from caches.
	  
</dd>
<dt>DS change:</dt>
<dd> 
	    The parent replaces DS_K_1 with DS_K_2.
          
</dd>
<dt>DNSKEY removal:</dt>
<dd> 
	    DNSKEY_K_1 has been removed.
	  
</dd>
</dl></blockquote><p>
	  
</p>
<p>
	    The scenario above puts the responsibility for maintaining
	    a valid chain of trust with the child. It also is based on
	    the premise that the parent only has one DS RR (per
	    algorithm) per zone.  An alternative mechanism has been
	    considered.  Using an established trust relation, the
	    interaction can be performed in-band, and the removal of
	    the keys by the child can possibly be signaled by the
	    parent. In this mechanism, there are periods where there
	    are two DS RRs at the parent. Since at the moment of
	    writing the protocol for this interaction has not been
	    developed, further discussion is out of scope for this
	    document.
	  
</p>
<a name="5011KSK"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2.1"></a><h3>4.1.2.1.&nbsp;
Special Considerations for RFC5011 KSK rollover</h3>

<p>
	    The scenario sketched above assumes that the KSK is not in
	    use as a trust-anchor too but that validating nameservers
	    exclusively depend on the parental DS record to establish
	    the zone's security. If it is known that validating
	    nameservers have configured trust-anchors then such needs
	    to be taken into account. Here we assume that operators of
	    zones will deploy <a class='info' href='#RFC5011'>RFC5011<span> (</span><span class='info'>StJohns, M., &ldquo;Automated Updates of DNS Security (DNSSEC) Trust Anchors,&rdquo; September&nbsp;2007.</span><span>)</span></a> [16]
	    style rollovers.
	  
</p>
<p>
	    RFC5011 style rollovers increase the duration of key
	    rollovers: the key to be removed must first be
	    revoked. Thus, before the DNSKEY_K_1 removal phase,
	    DNSKEY_K_1 must be published for one more Maximum Zone TTL
	    with the REVOKE bit set. The revoked key must be
	    self-signed, so in this phase the DNSKEY RRset must also
	    be signed with DNSKEY_K_1.
	  
</p>
<a name="diff_zsk_ksk"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.3"></a><h3>4.1.3.&nbsp;
Difference Between ZSK and KSK Rollovers</h3>

<p> Note that KSK rollovers and ZSK rollovers are different in the
	sense that a KSK rollover requires interaction with the parent (and
	possibly replacing of trust anchors) and the ensuing delay while waiting
	for it.
	
</p>
<p>
	  A zone key
	  rollover can be handled in two different ways: pre-publish (<a class='info' href='#pre-pub-zsk'>Section&nbsp;4.1.1.1<span> (</span><span class='info'>Pre-Publish Zone Signing Key Rollover</span><span>)</span></a>) and double signature (<a class='info' href='#dub-sig-zsk'>Section&nbsp;4.1.1.2<span> (</span><span class='info'>Double Signature Zone Signing Key Rollover</span><span>)</span></a>).
	
</p>
<p>
	  As the KSK is used to validate the key set and because the
	  KSK is not changed during a ZSK rollover, a cache is able to
	  validate the new key set of the zone.  The pre-publish
	  method would also work for a KSK rollover. The records that are to
	  be pre-published are the parental DS RRs.
	The pre-publish method has some drawbacks for KSKs. We first describe the
	rollover scheme and then indicate these drawbacks.
        
</p><br /><hr class="insert" />
<a name="pre-pubkish-ksk-roll-fig"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
--------------------------------------------------------------------
  initial         new DS           new DNSKEY      DS/DNSKEY removal
--------------------------------------------------------------------
Parent:
  SOA0              SOA1             --------&gt;        SOA2
  RRSIG_par(SOA)    RRSIG_par(SOA)   --------&gt;        RRSIG_par(SOA)
  DS_K_1            DS_K_1           --------&gt;        DS_K_2
                    DS_K_2           --------&gt;
  RRSIGpar(DS)      RRSIG_par(DS)    --------&gt;        RRSIG_par(DS)

Child:
  SOA0               --------&gt;     SOA1               SOA1
  RRSIG_Z_10(SOA)    --------&gt;     RRSIG_Z_10(SOA)    RRSIG_Z_10(SOA)
                     --------&gt;
  DNSKEY_K_1         --------&gt;     DNSKEY_K_2         DNSKEY_K_2
                     --------&gt;
  DNSKEY_Z_10        --------&gt;     DNSKEY_Z_10        DNSKEY_Z_10
  RRSIG_K_1 (DNSKEY) --------&gt;     RRSIG_K_2(DNSKEY)  RRSIG2 (DNSKEY)
  RRSIG_Z_10(DNSKEY) --------&gt;     RRSIG_Z_10(DNSKEY) RRSIG10(DNSKEY)
--------------------------------------------------------------------

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Stages of Deployment for a Pre-Publish Key Signing Key
            Rollover&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
	  When the child zone wants to roll, it notifies the
	  parent during the "new DS" phase and submits the new key (or
	  the corresponding DS) to the parent.
	  The parent publishes DS_K_1 and DS_K_2, pointing to
	  DNSKEY_K_1 and DNSKEY_K_2, respectively. During the rollover ("new DNSKEY"
          phase), which
	  can take place as soon as the new DS set propagated through
	  the DNS, the child replaces DNSKEY_K_1 with
   	  DNSKEY2. Immediately after that ("DS/DNSKEY removal" phase),
          it can notify the parent that the old DS record can be deleted.
	
</p>
<p> 
	  The drawbacks of this scheme are that during the
	  "new DS" phase the parent cannot verify the match between the
	  DS_K_2 RR and DNSKEY_K_2 using the DNS -- as DNSKEY_K_2 is not
	  yet published. Besides, we introduce a
	  "security lame" key (see <a class='info' href='#lame'>Section&nbsp;4.3.3<span> (</span><span class='info'>Security Lameness</span><span>)</span></a>). Finally, the
	  child-parent interaction consists of two steps. The "double
	  signature" method only needs one interaction.
	  
	
</p>
<a name="STSrollover"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.4"></a><h3>4.1.4.&nbsp;
Rollover for a Single Type Signing Key rollover</h3>

<p>
	  The rollover of a DNSKEY when a Single Type Signing scheme
	  is used is subject to the same requirement as the rollover
	  of a KSK or ZSK: During any stage of the rollover the chain
	  of trust needs to continue to validate for any combination
	  of data in the zone as well as data that may still live in
	  distant caches.
	
</p>
<p>
	  There are two variants for this rollover. Since the choice
	  for a Single Type Signing scheme is motivated by operational
	  simplicity we first describe the most straightforward
	  rollover scheme first.
	
</p><br /><hr class="insert" />
<a name="single-type-roll-fig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  ----------------------------------------------------------------
  initial           new DNSKEY       DS change     DNSKEY removal
  ----------------------------------------------------------------
Parent:
  SOA0             --------&gt;        SOA1            --------&gt;
  RRSIG_par(SOA)   --------&gt;        RRSIG_par(SOA)  --------&gt;
  DS1              --------&gt;        DS2             --------&gt;
  RRSIG_par(DS)    --------&gt;        RRSIG_par(DS)   --------&gt;

Child:
  SOA0              SOA1              ------------&gt; SOA2
  RRSIG_S_1(SOA)    RRSIG_S_1(SOA)    ------------&gt; RRSIG_S_2(SOA)
                    RRSIG_S_2(SOA1)   ------------&gt;
  DNSKEY_S_1        DNSKEY_S_1        ------------&gt; DNSKEY_S_2
                    DNSKEY_S_2        ------------&gt;
  RRSIG_S_1(DNSKEY) RRSIG_S_1(DNSKEY) ------------&gt; RRSIG_S_2(DNSKEY)
                    RRSIG_S_2(DNSKEY) ------------&gt;
  -----------------------------------------------------------------
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Stages of the Straightforward rollover in a Single Type Signing scheme&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
	    </p>
<blockquote class="text"><dl>
<dt>initial:</dt>
<dd>
		Parental DS points to DNSKEY_K_1. All RR sets in the zone are signed with DNSKEY_K_1.
	      
</dd>
<dt>new DNSKEY:</dt>
<dd>
		A new key (DNSKEY_K_2) is introduced and all the RR sets are signed with both DNSKEY_K_1 and DNSKEY_K_2.
	      
</dd>
<dt>DS change:</dt>
<dd>
		After the DNSKEY RRset with the two keys had time to
		propagate into distant caches (that is the key set
		exclusively containing DNSKEY_K_1 has been expired) the
		parental DS record can be changed.
	      
</dd>
<dt>DNSKEY removal:</dt>
<dd>
		After the DS RRset containing DS_K_1 has expired from
		distant caches DNSKEY_K_1 can be removed from the DNSKEY
		RRset .
	      
</dd>
</dl></blockquote><p>
	  
</p>
<p>
	    There is a second variety of this rollover during which
	    one introduces a new DNSKEY into the key set and signs the
	    keyset with both keys while signing the zone data with
	    only the original DNSKEY_K_1. One replaces the DNSKEY_K_1
	    signatures with signatures made with DNSKEY_K_2 at the moment
	    of DNSKEY_K_1 removal.
	  
</p>
<p>
	    The second variety of this rollover can be considered when
	    zone size considerations prevent the introduction of
	    double signatures over all of the zone data although in
	    that case choosing for a KSK/ZSK split may be a better
	    option.
	  
</p>
<p>
	    A double DS rollover scheme is compatible with a rollover
	    using a Single Type signing scheme although in order to
	    maintain a valid chain of trust the zone data would need
	    to be published with a double signatures or a double key
	    key set would need to be published. Since this leads to
	    increase in zone and packet size at both child and parent
	    there are little benefits to a double DS rollover with a
	    Single Type signing scheme.
	  
</p>
<a name="KAR"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.5"></a><h3>4.1.5.&nbsp;
Algorithm rollovers</h3>

<p>
	A special class of key rollover is the one needed for a change
	of key algorithms (either adding a new algorithm, removing an
	old algorithm, or both). Additional steps are needed to retain
	integrity during this rollover. We first describe the generic
	case, special considerations for rollovers that involve
	trust-anchors, single type keys, and rollovers from NSEC to
	NSEC3 are discussed below.
      
</p>
<p>
	Because of the algorithm downgrade protection in RFC4035 section 2.2,
	you may not have a key of an algorithm for which you do not have
	signatures, and you may not have a DS record in the parent zone of an
	algorithm for which you don't have a corresponding key in the zone
	apex.
      
</p>
<p>
	When adding a new algorithm, the signatures should be added
	first.  After the TTL of RRSIGS has expired, and caches have
	dropped the old data covered by those signatures, the DNSKEY
	with the new algorithm can be added.

      
</p>
<p>
	After the new algorithm has been added, the DS record can be
	exchanged using Double Signature Key Rollover.  You cannot use
	Pre-publish key rollover method when you do key algorithm rollover.
      
</p>
<p>
	When removing an old algorithm, the DNSKEY should be removed first,
	but only after the DS for the old algorithm was removed from the
	parent zone.
      
</p>
<p>
	The following figure describes the steps. Whereby the trailing
	underscored number indicates the algorithm and ZSK and KSK
	indicate the obvious difference in key use. For example
	DNSKEY_KSK_1 is a the DNSKEY RR representing the public part
	of the old key signing key of algorithm type 1 while
	RRSIG_ZSK_2(SOA3) is the RRSIG RR made with the private part
	of the new zone signing key of algorithm type 2 over a SOA RR (that
	has serial number 3). It is assumed that the key that signes
	the SOA RR also signes all other non-DNSKEY RRset data.
      
</p><br /><hr class="insert" />
<a name="alg-rollover-fig"></a>

<p>
	  
	
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
----------------------------------------------------------------
1 Initial            2 New RRSIGS         3 New DNSKEY
----------------------------------------------------------------
Parent:
 SOA0                 -------------- ( SOA ) --------------&gt;
 RRSIG_par(SOA)       -------------------------------------&gt;
 DS_K_1               -------------------------------------&gt;
 RRSIG_par(DS_K_1)    -------------------------------------&gt;

Child:
 SOA0                 SOA1                 SOA2
 RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)
                      RRSIG_Z_2(SOA)       RRSIG_Z_2(SOA)

 DNSKEY_K_1           DNSKEY_K_1           DNSKEY_K_1
 DNSKEY_Z_1           DNSKEY_Z_1           DNSKEY_Z_1
 RRSIG_K_1(DNSKEY)    RRSIG_K_1(DNSKEY)    DNSKEY_K_2
                      RRSIG_K_2(DNSKEY)    DNSKEY_Z_2
                                           RRSIG_K_1(DNSKEY)
                                           RRSIG_K_2(DNSKEY)
----------------------------------------------------------------
4 Exchange DS         5 Remove DNSKEY      6 Remove RRSIGS
----------------------------------------------------------------
Parent:
 SOA1                 -------------( SOA )----------------&gt;
 RRSIG_par(SOA)       -------------------------------------&gt;
 DS_K_2               -------------------------------------&gt;
 RRSIG_par(DS_K_2)    -------------------------------------&gt;

Child:
 ---- (SOA2 ) ---&gt;    SOA3                 SOA4
 ----------------&gt;    RRSIG_Z_1(SOA3)      RRSIG_Z_2(SOA4)
 ----------------&gt;    RRSIG_Z_2(SOA3)

 ----------------&gt;    DNSKEY_K_2           DNSKEY_K_2
 ----------------&gt;    DNSKEY_Z_2           DNSKEY_Z_2
 ----------------&gt;    RRSIG_K_1(DNSKEY)    RRSIG_K_2(DNSKEY)
 ----------------&gt;    RRSIG_K_2(DNSKEY)
----------------------------------------------------------------

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Stages of Deployment during an Algorithm Rollover&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
	Step 1 describes state of the zone before any transition is done.
	Number of the keys may vary, but the algorithm of keys in the zone is
	same for all DNSKEY records.
      
</p>
<p>
	Step 2: the signatures made with the new key over all
	records in the zone are added, but the key itself is not.
	This includes the signature for the DNSKEY rrset.  While in
	theory, the signatures of the keyset should always be
	synchronized with the keyset itself, it can be possible that
	RRSIGS are requested separately, so it is prudent to also sign
	the DNSKEY set with the new signature.
      
</p>
<p>
	This step is needed to propagate the signatures created with
	the new algorithm to the caches. If you do not do that, it
	might happen that the resolver picks up the new DNSKEY RRset
	(with the new algorithm included), but still have the old list
	of signatures stored.
      
</p>
<p>
	Step 3: After the cache data has expired, the new key can be
	added to the zone.
      
</p>
<p>
	Step 4: After the cache data for the DNSKEY has expired, the
	DS record for the new key can be added to the parent zone and
	the DS record for the old key can be removed in the same step.
      
</p>
<p>
	Step 5: After the cache data for the DS has expired, the old
	algorithm can be removed.  This time the key needs to be
	removed first, before removing the signatures.  The key is
	removed in this step , and after the cache data for the DNSKEY has
	expired, the signatures can also be removed during this step.
      
</p>
<p>
	Below we deal with a few special cases of algorithm rollovers.
	</p>
<blockquote class="text"><dl>
<dt>1: NSEC to NSEC3</dt>
<dd>: the case where one wants to
	  roll algorithm in order to deploy NSEC3 instead of NSEC
	  (<a class='info' href='#NSEC-NSEC3'>Section&nbsp;4.1.5.1<span> (</span><span class='info'>NSEC to NSEC3 algorithm rollover</span><span>)</span></a>).
</dd>
<dt>2: Single Type Signing Scheme Algorithm
	  Rollover</dt>
<dd>: when you have chosen not to differentiate
	  between Zone and Key signing keys (<a class='info' href='#SingleTypeAlg'>Section&nbsp;4.1.5.2<span> (</span><span class='info'>Single Type Signing Scheme Algorithm Rollover</span><span>)</span></a>) 
</dd>
<dt>3: RFC5011</dt>
<dd>: when trust-anchors can track the
	  roll via RFC5011 style rollover (<a class='info' href='#5011style'>Section&nbsp;4.1.5.3<span> (</span><span class='info'>Algorithm rollover, RFC5011 style</span><span>)</span></a>
</dd>
<dt>4: 2 and 3 combined</dt>
<dd>: when a Single Type
	  Signing Scheme is rolled via RFC5011 (<a class='info' href='#5011andSingleType'>Section&nbsp;4.1.5.4<span> (</span><span class='info'>Single Signing Type, RFC5011 style rollovers</span><span>)</span></a>)
</dd>
</dl></blockquote><p>
	In addition to the narrative below these special cases are represented in the figures in <a class='info' href='#AlgoFigures'>Appendix&nbsp;C<span> (</span><span class='info'>Transition Figures for Special Case Algorithm Rollovers</span><span>)</span></a>.
      
</p>
<a name="NSEC-NSEC3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.5.1"></a><h3>4.1.5.1.&nbsp;
NSEC to NSEC3 algorithm rollover</h3>

<p>
	A special case is the rollover from an NSEC signed zone to an
	NSEC3 signed zone. In this case algorithm numbers are used to
	signal support for NSEC3 but they do not mandate the use of
	NSEC3. Therefore NSEC records should remain in the zone until
	the rollover to a new algorithm has completed and the new
	DNSKEY RR set has populated distant caches(at least one TTL
	into stage 4, or at any time during stage 5). At that point
	the validators that have not implemented NSEC3 will treat the
	zone as unsecured as soon as they follow the chain of trust to
	DS that points to a DNSKEY of the new algorithm while
	validators that support NSEC3 will happily validate using
	NSEC. Turning on NSEC3 can then be done when changing from
	zone serial number, realizing that that involves a resigning
	of the zone and the introduction of the NSECPARAM record in
	order to signal authoritative servers to start serving NSEC3
	authenticated denial of existence.
	
      
</p>
<p>
	Summarizing, an NSEC to NSEC3 rollover is an ordinary algorithm
	rollover whereby NSEC is used all the time and only after that
	rollover finished NSEC3 needs to be deployed.
      
</p>
<a name="SingleTypeAlg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.5.2"></a><h3>4.1.5.2.&nbsp;
Single Type Signing Scheme Algorithm Rollover</h3>

<p>
	  If one key is used that acts both as ZSK and KSK, the same
	  scheme and figure as above applies whereby all DNSKEY_Z_*
	  records from the table are removed and all RRSIG_Z_* are
	  replaced with RRSIG_K_*. The requirement to sign with both
	  algorithms and make sure that old RRSIGS had the opportunity
	  to expire from distant caches before introducing the new
	  algorithm in the DNSKEY RRset still holds.
	
</p>
<p> 
	  Also see <a class='info' href='#single-type-algorithm-roll-fig'>Figure&nbsp;11<span> (</span><span class='info'>Single Type Signing Scheme Algorithm Roll</span><span>)</span></a> in <a class='info' href='#AlgoFigures'>Appendix&nbsp;C<span> (</span><span class='info'>Transition Figures for Special Case Algorithm Rollovers</span><span>)</span></a>.
	
</p>
<a name="5011style"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.5.3"></a><h3>4.1.5.3.&nbsp;
Algorithm rollover, RFC5011 style</h3>

<p>
	  Trust anchor algorithm rollover is as simple as a regular
	  RFC5011 based rollover. However, the old trust anchor must
	  be revoked before it is removed from the zone.
	
</p>
<p>
	  Take a look at the <a class='info' href='#alg-rollover-fig'>Figure&nbsp;7<span> (</span><span class='info'>Stages of Deployment during an Algorithm Rollover</span><span>)</span></a> above.
	  After Step 4 (Exchange DS) we need an additional step 4a
	  whereby the DNSKEY is revoked (Revoke DNSKEY):
	
</p><br /><hr class="insert" />
<a name="revoke-key-fig"></a>

<p>
	    
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
---------------------------------
4b Revoke DNSKEY
---------------------------------
Parent:
-----------(SOA)-------------&gt;
-----------------------------&gt;
-----------------------------&gt;
-----------------------------&gt;

Child:
SOA3
RRSIG_Z_1(SOA3)
RRSIG_Z_2(SOA3)

DNSKEY_K_1_REVOKED
DNSKEY_Z_1
DNSKEY_K_2
DNSKEY_Z_2
RRSIG_K_1_REVOKED(DNSKEY)
RRSIG_K_2(DNSKEY)
--------------------------------
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8: The Revoke DNSKEY state that is added to an algorithm
	    rollover when RFC5011 is in use.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p> 
	  Also see <a class='info' href='#5011-algorithm-roll-fig'>Figure&nbsp;12<span> (</span><span class='info'>RFC5011 Style algorithm roll</span><span>)</span></a> in <a class='info' href='#AlgoFigures'>Appendix&nbsp;C<span> (</span><span class='info'>Transition Figures for Special Case Algorithm Rollovers</span><span>)</span></a>.
	
</p>
<a name="5011andSingleType"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.5.4"></a><h3>4.1.5.4.&nbsp;
Single Signing Type, RFC5011 style rollovers</h3>

<p>
	  Combining Single Signing Type and RFC5011 style rollovers is
	  not trivial. 
	
</p>
<p>
	  Should you choose to perform an RFC5011 style rollover with a Single Signing Type key then remember that
	  section .1, RFC 5011 states:
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    Once the resolver sees the REVOKE bit, it MUST NOT use this key
    as a trust anchor or for any other purpose except to validate
    the RRSIG it signed over the DNSKEY RRSet specifically for the
    purpose of validating the revocation.

</pre></div><p>


          This means that if you revoke DNSKEY_KSK_1, it cannot be
          used to validate its signatures over non-DNSKEY
          RRsets. Thus, those RRsets should be signed with a shadow
          key, DNSKEY_ZSK_1, during the algorithm rollover.  This
          shadow key can be introduced at the same time the signatures
          are pre-published, in step 2 (new RRSIGs). The shadow key
          must be removed at the same time the revoked KSK_1 is
          removed from the zone. De-facto you temporarily falling back
          to a zone and key signing key model.
	
</p>
<p>
	  In other words, the rule that at every RRset there must be
	  at least one signature for each algorithm used in the DNSKEY
	  RRset still applies. This means that a different key with
	  the same algorithm, other than the revoked key, must sign
	  the entire zone. This can be the ZSK. More operations is
	  needed if the single type signing scheme is used. Before
	  rolling the algorithm, a new key must be introduced with the
	  same algorithm as the key that is candidate for
	  revocation. That key can than temporarily act as ZSK during
	  the algorithm rollover.
	
</p>
<p>
	  There is one exception to the rule above. While all zone
	  data must be signed with an unrevoked key, it is permissable
	  to sign the keyset with a revoked key. The somewhat esoteric
	  argument follows.
	
</p>
<p>
	  Resolvers that do not understand the RFC5011 Revoke flag
	  will handle DNSKEY_K_1_REVOKED the same as a new key
	  DNSKEY_K_*. The identity of the public key is partly
	  determined by the flag field and by setting REVOKE the
	  identity changed. Resolvers that implement RFC5011
	  will remove DNSKEY_K_1 from the set of trust anchors. That
	  is okay, since they have already added DNSKEY_K_2 as the new
	  trust anchor. Thus, algorithm 2 is the only signaled
	  algorithm by now. That means, we only need RRSIG_K_2(DNSKEY)
	  to authenticate the DNSKEY RRset, and we still are compliant
	  with section 2.2 from RFC 4035: There must be a RRSIG for
	  each RRset using at least one DNSKEY of each algorithm in
	  the zone apex DNSKEY RRset.
      
</p>
<p>
	The lesson of all of this is that a Single Type Signing
	scheme algorithm rolover using RFC5011 is as
	complicated as the name of the rollover implies, one is better off
	explicitly using a slit key temporarily.
      
</p>
<p> 
	  Also see <a class='info' href='#5011-algorithm-roll-fig'>Figure&nbsp;12<span> (</span><span class='info'>RFC5011 Style algorithm roll</span><span>)</span></a> in <a class='info' href='#AlgoFigures'>Appendix&nbsp;C<span> (</span><span class='info'>Transition Figures for Special Case Algorithm Rollovers</span><span>)</span></a>.
	
</p>
<a name="autokeyroll"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.6"></a><h3>4.1.6.&nbsp;
Considerations for Automated Key Rollovers</h3>

<p>
	    As keys must be renewed periodically, there is some
	    motivation to automate the rollover process. Consider the
	    following:
	  
</p>
<p>
	    </p>
<ul class="text">
<li>
		ZSK rollovers are easy to automate as only the child
		zone is involved.
	      
</li>
<li>
		A KSK rollover needs interaction between parent and
		child.  Data exchange is needed to provide the new
		keys to the parent; consequently, this data must be
		authenticated and integrity must be guaranteed in
		order to avoid attacks on the rollover.
	      
</li>
</ul><p>
	  
</p>
<a name="emergency"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Planning for Emergency Key Rollover</h3>

<p>
	  This section deals with preparation for a possible key
	  compromise. Our advice is to have a documented procedure
	  ready for when a key compromise is suspected or confirmed.
	
</p>
<p> 
	  When the private material of one of your keys is compromised
	  it can be used for as long as a valid trust chain exists.  A
	  trust chain remains intact for
	  </p>
<ul class="text">
<li> 
	      as long as a signature over the compromised key in the
	      trust chain is valid,
	    
</li>
<li> 
	      as long as the DS RR in the parent zone points to the
	      compromised key,
	    
</li>
<li> 
	      as long as the key is anchored in a resolver and is used
	      as a starting point for validation (this is generally
	      the hardest to update).
	  
</li>
</ul><p>
	
	
	
</p>
<p>
	  While a trust chain to your compromised key exists, your
	  namespace is vulnerable to abuse by anyone who has obtained
	  illegitimate possession of the key. Zone operators have to
	  make a trade-off if the abuse of the compromised key is
	  worse than having data in caches that cannot be
	  validated. If the zone operator chooses to break the trust
	  chain to the compromised key, data in caches signed with
	  this key cannot be validated. However, if the zone
	  administrator chooses to take the path of a regular
	  rollover, during the rollover the the malicious key holder
	  can continue to spoof data so that it appears to be valid.
	
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
KSK Compromise</h3>

<p> 
	    A zone containing a DNSKEY RRSet with a compromised KSK is
	    vulnerable as long as the compromised KSK is configured as
	    trust anchor or a DS record in the parent zone points to it.
	  
</p>
<p> 
	    A compromised KSK can be used to sign the key set of an
	    attacker's zone. That zone could be used to poison the
	    DNS.
	   
</p>
<p>
	     Therefore, when the KSK has been compromised, the trust
	     anchor or the parent DS record should be replaced as soon as
	     possible. It is local policy whether to break the trust
	     chain during the emergency rollover. The trust chain
	     would be broken when the compromised KSK is removed from
	     the child's zone while the parent still has a DS record pointing
	     to the compromised KSK (the assumption is that there is
	     only one DS record at the parent. If there are multiple DS records
	     this does not apply -- however the chain of trust of this
	     particular key is broken).  
	   
</p>
<p> 
	     Note that an attacker's zone still uses the compromised
	     KSK and the presence of the corresponding DS record in
	     the parent would cause the data in this zone to appear as
	     valid. Removing the compromised key would cause the
	     attacker's zone to appear as valid and the child's zone
	     as Bogus. Therefore, we advise not to remove the KSK
	     before the parent has a DS record for the new KSK in
	     place.
	   
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1.1"></a><h3>4.2.1.1.&nbsp;
Keeping the Chain of Trust Intact</h3>

<p>
	       If we follow this advice, the timing of the replacement
	       of the KSK is somewhat critical. The goal is to remove
	       the compromised KSK as soon as the new DS RR is
	       available at the parent.  We therefore have to make
	       sure that the signature made with a new KSK over the
	       key set that contains the compromised KSK expires just
	       after the new DS appears at the parent. Expiration of
	       that signature will cause expiration of that key set
	       from the caches.
	     
</p>
<p>
	       The procedure is as follows:
	       </p>
<ol class="text">
<li>Introduce a new KSK into the key set, keep the
          compromised KSK in the key set.
</li>
<li>Sign the key set, with a short validity period.  The
	  validity period should expire shortly after the DS is
	  expected to appear in the parent and the old DSes have
	  expired from caches.
</li>
<li>Upload the DS for this new key to the parent.
</li>
<li>Follow the procedure of the regular KSK rollover: Wait
          for the DS to appear in the authoritative servers and then
          wait as long as the TTL of the old DS RRs. If necessary
          re-sign the DNSKEY RRSet and modify/extend the expiration time.
</li>
<li> Remove the compromised
             DNSKEY RR from the zone and re-sign the key set using your
             "normal" validity interval.
	     
</li>
</ol><p>
	
     
</p>
<p>
          An additional danger of a key compromise is that the
          compromised key could be used to facilitate a legitimate
          DNSKEY/DS rollover and/or nameserver changes at the parent. When
          that happens, the domain may be in dispute. An
          authenticated out-of-band and secure notify mechanism to
          contact a parent is needed in this case.
                  
</p>
<p>
                  Note that this is only a problem when the DNSKEY and or
                  DS records are used for authentication at the parent.
                  
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1.2"></a><h3>4.2.1.2.&nbsp;
Breaking the Chain of Trust</h3>

<p> 
	  There are two methods to break the chain of trust. The first
	  method causes the child zone to appear 'Bogus' to validating
	  resolvers. The other causes the child zone to appear
	  'insecure'. These are described below.
	
</p>
<p>
	  In the method that causes the child zone to appear 'Bogus'
	  to validating resolvers, the child zone replaces the current
	  KSK with a new one and re-signs the key set.  Next it sends
	  the DS of the new key to the parent. Only after the parent
	  has placed the new DS in the zone is the child's chain of
	  trust repaired.
	
</p>
<p>
	  An alternative method of breaking the chain of trust is by
	  removing the DS RRs from the parent zone altogether. As a
	  result, the child zone would become insecure.
	
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
ZSK Compromise</h3>

<p>
	Primarily because there is no  interaction with the parent required
	when a ZSK is compromised, the situation is less severe than
	with a KSK compromise. The zone must still be re-signed with a
	new ZSK as soon as possible. As this is a local operation and
	requires no communication between the parent and child, this
	can be achieved fairly quickly. However, one has to take into
	account that just as with a normal rollover the immediate
	disappearance of the old compromised key may lead to
	verification problems.  Also note that unil the RRSIG
	over the compromised ZSK has expired, the zone may be still
	at risk.
      
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3"></a><h3>4.2.3.&nbsp;
Compromises of Keys Anchored in Resolvers</h3>

<p>
	A key can also be pre-configured in resolvers. For instance,
	if DNSSEC is successfully deployed the root key may be
	pre-configured in most security aware resolvers.
      
</p>
<p>
	If trust-anchor keys are compromised, the administrators of
	resolvers using these keys should be notified of this
	fact. Zone administrators may consider setting up a mailing
	list to communicate the fact that a SEP key is about to be
	rolled over. This communication will of course need to be
	authenticated by some means, e.g. by using digital signatures.
      
</p>
<p>
	End-users faced with the task of updating an anchored key
	should always validate the new key. New keys should be
	authenticated out-of-band, for example, through the use of an
	announcement website that is secured using secure sockets
	(TLS) <a class='info' href='#RFC5246'>[22]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>.
	  
</p>
<a name="parents"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Parent Policies</h3>

<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
Initial Key Exchanges and Parental Policies Considerations</h3>

<p> The initial key exchange is always subject to the
	  policies set by the parent.  It is specifically important in
	  a registry-registrar model where the key material is to be
	  passed from the DNS operator, to the (parent) registry via a registrar,
	  where both DNS operator and registrar are selected by the
	  registrant and might be different organisations. When
	  designing a key exchange policy one should take into account
	  that the authentication and authorization mechanisms used
	  during a key exchange should be as strong as the
	  authentication and authorization mechanisms used for the
	  exchange of delegation information between parent and
	  child. That is, there is no implicit need in DNSSEC to make
	  the authentication process stronger than it is for regular DNS.
</p>
<p> Using the DNS itself as the source for the actual DNSKEY
	  material, with an out-of-band check on the validity of the
	  DNSKEY, has the benefit that it reduces the chances of user
	  error. A DNSKEY query tool can make use of the
	  SEP bit <a class='info' href='#RFC4035'>[5]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a> to select the proper
	  key from a DNSSEC key set, thereby reducing the chance that
	  the wrong DNSKEY is sent. It can validate the self-signature
	  over a key; thereby verifying the ownership of the private
	  key material. Fetching the DNSKEY from the DNS ensures that
	  the chain of trust remains intact once the parent publishes
	  the DS RR indicating the child is secure.  
</p>
<p> Note: the out-of-band verification is still needed when the
	  key material is fetched via the DNS. The parent can never be
	  sure whether or not the DNSKEY RRs have been spoofed.
	  
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Storing Keys or Hashes?</h3>

<p>When designing a registry system one should consider
	  which of the DNSKEYs and/or the corresponding DSes to store.
	  Since a child zone might wish to have a DS published using a
	  message digest algorithm not yet understood by the registry,
	  the registry can't count on being able to generate the DS
	  record from a raw DNSKEY.  Thus, we recommend that registry
	  systems at least support storing DS records (also see <a class='info' href='#I-D.ietf-dnsop-dnssec-trust-anchor'>draft-ietf-dnsop-dnssec-trut-anchor<span> (</span><span class='info'>Larson, M. and O. Gudmundsson, &ldquo;DNSSEC Trust Anchor Configuration and Maintenance,&rdquo; March&nbsp;2009.</span><span>)</span></a> [26]).

	  
</p>
<p> It may also be useful to store DNSKEYs, since having
	  them may help during troubleshooting and, as long as the
	  child's chosen message digest is supported, the overhead of
	  generating DS records from them is minimal.  Having an
	  out-of-band mechanism, such as a registry directory (e.g., Whois),
	  to find out which keys are used to generate DS Resource Records for
	  specific owners and/or zones may also help with
	  troubleshooting.
	  
</p>
<p>
	    The storage considerations also relate to the design of
	    the customer interface and the method by which data is
	    transferred between registrant and registry; Will the
	    child zone administrator be able to upload DS RRs with
	    unknown hash algorithms or does the interface only allow
	    DNSKEYs?  When Registries support the Extensible
	    Provisioning Protocol (EPP) <a class='info' href='#RFC5910'>[17]<span> (</span><span class='info'>Gould, J. and S. Hollenbeck, &ldquo;Domain Name System (DNS) Security Extensions Mapping for the Extensible Provisioning Protocol (EPP),&rdquo; May&nbsp;2010.</span><span>)</span></a>,
	    that can be used for registrar-registry interactions since
	    that protocol allows the transfer of both DS and optionally
	    DNSKEY RRs. There is no standardized way for moving the
	    data between the customer and the registrar.  Different registrars have different mechanisms,
	    ranging from simple web interfaces to various APIs. In
	    some cases the use of the DNSSEC extentions to EPP may be
	    applicable.
	  
</p>
<a name="lame"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
Security Lameness</h3>

<p> Security lameness is defined as the state whereby the
	  parent has a DS RR pointing to a non-existing DNSKEY
	  RR. Security lameness may occur temporarily during a
	  double-DS rollover scheme. However care should be taken that
	  not all DS RRs are security lame which may cause the child's
	  zone to be marked "Bogus" by verifying DNS clients.
	  
</p>
<p> As part of a comprehensive delegation check, the parent could,
	 at key exchange time, verify that the child's key is actually
	 configured in the DNS.
	  However, if a parent does not understand the hashing algorithm used
	  by child, the parental checks are limited to only comparing the key
	  id.
	  
</p>
<p>
	    Child zones should be very careful in removing DNSKEY material,
	    specifically SEP keys, for which a DS RR exists.
	  
</p>
<p> Once a zone is "security lame", a fix (e.g., removing a
	  DS RR) will take time to propagate through the DNS.

	  
</p>
<a name="DSvalidity"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.4"></a><h3>4.3.4.&nbsp;
DS Signature Validity Period</h3>

<p>
	    Since the DS can be replayed as long as it has a valid
	    signature, a short signature validity period for the DS
	    RRSIG minimizes the time a child is vulnerable in the case
	    of a compromise of the child's KSK(s).  A signature
	    validity period that is too short introduces the
	    possibility that a zone is marked "Bogus" in case of a
	    configuration error in the signer. There may not be enough
	    time to fix the problems before signatures expire (this is
	    a generic argument also see <a class='info' href='#sigval'>Section&nbsp;4.4.2<span> (</span><span class='info'>Signature Validation Periods</span><span>)</span></a>).
	    Something as mundane as operator unavailability during
	    weekends shows the need for DS signature validity periods
	    longer than two days. We recommend an absolute minimum for
	    a DS signature validity period of a few days.
	  
</p>
<p>
	    The maximum signature validity period of the DS record
	    depends on how long child zones are willing to be
	    vulnerable after a key compromise. On the other hand,
	    shortening the DS signature validity interval increases
	    the operational risk for the parent. Therefore, the parent
	    may have policy to use a signature validity interval that
	    is considerably longer than the child would hope for.
	  
</p>
<p> 
	    A compromise between the operational constraints of the
	    parent and minimizing damage for the child may result in a
	    DS signature validity period somewhere between a week and
	    months.
	  
</p>
<p>
	    In addition to the signature validity period, which sets a
	    lower bound on the number of times the zone owner will
	    need to sign the zone data and which sets an upper bound
	    to the time a child is vulnerable after key compromise,
	    there is the TTL value on the DS RRs.  Shortening the TTL
	    means that the authoritative servers will see more
	    queries.  But on the other hand, a short TTL lowers the
	    persistence of DS RRSets in caches thereby increasing the
	    speed with which updated DS RRSets propagate through the
	    DNS.
	  
</p>
<a name="changing-operators"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.5"></a><h3>4.3.5.&nbsp;
Changing DNS Operators</h3>

<p>
	      The parent-child relation is often described in terms of
	      a (thin) registry model. Where a registry maintains the
	      parent zone, and the registrant (the user of the
	      child-domain name), deals with the registry through an
	      intermediary called a registrar. (See <a class='info' href='#RFC3375'>[11]<span> (</span><span class='info'>Hollenbeck, S., &ldquo;Generic Registry-Registrar Protocol Requirements,&rdquo; September&nbsp;2002.</span><span>)</span></a> for a comprehensive
	      definition). Registrants may out-source the maintenance
	      of their DNS system, including the maintenance of DNSSEC
	      key material, to the registrar or to another third
	      party, which we will call the DNS operator. The DNS
	      operator that has control over the DNS zone and its keys
	      may prevent the registrant to make a timely move to a
	      different DNS operator.

	    
</p>
<p>
	      For various reasons, a registrant may want to move
	      between DNS operators.  How easy this move will be
	      depends principally on the DNS operator from which the
	      registrant is moving (the losing operator), as they have
	      control over the DNS zone and its keys.  The following
	      sections describe the two cases: where the losing
	      operator cooperates with the new operator (the gaining
	      operator), and where the two do not cooperate.
	    
</p>
<a name="non_cooperating_registrars"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.5.1"></a><h3>4.3.5.1.&nbsp;
Cooperationg DNS operators</h3>

<p>
	    In this scenario, it is assumed that losing operator will not
	    pass any private key material to the gaining operator (that would
	    constitute a trivial case) but is otherwise fully cooperative.
	    
</p>
<p>
	      In this environment one could proceed with a
	      pre-publish ZSK rollover whereby the losing operator
	      pre-publishes the ZSK of the gaining operator, combined
	      with a double signature KSK rollover where the two
	      registrars exchange public KSKs and independently
	      generate a signature over those keysets that they
	      combine and both publish in their copy of the zone. Once
	      that is done they can use their own private keys to sign
	      any of their zone content during the transfer.
	    
</p><br /><hr class="insert" />
<a name="operator-roll-fig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 ------------------------------------------------------------
 initial            |        pre-publish                    |
 ------------------------------------------------------------
 Parent:
  NS_A                            NS_A
  DS_A                            DS_A
 ------------------------------------------------------------
 Child at A:            Child at A:       Child at B:
  SOA_A0                 SOA_A1            SOA_B0
  RRSIG_Z_A(SOA)         RRSIG_Z_A(SOA)    RRSIG_Z_B(SOA)

  NS_A                   NS_A              NS_B
  RRSIG_Z_A(NS)          NS_B              RRSIG_Z_B(NS)
                         RRSIG_Z_A(NS)




  DNSKEY_Z_A             DNSKEY_Z_A         DNSKEY_Z_A
  DNSKEY_K_A             DNSKEY_Z_B         DNSKEY_K_B
  RRSIG_Z_A(DNSKEY)      DNSKEY_K_A         DNSKEY_K_A
  RRSIG_K_A(DNSKEY)      DNSKEY_K_B         DNSKEY_K_B
                         RRSIG_Z_B(DNSKEY)  RRSIG_Z_B(DNSKEY)
                         RRSIG_K_B(DNSKEY)  RRSIG_K_B(DNSKEY)
                         RRSIG_Z_A(DNSKEY)  RRSIG_Z_A(DNSKEY)
                         RRSIG_K_A(DNSKEY)  RRSIG_K_A(DNSKEY)
 ------------------------------------------------------------

 ------------------------------------------------------------
       Redelegation                 |   post migration      |
 ------------------------------------------------------------
 Parent:
           NS_B                           NS_B
           DS_B                           DS_B
 ------------------------------------------------------------
 Child at A:       Child at B:             Child at B:

  SOA_A2             SOA_B1                SOA_B2
  RRSIG_Z_A(SOA)     RRSIG_Z_B(SOA)        RRSIG_Z_B(SOA)

  NS_A               NS_B                  NS_B
  NS_B               RRSIG_Z_B(NS)         RRSIG_Z_B(NS)
  RRSIG_Z_A(NS)


  DNSKEY_Z_A         DNSKEY_Z_A            DNSKEY_Z_B
  DNSKEY_Z_B         DNSKEY_Z_B            DNSKEY_K_B
  DNSKEY_K_A         DNSKEY_K_A            RRSIG_Z_B(DNSKEY)
  DNSKEY_K_B         DNSKEY_K_B            RRSIG_K_B(DNSKEY)
  RRSIG_Z_B(DNSKEY)  RRSIG_Z_B(DNSKEY)
  RRSIG_K_B(DNSKEY)  RRSIG_K_B(DNSKEY)
  RRSIG_Z_A(DNSKEY)  RRSIG_Z_A(DNSKEY)
  RRSIG_K_A(DNSKEY)  RRSIG_K_A(DNSKEY)

 ------------------------------------------------------------
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;9: Rollover for cooperating operators&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
		In this figure A denotes the losing operator and
		B the gaining operator. RRSIGZ is the RRSIG
		produced by a ZSK, RRSIGK is produced with a KSK, the
		appended A or B indicates the producers of the key
		pair. Child at A is how the zone content is represented
 		by the losing DNS operator and Child at B is how the
 		zone content is represented by the gaining DNS
		operator.
	      
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.5.2"></a><h3>4.3.5.2.&nbsp;
Non Cooperationg DNS Operators</h3>

<p>
	      In the non-cooperative case matters are more
	      complicated. The losing operator may not cooperate and
	      leave the data in the DNS as is.  In the extreme case
	      the losing operator may become obstructive and publish
	      a DNSKEY RR with a high TTL and corresponding signature
	      validity so that registrar A's DNSKEY could end up in
	      caches for (in theory at least) tens of years.
	    
</p>
<p>
	      The problem arises when a validator tries to validate
	      with the losing operator's key and there is no
	      signature material produced with the losing operator
	      available in the delegation path after redelegation from
	      the loosing operator to the gaining operator has taken
	      place.  One could imagine a rollover scenario where the
	      gaining operator pulls all RRSIGs created by the losing
	      operator and publishes those in conjunction with its own
	      signatures, but that would not allow any changes in the
	      zone content. Since a redelegation took place the NS
	      RRset has - by definition - changed so such rollover
	      scenario will not work. Besides if zone transfers are
	      not allowed by the losing operator and NSEC3 is
	      deployed in the losing operator's zone, then the
	      gaining operator's zone will not have certainty that
	      all of A's RRSIGs are transferred.
	    
</p>
<p>
	      The only viable option for the registrant is to publish
	      its zone unsigned and ask the registry to remove the DS RR
	      pointing to the losing operator's DNSKEY for as long as
	      the DNSKEY of the losing operator, or any of the
	      signatures produced by it are likely to disappear in
	      caches, which as mentioned above could in theory be for
	      tens of years.
	    
</p>
<p>
	      Note that implementations limit the time DNSKEYs that
	      seem to be unable to validate signatures are cached
	      and/or will try to recover from cases where DNSKEYs do
	      not seem to be able to validate data. Although that is
	      not a protocol requirement it seems that that practice
	      may limit the impact of this problem the problem of
	      non-cooperating registrars.
	    
</p>
<p>
	      However, there is no operational methodology to work
	      around this business issue, and proper contractual
	      relationships between all involved parties seems to be
	      the only solution to cope with these problems. It should
	      be noted that in many cases, the problem with temporary
	      broken delegations already exists when a zone changes
	      from one DNS operator to another. Besides, it is often
	      the case that when operators are changed the services
	      that that zone references also change operator, possibly
	      involving some downtime.
	    
</p>
<p>
	      In any case, to minimise such problems, the classic
	      recommendation is to have relative short TTL on all
	      involved resource records. That will solve many of the
	      problems regarding changes to a zone regardless of
	      whether DNSSEC is used.

	    
</p>
<a name="time"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Time in DNSSEC</h3>

<p>
	Without DNSSEC, all times in the DNS are relative. The SOA
	fields REFRESH, RETRY, and EXPIRATION are timers used to
	determine the time elapsed after a slave server synchronized
	with a master server. The Time to Live (TTL) value and the SOA
	RR minimum TTL parameter <a class='info' href='#RFC2308'>[9]<span> (</span><span class='info'>Andrews, M., &ldquo;Negative Caching of DNS Queries (DNS NCACHE),&rdquo; March&nbsp;1998.</span><span>)</span></a> are used to
	determine how long a forwarder should cache data after it has
	been fetched from an authoritative server. By using a
	signature validity period, DNSSEC introduces the notion of an
	absolute time in the DNS. Signatures in DNSSEC have an
	expiration date after which the signature is marked as invalid
	and the signed data is to be considered Bogus.
      
</p>
<p>
	The considerations in this section are all qualitative and
	focused on the operational and managerial issues. A more
	thorough quantitative analysis of rollover timing parameters
	can be found in <a class='info' href='#I-D.ietf-dnsop-dnssec-key-timing'>draft-ietf-dnsop-dnssec-key-timing<span> (</span><span class='info'>Morris, S., Ihren, J., and J. Dickinson, &ldquo;DNSSEC Key Timing Considerations,&rdquo; July&nbsp;2010.</span><span>)</span></a> [24]
      
</p>
<a name="time_considerations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
Time Considerations</h3>

<p>
	  Because of the expiration of signatures, one should consider the
	  following:
	
</p>
<p>
	  </p>
<ul class="text">
<li>
	      We suggest the Maximum Zone TTL of your zone data to be a
	      fraction of your signature validity period.

	      
<blockquote class="text"><dl>
<dt></dt>
<dd>
		  If the TTL was of similar order as the signature
		  validity period, then all RRSets fetched during the
		  validity period would be cached until the signature
		  expiration time.  <a class='info' href='#RFC4033'>Section 8.1
		  of RFC4033<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;DNS Security Introduction and Requirements,&rdquo; March&nbsp;2005.</span><span>)</span></a> [3] suggests that "the resolver may
		  use the time remaining before expiration of the
		  signature validity period of a signed RRSet as an
		  upper bound for the TTL". As a result, query load on
		  authoritative servers would peak at signature
		  expiration time, as this is also the time at which
		  records simultaneously expire from caches.
		
</dd>
<dt></dt>
<dd>
		  To avoid query load peaks, we suggest the TTL on all
		  the RRs in your zone to be at least a few times
		  smaller than your signature validity period.
		
</dd>
</dl></blockquote>
	    
</li>
<li>
	      We suggest the signature publication period to end at
	      least one Maximum Zone TTL duration before the end of
	      the signature validity period.
	      
<blockquote class="text"><dl>
<dt></dt>
<dd>
		  Re-signing a zone shortly before the end of the
		  signature validity period may cause simultaneous
		  expiration of data from caches. This in turn may
		  lead to peaks in the load on authoritative
		  servers. To avoid this schemes are deployed whereby
		  the zone is periodically visited for a resigning
		  operation and those signatures that are within a so
		  called refresh interval from signature expiration
		  are recreated. Also see <a class='info' href='#sigval'>Section&nbsp;4.4.2<span> (</span><span class='info'>Signature Validation Periods</span><span>)</span></a>
		  below.
		
</dd>
</dl></blockquote>
	    
</li>
<li>
	      We suggest the Minimum Zone TTL to be long enough to
	      both fetch and verify all the RRs in the trust chain. In
	      workshop environments, it has been demonstrated <a class='info' href='#NIST-workshop'>[18]<span> (</span><span class='info'>Rose, S., &ldquo;NIST DNSSEC workshop notes,&rdquo; June&nbsp;2001.</span><span>)</span></a> that a low TTL (under 5 to 10
	      minutes) caused disruptions because of the following two
	      problems:

	      
<blockquote class="text"><dl>
<dt></dt>
<dd>
		  1. During validation, some data may expire before
		  the validation is complete. The validator should be
		  able to keep all data until it is completed. This
		  applies to all RRs needed to complete the chain of
		  trust: DS, DNSKEY, RRSIG, and the final answers,
		  i.e., the RRSet that is returned for the initial
		  query.
		
</dd>
<dt></dt>
<dd>
		  2. Frequent verification causes load on recursive
		  nameservers. Data at delegation points, DS, DNSKEY, and
		  RRSIG RRs benefit from caching. The TTL on those should be
		  relatively long.

		
</dd>
</dl></blockquote>
	    
</li>
<li>
	      Slave servers will need to be able to fetch newly signed
	      zones well before the RRSIGs in the zone served by the
	      slave server pass their signature expiration time.
	      
<blockquote class="text"><dl>
<dt></dt>
<dd>
		  When a slave server is out of synchronization with its master
		  and data in a zone is signed by expired signatures,
		  it may be better for the slave server not to give
		  out any answer.
		
</dd>
<dt></dt>
<dd>
		  Normally, a slave server that is not able to contact
		  a master server for an extended period will expire a
		  zone. When that happens, the server will respond
		  differently to queries for that zone. Some servers
		  issue SERVFAIL, whereas others turn off the 'AA' bit
		  in the answers.

		  The time of expiration is set in the SOA
		  record and is relative to the last successful refresh
		  between the master and the slave servers. There exists no
		  coupling between the signature expiration of RRSIGs in
		  the zone and the expire parameter in the SOA.
		
</dd>
<dt></dt>
<dd>
		  If the server serves a DNSSEC zone, then it may well
		  happen that the signatures expire well before the SOA
		  expiration timer counts down to zero. It is not possible
		  to completely prevent this by modifying
		  the SOA parameters.
		
</dd>
<dt></dt>
<dd>
		  However, the effects can be minimized where the SOA
		  expiration time is equal to or shorter than the
		  signature validity period.
		
</dd>
<dt></dt>
<dd>
		  The consequence of an authoritative server not being
		  able to update a zone for an extended period of time
		  is that signatures may expire. In this case
		  non-secure resolvers will continue to be able to
		  resolve data served by the particular slave servers
		  while security-aware resolvers will experience
		  problems because of answers being marked as Bogus.
		
</dd>
<dt></dt>
<dd>
		  We suggest the SOA expiration timer being approximately
		  one third or a quarter of the signature validity period.
		  It will allow problems with transfers from the master server
		  to be noticed before the actual signature times out.
		
</dd>
<dt></dt>
<dd>
		  We also suggest that operators of nameservers that
		  supply secondary services develop systems to identify
		  upcoming signature expirations in zones they slave and
		  take appropriate action where such an event is detected.
		
</dd>
<dt></dt>
<dd>
		  When determining the value for the expiration parameter
		  one has to take the following into account: what are the
		  chances that all my secondaries expire the zone? How quickly
		  can I reach an administrator of secondary servers to
		  load a valid zone? These questions are not DNSSEC
		  specific but may influence the choice of your signature
		  validity intervals.
	      
</dd>
</dl></blockquote>
	    
</li>
</ul><p>
	
</p>
<a name="sigval"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;
Signature Validation Periods</h3>

<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2.1"></a><h3>4.4.2.1.&nbsp;
Maximum Value</h3>

<p>
	The first consideration for choosing a maximum signature
	validity period is the risk of a replay attack. For low-value,
	long-term stable resources the risks may be minimal and the
	signature validity period may be several months. Although
	signature validity periods of many years are allowed the same
	operational habit arguments as in <a class='info' href='#rolling-ksk-ta'>Section&nbsp;3.2.2<span> (</span><span class='info'>Rolling a KSK that is a trust-anchor</span><span>)</span></a> play a role: when a zone is re-signed
	with some regularity then operators remain conscious about the
	operational necessity of re-signing.
      
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2.2"></a><h3>4.4.2.2.&nbsp;
Minimum Value</h3>

<p> 
	  The minimum value of the signature validity period is set for
	  the time by which one would like to survive operational
	  failure in provisioning: what is the time that a failure
	  will be noticed, what is the time that action is expected to
	  be taken? By answering these questions availability of
	  operators during (long) weekends or time taken to access to backup media
	  can be taken into account. The result could easily suggest a
	  minimum Signature Validity period of a few days.
	
</p>
<p>
	  Note however, the argument above is assuming that zone data
	  has just been signed and published when the problem
	  occurred. In practice it may be that a zone is signed
	  according to a frequency set by the Re-Sign Period whereby
	  the signer visits the zone content and only refreshes
	  signatures that are close to expiring: the signer will only
	  refresh signatures if they are within the Refresh Period
	  from the signature expiration time.  The Re-Sign Period must
	  be smaller than the Refresh Period in order for zone data to
	  be signed in timely fashion.
	
</p>
<p>
	  If an operational problem occurs during resigning then the
	  signatures in the zone to expire first are the ones
	  that have been generated longest ago. In the worst case
	  these signatures are the Refresh Period minus the Re-Sign
	  Period away from signature expiration.
	
</p>
<p>
	  In other words, the minimum Signature Validity intervall is
	  set by first choosing the Refresh Period (usually a few
	  days), then defining the Re-Sign period in such a way that 
	  the Refresh Period minus the Resign period sets the time in
	  which operational havoc can be resolved.
	
</p>
<p>
	  To make matters slightly more complicated, some signers vary
	  the signature validity period over a smal range (the jitter
	  interval) so that not all signatures expire at the same
	  time.  The jitter should not influence your calculation as
	  long as it is smaller than the refresh period and the resign
	  period is at least half the refresh period.
	
</p><br /><hr class="insert" />
<a name="signature-fig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

 Inception         Signing                             Expiration
 time                time                                time
 |                     |                           |       |       |
 |---------------------|---------------------------|.......|.......|
 |                     |                           |       |       |
                                                       +/- jitter

 |  Inception offset   |                                   |
 |&lt;-------------------&gt;|        Validity Period            |
 |                  |&lt;------------------------------------&gt;|




 Inception      Signing  reuse  reuse  reuse    new      Expiration
 time             time                          signature     time
 |                  |      |      |      |      |             |
 |------------------|-----------------------------------------|
 |                  |      |      |      |      |             |
                     &lt;----&gt; &lt;----&gt; &lt;----&gt; &lt;----&gt;
                 Resign Period

                                             |                  |
                                             |&lt;-Refresh Period-&gt;|
                                             |                  |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;10: Signature Timing Parameters&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p> 
	  Note that in the figure the validity of the signature starts
	  shortly before the inception time. That is done to deal with 
	  validators that might have some clock skew.
	
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2.3"></a><h3>4.4.2.3.&nbsp;
Differentiation between RR sets</h3>

<p>
	  It is possible to vary signature validity periods between
	  signatures over different RR sets in the zone. In practice
	  this could be done when zones contain highly volatile data
	  (which may be the case in dynamic update environments). Note
	  however that the risk of replay (e.g. by stale secondary
	  servers) is what should be leading in determining the
	  signature validity period since the TTL on the data itself
	  still are the primary parameter for cache expiry.  
	
</p>
<p>
	  In some cases the risk of replaying existing data might be
	  different from the risk of replaying the denial of data. In
	  those cases the signature validity period on NSEC or NSEC3
	  records may be tweaked accordingly.
	
</p>
<p>
	  When a zone contains secure delegations then a relatively
	  short signature validity interval protects the child agains
	  replay attacks, in the case the child's key is compromised
	  (see <a class='info' href='#DSvalidity'>Section&nbsp;4.3.4<span> (</span><span class='info'>DS Signature Validity Period</span><span>)</span></a>). Since there is a higher
	  operational risk for the parent registry when choosing a
	  short validity interval and a higher operational risk for
	  the child when choosing a long validity period some (price)
	  differentiation may occur for validity periods between
	  individual DS RRs in a single zone.
	
</p>
<p>
	  There seem to be no other arguments for differentiation in
	  validity periods.
	
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2.4"></a><h3>4.4.2.4.&nbsp;
Other timing parameters in a zone</h3>

<p>
	  The arguments for tuning minimum signature validity period
	  are remarkably similar to the arguments used to set the SOA
	  expiration timer. It is advised to set the SOA expiration to
	  a value greater than the signature validity period.
	
</p>
<a name="nsec_nsec3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Next Record type</h3>

<p>
    One of the design tradeoffs made during the development of DNSSEC
    was to separate the signing and serving operations instead of
    performing cryptographic operations as DNS requests are being
    serviced. It is therefore necessary to create records that cover
    the very large number of non-existent names that lie between the
    names that do exist.
  
</p>
<p>
    There are two mechanisms to provide authenticated proof of
    non-existence of domain names in DNSSEC: a clear text one and an
    obfuscated-data one.  Each mechanism:
    </p>
<ul class="text">
<li>
	includes a list of all the RRTYPEs present which can be used
	to prove the non-existence of RRTYPEs at a certain name;
      
</li>
<li>
	stores only the name for which the zone is authoritative (that
	is, glue in the zone is omitted); and
      
</li>
<li>
	uses a specific RRTYPE to store information about the RRTYPEs
	present at the name: the clear-text mechanism uses NSEC, and
	the obfuscated-data mechanism uses NSEC3.
      
</li>
</ul><p>
  
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Differences between  NSEC and NSEC3</h3>

<p>
      The clear text mechanism (NSEC) is implemented using a sorted
      linked list of names in the zone.  The obfuscated-data mechanism
      (NSEC3) is similar but first hashes the names using a one-way
      hash function, before creating a sorted linked list of the
      resulting (hashed) strings.
    
</p>
<p>
      The NSEC record requires no cryptographic operations aside from
      the validation of its associated signature record. It is human
      readable and can be used in manual queries to determine correct
      operation.  The disadvantage is that it allows for "zone
      walking", where one can request all the entries of a zone by
      following the linked list of NSEC RRs via the "Next Domain Name"
      field.
    
</p>
<p>
      Though all agree DNS data is accessible through query
      mechanisms, a side effect of NSEC is that it allows the contents
      of a zone file to be enumerated in full by sequential
      queries. Whilst for some operators this behaviour is acceptable
      or even desirable, for others it is undesirable for policy,
      regulatory or other reasons.  This is the first difference
      between NSEC and NSEC3.
    
</p>
<p>
      The second difference between NSEC and NSEC3 is that NSEC
      requires a signature over every RR in the zonefile, thereby
      ensuring that any denial of existence is cryptographically
      signed. However, in a large zonefile containing many delegations
      very few of which are to signed zones, this may produce
      unacceptable additional overhead especially where insecure
      delegations are subject to frequent update (a typical example
      might be a TLD operator with few registrants using secure
      delegations). NSEC3 allows intervals between two such
      delegations to "Opt-out" in which case they may contain one more
      more insecure delegations, thus reducing the size and
      cryptographic complexity of the zone at the expense of the
      ability to cryptographically deny the existence of names in a
      specific span.
    
</p>
<p>
      The NSEC3 record uses a hashing method of the requested RRlabel.
      To increase the workload required to guess entries in the zone,
      the number of hashing iteration's can be specified in the NSEC3
      record. Additionally, a salt can be specified that also modifies
      the hashes. Note that NSEC3 does not give full protection
      against information leakage from the zone.
    
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
NSEC or NSEC3</h3>

<p> 
      The first motivation to deploy NSEC3, prevention of zone
      enumeration, only makes sense when zone content is not highly
      structured or trivially guessable. Highly structured zones such
      as the in-addr.arpa, ip6.arpa and e164.arpa can be trivially
      enumerated using ordinary DNS properties while for small zones
      that only contain contain records in the APEX and a few common
      RRlabels such as "www" or "mail" guessing zone content and
      proving completeness is also trivial when using NSEC3.
    
</p>
<p>
      In those cases the use of NSEC is recommended to ease the work
      required by signers and validating resolvers.
    
</p>
<p>
      
      For large zones where there is an implication of "not readily
      available" RRlabels, such as those where one has to sign a
      non-disclosure agreement before obtaining it, NSEC3 is
      recommended.
    
</p>
<p>The considerations for the second reason to deploy NSEC3 are
    discussed below (<a class='info' href='#opt-out'>Section&nbsp;5.3.4<span> (</span><span class='info'>Opt-out</span><span>)</span></a>).
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
NSEC3 parameters</h3>

<p>
      The NSEC3 hashing algorithm is performed on the Fully Qualified
      Domain Name (FQDN) in its uncompressed form. This ensures brute
      force work done by an attacker for one (FQDN) RRlabel cannot be
      re-used for another (FQDN) RRlabel attack, as these entries are,
      by definition unique.
    
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
NSEC3 Algorithm</h3>

<p>
	At the moment of writing there is only one NSEC3 Hashing
	algorithm defined. <a class='info' href='#RFC5155'>[21]<span> (</span><span class='info'>Laurie, B., Sisson, G., Arends, R., and D. Blacka, &ldquo;DNS Security (DNSSEC) Hashed Authenticated Denial of Existence,&rdquo; March&nbsp;2008.</span><span>)</span></a> specifically calls
	out that when a new hash algorithm for use with NSEC3 is
	specified, a transition mechanism MUST also be
	defined. Therefore this document does not consider NSEC3 hash
	algorithm transition.

      
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2"></a><h3>5.3.2.&nbsp;
NSEC3 Iterations</h3>

<p>
	One of the concerns with NSEC3 is  a pre-calculated dictionary attack could be made in order to assess
	if certain domain names exist within the zones or not. Two
	mechanisms are introduced in the NSEC3 specification to
	increase the costs of such dictionary attacks: Iterations and
	Salt.
      
</p>
<p>
	<a class='info' href='#RFC5155'>RFC5155 Section 10.3<span> (</span><span class='info'>Laurie, B., Sisson, G., Arends, R., and D. Blacka, &ldquo;DNS Security (DNSSEC) Hashed Authenticated Denial of Existence,&rdquo; March&nbsp;2008.</span><span>)</span></a> [21] considers the trade-offs
	between incurring cost during the signing process and imposing
	costs to the validating nameserver, while still providing a
	reasonable barrier against dictionary attacks. It provides
	useful limits of iterations for a given RSA key size. These
	are 150 iterations for 1024 bit keys, 500 iterations for 2048
	bit keys and 2,500 iterations for 4096 bit keys. Choosing
	two-thirds of the maximum is deemed to be a sufficiently costly yet
	not excessive value.
      
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.3"></a><h3>5.3.3.&nbsp;
NSEC3 Salt</h3>

<p>
	While the NSEC3 iterations parameter increases the cost of
	hashing a dictionary word, the NSEC3 salt reduces the lifetime
	for which that calculated hash can be used. A change of the
	salt value by the zone owner would cause an attacker to lose
	all precalculated work for that zone.
      
</p>
<p>
	The FQDN RRlabel, which is part of the value that is hashed,
	already ensures that brute force work for one RRlabel can not
	be re-used to attack other RRlabel (e.g. in other domains) due
	to their uniqueness.
      
</p>
<p>
	The salt of all NSEC3 records in a zone needs to be the same.
	Since changing the salt requires all the NSEC3 records to be
	regenerated, and thus requires generating new RRSIG's over
	these NSEC3 records, it is recommended to align the change of
	the salt with a change of the Zone Signing Key, as that
	process in itself already requires all RRSIG's to be
	regenerated. If there is no critical dependency on incremental
	signing and the whole zone can be signed with little effort
	there is no need for such alignment. However, unlike Zone
	Signing Key changes, NSEC3 salt changes do not need special
	rollover procedures.  It is possible to change the salt each
	time the zone is updated.
      
</p>
<a name="opt-out"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.4"></a><h3>5.3.4.&nbsp;
Opt-out</h3>

<p>
	The Opt-Out mechanism was introduced to allow for a gradual
	introduction of signed records in zones that contain mostly
	delegation records. The use of the OPT-OUT flag changes the
	meaning of the NSEC3 span from authoritative denial of the
	existence of names within the span to a proof that DNSSEC is
	not available for the delegations within the span. [Editors
	Note: One could make this construct more correct by talking
	about the hashed names and the hashed span, but I believe that
	is overkill]. This allows for the addition or removal of the
	delegations covered by the span without recalculating or re-
	signing RRs in the NSEC3 RR chain.
      
</p>
<p>
	Opt-Out is specified to be used only over delegation points
	and will therefore only bring relief to zones with a large
	number of zones and where the number of secure delegations is
	small. This consideration typically holds for large
	top-level-domains and similar zones; in most other
	circumstances Opt-Out should not be deployed. Further
	considerations can be found in <a class='info' href='#RFC5155'>RFC5155
	section 12.2<span> (</span><span class='info'>Laurie, B., Sisson, G., Arends, R., and D. Blacka, &ldquo;DNS Security (DNSSEC) Hashed Authenticated Denial of Existence,&rdquo; March&nbsp;2008.</span><span>)</span></a> [21].
	
      
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p> 
	DNSSEC adds data integrity to the DNS. This document tries to
	assess the operational considerations to maintain a stable and
	secure DNSSEC service. Not taking into account the 'data
	propagation' properties in the DNS will cause validation
	failures and may make secured zones unavailable to
	security-aware resolvers.  
      
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA considerations</h3>

<p>
	There are no IANA considerations with respect to this document
      
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Contributors and Acknowledgments</h3>

<p>
	Significant parts of the text of this document is copied from <a class='info' href='#RFC4641'>RFC4641<span> (</span><span class='info'>Kolkman, O. and R. Gieben, &ldquo;DNSSEC Operational Practices,&rdquo; September&nbsp;2006.</span><span>)</span></a> [14]. That document was edited by
	Olaf Kolkman and Miek Gieben. Other people that contributed or
	where otherwise involved in that work were in random order:
	Rip Loomis, Olafur Gudmundsson, Wesley Griffin, Michael
	Richardson, Scott Rose, Rick van Rein, Tim McGinnis, Gilles
	Guette, Olivier Courtay, Sam Weiler, Jelte Jansen, Niall
	O'Reilly, Holger Zuleger, Ed Lewis, Hilarie Orman, Marcos
	Sanz, Peter Koch, Mike StJohns, Emma Bretherick, Adrian
	Bedford, and Lindy Foster, and O. Courtay.
	
</p>
<p>
	  For this version of the document we would like to
	  acknowledge a few people for significant contributions:
	  </p>
<blockquote class="text"><dl>
<dt>Paul Hoffman</dt>
<dd> for his contribution on the choice of
	    cryptographic paramenters and addressing some of the
	    trust anchor issues;
</dd>
<dt>Jelte Jansen</dt>
<dd> who provided the initial
	    text in <a class='info' href='#KAR'>Section&nbsp;4.1.5<span> (</span><span class='info'>Algorithm rollovers</span><span>)</span></a>;
</dd>
<dt>Paul Wouters</dt>
<dd> who provided the initial text for <a class='info' href='#nsec_nsec3'>Section&nbsp;5<span> (</span><span class='info'>Next Record type</span><span>)</span></a> and Alex Bligh who improved it;
</dd>
<dt>Erik Rescorla</dt>
<dd> whos blogpost on "the Security of ZSK
	    rollovers" inspired text in <a class='info' href='#zsk-ksk-motivation'>Section&nbsp;3.1<span> (</span><span class='info'>Operational Motivation for Zone Signing and Key Signing Keys</span><span>)</span></a>;
</dd>
<dt>Stephen Morris</dt>
<dd> who made a pass on English style and
	    grammar;
</dd>
<dt>Matthijs Mekking</dt>
<dd> throurougly reviewed and provided
	    concrete improvements on the specific types of
	    keyrollovers (e.g. he provided the tables in <a class='info' href='#AlgoFigures'>Appendix&nbsp;C<span> (</span><span class='info'>Transition Figures for Special Case Algorithm Rollovers</span><span>)</span></a>); and 
</dd>
<dt>Olafur Gudmundsson and Onrej Sury</dt>
<dd> who provided input
	    on <a class='info' href='#KAR'>Section&nbsp;4.1.5<span> (</span><span class='info'>Algorithm rollovers</span><span>)</span></a> based on actual operational
	    experience.
</dd>
</dl></blockquote><p>
	
</p>
<p> The figure in <a class='info' href='#sigval'>Section&nbsp;4.4.2<span> (</span><span class='info'>Signature Validation Periods</span><span>)</span></a> was adapted from
	the OpenDNSSEC user documentation.
	
</p>
<p>
	  In addition valuable contributions in the form of text,
	  comments, or review where provided by Mark Andrews, Patrik Faltstrom, Tony
	  Finch,  Alfred Hines, Bill Manning, Scott Rose, and Wouter Wijngaards.
	
</p>
<p>
	  [EDITOR NOTE: please let me know if there is an oversight here]
	
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1034">[1]</a></td>
<td class="author-text">Mockapetris, P., &ldquo;<a href="http://tools.ietf.org/html/rfc1034">Domain names - concepts and facilities</a>,&rdquo; STD&nbsp;13, RFC&nbsp;1034, November&nbsp;1987 (<a href="ftp://ftp.isi.edu/in-notes/rfc1034.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1035">[2]</a></td>
<td class="author-text">Mockapetris, P., &ldquo;<a href="http://tools.ietf.org/html/rfc1035">Domain names - implementation and specification</a>,&rdquo; STD&nbsp;13, RFC&nbsp;1035, November&nbsp;1987 (<a href="ftp://ftp.isi.edu/in-notes/rfc1035.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4033">[3]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4033">DNS Security Introduction and Requirements</a>,&rdquo; RFC&nbsp;4033, March&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4033.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4034">[4]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4034">Resource Records for the DNS Security Extensions</a>,&rdquo; RFC&nbsp;4034, March&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4034.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4035">[5]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4035">Protocol Modifications for the DNS Security Extensions</a>,&rdquo; RFC&nbsp;4035, March&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4035.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[6]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1995">[7]</a></td>
<td class="author-text"><a href="mailto:mohta@necom830.hpcl.titech.ac.jp">Ohta, M.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1995">Incremental Zone Transfer in DNS</a>,&rdquo; RFC&nbsp;1995, August&nbsp;1996 (<a href="ftp://ftp.isi.edu/in-notes/rfc1995.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1996">[8]</a></td>
<td class="author-text"><a href="mailto:paul@vix.com">Vixie, P.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1996">A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY)</a>,&rdquo; RFC&nbsp;1996, August&nbsp;1996 (<a href="ftp://ftp.isi.edu/in-notes/rfc1996.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2308">[9]</a></td>
<td class="author-text"><a href="mailto:Mark.Andrews@cmis.csiro.au">Andrews, M.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2308">Negative Caching of DNS Queries (DNS NCACHE)</a>,&rdquo; RFC&nbsp;2308, March&nbsp;1998 (<a href="ftp://ftp.isi.edu/in-notes/rfc2308.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2308.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3007">[10]</a></td>
<td class="author-text">Wellington, B., &ldquo;<a href="http://tools.ietf.org/html/rfc3007">Secure Domain Name System (DNS) Dynamic Update</a>,&rdquo; RFC&nbsp;3007, November&nbsp;2000 (<a href="ftp://ftp.isi.edu/in-notes/rfc3007.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3375">[11]</a></td>
<td class="author-text">Hollenbeck, S., &ldquo;<a href="http://tools.ietf.org/html/rfc3375">Generic Registry-Registrar Protocol Requirements</a>,&rdquo; RFC&nbsp;3375, September&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3375.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3766">[12]</a></td>
<td class="author-text">Orman, H. and P. Hoffman, &ldquo;<a href="http://tools.ietf.org/html/rfc3766">Determining Strengths For Public Keys Used For Exchanging Symmetric Keys</a>,&rdquo; BCP&nbsp;86, RFC&nbsp;3766, April&nbsp;2004 (<a href="ftp://ftp.isi.edu/in-notes/rfc3766.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4086">[13]</a></td>
<td class="author-text">Eastlake, D., Schiller, J., and S. Crocker, &ldquo;<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>,&rdquo; BCP&nbsp;106, RFC&nbsp;4086, June&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4086.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4641">[14]</a></td>
<td class="author-text">Kolkman, O. and R. Gieben, &ldquo;<a href="http://tools.ietf.org/html/rfc4641">DNSSEC Operational Practices</a>,&rdquo; RFC&nbsp;4641, September&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4641.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4949">[15]</a></td>
<td class="author-text">Shirey, R., &ldquo;<a href="http://tools.ietf.org/html/rfc4949">Internet Security Glossary, Version 2</a>,&rdquo; RFC&nbsp;4949, August&nbsp;2007 (<a href="ftp://ftp.isi.edu/in-notes/rfc4949.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5011">[16]</a></td>
<td class="author-text">StJohns, M., &ldquo;<a href="http://tools.ietf.org/html/rfc5011">Automated Updates of DNS Security (DNSSEC) Trust Anchors</a>,&rdquo; RFC&nbsp;5011, September&nbsp;2007 (<a href="ftp://ftp.isi.edu/in-notes/rfc5011.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5910">[17]</a></td>
<td class="author-text">Gould, J. and S. Hollenbeck, &ldquo;<a href="http://tools.ietf.org/html/rfc5910">Domain Name System (DNS) Security Extensions Mapping for the Extensible Provisioning Protocol (EPP)</a>,&rdquo; RFC&nbsp;5910, May&nbsp;2010 (<a href="http://www.rfc-editor.org/rfc/rfc5910.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="NIST-workshop">[18]</a></td>
<td class="author-text">Rose, S., &ldquo;NIST DNSSEC workshop notes,&rdquo; &nbsp;, June&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="NIST-SP-800-90">[19]</a></td>
<td class="author-text">Barker, E. and J. Kelsey, &ldquo;Recommendation for Random Number Generation Using
	    Deterministic Random Bit Generators (Revised),&rdquo; Nist Special Publication&nbsp;800-90, March&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4509">[20]</a></td>
<td class="author-text">Hardaker, W., &ldquo;<a href="http://tools.ietf.org/html/rfc4509">Use of SHA-256 in DNSSEC Delegation Signer (DS) Resource Records (RRs)</a>,&rdquo; RFC&nbsp;4509, May&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4509.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5155">[21]</a></td>
<td class="author-text">Laurie, B., Sisson, G., Arends, R., and D. Blacka, &ldquo;<a href="http://tools.ietf.org/html/rfc5155">DNS Security (DNSSEC) Hashed Authenticated Denial of Existence</a>,&rdquo; RFC&nbsp;5155, March&nbsp;2008 (<a href="ftp://ftp.isi.edu/in-notes/rfc5155.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5246">[22]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>,&rdquo; RFC&nbsp;5246, August&nbsp;2008 (<a href="ftp://ftp.rfc-editor.org/in-notes/rfc5246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5702">[23]</a></td>
<td class="author-text">Jansen, J., &ldquo;<a href="http://tools.ietf.org/html/rfc5702">Use of SHA-2 Algorithms with RSA in DNSKEY and RRSIG Resource Records for DNSSEC</a>,&rdquo; RFC&nbsp;5702, October&nbsp;2009 (<a href="ftp://ftp.isi.edu/in-notes/rfc5702.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-dnsop-dnssec-key-timing">[24]</a></td>
<td class="author-text">Morris, S., Ihren, J., and J. Dickinson, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-dnsop-dnssec-key-timing-00.txt">DNSSEC Key Timing Considerations</a>,&rdquo; draft-ietf-dnsop-dnssec-key-timing-00 (work in progress), July&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-dnsop-dnssec-key-timing-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-dnsop-dnssec-dps-framework">[25]</a></td>
<td class="author-text">Ljunggren, F., Eklund-Lowinder, A., and T. Okubo, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-dnsop-dnssec-dps-framework-02.txt">DNSSEC Policy &amp; Practice Statement Framework</a>,&rdquo; draft-ietf-dnsop-dnssec-dps-framework-02 (work in progress), July&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-dnsop-dnssec-dps-framework-02.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-dnsop-dnssec-trust-anchor">[26]</a></td>
<td class="author-text">Larson, M. and O. Gudmundsson, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-dnsop-dnssec-trust-anchor-03.txt">DNSSEC Trust Anchor Configuration and Maintenance</a>,&rdquo; draft-ietf-dnsop-dnssec-trust-anchor-03 (work in progress), March&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-dnsop-dnssec-trust-anchor-03.txt">TXT</a>).</td></tr>
</table>

<a name="terminology"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Terminology</h3>

<p> 
	In this document, there is some jargon used that is defined in
	other documents. In most cases, we have not copied the text
	from the documents defining the terms but have given a more
	elaborate explanation of the meaning. Note that these
	explanations should not be seen as authoritative.
      
</p>
<p>
	</p>
<blockquote class="text"><dl>
<dt>Anchored key:</dt>
<dd>
	    A DNSKEY configured in resolvers around the globe. This key
	    is hard to update, hence the term anchored.
	  
</dd>
<dt>Bogus:</dt>
<dd>
	    Also see <a class='info' href='#RFC4033'>Section
	    5 of RFC4033<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;DNS Security Introduction and Requirements,&rdquo; March&nbsp;2005.</span><span>)</span></a> [3].  An RRSet in DNSSEC is marked "Bogus" when a
	    signature of an RRSet does not validate against a DNSKEY.
	  
</dd>
<dt>Key Signing Key or KSK:</dt>
<dd>
	    A Key Signing Key (KSK) is a key that is used exclusively for
	    signing the apex key set.  The fact that a key is a KSK is
	    only relevant to the signing tool.
	  
</dd>
<dt>Key size:</dt>
<dd>
	    The term 'key size' can be substituted by 'modulus size'
	    throughout the document. It is mathematically more correct to
	    use modulus size, but as this is a document directed at
	    operators we feel more at ease with the term key size.
	  
</dd>
<dt>Private and public keys:</dt>
<dd>
	    DNSSEC secures the DNS through the use of public key
	    cryptography. Public key cryptography is based on the
	    existence of two (mathematically related) keys, a public
	    key and a private key. The public keys are published in
	    the DNS by use of the DNSKEY Resource Record (DNSKEY
	    RR). Private keys should remain private.
	  
</dd>
<dt>Key rollover:</dt>
<dd>
	    A key rollover (also called key supercession in some
	    environments) is the act of replacing one key pair with
	    another at the end of a key effectivity period.
	  
</dd>
<dt>Refresh Period:</dt>
<dd>
	    The time at the end of the Signature Validity
	    Period during which signatures are refreshed.
	  
</dd>
<dt>Re-Signing frequency:</dt>
<dd> 
	    Frequency with which a signing pass on the zone is
	    performed. Alternatively expressed as "Re-Signing
	    Period". It defines when the zone is exposed to the
	    signer. During a signing pass not all signatures in the
	    zone may be refreshed, that depend refresh
	    frequency/interval.
	  
</dd>
<dt>Secure Entry Point (SEP) key:</dt>
<dd>
	    A KSK that has a DS record in the parent zone pointing to it or is
	    configured as a trust anchor. Although not required by the
	    protocol, we recommend that the SEP flag <a class='info' href='#RFC4035'>[5]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a> is set on these keys.
	  
</dd>
<dt>Self-signature:</dt>
<dd>
            This only applies to signatures over DNSKEYs; a signature
            made with DNSKEY x, over DNSKEY x is called a
            self-signature.  Note: without further information,
            self-signatures convey no trust. They are useful to check
            the authenticity of the DNSKEY, i.e., they can be used as
            a hash.
	  
</dd>
<dt>Signing Jitter:</dt>
<dd>
	    Jitter applied to the signature validty intervall.
	  
</dd>
<dt>Signer:</dt>
<dd>
	    The system that has access to the private key material and
	    signs the Resource Record sets in a zone. A signer may be
	    configured to sign only parts of the zone, e.g., only
	    those RRSets for which existing signatures are about to
	    expire.
	  
</dd>
<dt>Single Type Signing Scheme:</dt>
<dd>
	    A signing scheme whereby the distinction between Zone Signing Keys
	    and Key Signing Keys is not made.
	  
</dd>
<dt>Zone Signing Key (ZSK):</dt>
<dd>
	    A key that is used for signing all data in a zone
	    (except, perhaps, the DNSKEY RRSet).  The fact that a
	    key is a ZSK is only relevant to the signing tool.
	  
</dd>
<dt>Singing the zone file:</dt>
<dd>
	    The term used for the event where an administrator joyfully
	    signs its zone file while producing melodic sound patterns.
	  
</dd>
<dt>Zone administrator:</dt>
<dd>
	    The 'role' that is responsible for signing a zone and
	    publishing it on the primary authoritative server.
	  
</dd>
</dl></blockquote><p>
	
      
</p>
<a name="typography"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Typographic Conventions</h3>

<p>
	The following typographic conventions are used in this document:
	
	</p>
<blockquote class="text"><dl>
<dt>Key notation:</dt>
<dd>
	    A key is denoted by DNSKEY_x_y, where y is an identifier
	    for the type of key: K for Keys Signing Key, Z for Zone
	    Signing Key and S when there is no distinction made
	    between KSK and ZSKs but the key is used as a secure entry
	    point. The 'x' denotes a number or an identifier, x could be thought
	    of as the key id.
	  
</dd>
<dt>RRSet notations:</dt>
<dd>
	    RRs are only denoted by the type. All other information
	    -- owner, class, rdata, and TTL -- is left out. Thus:
	    "example.com 3600 IN A 192.0.2.1" is reduced to
	    "A". RRSets are a list of RRs. A example of this would
	    be "A1, A2", specifying the RRSet containing two "A"
	    records. This could again be abbreviated to just "A".
	  
</dd>
<dt>Signature notation:</dt>
<dd>
	    Signatures are denoted as RRSIG_x_y(RRSet), which means
	    that RRSet is signed with DNSKEY_x_y.
	  
</dd>
<dt>Zone representation:</dt>
<dd>
	    Using the above notation we have simplified the
	    representation of a signed zone by leaving out all
	    unnecessary details such as the names and by
	    representing all data by "SOAx"
	  
</dd>
<dt>SOA representation:</dt>
<dd>
	    SOAs are represented as SOAx, where x is the serial
	    number.
	  
</dd>
<dt>RRsets ignored:</dt>
<dd>
	    If the signature of non DNSKEY RRsets have the same
	    parameters as the SOA than those are not
	    mentioned. e.g. In the example below the SOA is signed
	    with the same parameters as the foo.example.com A RRset
	    and the latter is therefore ignored in the abbreviated
	    notation.
	  
</dd>
</dl></blockquote><p>
	
	Using this notation the following signed zone:
	
	</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 example.com.  3600  IN SOA   ns1.example.com. olaf.example.net. (
                         2005092303 ; serial
                         450        ; refresh (7 minutes 30 seconds)
                         600        ; retry (10 minutes)
                         345600     ; expire (4 days)
                         300        ; minimum (5 minutes)
                         )
        3600    RRSIG    SOA 5 2 3600 20120824013000 (
                         20100424013000 14 example.com.
                         NMafnzmmZ8wevpCOI+/JxqWBzPxrnzPnSXfo
                         ...
                         OMY3rTMA2qorupQXjQ== )
        3600    NS    ns1.example.com.
        3600    NS    ns2.example.com.
        3600    NS    ns3.example.com.
        3600    RRSIG    NS 5 2 3600 20120824013000 (
                         20100424013000 14 example.com.
                         p0Cj3wzGoPFftFZjj3jeKGK6wGWLwY6mCBEz
                         ...
                         +SqZIoVHpvE7YBeH46wuyF8w4XknA4Oeimc4
                         zAgaJM/MeG08KpeHhg== )
        3600    TXT      "Net::DNS  domain"
        3600    RRSIG    TXT 5 2 3600 20120824013000 (
                         20100424013000 14 example.com.
                         o7eP8LISK2TEutFQRvK/+U3wq7t4X+PQaQkp
                         ...
                         BcQ1o99vwn+IS4+J1g== )
        300    NSEC      foo.example.com. NS SOA TXT RRSIG NSEC DNSKEY
        300    RRSIG     NSEC 5 2 300 20120824013000 (
                         20100424013000 14 example.com.
                         JtHm8ta0diCWYGu/TdrE1O1sYSHblN2i/IX+
                         ...
                         PkXNI/Vgf4t3xZaIyw== )
        3600    DNSKEY   256 3 5 (
                         AQPaoHW/nC0fj9HuCW3hACSGiP0AkPS3dQFX
                         ...
                         sAuryjQ/HFa5r4mrbhkJ
                         ) ; key id = 14
        3600    DNSKEY   257 3 5 (
                         AQPUiszMMAi36agx/V+7Tw95l8PYmoVjHWvO
                         ...
                         oy88Nh+u2c9HF1tw0naH
                         ) ; key id = 15
        3600    RRSIG    DNSKEY 5 2 3600 20120824013000 (
                         20100424013000 14 example.com.
                         HWj/VEr6p/FiUUiL70QQWtk+NBIlsJ9mdj5U
                         ...
                         QhhmMwV3tIxJk2eDRQ== )
        3600    RRSIG    DNSKEY 5 2 3600 20120824013000 (
                         20100424013000 15 example.com.
                         P47CUy/xPV8qIEuua4tMKG6ei3LQ8RYv3TwE
                         ...
                         JWL70YiUnUG3m9OL9w== )
foo.example.com.  3600  IN A 192.0.2.2
        3600    RRSIG    A 5 3 3600 20120824013000 (
                         20100424013000 14 example.com.
                         xHr023P79YrSHHMtSL0a1nlfUt4ywn/vWqsO
                         ...
                         JPV/SA4BkoFxIcPrDQ== )
        300    NSEC      example.com. A RRSIG NSEC
        300    RRSIG     NSEC 5 3 300 20120824013000 (
                        20100424013000 14 example.com.
                         Aaa4kgKhqY7Lzjq3rlPlFidymOeBEK1T6vUF
                         ...
                         Qe000JyzObxx27pY8A== )
</pre></div><p>

	
	is reduced to the following representation:
	
	</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         SOA2005092303
         RRSIG_Z_14(SOA2005092303)
         DNSKEY_K_14
         DNSKEY_Z_15
         RRSIG_K_14(DNSKEY)
         RRSIG_Z_15(DNSKEY)
</pre></div><p>

	
	
	
	
	The rest of the zone data has the same signature as the SOA
	record, i.e., an RRSIG created with DNSKEY 14.
	
      
</p>
<a name="AlgoFigures"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C"></a><h3>Appendix C.&nbsp;
Transition Figures for Special Case Algorithm Rollovers</h3>

<p> The figures appendix complement and illustrate the special
      cases of algorithm rollovers as described in <a class='info' href='#KAR'>Section&nbsp;4.1.5<span> (</span><span class='info'>Algorithm rollovers</span><span>)</span></a>
      
</p>
<p>
	<br /><hr class="insert" />
<a name="single-type-algorithm-roll-fig"></a>

<p>
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

______________________________________________________________________

 ----------------------------------------------------------------
  1 Initial            2 New RRSIGS         3 New DNSKEY
 ----------------------------------------------------------------
  Parent:
   SOA0                 -------------- ( SOA ) --------------&gt;
   RRSIG_par(SOA)       -------------------------------------&gt;
   DS_K_1               -------------------------------------&gt;
   RRSIG_par(DS_K_1)    -------------------------------------&gt;

  Child:
   SOA0                 SOA1                 SOA2
   RRSIG_K_1(SOA)       RRSIG_K_1(SOA)       RRSIG_K_1(SOA)
                        RRSIG_K_2(SOA)       RRSIG_K_2(SOA)

   DNSKEY_K_1           DNSKEY_K_1           DNSKEY_K_1
   RRSIG_K_1(DNSKEY)    RRSIG_K_1(DNSKEY)    DNSKEY_K_2
                        RRSIG_K_2(DNSKEY)    RRSIG_K_1(DNSKEY)
                                             RRSIG_K_2(DNSKEY)
  ----------------------------------------------------------------
  4 Exchange DS         5 Remove DNSKEY      6 Remove RRSIGS
  ----------------------------------------------------------------
  Parent:
   SOA1                 -------------( SOA )----------------&gt;
   RRSIG_par(SOA)       -------------------------------------&gt;
   DS_K_2               -------------------------------------&gt;
   RRSIG_par(DS_K_2)    -------------------------------------&gt;

  Child:
   ---- (SOA2 ) ---&gt;    SOA3                 SOA4
   ----------------&gt;    RRSIG_K_1(SOA)       RRSIG_K_2(SOA)
   ----------------&gt;    RRSIG_K_2(SOA)

   ----------------&gt;    DNSKEY_K_2           DNSKEY_K_2
   ----------------&gt;    RRSIG_K_1(DNSKEY)    RRSIG_K_2(DNSKEY)
   ----------------&gt;    RRSIG_K_2(DNSKEY)
  ----------------------------------------------------------------


</pre></div>
<p>
	    
<p>  Also see <a class='info' href='#SingleTypeAlg'>Section&nbsp;4.1.5.2<span> (</span><span class='info'>Single Type Signing Scheme Algorithm Rollover</span><span>)</span></a>.
</p>
	  
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;11: Single Type Signing Scheme Algorithm Roll&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

	

	<br /><hr class="insert" />
<a name="5011-algorithm-roll-fig"></a>

<p>
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
______________________________________________________________________

-------------------------------------------------------------------
1 Initial            2 New RRSIGS         3 New DNSKEY
-------------------------------------------------------------------
Parent:
 SOA0                 -------------- ( SOA ) --------------&gt;
 RRSIG_par(SOA)       -------------------------------------&gt;
 DS_K_1               -------------------------------------&gt;
 RRSIG_par(DS_K_1)    -------------------------------------&gt;

Child:
 SOA0                 SOA1                 SOA2
 RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)
                      RRSIG_Z_2(SOA)       RRSIG_Z_2(SOA)

 DNSKEY_K_1           DNSKEY_K_1           DNSKEY_K_1
 DNSKEY_Z_1           DNSKEY_Z_1           DNSKEY_Z_1
 RRSIG_K_1(DNSKEY)    RRSIG_K_1(DNSKEY)    DNSKEY_K_2
                      RRSIG_K_2(DNSKEY)    DNSKEY_Z_2
                                           RRSIG_K_1(DNSKEY)
                                           RRSIG_K_2(DNSKEY)
--------------------------------------------------------------------
4 Exchange DS         4b Revoke DNSKEY     5 Remove DNSKEY
--------------------------------------------------------------------
Parent:
 SOA1                 -------------( SOA )----------------&gt;
 RRSIG_par(SOA)       -------------------------------------&gt;
 DS_K_2               -------------------------------------&gt;
 RRSIG_par(DS_K_2)    -------------------------------------&gt;

Child:
 ---- (SOA2 ) ---&gt;    SOA3                 SOA4
 ----------------&gt;    RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)
 ----------------&gt;    RRSIG_Z_2(SOA)       RRSIG_Z_2(SOA)

 ----------------&gt;    DNSKEY_K_1_REVOKED   DNSKEY_K_2
 ----------------&gt;    DNSKEY_Z_1           DNSKEY_Z_2
 ----------------&gt;    DNSKEY_K_2           RRSIG_K_1_REVOKED(DNSKEY)
 ----------------&gt;    DNSKEY_Z_2           RRSIG_K_2(DNSKEY)
 ----------------&gt;    RRSIG_K_1_REVOKED(DNSKEY)
 ----------------&gt;    RRSIG_K_2(DNSKEY)
--------------------------------------------------------------------
6 Remove RRSIGS
--------------------------------------------------------------------
Parent:
 --------------( SOA )----------------&gt;
 -------------------------------------&gt;
 -------------------------------------&gt;
 -------------------------------------&gt;

Child:
 SOA5
 RRSIG_Z_2(SOA)

 DNSKEY_K_2
 DNSKEY_Z_2
 RRSIG_K_2(DNSKEY)
--------------------------------------------------------------------
</pre></div>
<p>
	    
<p>  Also see <a class='info' href='#5011style'>Section&nbsp;4.1.5.3<span> (</span><span class='info'>Algorithm rollover, RFC5011 style</span><span>)</span></a>.
</p>
	  
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;12: RFC5011 Style algorithm roll&nbsp;</b></font><br /></td></tr></table><hr class="insert" />


	<br /><hr class="insert" />
<a name="single-type-5011-roll-fig"></a>

<p>
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
______________________________________________________________________



-------------------------------------------------------------------
 1 Initial            2 New RRSIGS         3 New DNSKEY
-------------------------------------------------------------------
Parent:
 SOA0                 -------------- ( SOA ) --------------&gt;
 RRSIG_par(SOA)       -------------------------------------&gt;
 DS_K_1               -------------------------------------&gt;
 RRSIG_par(DS_K_1)    -------------------------------------&gt;

Child:
 SOA0                 SOA1                 SOA2
 RRSIG_K_1(SOA)       RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)
                      RRSIG_Z_2(SOA)       RRSIG_K_2(SOA)

 DNSKEY_K_1           DNSKEY_K_1           DNSKEY_K_1
 RRSIG_K_1(DNSKEY)    DNSKEY_Z_1           DNSKEY_Z_1
                      RRSIG_K_1(DNSKEY)    DNSKEY_K_2
                      RRSIG_K_2(DNSKEY)    RRSIG_K_1(DNSKEY)
                                           RRSIG_K_2(DNSKEY)
-------------------------------------------------------------------
4 Exchange DS         4b Revoke DNSKEY     5 Remove DNSKEY
-------------------------------------------------------------------
Parent:
 SOA1                 -------------( SOA )----------------&gt;
 RRSIG_par(SOA)       -------------------------------------&gt;
 DS_K_2               -------------------------------------&gt;
 RRSIG_par(DS_K_2)    -------------------------------------&gt;

Child:
 ---- (SOA2 ) ---&gt;    SOA3                 SOA4
 ----------------&gt;    RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)
 ----------------&gt;    RRSIG_Z_2(SOA)       RRSIG_Z_2(SOA)

 ----------------&gt;    DNSKEY_K_1_REVOKED   DNSKEY_K_2
 ----------------&gt;    DNSKEY_Z_1           RRSIG_K_1_REVOKED(DNSKEY)
 ----------------&gt;    DNSKEY_K_2           RRSIG_K_2(DNSKEY)
 ----------------&gt;    RRSIG_K_1_REVOKED(DNSKEY)
 ----------------&gt;    RRSIG_K_2(DNSKEY)
-------------------------------------------------------------------
6 Remove RRSIGS
-------------------------------------------------------------------
Parent:
 --------------( SOA )----------------&gt;
 -------------------------------------&gt;
 -------------------------------------&gt;
 -------------------------------------&gt;

Child:
 SOA5
 RRSIG_K_2(SOA)

 DNSKEY_K_2
 RRSIG_K_2(DNSKEY)
-------------------------------------------------------------------
</pre></div>
<p>
	    
<p>  Also see <a class='info' href='#5011andSingleType'>Section&nbsp;4.1.5.4<span> (</span><span class='info'>Single Signing Type, RFC5011 style rollovers</span><span>)</span></a>.
</p>
	  
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;13: RFC5011 algorithm roll in a Single Type Signing Sheme Environment&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



      

<a name="DED"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D"></a><h3>Appendix D.&nbsp;
Document Editing History</h3>

<p>
      [To be removed prior to publication as an RFC]
      
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.1"></a><h3>D.1.&nbsp;
draft-ietf-dnsop-rfc4641-00</h3>

<p>
	  Version 0 was differs from RFC4641 in the following ways.
	  </p>
<ul class="text">
<li>
	      Status of this memo appropriate for I-D
	    
</li>
<li>
	      TOC formatting differs.
	    
</li>
<li>
	      Whitespaces, linebreaks, and pagebreaks may be slightly different
	      because of xml2rfc generation.
	    
</li>
<li>
	      References slightly reordered.
	    
</li>
<li>
	      Applied the errata from
	      http://www.rfc-editor.org/errata_search.php?rfc=4641
	    
</li>
<li>
	      Inserted trivial "IANA considertations" section.
	    
</li>
</ul><p>

	  In other words it should not contain substantive changes in
	  content as intended by the workinggroup for the original RFC4641.
	  
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.2"></a><h3>D.2.&nbsp;
version 0->1</h3>

<p>Cryptography details rewritten.
	  (See http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/cryptography_flawed)
	  
</p>
<p>
	    </p>
<ul class="text">
<li>Reference to NIST 800-90 added
</li>
<li>RSA/SHA256 is being recommended in addition to RSA/SHA1.
</li>
<li> Complete rewrite of <a class='info' href='#key sizes'>Section&nbsp;3.4.2<span> (</span><span class='info'>Key Sizes</span><span>)</span></a>
	      removing the table and suggesting a keysize of 1024 for
	      keys in use for less than 8 years, issued up to at least
	      2015.  
</li>
<li>Replaced the reference to Schneiers' applied cryptograpy with a reference to RFC4949.
	      
</li>
<li> Removed the KSK for high level zones consideration
</li>
</ul><p>
	  
</p>
<p>
	    Applied some differentiation with respect of the use of a
	    KSK for parent or trust-anchor relation
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/differentiation_trustanchor_parent
	  
</p>
<p>
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/rollover_assumptions
	  
</p>
<p>
	    Added <a class='info' href='#KAR'>Section&nbsp;4.1.5<span> (</span><span class='info'>Algorithm rollovers</span><span>)</span></a> as suggested by Jelte Jansen
	    in
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/Key_algorithm_roll
	  
</p>
<p>
	    Added <a class='info' href='#non_cooperating_registrars'>Section&nbsp;4.3.5.1<span> (</span><span class='info'>Cooperationg DNS operators</span><span>)</span></a> Issue
	    identified by Antoin Verschuur
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/non-cooperative-registrars
	  
</p>
<p>
	  In <a class='info' href='#terminology'>Appendix&nbsp;A<span> (</span><span class='info'>Terminology</span><span>)</span></a>: ZSK does not nescessarily sign the DNSKEY RRset.
	  
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.3"></a><h3>D.3.&nbsp;
version 1->2</h3>

<p>
	    </p>
<ul class="text">
<li>
		Significant rewrite of <a class='info' href='#keys'>Section&nbsp;3<span> (</span><span class='info'>Keys Generation and Storage</span><span>)</span></a> whereby the
		argument is made that the timescakes for rollovers are
		made purely on operational arguments hopefully resolving
		http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/discussion_of_timescales
	      
</li>
<li>
		Added <a class='info' href='#nsec_nsec3'>Section&nbsp;5<span> (</span><span class='info'>Next Record type</span><span>)</span></a> based on
		http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/NSEC-NSEC3
	      
</li>
<li>
		Added a reference to <a class='info' href='#I-D.ietf-dnsop-dnssec-key-timing'>draft-morris-dnsop-dnssec-key-timing<span> (</span><span class='info'>Morris, S., Ihren, J., and J. Dickinson, &ldquo;DNSSEC Key Timing Considerations,&rdquo; July&nbsp;2010.</span><span>)</span></a> [24]
		for the quantitative analysis on keyrolls 
	      
</li>
<li> 
		Updated <a class='info' href='#changing-operators'>Section&nbsp;4.3.5<span> (</span><span class='info'>Changing DNS Operators</span><span>)</span></a> to reflect
		that the problem occurs when changing DNS operators, and
		not DNS registrars, also added the table indicating the
		redelegation procedure. Added text about the fact that
		implementations will dismiss keys that fail to validate
		at some point.
	      
</li>
<li> 
		Updated a number of references.
	      
</li>
</ul><p>
	  
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.4"></a><h3>D.4.&nbsp;
version 2->3</h3>

<p>
	  </p>
<ul class="text">
<li>
	      Added bulleted list to serve as an introduction on the
	      decision tree in <a class='info' href='#keys'>Section&nbsp;3<span> (</span><span class='info'>Keys Generation and Storage</span><span>)</span></a>.
	    
</li>
<li>
	      In section <a class='info' href='#zsk-ksk-motivation'>Section&nbsp;3.1<span> (</span><span class='info'>Operational Motivation for Zone Signing and Key Signing Keys</span><span>)</span></a>:
	    
<ul class="text">
<li>
		tried to motivate that keylength is not a strong
		motivation for KSK ZSK split (based on
		http://www.educatedguesswork.org/2009/10/on_the_security_of_zsk_rollove.html)
	      
</li>
<li>
		Introduced Common Signing Key terminology and made the
		arguments for the choice of a Common Signing Key more
		explicit.
	      
</li>
<li>
		Moved the SEP flag considerations to its own paragraph
	      
</li>
</ul>
	    
</li>
<li>
	      In a few places in the document, but section <a class='info' href='#sigs_keyrolls_policies'>Section&nbsp;4<span> (</span><span class='info'>Signature Generation, Key Rollover, and Related Policies</span><span>)</span></a> in particular the
	      comments from Patrik Faltstrom (On Mar 24, 2010) on the
	      clarity on the roles of the registrant, dns operator,
	      registrar and registry was addressed.
	    
</li>
<li>
	      Added some terms based on
	      http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/timing_terminology
	    
</li>
<li>
	      Added paragrap 2 and clarified the second but last
	      paragraph of <a class='info' href='#rolling-ksk-ta'>Section&nbsp;3.2.2<span> (</span><span class='info'>Rolling a KSK that is a trust-anchor</span><span>)</span></a>.
	    
</li>
<li>
	      Clarified the table and some text in <a class='info' href='#KAR'>Section&nbsp;4.1.5<span> (</span><span class='info'>Algorithm rollovers</span><span>)</span></a>. Also added some text on what happens
	      when the algorithm rollover also involves a roll from
	      NSEC to NSEC3.
	    
</li>
<li>
	      Added a paragraph about rolling KSKs that are also
	      configured as trust-anchors in <a class='info' href='#ksk-rollover'>Section&nbsp;4.1.2<span> (</span><span class='info'>Key Signing Key Rollovers</span><span>)</span></a>
	    
</li>
<li>
	      Added <a class='info' href='#STSrollover'>Section&nbsp;4.1.4<span> (</span><span class='info'>Rollover for a Single Type Signing Key rollover</span><span>)</span></a>.
	    
</li>
<li>
	      Added <a class='info' href='#sigval'>Section&nbsp;4.4.2<span> (</span><span class='info'>Signature Validation Periods</span><span>)</span></a> to address issue "Signature_validity"
	    
</li>
</ul><p>
	  
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.5"></a><h3>D.5.&nbsp;
version 3->4</h3>

<p>
	  </p>
<ul class="text">
<li>Stephen Morris submitted a large number of language, style and editorial nits.
</li>
<li><a class='info' href='#KAR'>Section&nbsp;4.1.5<span> (</span><span class='info'>Algorithm rollovers</span><span>)</span></a> improved based on comments from  Olafur Gudmundsson and Ondrej Sury.
</li>
<li>Tried to improve consistency of notation in the various rollover figures
</li>
</ul><p>
	  
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.6"></a><h3>D.6.&nbsp;
version 4->5</h3>

<p>
	  </p>
<ul class="text">
<li>Improved consistendy of notation
</li>
<li>Matthijs Mekking provided substantive feedback on algorighm rollover and suggested the content of the subsections of <a class='info' href='#KAR'>Section&nbsp;4.1.5<span> (</span><span class='info'>Algorithm rollovers</span><span>)</span></a> and the content of the figures in <a class='info' href='#AlgoFigures'>Appendix&nbsp;C<span> (</span><span class='info'>Transition Figures for Special Case Algorithm Rollovers</span><span>)</span></a>
</li>
</ul><p>
	  
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.7"></a><h3>D.7.&nbsp;
Subversion infromation</h3>

<p>www.nlnetlabs.nl/svn/rfc4641bis/
</p>
<p>$Id: draft-ietf-dnsop-rfc4641bis-05.xml 71 2010-10-22 19:19:43Z olaf $
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Olaf M. Kolkman</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NLnet Labs</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Kruislaan 419</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Amsterdam  1098 VA</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The Netherlands</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:olaf@nlnetlabs.nl">olaf@nlnetlabs.nl</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.nlnetlabs.nl">http://www.nlnetlabs.nl</a></td></tr>
</table>
</body></html>
