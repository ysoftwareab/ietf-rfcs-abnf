





IPSEC Working Group                                   Charlie Kaufman
INTERNET-DRAFT                                                 editor
draft-ietf-ipsec-ikev2-03.txt                            October 2002


                 Internet Key Exchange (IKEv2) Protocol
                    <draft-ietf-ipsec-ikev2-03.txt>


                          Status of this Memo

   This document is an Internet Draft and is in full conformance with
   all provisions of Section 10 of RFC2026 [Bra96]. Internet Drafts are
   working documents of the Internet Engineering Task Force (IETF), its
   areas, and working groups. Note that other groups may also distribute
   working documents as Internet Drafts.

   Internet Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time. It is inappropriate to use Internet Drafts as reference
   material or to cite them other than as "work in progress."

   To learn the current status of any Internet Draft, please check the
   "1id-abstracts.txt" listing contained in the Internet Drafts Shadow
   Directories on ftp.is.co.za (Africa), nic.nordu.net (Europe),
   munnari.oz.au (Australia), ds.internic.net (US East Coast), or
   ftp.isi.edu (US West Coast).


Abstract

   This document describes version 2 of the IKE (Internet Key Exchange)
   protocol.  IKE performs mutual authentication and establishes an IKE
   security association that can be used to efficiently establish SAs
   for ESP, AH and/or IPcomp. This version greatly simplifies IKE by
   replacing the 8 possible phase 1 exchanges with a single exchange
   based on either public signature keys or shared secret keys.  The
   single exchange provides identity hiding, yet works in 2 round trips
   (all the identity hiding exchanges in IKE v1 required 3 round trips).
   Latency of setup of an IPsec SA is further reduced from IKEv1 by
   allowing setup of an SA for ESP, AH, and/or IPcomp to be piggybacked
   on the initial IKE exchange.  It also improves security by allowing
   the Responder to be stateless until it can be assured that the
   Initiator can receive at the claimed IP source address.  This version
   also presents the entire protocol in a single self-contained
   document, in contrast to IKEv1, in which the protocol was described
   in ISAKMP (RFC 2408), IKE (RFC 2409), and the DOI (RFC 2407)
   documents.



IKEv2                                                       [Page 1]






INTERNET DRAFT                                              October 2002


Table of Contents


   Abstract.....................................................1
   1 Summary of Changes from IKEv1..............................3
   2 Requirements Terminology...................................4
   3 IKE Protocol Overview......................................4
   3.1 The Initial (Phase 1) Exchange...........................6
   3.2 The CREATE_CHILD_SA (Phase 2) Exchange...................7
   3.3 Informational (Phase 2) Exchange.........................9
   4 IKE Protocol Details and Variations.......................10
   4.1 Use of Retransmission Timers............................10
   4.2 Use of Sequence Numbers for Message ID..................11
   4.3 Window Size for overlapping requests....................12
   4.4 State Synchronization and Connection Timeouts...........12
   4.5 Version Numbers and Forward Compatibility...............14
   4.6 Cookies.................................................15
   4.7 Cryptographic Algorithm Negotiation.....................18
   4.8 Rekeying................................................19
   4.9 Traffic Selector Negotiation............................20
   4.10 Nonces.................................................21
   4.11 Address and Port Agility...............................22
   4.12 Reuse of Diffie-Hellman Exponentials...................22
   4.13 Generating Keying Material.............................23
   4.14 Generating Keying Material for the IKE-SA..............23
   4.15 Authentication of the IKE-SA...........................24
   4.16 Generating Keying Material for Child-SAs...............25
   4.17 Rekaying IKE-SAs using a CREATE_CHILD_SA exchange......26
   4.18 Error Handling.........................................26
   5 Header and Payload Formats................................27
   5.1 The IKE Header..........................................27
   5.2 Generic Payload Header..................................30
   5.3 Security Association Payload............................31
   5.3.1 Proposal Substructure.................................32
   5.4 Key Exchange Payload....................................33
   5.5 Identification Payload..................................34
   5.6 Certificate Payload.....................................36
   5.7 Certificate Request Payload.............................37
   5.8 Authentication Payload..................................38
   5.9 Nonce Payload...........................................39
   5.10 Notify Payload.........................................40
   5.10.1 Notify Message Types.................................41
   5.11 Delete Payload.........................................43
   5.12 Vendor ID Payload......................................45
   5.13 Traffic Selector Payload...............................46
   5.13.1 Traffic Selector.....................................46
   5.14 Encrypted Payload......................................48
   5.15 Other Payload types....................................49



IKEv2                                                       [Page 2]






INTERNET DRAFT                                              October 2002


   6 Conformance Requirements..................................50
   7 Security Considerations...................................50
   8 IANA Considerations.......................................51
   9 Acknowledgements..........................................52
   10 References...............................................52
   Appendix B: Diffie-Hellman Groups...........................55
   Change History..............................................58
   Author's Address............................................59

1 Summary of changes from IKEv1


   The goals of this revision to IKE are:

   1) To define the entire IKE protocol in a single document, rather
   than three that cross reference one another;

   2) To simplify IKE by replacing the eight different initial phase 1
   exchanges with a single four message exchange (with changes in
   authentication mechanisms affecting only a single AUTH payload rather
   than restructuring the entire exchange);

   3) To remove the Domain of Interpretation (DOI), Situation (SIT), and
   Labeled Domain Identifier fields, and the Commit and Authentication
   only bits;

   4) To decrease IKE's latency by making the initial exchange be 2
   round trips (4 messages), and allowing the ability to piggyback setup
   of a Child-SA on that exchange;

   5) To replace the cryptographic syntax for protecting the IKE
   messages themselves with one based closely on ESP to simplify
   implementation and security analysis;

   6) To reduce the number of possible error states by making the
   protocol reliable (all messages are acknowledged) and sequenced. This
   allows shortening Phase 2 exchanges from 3 messages to 2;

   7) To increase robustness by allowing the responder to not do
   significant processing until it receives a message proving that the
   initiator can receive messages at its claimed IP address, and not
   commit any state to an exchange until the initiator can be
   cryptographically authenticated;

   8) To fix bugs such as the hash problem documented in [draft-ietf-
   ipsec-ike-hash-revised-02.txt];

   9) To specify Traffic Selectors in their own payloads type rather



IKEv2                                                       [Page 3]






INTERNET DRAFT                                              October 2002


   than overloading ID payloads, and making more flexible the Traffic
   Selectors that may be specified;

   10) To replace the complex mix and match negotiation of cryptographic
   algorithms with proposals based on suites of algorithms.

   11) To specify required behavior under certain error conditions or
   when data that is not understood is received in order to make it
   easier to make future revisions in a way that does not break
   backwards compatibility;

   12) To simplify and clarify how shared state is maintained in the
   presence of network failures and Denial of Service attacks; and

   13) To maintain existing syntax and magic numbers to the extent
   possible to make it likely that implementations of IKEv1 can be
   enhanced to support IKEv2 with minimum effort.

2 Requirements Terminology

   Keywords "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT" and
   "MAY" that appear in this document are to be interpreted as described
   in [Bra97].

3 IKE Protocol Overview

   IP Security (IPsec) provides confidentiality, data integrity, and
   data source authentication to IP datagrams. These services are
   provided by maintaining shared state between the source and the sink
   of an IP datagram. This state defines, among other things, the
   specific services provided to the datagram, which cryptographic
   algorithms will be used to provide the services, and the keys used as
   input to the cryptographic algorithms.

   Establishing this shared state in a manual fashion does not scale
   well.  Therefore a protocol to establish this state dynamically is
   needed.  This memo describes such a protocol-- the Internet Key
   Exchange (IKE).  This is version 2 of IKE. Version 1 of IKE was
   defined in RFCs 2407, 2408, and 2409. This single document is
   intended to replace all three of those RFCs.

   IKE performs mutual authentication between two parties and
   establishes an IKE security association that includes shared secret
   information that can be used to efficiently establish SAs for ESP
   (RFC 2406), AH (RFC 2402) and/or IPcomp (RFC 2393).  We call the IKE
   SA an "IKE-SA". The SAs for ESP, AH, and/or IPcomp that get set up
   through that IKE-SA we call "child-SA"s.




IKEv2                                                       [Page 4]






INTERNET DRAFT                                              October 2002


   We call the first four messages establishing an IKE-SA a "phase 1"
   exchange and subsequent IKE exchanges "phase 2", inheriting this
   terminology from IKEv1. The phase 1 exchange establishes the IKE-SA
   and the first child-SA. In some scenarios, only a single child-SA is
   needed between the IPsec endpoints and therefore there would be no
   phase 2 exchanges. Phase 2 exchanges MAY be used to establish
   additional child-SAs between the same authenticated pair of endpoints
   as well as other housekeeping.  The phase 1 exchange consists of two
   request/response pairs.  A phase 2 exchange is one request/response
   pair, and can be used to create or delete a child-SA, rekey or delete
   the IKE-SA, or report information such as error conditions.

   IKE message flow always consists of a request followed by a response.
   It is the responsibility of the requester to ensure reliability.  If
   the response is not received within a timeout interval, the requester
   MUST retransmit the request (or abandon the connection).

   The first request/response of a phase 1 exchange negotiates security
   parameters for the IKE-SA, sends nonces, and sends Diffie-Hellman
   values. We call the request message IKE_SA_init and the response
   IKE_SA_init_response.

   The second request/response, which we'll call IKE_auth and
   IKE_auth_response transmits identities, proves knowledge of the
   secrets corresponding to the two identities, and sets up an SA for
   the first (and often only) AH and/or ESP and/or IPcomp child-SA. In
   order to allow Bob to be stateless until receiving message 3, message
   3 must repeat all of message 1 and Bob must be able to reconstruct
   (bit for bit) what he sent in message 2.

   Phase 2 exchanges each consist of a single request/response pair. The
   types of exchanges are CREATE_CHILD_SA (which creates a child-SA), or
   an Informational exchange which deletes a child-SA or the IKE-SA or
   informs the other side of some error condition.  All these messages
   require a response. An informational message with no payloads is
   commonly used as a check for liveness.

   In the description that follow, we assume that no errors occur.
   Modifications to the flow should errors occur are described in
   section 4.

3.1 The Initial (Phase 1) Exchange

   The base Phase 1 exchange is a four message exchange (two
   request/response pairs). The first pair of messages (IKE_SA_init)
   negotiate cryptographic algorithms, exchange nonces, and do a
   Diffie-Hellman exchange.




IKEv2                                                       [Page 5]






INTERNET DRAFT                                              October 2002


   The second pair of messages (IKE_AUTH) authenticate the previous
   messages, exchange identities and certificates, and establish the
   first child_SA. Parts of these messages are encrypted and integrity
   protected with keys established through the IKE_SA_init exchange, so
   the identities are hidden from eavesdroppers and all fields in all
   the messages are authenticated.

   In the following description, the payloads contained in the message
   are indicated by names such as SA. The details of the contents of
   each payload are described later. Payloads which may optionally
   appear will be shown in brackets, such as [CERTREQ], would indicate
   that optionally a certificate request payload can be included.

   The Phase 1 exchange is as follows:

       Initiator                          Responder
      -----------                        -----------
       HDR, SAi1, KEi, Ni   -->

   HDR contains the SPIs (formerly called cookies), version numbers, and
   flags of various sorts.  The SAi1 payload states the cryptographic
   algorithms the Initiator supports for the IKE SA.  The KE payload
   sends the Initiator's Diffie-Hellman value. Ni is the Initiator's
   nonce.

                            <--    HDR, SAr1, KEr, Nr, [CERTREQ]

   The Responder chooses a cryptographic suite from the Initiator's
   offered choices and expresses that choice in the SAr1 payload,
   completes the Diffie-Hellman exchange with the KEr payload, and sends
   its nonce in the Nr payload.

   At this point in time each party can generate SKEYSEED from which all
   keys are derived for that IKE SA.  Parts of the following two
   messages, the IKE_AUTH and IKE_AUTH_response, are encrypted and
   integrity protected.  The keys used for the encryption and integrity
   protection are derived from SKEYSEED and are known as SK_e
   (encryption) and SK_a (authentication, a.k.a.  integrity protection).
   A separate SK_e and SK_a is computed for each direction.  The
   notation SK { ... } indicates that these payloads are encrypted and
   integrity protected using that direction's SK_e and SK_a.

       HDR, SAi1, KEi, Ni, Nr,
             SK {IDi, [CERT,] [CERTREQ,] [IDr,]
                  AUTH, SAi2, TSi, TSr}     -->

   The initial payloads in message three are identical to the payloads
   in message 1. If message 1 included any optional payloads (e.g.



IKEv2                                                       [Page 6]






INTERNET DRAFT                                              October 2002


   Vendor ID), they must be repeated in message 3 in the same order.
   Then she includes Nr (Bob's nonce) copied from message 2.  The
   Initiator identifies herself with the IDi payload, proves knowledge
   of the secret corresponding to IDi and integrity protects the
   contents of the first two messages using the AUTH payload. She might
   also send her certificate(s) in CERT payload(s) and a list of her
   trust anchors in CERTREQ payload(s).  The optional payload IDr
   enables Alice to specify which of Bob's identities she wants to talk
   to. This is useful when Bob is hosting multiple identities at the
   same IP address.  She begins negotiation of a child-SA using the SAi2
   payload. The fields starting with SAi2 are described in the
   description of Phase 2.

   There are optional fields where the Initiator can provide
   certificates [CERT] the Responder might find useful in validating
   AUTH, her list of preferred root certifiers [CERTREQ], and the name
   of the entity with which she is trying to open a connection [IDr]
   (for the case where multiple named entities exist at a single IP
   address).

                                   <--    HDR, SK {IDr, [CERT,] AUTH,
                                                SAr2, TSi, TSr}

   The Responder identifies himself with the IDr payload, optionally
   sends one or more certificates, authenticates himself with the AUTH
   payload, and completes negotiation of a child-SA with the additional
   fields described below in the phase 2 exchange.

   The recipients of messages 3 and 4 MUST verify that all signatures
   and MACs are computed correctly and that the names in the ID payloads
   correspond to the keys used to generate the AUTH payload.

3.2 The CREATE_CHILD_SA (Phase 2) Exchange

   A phase 2 exchange is one request/response pair, and can be used to
   create or delete a child-SA, delete or rekey the IKE-SA, check the
   liveness of the IKE-SA, or deliver information such as error
   conditions. It is encrypted and integrity protected using the keys
   negotiated during the creation of the IKE-SA.

   Messages are cryptographically protected using the cryptographic
   algorithms and keys negotiated in the first two messages of the IKE
   exchange using a syntax described in section 5.14.  Encryption uses
   keys derived from SK_e, one in each direction; Integrity uses keys
   derived from SK_a, one in each direction.

   Either endpoint may initiate a CREATE_CHILD_SA exchange, so in this
   section the term Initiator refers to the endpoint initiating this



IKEv2                                                       [Page 7]






INTERNET DRAFT                                              October 2002


   exchange.

   A child-SA is created by sending a CREATE_CHILD_SA request.  The
   CREATE_CHILD_SA request MAY optionally contain a KE payload for an
   additional Diffie-Hellman exchange to enable stronger guarantees of
   forward secrecy for the child-SA. The keying material for the child-
   SA is a function of SK_d established during the establishment of the
   IKE-SA, the nonces exchanged during the CREATE_CHILD_SA exchange, and
   the Diffie-Hellman value (if KE payloads are included in the
   CREATE_CHILD_SA exchange).

   In the child-SA created as part of the phase 1 exchange, a second KE
   payload MUST NOT be used, and the Nonces are not transmitted but are
   assumed to be the same as the phase 1 nonces.

   The CREATE_CHILD_SA request contains:

       Initiator                                 Responder
      -----------                               -----------
       HDR, SK {SA, Ni, [KEi],
           [TSi, TSr]}             -->

   The Initiator sends SA offer(s) in the SA payload, a nonce in the Ni
   payload, optionally a Diffie-Hellman value in the KEi payload, and
   the proposed traffic selectors in the TSi and TSr payloads. If the SA
   offers include different Diffie-Hellman groups, KEi must be an
   element of the first group offered.

   The message past the header is encrypted and the message including
   the header is integrity protected using the cryptographic algorithms
   negotiated in Phase 1.

   The CREATE_CHILD_SA response contains:

                                  <--    HDR, SK {SA, Nr, [KEr],
                                               [TSi, TSr]}

   The Responder replies (using the same Message ID to respond) with the
   accepted offer in an SA payload, a Diffie-Hellman value in the KEr
   payload if KEi was included in the request and the selected
   cryptographic suite includes that group.  If the responder chooses a
   cryptographic suite with a different group, it must reject the
   request and have the initiator make another one.

   The traffic selectors for traffic to be sent on that SA are specified
   in the TS payloads, which may be a subset of what the Initiator of
   the child-SA proposed. Traffic selectors are omitted if this
   CREATE_CHILD_SA request is being used to change the key of the IKE-



IKEv2                                                       [Page 8]






INTERNET DRAFT                                              October 2002


   SA.

3.3 Informational (Phase 2) Exchange

   At various points during an IKE-SA, peers may desire to convey
   control messages to each other regarding errors or notifications of
   certain events. To accomplish this IKE defines a (reliable)
   Informational exchange.  Usually Informational exchanges happen
   during phase 2 and are cryptographically protected with the IKE
   exchange.

   Control messages that pertain to an IKE-SA MUST be sent under that
   IKE-SA. Control messages that pertain to Child-SAs MUST be sent under
   the protection of the IKE-SA which generated them (or its successor
   if the IKE-SA is replaced for the purpose of rekeying).

   There are two cases in which there is no IKE-SA to protect the
   information. One is in the response to an IKE_SA_init_request to
   refuse the SA proposal. This would be conveyed in a Notify payload of
   the IKE_SA_init_response.

   The other case in which there is no IKE-SA to protect the information
   is when a packet is received with an unknown SPI.  In that case the
   notification of this condition will be sent in an informational
   exchange that is not cryptographically protected.

   Messages in an Informational Exchange contain zero or more
   Notification or Delete payloads. The Recipient of an Informational
   Exchange request MUST send some response (else the Sender will assume
   the message was lost in the network and will retransmit it). That
   response can be a message with no payloads. Actually, the request
   message in an Informational Exchange can also contain no payloads.
   This is the expected way an endpoint can ask the other endpoint to
   verify that it is alive.

   ESP, AH, and IPcomp SAs always exist in pairs, with one SA in each
   direction. When an SA is closed, both members of the pair MUST be
   closed. When SAs are nested, as when data is encapsulated first with
   IPcomp, then with ESP, and finally with AH between the same pair of
   endpoints, all of the SAs (up to six) must be deleted together. To
   delete an SA, an Informational Exchange with one or more delete
   payloads is sent listing the SPIs (as known to the recipient) of the
   SAs to be deleted. The recipient MUST close the designated SAs.
   Normally, the reply in the Informational Exchange will contain delete
   payloads for the paired SAs going in the other direction. There is
   one exception.  If by chance both ends of a set of SAs independently
   decide to close them, each may send a delete payload and the two
   requests may cross in the network. If a node receives a delete



IKEv2                                                       [Page 9]






INTERNET DRAFT                                              October 2002


   request for SAs that it has already issued a delete request for, it
   MUST delete the incoming SAs while processing the request and the
   outgoing SAs while processing the response. In that case, the
   responses MUST NOT include delete payloads for the deleted SAs, since
   that would result in duplicate deletion and could in theory delete
   the wrong SA.

   A node SHOULD regard half open connections as anomalous and audit
   their existence should they persist. Note that this specification
   nowhere specifies time periods, so it is up to individual endpoints
   to decide how long to wait. A node MAY refuse to accept incoming data
   on half open connections but MUST NOT unilaterally close them and
   reuse the SPIs. If connection state becomes sufficiently messed up, a
   node MAY close the IKE-SA which will implicitly close all SAs
   negotiated under it. It can then rebuild the SA's it needs on a clean
   base under a new IKE-SA.

   The Informational Exchange is defined as:

       Initiator                        Responder
      -----------                      -----------
       HDR, SK {N, ..., D, ...} -->
                                <--     HDR, SK {N, ..., D, ...}

   The processing of an Informational Exchange is determined by its
   component payloads.

4 IKE Protocol Details and Variations

   IKE runs over UDP port 500. Since UDP is a datagram (unreliable)
   protocol, IKE includes in its definition recovery from transmission
   errors, including packet loss, packet replay, and packet forgery. IKE
   is designed to function so long as at least one of a series of
   retransmitted packets reaches its destination before timing out and
   the channel is not so full of forged and replayed packets so as to
   exhaust the network or CPU capacities of either endpoint. Even in the
   absence of those minimum performance requirements, IKE is designed to
   fail cleanly (as though the network were broken).

4.1 Use of Retransmission Timers

   All messages in IKE exist in pairs: a request and a response.  The
   setup of an IKE SA normally consists of two request/response pairs.
   Once the IKE SA is set up, either end of a security association may
   initiate requests at any time, and there can be many requests and
   responses "in flight" at any given moment. But each message is
   labelled as either a request or a response and for each
   request/response pair one end of the security association is the



IKEv2                                                      [Page 10]






INTERNET DRAFT                                              October 2002


   Initiator and the other is the Responder.

   For every pair of messages, the Initiator is responsible for
   retransmission in the event of a timeout. The Responder will never
   retransmit a response unless it receives a retransmission of the
   request. In that event, the Responder MUST either ignore the
   retransmitted request except insofar as it triggers a retransmission
   of the response OR if processing the request a second time has no
   adverse effects, the Responder may choose to process the request
   again and send a semantically equivalent reply.

   IKE is a reliable protocol, in the sense that the Initiator MUST
   retransmit a request until either it receives a corresponding reply
   OR it deems the IKE security association to have failed and it
   discards all state associated with the IKE-SA and any Child-SAs
   negotiated using that IKE-SA.

4.2 Use of Sequence Numbers for Message ID

   Every IKE message contains a Message ID as part of its fixed header.
   This Message ID is used to match up requests and responses, and to
   identify retransmissions of messages.

   The Message ID is a 32 bit quantity, which is zero for the first IKE
   request in each direction. The IKE SA initial setup messages will
   always be numbered 0 and 1.  Each endpoint in the IKE Security
   Association maintains two "current" Message IDs: the next one to be
   used for a request it initiates and the next one it expects to see
   from the other end. These counters increment as requests are
   generated and received. Responses always contain the same message ID
   as the corresponding request. That means that after the initial
   exchange, each integer n may appear as the message ID in four
   distinct messages: The nth request from the original IKE Initiator,
   the corresponding response, the nth request from the original IKE
   Responder, and the corresponding response. If the two ends make very
   different numbers of requests, the Message IDs in the two directions
   can be very different. There is no ambiguity in the messages,
   however, because each packet contains enough information to determine
   which of the four messages a particular one is.

   Note that Message IDs are cryptographically protected and provide
   protection against message replays.


4.3 Window Size for overlapping requests

   In order to maximize IKE throughput, an IKE endpoint MAY issue
   multiple requests before getting a response to any of them. For



IKEv2                                                      [Page 11]






INTERNET DRAFT                                              October 2002


   simplicity, an IKE implementation MAY choose to process requests
   strictly in order and/or wait for a response to one request before
   issuing another. Certain rules must be followed to assure
   interoperability between implementations using different strategies.

   After an IKE-SA is set up, either end can initiate one or more
   requests. These requests may pass one another over the network. An
   IKE endpoint MUST be prepared to accept and process a request while
   it has a request outstanding in order to avoid a deadlock in this
   situation. An IKE endpoint SHOULD be prepared to accept and process
   multiple requests while it has a request outstanding.

   An IKE endpoint MUST wait for a response to each of its messages
   before sending a subsequent message unless it has received a Notify
   message from its peer informing it that the peer is prepared to
   maintain state for multiple outstanding messages in order to allow
   greater throughput.

   An IKE endpoint MUST NOT exceed the peer's stated window size (see
   section 5.3.2) for transmitted IKE requests. In other words, if Bob
   stated his window size is N, then when Alice needs to make a request
   X, she MUST wait until she has received responses to all requests up
   through request X-N. An IKE endpoint MUST keep a copy of (or be able
   to regenerate exactly) each request it has sent until it receives the
   corresponding response. An IKE endpoint MUST keep a copy of (or be
   able to regenerate with semantic equivalence) the number of previous
   responses equal to its contracted window size in case its response
   was lost and the Initiator requests its retransmission by
   retransmitting the request.

   An IKE endpoint SHOULD be capable of processing incoming requests out
   of order to maximize performance in the event of network failures or
   packet reordering.

4.4 State Synchronization and Connection Timeouts

   An IKE endpoint is allowed to forget all of its state associated with
   an IKE-SA and the collection of corresponding child-SAs at any time.
   This is the anticipated behavior in the event of an endpoint crash
   and restart. It is important when an endpoint either fails or
   reinitializes its state that the other endpoint detect those
   conditions and not continue to waste network bandwidth by sending
   packets over those SAs and having them fall into a black hole.

   Since IKE is designed to operate in spite of Denial of Service (DoS)
   attacks from the network, an endpoint MUST NOT conclude that the
   other endpoint has failed based on any routing information (e.g. ICMP
   messages) or IKE messages that arrive without cryptographic



IKEv2                                                      [Page 12]






INTERNET DRAFT                                              October 2002


   protection (e.g., notify messages complaining about unknown SPIs). An
   endpoint MUST conclude that the other endpoint has failed only when
   repeated attempts to contact it have gone unanswered for a timeout
   period. An endpoint SHOULD suspect that the other endpoint has failed
   based on routing information and initiate a request to see whether
   the other endpoint is alive. To check whether the other side is
   alive, IKE specifies an empty Informational message that (like all
   IKE requests) requires an acknowledgment. If a cryptographically
   protected message has been received from the other side recently,
   unprotected notifications MAY be ignored. Implementations MUST limit
   the rate at which they take actions based on unprotected messages.

   Numbers of retries and lengths of timeouts are not covered in this
   specification because they do not affect interoperability. It is
   suggested that messages be retransmitted at least a dozen times over
   a period of at least several minutes before giving up on an SA, but
   different environments may require different rules. If there is
   outgoing traffic on an SA, it is essential to confirm liveness of
   that SA to avoid black holes. If no cryptographically protected
   messages have been received on an IKE-SA or any of its child-SAs
   recently, a liveness check MUST be performed. Receipt of a fresh
   cryptographically protected message on an IKE-SA or any of its
   child-SAs assures liveness of the IKE-SA and all of its child-SAs.

   There is a Denial of Service attack on the Initiator of an IKE-SA
   that can be avoided if the Initiator takes the proper care. Since the
   first two messages of an SA setup are not cryptographically
   protected, an attacker could respond to the Initiator's message
   before the genuine Responder and poison the connection setup attempt.
   To prevent this, the Initiator SHOULD be willing to accept multiple
   responses to its first message, treat each as potentially legitimate,
   respond to it, and then discard all the invalid half open connections
   when she receives a valid cryptographically protected response to any
   one of her requests.  Once a cryptographically valid response is
   received, all subsequent responses should be ignorred whether or not
   they are cryptographically valid.

   Note that with these rules, there is no reason to negotiate and agree
   upon an SA lifetime. If IKE presumes the partner is dead, based on
   repeated lack of acknowledgment to an IKE message, then the IKE SA
   and all child-SAs set up through that IKE-SA are deleted.

   An IKE endpoint MAY delete inactive Child-SAs to recover resources
   used to hold their state. If an IKE endpoint chooses to do so, it
   MUST send Delete payloads to the other end notifying it of the
   deletion. It MAY similarly time out the IKE-SA. Closing the IKE-SA
   implicitly closes all associated Child-SAs. An IKE endpoint SHOULD
   send a Delete payload indicating that it has closed the IKE-SA.



IKEv2                                                      [Page 13]






INTERNET DRAFT                                              October 2002


4.5 Version Numbers and Forward Compatibility

   This document describes version 2.0 of IKE, meaning the major version
   number is 2 and the minor version number is zero. It is likely that
   some implementations will want to support both version 1.0 and
   version 2.0, and in the future, other versions.

   The major version number should only be incremented if the packet
   formats or required actions have changed so dramatically that an
   older version node would not be able to interoperate with a newer
   version node if it simply ignored the fields it did not understand
   and took the actions specified in the older specification. The minor
   version number indicates new capabilities, and MUST be ignored by a
   node with a smaller minor version number, but used for informational
   purposes by the node with the larger minor version number. For
   example, it might indicate the ability to process a newly defined
   notification message. The node with the larger minor version number
   would simply note that its correspondent would not be able to
   understand that message and therefore would not send it.

   If you receive a message with a higher major version number, you MUST
   drop the message and SHOULD send an unauthenticated notification
   message containing the highest version number you support.  If you
   support major version n, and major version m, you MUST support all
   versions between n and m. If you receive a message with a major
   version that you support, you MUST respond with that version number.
   In order to prevent two nodes from being tricked into corresponding
   with a lower major version number than the maximum that they both
   support, IKE has a flag that indicates that the node is capable of
   speaking a higher major version number.

   Thus the major version number in the IKE header indicates the version
   number of the message, not the highest version number that the
   transmitter supports. If A is capable of speaking versions n, n+1,
   and n+2, and B is capable of speaking versions n and n+1, then they
   will negotiate speaking n+1, where A will set the flag indicating
   ability to speak a higher version. If they mistakenly (perhaps
   through an active attacker sending error messages) negotiate to
   version n, then both will notice that the other side can support a
   higher version number, and they MUST break the connection and
   reconnect using version n+1.

   Note that IKEv1 does not follow these rules, because there is no way
   in v1 of noting that you are capable of speaking a higher version
   number. So an active attacker can trick two v2-capable nodes into
   speaking v1.  When a v2-capable node negotiates down to v1, it SHOULD
   note that fact in its logs.




IKEv2                                                      [Page 14]






INTERNET DRAFT                                              October 2002


   Also for forward compatibility, all fields marked RESERVED MUST be
   set to zero by a version 2.0 implementation and their content MUST be
   ignored by a version 2.0 implementation ("Be conservative in what you
   send and liberal in what you receive"). In this way, future versions
   of the protocol can use those fields in a way that is guaranteed to
   be ignored by implementations that do not understand them.
   Similarly, payload types that are not defined are reserved for future
   use and implementations of version 2.0 MUST skip over those payloads
   and ignore their contents.

   IKEv2 adds a "critical" flag to each payload header for further
   flexibility for forward compatibility. If the critical flag is set
   and the payload type is unsupported, the message MUST be rejected and
   the response to the IKE request containing that payload MUST include
   a notify payload UNSUPPORTED-CRITICAL-PAYLOAD, indicating an
   unsupported critical payload was included. If the critical flag is
   not set and the payload type is unsupported, that payload is simply
   skipped. While new payload types may be added in the future and may
   appear interleaved with the fields defined in this specification,
   implementations MUST send the payloads defined in this specification
   in the stated order and implementations SHOULD reject as invalid a
   message with payloads in an unexpected order.

4.6 Cookies

   The term "cookies" originates with Karn and Simpson [RFC 2522] in
   Photuris, an early proposal for key management with IPsec.  It has
   persisted because the IETF has never rejected a proposal involving
   cookies. The ISAKMP fixed message header includes two eight octet
   fields titled "cookies", and that syntax is used by both IKEv1 and
   IKEv2. Those eight octet fields are used as an SPI or connection
   identifier at the beginning of IKE packets. They were also intended
   to be used as Karn/Simpson "anti-clogging" tokens in IKEv1, but
   certain aspects of that design prevented them from being used as
   such.  IKEv2 was carefully constructed to allow an implementation to
   implement these anti-clogging tokens, either using the fields titled
   "cookies" or by creative choices of nonces.

   While IKE implementations SHOULD implement anti-clogging tokens to
   protect themselves from denial of service attacks, the algorithms and
   syntax they use in cookies and/or nonces does not affect
   interoperability and hence is not specified here. The following
   should be interpreted as an explanation of why the protocol has the
   fields it does and as an example of how an implementation could
   implementing anti-clogging tokens.

   In IKEv2, the cookies are used as IKE-SA identifiers in the headers
   of IKE messages. As with ESP and AH, in IKEv2 the recipient of a



IKEv2                                                      [Page 15]






INTERNET DRAFT                                              October 2002


   message chooses an IKE-SA identifier that uniquely defines that SA to
   that recipient. For this purpose (IKE-SA identifiers), it might be
   convenient for the cookie value to be chosen so as to be a table
   index for fast lookups of SAs. But this conflicts with the second use
   of the cookies.

   Unlike ESP and AH where only the recipient's SA identifier appears in
   the message, in IKE the sender's IKE SA identifier is also sent in
   every message. In IKEv1 the IKE-SA identifier consisted of the pair
   (Initiator cookie, Responder cookie), whereas in IKEv2, the SA is
   uniquely defined by the recipient's SA identifier even though both
   are included in the IKEv2 header.

   An expected attack against IKE is state and CPU exhaustion, where the
   target is flooded with session initiation requests from forged IP
   addresses. This attack can be made less effective if an
   implementation of a responder uses minimal CPU and commits no state
   to a connection until it has received the third message of the
   protocol. That third message repeats information from the second
   message, and hence proves that the initiator can receive packets at
   the address it claims to be sending from.

   Since all of the information from message 1 is repeated in message 3,
   the responder need not store any of that information. What the
   responder must be able to do is: (1) assure itself that the Nr
   returned in message 3 is fresh and (2) assure that message 3 came
   from the same IP address as message 1. If the responder uses multiple
   KEr's during the period of message 1 & 3, it must encode in message 2
   some way to figure out which KEr applies to this exchange.

   A good way to do this is to set the IKE-SA identifier to be:

      SPIr = Hash(KEr | Nr | IPi | <secret>)

   where <secret> is a randomly generated secret known only to the
   responder and periodically changed. This value can be recomputed when
   message 3 arrives and compared to the SPIr in message 3. If it
   matches, the responder knows that Nr was generated since the last
   change to <secret> and that IPi must be the same as the source
   address it saw in message 1.

   To prevent replays of message 3 without remembering all the Nr's that
   were used, the responder must keep a list of all of the Nr's that
   have been returned in a message 3 since <secret> was last changed.
   If this list becomes long enough to be cumbersome, the responder can
   change <secret> and forget all of the used values.

   If a new value for <secret> is chosen while there are connections in



IKEv2                                                      [Page 16]






INTERNET DRAFT                                              October 2002


   the process of being initialized, a message 3 might be returned where
   the responder does not know which of its values for <secret> were
   used in generating message 2. Using the formula above, the responder
   could compute SPIr with each candidate <secret> and accept message 3
   if any of the values match. A similar situation occurs if the
   responder uses multiple values of KEr. An alternative implementation
   would be to take a few bits of SPIr as indices of <secret>s and KEr's
   (where the rest of SPIr is computed as the above hash).

   If the responder wants to keep other forms of state without tying up
   its memory, it can encode that state in the nonce. The nonce can be
   up to 256 octets long, and the protocol is secure so long as values
   are not reused, so the responder can put state there (possibly
   encrypted) and be guaranteed that it will come back with message 3.
   For subtle cryptographic reasons, the nonce SHOULD contain some
   random bits - at least as many random bits as the size of the
   strongest key be generated by the exchange.

   It may be convenient for the IKE-SA identifier to be an index into a
   table.  It is not difficult for the Initiator to choose an IKE-SA
   identifier that is convenient as a table identifier, since the
   Initiator does not need to use it as an anti-clogging token, and is
   keeping state.  IKEv2 allows the Responder to initially choose a
   stateless anti-clogging type cookie by responding to an IKE_SA_init
   with a cookie request, and then upon receipt of an IKE_SA_init with a
   valid cookie, change his cookie value from the computed anti-clogging
   token to a more convenient value, by sending a different value for
   his cookie in the IKE_SA_auth_response. This will not confuse the
   Initiator (Alice), because she will have chosen a unique cookie value
   A, so if her SA state for the partially set up IKE-SA says that Bob's
   cookie for the SA that Alice knows as "A" is B, and she receives a
   response from Bob with cookies (A,C), that means that Bob wants to
   change his value from B to C for the SA that Alice knows uniquely as
   "A".

   Another reason why Bob might want to change his cookie value is that
   it is possible (though unlikely) that Bob will choose the same cookie
   for multiple SAs if the hash of the Initiator IP address, Nr, and
   whatever other information might be included happens to hash to the
   same value.

   In IKEv2, like IKEv1, both 8-octet cookies appear in the message, but
   in IKEv2 (unlike v1), the value chosen by the message recipient
   always appears first in the message.

   The cookies are one of the inputs into the function that computes the
   keying material. If the responder changes its cookie to a different
   value when it sends its IKE_AUTH_response, it is the cookie value in



IKEv2                                                      [Page 17]






INTERNET DRAFT                                              October 2002


   the IKE_SA_init_response that is the input for generating the keying
   material.


4.7 Cryptographic Algorithm Negotiation

   The payload type known as "SA" indicates a proposal for a set of
   choices of protocols (IKE, ESP, AH, and/or IPcomp) for the SA as well
   as cryptographic algorithms associated with each protocol. In IKEv1
   it was extremely complex, and was one of the motivations for revising
   the spec.

   An SA consists of one or more proposals. Each proposal includes a
   Suite-ID, which implies one or more protocols and the associated
   cryptographic algorithms.

   In IKEv2, since the Initiator sends her Diffie-Hellman value in the
   IKE_SA_init, she must guess at the Diffie-Hellman group that Bob will
   select from her list of supported groups. Her guess MUST be the first
   in the list to allow Bob to unambiguously identify which group the
   accompanying KE payload is from. If her guess is incorrect then Bob's
   response informs her of the group he chose, and includes his KE from
   his chosen group.  In this case, Alice MUST choose a KE from Bob's
   chosen group, compute keys based on her and Bob's values and send the
   new KE in message 3.

   You might wonder why Alice includes KE in the first message given
   that Bob doesn't need it until message 3 and it could change in
   message 3. The reason is to allow an optional optimization in Bob.
   Bob MAY start his Diffie-Hellman computation as soon as he receives
   message 1 and likely complete it by the time he receives message 3.
   This will minimize latency of connection setup in the common case
   where Alice correctly guesses the Diffie-Hellman group that Bob will
   choose. If Bob accepts Alice's first choice of Diffie-Hellman group,
   Alice MUST send the same value for KE in message 3 as she sent in
   message 1.

   Note that an implementation cannot simultaneously exploit this
   optimization and protect itself from a denial of service attack using
   cookies. But an implementation could alternate between the two based
   on load.

   If none of Alice's options are acceptable, then Bob notifies her
   accordingly.

4.8 Rekeying

   Security associations negotiated in both phase 1 and phase 2 contain



IKEv2                                                      [Page 18]






INTERNET DRAFT                                              October 2002


   secret keys which may only be used for a limited amount of time and
   to protect a limited amount of data. This determines the lifetime of
   the entire security association. When the lifetime of a security
   association expires the security association MUST NOT be used.  If
   there is demand, new security associations can be established.
   Reestablishment of security associations to take the place of ones
   which expire is referred to as "rekeying".

   To rekey a child-SA, create a new, equivalent SA (see section 4.17
   below), and when the new one is established, delete the old one.  To
   rekey an IKE-SA, establish a new equivalent IKE-SA (see section 4.18
   below) with the peer to whom the old IKE-SA is shared using a Phase 2
   negotiation within the existing IKE-SA. An IKE-SA so created inherits
   all of the original IKE-SA's child SAs.  Use the new IKE-SA for all
   control messages needed to maintain the child-SAs created by the old
   IKE-SA, and delete the old IKE-SA. The Delete payload to delete
   itself MUST be the last request sent over an IKE-SA.

   SAs SHOULD be rekeyed proactively, i.e., the new SA should be
   established before the old one expires and becomes unusable. Enough
   time should elapse between the time the new SA is established and the
   old one becomes unusable so that traffic can be switched over to the
   new SA.

   A difference between IKEv1 and IKEv2 is that in IKEv1 SA lifetimes
   were negotiated. In IKEv2, each end of the SA is responsible for
   enforcing its own lifetime policy on the SA and rekeying the SA when
   necessary.  If the two ends have different lifetime policies, the end
   with the shorter lifetime will end up always being the one to request
   the rekeying.

   If the two ends have the same lifetime policies, it is possible that
   both will initiate a rekeying at the same time (which will result in
   redundant SAs). To reduce the probability of this happening, the
   timing of rekeying requests should be jittered (delayed by a random
   amount of time).

   This form of rekeying will temporarily result in multiple similar SAs
   between the same pairs of nodes. When there are two SAs eligible to
   receive packets, a node MUST accept incoming packets through either
   SA. The node that initiated the rekeying SHOULD delete the older SA
   after the new one is established.

4.9 Traffic Selector Negotiation

   When an IP packet is received by an RFC2401 compliant IPsec subsystem
   and matches a "protect" selector in its SPD, the subsystem MUST
   protect that packet with IPsec. When no SA exists yet it is the task



IKEv2                                                      [Page 19]






INTERNET DRAFT                                              October 2002


   of IKE to create it. Information about the traffic that needs
   protection is transmitted to the IKE subsystem in a manner outside
   the scope of this document (see [PFKEY] for an example).  This
   information is negotiated between the two IKE endpoints using TS
   (Traffic Selector) payloads.

   Two TS payloads appear in each of the messages in the exchange that
   creates a child-SA pair. Each TS payload contains one or more Traffic
   Selectors. Each Traffic Selector consists of an address range (IPv4
   or IPv6), a port range, and a protocol ID.

   IKEv2 is more flexible than IKEv1. IKEv2 allows sets of ranges of
   both addresses and ports, and allows the responder to choose a subset
   of the requested traffic rather than simply responding "not
   acceptable".  This could happen when the configuration of the two
   endpoints are being updated but only one end has received the new
   information.  Since the two endpoints may be configured by different
   people, the incompatibility may persist for an extended period even
   in the absense of errors. It allows for intentionally different
   configurations, as when one end is configured to tunnel all addresses
   and depends on the other end to have the up to date list.

   The first of the two TS payloads is known as TSi (Traffic Selector-
   initiator).  The second is known as TSr (Traffic Selector-responder).
   TSi specifies the source address of traffic forwarded from (or the
   destination address of traffic forwarded to) the initiator of the
   child-SA pair. TSr specifies the destination address of the traffic
   forwarded from (or the source address of the traffic forwarded to)
   the responder of the child-SA pair.  For example, if Alice initiates
   the creation of the child-SA pair from Alice to Bob, and wishes to
   tunnel all traffic from subnet 10.2.16.* on Alice's side to subnet
   18.16.*.* on Bob's side, Alice would include a single traffic
   selector in each TS payload. TSi would specify the address range
   (10.2.16.0 - 10.2.16.255) and TSr would specify the address range
   (18.16.0.0 - 18.16.255.255). Assuming that proposal was acceptable to
   Bob, he would send identical TS payloads back.

   The Responder is allowed to narrow the choices by selecting a subset
   of the traffic, for instance by eliminating or narrowing the range of
   one or more members of the set of traffic selectors, provided the set
   does not become the NULL set.

   It is possible for the Responder's policy to contain multiple smaller
   ranges, all encompassed by the Initiator's traffic selector, and with
   the Responder's policy being that each of those ranges should be sent
   over a different SA. Continuing the example above, Bob might have a
   policy of being willing to tunnel those addresses to and from Alice,
   but might require that each address pair be on a separately



IKEv2                                                      [Page 20]






INTERNET DRAFT                                              October 2002


   negotiated child-SA. If Alice generated her request in response to an
   incoming packet from 10.2.16.43 to 18.16.2.123, there would be no way
   for Bob to determine which pair of addresses it is most urgent to
   tunnel, and he would have to make his best guess or reject the
   request with a status of SINGLE-PAIR-REQUIRED.

   To enable Bob to choose the appropriate range in this case, if Alice
   has initiated the SA due to a data packet, Alice MAY include as the
   first traffic selector in each of TSi and TSr a very specific traffic
   selector including the addresses in the packet triggering the
   request. In the example, Alice would include in TSi two traffic
   selectors: the first containing the address range (10.2.16.43 -
   10.2.16.43) and the source port and protocol from the packet and the
   second containing (10.2.16.0 - 10.2.16.255) with all ports and
   protocols. She would similarly include two traffic selectors in TSr.

   If Bob's policy does not allow him to accept the entire set of
   traffic selectors in Alice's request, but does allow him to accept
   the first selector of TSi and TSr, then Bob MUST narrow the traffic
   selectors to a subset that includes Alice's first choices. In this
   example, Bob might respond with TSi being (10.2.16.43 - 10.2.16.43)
   with all ports and protocols.

   If Alice creates the child-SA pair not in response to an arriving
   packet, but rather - say - upon startup, then there may be no
   specific data packet to describe.  In that case, the first values in
   TSi and TSr are ranges rather than specific values, and Bob chooses a
   subset of Alice's TSi and TSr that are acceptable to him. If more
   than one subset is acceptable but their union is not, Bob MUST accept
   some subset and MAY include a NOTIFY payload of type ADDITIONAL-TS-
   POSSIBLE to indicate that Alice might want to try again.

4.10 Nonces

   The IKE_SA_init and the IKE_SA_init_response each contain a nonce.
   These nonces are used as inputs to cryptographic functions.  The
   CREATE_CHILD_SA request and the CREATE_CHILD_SA response also contain
   nonces. These nonces are used to add freshness to the key derivation
   technique used to obtain keys for child SAs. Nonces used in IKEv2
   MUST therefore be unique (either deterministically by use of
   timestamps and sequence numbers or probabilistically by use of a
   strong pseudo-random number generator).

4.11 Address and Port Agility

   IKE runs over UDP port 500, and implicitly sets up ESP, AH, and
   IPcomp associations for the same IP addresses it runs over. The IP
   addresses and ports in the outer header are, however, not themselves



IKEv2                                                      [Page 21]






INTERNET DRAFT                                              October 2002


   cryptographically protected, and IKE is designed to work even through
   Network Address Translation (NAT) boxes. An implementation MUST
   accept incoming connection requests even if not received from UDP
   port 500, and should respond to the address and port from which the
   request was received. An implementation MUST, however, accept
   incoming requests only on UDP port 500 and send all responses from
   UDP port 500. IKE functions identically over IPv4 or IPv6.

4.12 Reuse of Diffie-Hellman Exponentials

   IKE generates keying material using an ephemeral Diffie-Hellman
   exchange in order to gain the property of "perfect forward secrecy".
   This means that once a connection is closed and its corresponding
   keys are forgotten, even someone who has recorded all of the data
   from the connection and gets access to all of the long term keys of
   the two endpoints cannot reconstruct the keys used to protect the
   conversation.

   Achieving perfect forward secrecy requires that when a connection is
   closed, each endpoint must forget not only the keys used by the
   connection but any information that could be used to recompute those
   keys. In particular, it must forget the secrets used in the Diffie-
   Hellman calculation and any state that may persist in the state of a
   pseudo-random number generater that could be used to recompute the
   Diffie-Hellman secrets.

   Since the computing of Diffie-Hellman exponentials is computationally
   expensive, an endpoint may find it advantageous to reuse those
   exponentials for multiple connection setups. There are several
   reasonable strategies for doing this. An endpoint could choose a new
   exponential periodically though this could result in less-than-
   perfect forward secrecy if some connection lasts for less than the
   lifetime of the exponential. Or it could keep track of which
   exponential was used for each connection and delete the information
   associated with the exponential only when some corresponding
   connection was closed. This would allow the exponential to be reused
   without losing perfect forward secrecy at the cost of maintaining
   more state.

   Decisions as to whether and when to reuse Diffie-Hellman exponentials
   is a private decision in the sense that it will not affect
   interoperability.  An implementation that reuses exponentials may
   choose to remember the exponential used by the other endpoint on past
   exchanges and if one is reused to avoid the second half of the
   calculation.

4.13 Generating Keying Material




IKEv2                                                      [Page 22]






INTERNET DRAFT                                              October 2002


   In the context of the IKE SA, three cryptographic algorithms are
   negotiated:  an encryption algorithm, a Diffie-Hellman group, and a
   pseudo-random function (prf). The pseudo-random function is used both
   for integrity protection of the IKE payloads and for the construction
   of keying material for all of the cryptographic algorithms used in
   both the IKE SA and the Child-SAs.

   We assume that each cryptographic algorithm accepts a fixed size key,
   and that any randomly chosen value of that fixed size can serve as an
   appropriate key. For functions that accept a variable length key, a
   fixed key size MUST be specified as part of the cryptographic suite
   negotiated.  For prf functions based on HMAC, the fixed key size is
   the size of the output of the HMAC.

   Keying material will always be derived as the output of the
   negotiated prf algorithm. If the amount of keying material is greater
   than the size of the output of the prf algorithm, we will use the prf
   iteratively.  We will use the terminology prf+ to describe the
   function that outputs a pseudo-random stream based on the inputs to a
   prf as follows:

   prf+ (K,S) = T1 | T2 | T3 | T4 | ...

   where:
   T1 = prf (K, S | 0x01)
   T2 = prf (K, T1 | S | 0x02)
   T3 = prf (K, T2 | S | 0x03)
   T4 = prf (K, T3 | S | 0x04)

   as needed to compute all required keys. The keys are taken from the
   output string without regard to boundaries (e.g. if the required keys
   are a 256 bit AES key and a 160 bit HMAC key, and the prf function
   generates 160 bits, the AES key will come from T1 and the beginning
   of T2, while the HMAC key will come from the rest of T2 and the
   beginning of T3).

   The constant concatenated to the end of each string feeding the prf
   is a single octet. prf+ in this document is not defined beyond 255
   times the size of the prf output.

4.14 Generating Keying Material for the IKE-SA

   The shared keys are computed as follows.  A quantity called SKEYSEED
   is calculated from the nonces exchanged during the IKE_SA_init
   exchange and the Diffie-Hellman shared secret established during that
   exchange.  SKEYSEED is used to calculate three other secrets: SK_d
   used for deriving new keys for the child-SAs established with this
   IKE-SA; SK_a used as a key to the prf algorithm for authenticating



IKEv2                                                      [Page 23]






INTERNET DRAFT                                              October 2002


   the component messages of subsequent exchanges; and SK_e used for
   encrypting (and of course decrypting) all subsequent exchanges.
   SKEYSEED and its derivatives are computed as follows:

       SKEYSEED = prf(Ni | Nr, g^ir)
       {SK_d, SK_ai, SK_ar, SK_ei, SK_er}
                 = prf+ (SKEYSEED, Ni | Nr | CKY-I | CKY-R)

   g^ir is the shared secret from the ephemeral Diffie-Hellman exchange.
   Ni and Nr are the nonces, stripped of any headers.

   The two directions of flow use different keys. The keys used to
   protect messages from the original initiator are SK_ai and SK_ei. The
   keys used to protect messages in the other direction are SK_ar and
   SK_er. Each algorithm takes a fixed number of bits of keying
   material, which is specified as part of the algorithm.  For integrity
   algorithms based on HMAC, the key size is always equal to the length
   of the underlying hash function.

4.15 Authentication of the IKE-SA

   The peers are authenticated by having each sign (or MAC using a
   shared secret as the key) a block of data. For the responder, the
   octets to be signed start with the first octet of the header of the
   second message and end with the last octet of the last payload in the
   second message.  Appended to this (for purposes of computing the
   signature) is the initiator's nonce Ni (just the value, not the
   payload containing it).  The initiator signs the unencrypted part of
   message 3, starting with the first octet of the IKE header and ending
   with the last octet of the last unencrypted payload.  Note that
   message 3 includes Nr, so it does not need to be appended in order to
   be included under the signature. It is critical to the security of
   the exchange that each side sign the other side's nonce.

   Note that all of the payloads are included under the signature,
   including any payload types not defined in this document.

   Optionally, messages 3 and 4 MAY include a certificate, or
   certificate chain providing evidence that the key used to compute a
   digital signature belongs to the name in the ID payload. The
   signature or MAC will be computed using algorithms dictated by the
   type of key used by the signer, an RSA-signed PKCS1-padded-hash for
   an RSA digital signature, a DSS-signed SHA1-hash for a DSA digital
   signature, or the negotiated PRF function for a pre-shared key.
   There is no requirement that the Initiator and Responder sign with
   the same cryptographic algorithms. The choice of cryptographic
   algorithms depends on the type of key each has. This type is either
   indicated in the certificate supplied or, if the keys were exchanged



IKEv2                                                      [Page 24]






INTERNET DRAFT                                              October 2002


   out of band, the key types must have been similarly learned. It will
   commonly be the case (but it is not required) that if a shared secret
   is used for authentication that the same key is used in both
   directions. In particular, the initiator may be using a shared key
   while the responder may have a public signature key and certificate.
   Note that it is a common but insecure practice to have a shared key
   derived from a user chosen password. This is insecure because user
   chosen passwords are unlikely to have sufficient randomness to resist
   dictionary attacks.  The pre-shared key SHOULD contain as much
   randomness as the strongest key being negotiated.  In the case of a
   pre-shared key, the AUTH value is computed as:

      AUTH = prf(Shared Secret | "Key Pad for IKEv2", <message bytes>)
   where the string "Key Pad for IKEv2" is ASCII encoded and not null
   terminated. The shared secret can be variable length. The pad string
   is added so that if the shared secret is derived from a password,
   this exchange will not compromise use of the same password in other
   protocols.

   Note that the requirement that the responder sign the content of
   message 2 in message 4 introduces some special challenges when the
   responder is not maintaining state between messages 2 and 4 (see
   Section 4.6). Either the responder must be able to regenerate message
   2 octet for octet from the information in message 3, or it must
   encode in its nonce enough information to be able to construct the
   signature on message 2 after message 3 is returned.

4.16 Generating Keying Material for CHILD-SAs

   Child-SAs are created either by being piggybacked on the phase 1
   exchange, or in a phase 2 CREATE_CHILD_SA exchange. Keying material
   for them is generated as follows:

      KEYMAT = prf+(SK_d, Ni | Nr)

   Where Ni and Nr are the Nonces from the IKE_init exchange if this
   request is the first CHILD-SA created or the fresh Ni and Nr from the
   CREATE_CHILD_SA exchange if this is a subsequent creation.

   For phase 2 exchanges with PFS the keying material is defined as:

      KEYMAT = prf+(SK_d, g^ir (ph2) | Ni | Nr )

   where g^ir (ph2) is the shared secret from the ephemeral Diffie-
   Hellman exchange of this phase 2 exchange,

   A single child-SA negotiation may result in multiple security
   associations. ESP, AH, and IPcomp SAs exist in pairs (one in each



IKEv2                                                      [Page 25]






INTERNET DRAFT                                              October 2002


   direction), and six SAs could be created in a single child-SA
   negotiation if a combination of ESP, AH, and IPcomp is being
   negotiated.  KEYMAT is generated as described in section 4.13.

   Keying material is taken from the expanded KEYMAT in the following
   order:

      All keys for SAs carrying data from the initiator to the responder
      are taken before SAs going in the reverse direction.

      If multiple protocols are negotiated, keying material is taken in
      the order in which the protocol headers will appear in the
      encapsulated packet.

      If a single protocol has both encryption and authentication keys,
      the encryption key is taken from the first octets of KEYMAT and
      the authentication key is taken from the next octets.

   Each cryptographic algorithm takes a fixed number of bits of keying
   material specified as part of the algorithm.

4.17 Rekeying IKE-SAs using a CREATE_CHILD_SA exchange

   The CREATE_CHILD_SA exchange can be used to re-key an existing IKE-SA
   (see section 4.8).  New Initiator and Responder cookies are supplied
   in the SPI fields. The TS payloads are omitted when rekeying an IKE-
   SA.  SKEYSEED for the new IKE-SA is computed using SK_d from the
   existing IKE-SA as follows:

       SKEYSEED = prf(SK_d (old), [g^ir (ph2)] | Ni | Nr)

   where g^ir (ph2) is the shared secret from the ephemeral Diffie-
   Hellman exchange of this phase 2 exchange and Ni and Nr are the two
   nonces stripped of any headers.

   The new IKE SA MUST reset its message counters to 0.

   SK_d, SK_ai, SK_ar, and SK_ei, and SK_er are computed from SKEYSEED
   as specified in section 4.14.

4.18 Error Handling

   There are many kinds of errors that can occur during IKE processing.
   If a request is received that is badly formatted or unacceptable for
   reasons of policy (e.g. no matching cryptographic algorithms), the
   response MUST contain a Notify payload indicating the error. If an
   error occurs outside the context of an IKE request (e.g. the node is
   getting ESP messages on a non-existent SPI), the node SHOULD initiate



IKEv2                                                      [Page 26]






INTERNET DRAFT                                              October 2002


   an Informational Exchange with a Notify payload describing the
   problem.

   Errors that occur before a cryptographically protected IKE-SA is
   established must be handled very carefully. There is a trade-off
   between wanting to be helpful in diagnosing a problem and responding
   to it and wanting to avoid being a dupe in a denial of service attack
   based on forged messages.

   If a node receives a message on UDP port 500 outside the context of
   an IKE-SA (and not a request to start one), it may be the result of a
   recent crash. If the message is marked as a response, the node MAY
   audit the suspicious event but MUST NOT respond. If the message is
   marked as a request, the node MAY audit the suspicious event and MAY
   send a response. If a response is sent, the response MUST be sent to
   the IP address and port from whence it came with the IKE cookies
   reversed in the header and the Message ID copied. The response MUST
   NOT be cryptographically protected and MUST contain a notify payload
   indicating INVALID-COOKIE.

   A node receiving such a message MUST NOT respond and MUST NOT change
   the state of any existing SAs. The message might be a forgery or
   might be a response the genuine correspondent was tricked into
   sending. A node SHOULD treat such a message (and also a network
   message like ICMP destination unreachable) as a hint that there might
   be problems with SAs to that IP address and SHOULD initiate a
   liveness test for any such IKE-SA. An implementation SHOULD limit the
   frequency of such tests to avoid being tricked into participating in
   a denial of service attack.

   A node receiving a suspicious message from an IP address with which
   it has an IKE-SA MAY send an IKE notify payload in an IKE
   Informational exchange over that SA. The recipient MUST NOT change
   the state of any SA's as a result but SHOULD audit the event to aid
   in diagnosing malfunctions. A node MUST limit the rate at which it
   will send messages in response to unprotected messages.

5 Header and Payload Formats

5.1 The IKE Header

   IKE messages use UDP port 500, with one IKE message per UDP datagram.
   Information from the UDP header is largely ignored except that the IP
   addresses and UDP ports from the headers are reversed and used for
   return packets.  Each IKE message begins with the IKE header, denoted
   HDR in this memo. Following the header are one or more IKE payloads
   each identified by a "Next Payload" field in the preceding payload.
   Payloads are processed in the order in which they appear in an IKE



IKEv2                                                      [Page 27]






INTERNET DRAFT                                              October 2002


   message by invoking the appropriate processing routine according to
   the "Next Payload" field in the IKE header and subsequently according
   to the "Next Payload" field in the IKE payload itself until a "Next
   Payload" field of zero indicates that no payloads follow. If a
   payload of type "Encrypted" is found, that payload is decrypted and
   its contents parsed as additional payloads. An Encrypted payload must
   be the last payload in a packet and an encrypted payload may not
   contain another encrypted payload.

   The Recipient SPI in the header identifies an instance of an IKE
   security association. It is therefore possible for a single instance
   of IKE to multiplex distinct sessions with multiple peers.

   The format of the IKE header is shown in Figure 1.
                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                          Recipient                            !
      !                        SPI (aka Cookie)                       !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                            Sender                             !
      !                        SPI (aka Cookie)                       !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !  Next Payload ! MjVer ! MnVer ! Exchange Type !     Flags     !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                          Message ID                           !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                            Length                             !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Figure 1:  IKE Header Format

      o  Recipient SPI (aka Cookie) (8 octets) - A value chosen by the
         recipient to identify a unique IKE security association. For
         the first packet of an IKE_SA_init, this value MUST be zero.
         It MUST NOT be zero for any other packet.
         [NOTE: this is a deviation from ISAKMP and IKEv1, where the
         cookies were always sent with the Initiator of the IKE-SA's
         cookie first and the Responder's second. See section 3.6.]

      o  Sender SPI (aka Cookie) (8 octets) - A value chosen by the
         sender to identify a unique IKE security association. This
         value MUST NOT be zero.

      o  Next Payload (1 octet) - Indicates the type of payload that
         immediately follows the header. The format and value of each
         payload is defined below.




IKEv2                                                      [Page 28]






INTERNET DRAFT                                              October 2002


      o  Major Version (4 bits) - indicates the major version of the IKE
         protocol in use.  Implementations based on this version of IKE
         MUST set the Major Version to 2. Implementations based on
         previous versions of IKE and ISAKMP MUST set the Major Version
         to 1. Implementations based on this version of IKE MUST reject
         (or ignore) messages containing a version number greater than
         2.

      o  Minor Version (4 bits) - indicates the minor version of the
         IKE protocol in use.  Implementations based on this version of
         IKE MUST set the Minor Version to 0. They MUST ignore the minor
         version number of received messages.

      o  Exchange Type (1 octet) - indicates the type of exchange being
         used.  This dictates the payloads sent in each message and
         message orderings in the exchanges.

                       Exchange Type            Value

                       RESERVED                 0
                       Reserved for ISAKMP      1 - 31
                       Reserved for IKEv1       32 - 33
                       IKE_SA_init              34
                       IKE_SA_AUTH              35
                       CREATE_CHILD_SA          36
                       Informational            37
                       Reserved for IKEv2+      38-239
                       Reserved for private use 240-255

      o  Flags (1 octet) - indicates specific options that are set
         for the message. Presence of options are indicated by the
         appropriate bit in the flags field being set. The bits are
         defined LSB first, so bit 0 would be the least significant
         bit of the Flags octet. In the description below, a bit
         being 'set' means its value is '1', while 'cleared' means
         its value is '0'.

       --  R(eserved) (bits 0-2) - These bits MUST be cleared
           when sending and MUST be ignored on receipt.

       --  I(nitiator) (bit 3 of Flags) - This bit MUST be set in
           messages sent by the original Initiator of the IKE SA
           and MUST be cleared in messages sent by the original
           Responder. It is used by the recipient to determine
           whether the message ID should be interpreted
           in the context of its initiating state or its responding
           state.




IKEv2                                                      [Page 29]






INTERNET DRAFT                                              October 2002


       --  V(ersion) (bit 4 of Flags) - This bit indicates that
           the transmitter is capable of speaking a higher major
           version number of the protocol than the one indicated
           in the major version number field. Implementations of
           IKEv2 must clear this bit when sending and MUST ignore
           it in incoming messages.

       --  R(eserved) (bits 5-7 of Flags) - These bits MUST be
           cleared when sending and MUST be ignored on receipt.

      o  Message ID (4 octets) - Message identifier used to control
         retransmission of lost packets and matching of requests and
         responses. See section 4.2. In the first message of a Phase 1
         negotiation, the value MUST be set to 0. The response to that
         message MUST also have a Message ID of 0.

      o  Length (4 octets) - Length of total message (header + payloads)
         in octets. Session encryption can expand the size of an IKE
         message and that is reflected in the total length of the
         message.

5.2 Generic Payload Header

   Each IKE payload defined in sections 5.3 through 5.14 begins with a
   generic header, shown in Figure 2. Figures for each payload below
   will include the generic payload header but for brevity the
   description of each field will be omitted. The construction and
   processing of the generic payload header is identical for each
   payload and will similarly be omitted.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 2:  Generic Payload Header

   The Generic Payload Header fields are defined as follows:

   o  Next Payload (1 octet) - Identifier for the payload type of the
      next payload in the message.  If the current payload is the last
      in the message, then this field will be 0.  This field provides
      a "chaining" capability whereby additional payloads can be
      added to a message by appending it to the end of the message
      and setting the "Next Payload" field of the preceding payload
      to indicate the new payload's type. For an Encrypted payload,
      which must always be the last payload of a message, the Next



IKEv2                                                      [Page 30]






INTERNET DRAFT                                              October 2002


      Payload field is set to the payload type of the first contained
      payload.

   o  Critical (1 bit) - MUST be set to zero if the sender wants
      the recipient to skip this payload if he does not
      understand the payload type code. MUST be set to one if the
      sender wants the recipient to reject this entire message
      if he does not understand this payload type. MUST be ignored
      by the recipient if the recipient understands the payload type
      code. SHOULD be set to zero for payload types defined in this
      document. Note that the critical bit applies to the current
      payload rather than the "next" payload whose type code
      appears in the first octet. The reasoning behind not setting
      the critical bit for payloads defined in this document is
      that all implementations MUST understand all payload types
      defined in this document and therefore must ignore the
      Critical bit's value.

   o  RESERVED (7 bits) - MUST be sent as zero; MUST be ignored.

   o  Payload Length (2 octets) - Length in octets of the current
      payload, including the generic payload header.

5.3 Security Association Payload

   The Security Association Payload, denoted SA in this memo, is used to
   negotiate attributes of a security association.  An SA may contain
   multiple proposals. Each proposal may propose multiple protocols
   (where a protocol is IKE, ESP, AH, or IPcomp), along with a suite of
   cryptographic algorithms to be used by the protocols. The
   protocol(s), cryptographic algorithms, and any associated parameters
   are determined by the suite number. An SA payload MAY contain
   proposals for different protocols. For example, one suite might
   contain AH, ESP, and IPcomp, while another might contain only ESP and
   a third ESP and IPcomp.

   The Proposal structure contains within it a Proposal # and a Suite-
   ID.  The first proposal MUST have Proposal # = 1, the second MUST
   have Proposal # = 2, etc. If the proposals are misnumbered, the
   responder MUST reject all of them.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                          <Proposals>                          ~



IKEv2                                                      [Page 31]






INTERNET DRAFT                                              October 2002


      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               Figure 3:  Security Association Payload

      o  Proposals (variable) - one or more proposal substructures.

      The payload type for the Security Association Payload is one (1).

5.3.1 Proposal Substructure

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! 0 (last) or 2 !   RESERVED    !         Proposal Length       !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Proposal #    ! RESERVED-MBZ  !           Suite-ID            !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ~                        SPI(S)  (variable)                     ~
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               Figure 4:  Proposal Substructure

      o  0 (last) or 2 (more) (1 octet) - Specifies whether this is the
         last Proposal Substructure in the SA. This syntax is inherited
         from ISAKMP, but is unnecessary because the last Proposal
         could be identified from the length of the SA. The value (2)
         corresponds to a Payload Type of Proposal, and the first
         four octets of the Proposal structure are designed to look
         somewhat like the header of a Payload.

      o  RESERVED (1 octet) - MUST be sent as zero; MUST be ignored.

      o  Proposal Length (2 octets) - Length of this proposal,
         including the SPI

      o  Proposal # (1 octet) - When a proposal is made, the first
         proposal in an SA MUST be #1, and subsequent proposals
         MUST be one greater than the previous proposal. When a
         proposal is accepted, the SA MUST contain a single proposal
         and the proposal number MUST match the accepted proposal
         from the Initiator.

      o  RESERVED-MBZ (1 octet) - This field is reserved for
         possible use in specifying different kinds of proposals.
         This field MUST be sent as zero and a proposal containing
         a non-zero value MUST NOT be accepted.




IKEv2                                                      [Page 32]






INTERNET DRAFT                                              October 2002


      o  Suite-ID (2 octets) - This field specifies a suite of
         protocols and cryptographic algorithms. See table below.

      o  SPI(S) (variable) - The sending entity's SPI(s). If the
         suite proposed includes more than one protocol, the SPIs
         are concatenated together in the order in which they would
         appear in a packet sent using the suite (i.e. AH followed
         by ESP followed by IPcomp. When an initial IKE SA is being
         proposed, SPIs are implicit from the IKE header and are not
         repeated here. Even if the SPI
         Size is not a multiple of 4 octets, there is no padding
         applied to the payload. When the SPI Size field is zero,
         this field is not present in the Security Association
         payload.


   For Suite-ID, the following values are defined:

          Name            Number   Algorithms
          IKE_CLASSIC       0       DH-Group #5 (1536 bits)
                                    3DES encryption
                                    HMAC-SHA1 integrity and prf

          ESP_CLASSIC       1       3DES encryption
                                    HMAC-SHA1 integrity

             <some AES variants, ESP+IPcomp, AH (?))

          values 2-65000 are reserved to IANA. Values 65501-65533 are
          for private use among mutually consenting parties.

5.4 Key Exchange Payload

   The Key Exchange Payload, denoted KE in this memo, is used to
   exchange Diffie-Hellman public numbers as part of a Diffie-Hellman
   key exchange.  The Key Exchange Payload consists of the IKE generic
   header followed by the Diffie-Hellman public value itself.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                       Key Exchange Data                       ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+




IKEv2                                                      [Page 33]






INTERNET DRAFT                                              October 2002


                Figure 7:  Key Exchange Payload Format

   A key exchange payload is constructed by copying one's Diffie-Hellman
   public value into the "Key Exchange Data" portion of the payload.
   The length of the Diffie-Hellman public value MUST be equal to the
   length of the prime modulus over which the exponentiation was
   performed, prepending zero bits to the value if necessary.

   A key exchange payload is processed by first checking whether the
   length of the key exchange data (the "Payload Length" from the
   generic header minus the size of the generic header) is equal to the
   length of the prime modulus over which the exponentiation was
   performed.

   The payload type for the Key Exchange payload is four (4).

5.5 Identification Payload

   The Identification Payload, denoted ID in this memo, allows peers to
   identify themselves to each other. In Phase 1, the ID Payload names
   the identity to be authenticated with the signature. In Phase 2, the
   ID Payload is optional and if present names an identity asserted to
   be responsible for this SA. An example use would be a shared computer
   opening an IKE-SA to a server and asserting the name of its logged in
   user for the Phase 2 SA. If missing, this defaults to the Phase 1
   identity.

   NOTE: In IKEv1, two ID payloads were used in each direction in Phase
   2 to hold Traffic Selector information for data passing over the SA.
   In IKEv2, this information is carried in Traffic Selector (TS)
   payloads (see section 5.13).

   The Identification Payload consists of the IKE generic header
   followed by identification fields as follows:

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !   ID Type     !                 RESERVED                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                   Identification Data                         ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               Figure 8:  Identification Payload Format



IKEv2                                                      [Page 34]






INTERNET DRAFT                                              October 2002


   o  ID Type (1 octet) - Specifies the type of Identification being
      used.

   o  RESERVED - MUST be sent as zero; MUST be ignored.

   o  Identification Data (variable length) - Value, as indicated by
      the Identification Type. The length of the Identification Data
      is computed from the size in the ID payload header.

   The payload type for the Identification Payload is five (5).

   The following table lists the assigned values for the Identification
   Type field, followed by a description of the Identification Data
   which follows:

      ID Type                           Value
      -------                           -----
      RESERVED                            0

      ID_IPV4_ADDR                        1

            A single four (4) octet IPv4 address.

      ID_FQDN                             2

            A fully-qualified domain name string.  An example of a
            ID_FQDN is, "lounge.org".  The string MUST not contain any
            terminators (e.g. NULL, CR, etc.).

      ID_RFC822_ADDR                      3

            A fully-qualified RFC822 email address string, An example of
            a ID_RFC822_ADDR is, "lizard@lounge.org".  The string MUST
            not contain any terminators.

      ID_IPV6_ADDR                        5

            A single sixteen (16) octet IPv6 address.

      ID_DER_ASN1_DN                      9

            The binary DER encoding of an ASN.1 X.500 Distinguished Name
            [X.501].

      ID_DER_ASN1_GN                      10

            The binary DER encoding of an ASN.1 X.500 GeneralName
            [X.509].



IKEv2                                                      [Page 35]






INTERNET DRAFT                                              October 2002


      ID_KEY_ID                           11

            An opaque octet stream which may be used to pass vendor-
            specific information necessary to do certain proprietary
            forms of identification.



5.6 Certificate Payload

   The Certificate Payload, denoted CERT in this memo, provides a means
   to transport certificates or other certificate-related information
   via IKE. Certificate payloads SHOULD be included in an exchange if
   certificates are available to the sender.

   The Certificate Payload is defined as follows:

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Cert Encoding !                                               !
      +-+-+-+-+-+-+-+-+                                               !
      ~                       Certificate Data                        ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                Figure 9:  Certificate Payload Format

      o  Certificate Encoding (1 octet) - This field indicates the type
         of certificate or certificate-related information contained
         in the Certificate Data field.

                 Certificate Encoding               Value
                 --------------------               -----
                 NONE                                 0
                 PKCS #7 wrapped X.509 certificate    1
                 PGP Certificate                      2
                 DNS Signed Key                       3
                 X.509 Certificate - Signature        4
                 Kerberos Token                       6
                 Certificate Revocation List (CRL)    7
                 Authority Revocation List (ARL)      8
                 SPKI Certificate                     9
                 X.509 Certificate - Attribute       10
                 RESERVED                          11 - 255




IKEv2                                                      [Page 36]






INTERNET DRAFT                                              October 2002


      o  Certificate Data (variable length) - Actual encoding of
         certificate data.  The type of certificate is indicated
         by the Certificate Encoding field.

   The payload type for the Certificate Payload is six (6).

5.7 Certificate Request Payload

   The Certificate Request Payload, denoted CERTREQ in this memo,
   provides a means to request preferred certificates via IKE and can
   appear in the first, second, or third message of Phase 1.
   Certificate Request payloads SHOULD be included in an exchange
   whenever the peer may have multiple certificates, some of which might
   be trusted while others are not.  If multiple root CA's are trusted,
   then multiple Certificate Request payloads SHOULD be transmitted.

   Empty (zero length) CA names MUST NOT be generated and SHOULD be
   ignored.

   The Certificate Request Payload is defined as follows:

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Cert Encoding !                                               !
      +-+-+-+-+-+-+-+-+                                               !
      ~                    Certification Authority                    ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            Figure 10:  Certificate Request Payload Format

   o  Certificate Encoding (1 octet) - Contains an encoding of the type
      of certificate requested.  Acceptable values are listed in
      section 5.6.

   o  Certification Authority (variable length) - Contains an encoding
      of an acceptable certification authority for the type of
      certificate requested.

      The payload type for the Certificate Request Payload is seven (7).

   The Certificate Request Payload is constructed by setting the "Cert
   Encoding" field to be the type of certificate being desired and the
   "Certification Authority" field to a proper encoding of a
   certification authority for the specified certificate. For example,



IKEv2                                                      [Page 37]






INTERNET DRAFT                                              October 2002


   for an X.509 certificate this field would contain the Distinguished
   Name encoding of the Issuer Name of an X.509 certification authority
   acceptable to the sender of this payload.

   The Certificate Request Payload is processed by inspecting the "Cert
   Encoding" field to determine whether the processor has any
   certificates of this type. If so the "Certification Authority" field
   is inspected to determine if the processor has any certificates which
   can be validated up to the specified certification authority. This
   can be a chain of certificates. If a certificate exists which
   satisfies the criteria specified in the Certificate Request Payload
   it MUST be sent back to the certificate requestor; if a certificate
   chain exists which goes back to the certification authority specified
   in the request the entire chain SHOULD be sent back to the
   certificate requestor. If no certificates exist then no further
   processing is performed-- this is not an error condition of the
   protocol. There may be cases where there is a preferred CA, but an
   alternate might be acceptable (perhaps after prompting a human
   operator).

5.8 Authentication Payload

   The Authentication Payload, denoted AUTH in this memo, contains data
   used for authentication purposes. The only authentication method
   defined in this memo is digital signatures and therefore the contents
   of this payload when used with this memo will be the output generated
   by a digital signature function.

   The Authentication Payload is defined as follows:

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                      Authentication Data                      ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                 Figure 11:  Authentication Payload Format

   o  Authentication Data (variable length) - Data that results from
      applying the digital signature function to the IKE state
      (see section 3).

      The payload type for the Authentication Payload is nine (9).




IKEv2                                                      [Page 38]






INTERNET DRAFT                                              October 2002


   The Authentication Payload is constructed by computing a digital
   signature (or secret key MAC) over part of one of the sender's
   messages (see section 4.15).  The result is placed in the
   "Authentication Data" portion of the payload.  The encoding depends
   on the type of key being used to authenticate (see section 4.2).  The
   payload length is the size of the generic header plus the size of the
   "Authentication Data" portion of the payload which depends on the
   specific authentication method being used.

   The Authentication Payload is processed by extracting the
   "Authentication Data" from the payload and verifying it according to
   the specific authentication method being used. If authentication
   fails a NOTIFY Error message of AUTHENTICATION-FAILED MUST be sent
   back to the peer and the connection closed.

5.9 Nonce Payload

   The Nonce Payload, denoted Ni and Nr in this memo for the Initiator's
   and Responder's nonce respectively, contains random data used to
   guarantee liveness during an exchange and protect against replay
   attacks.

   The Nonce Payload is defined as follows:

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                            Nonce Data                         ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 12:  Nonce Payload Format

   o  Nonce Data (variable length) - Contains the random data generated
      by the transmitting entity.

      The payload type for the Nonce Payload is ten (10).

   The Nonce Payload is constructed by computing a pseudo-random value
   and copying it into the "Nonce Data" field. The size of a Nonce MUST
   be between 8 and 256 octets inclusive. Nonce values MUST NOT be
   reused.  They MAY be as long as 256 octets to support there use in
   carrying state when defending against certain denial of service
   attacks (see Section 4.6).




IKEv2                                                      [Page 39]






INTERNET DRAFT                                              October 2002


5.10 Notify Payload

   The Notify Payload, denoted N in this document, is used to transmit
   informational data, such as error conditions and state transitions to
   an IKE peer. A Notify Payload may appear in a response message
   (usually specifying why a request was rejected), or in an
   Informational Exchange (to report an error not in an IKE request).

   The Notify Payload is defined as follows:

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !  Protocol-ID  !   SPI Size    !      Notify Message Type      !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                Security Parameter Index (SPI)                 ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                       Notification Data                       ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               Figure 13:  Notification Payload Format

   o  Protocol-Id (1 octet) - Specifies the protocol about which
      this notification is being sent. For phase 1 notifications,
      this field MUST be zero (0). For phase 2 notifications
      concerning IPsec SAs this field will contain an IPsec
      protocol (either ESP, AH, or IPcomp). For notifications
      for which no protocol ID is relevant, this field MUST be
      sent as zero and MUST be ignored.

   o  SPI Size (1 octet) - Length in octets of the SPI as defined by
      the Protocol-Id or zero if no SPI is applicable.  For phase 1
      notification concerning the IKE-SA, the SPI Size MUST be zero.

   o  Notify Message Type (2 octets) - Specifies the type of
      notification message.

   o  SPI (variable length) - Security Parameter Index.

   o  Notification Data (variable length) - Informational or error data
      transmitted in addition to the Notify Message Type. Values for
      this field are message specific, see below.



IKEv2                                                      [Page 40]






INTERNET DRAFT                                              October 2002


      The payload type for the Notification Payload is eleven (11).

5.10.1 Notify Message Types

   Notification information can be error messages specifying why an SA
   could not be established.  It can also be status data that a process
   managing an SA database wishes to communicate with a peer process.
   For example, a secure front end or security gateway may use the
   Notify message to synchronize SA communication.  The table below
   lists the Notification messages and their corresponding values.  The
   number of different error statuses was greatly reduced from IKE V1
   both for simplication and to avoid giving configuration information
   to probers.

        NOTIFY MESSAGES - ERROR TYPES           Value
        -----------------------------           -----
        UNSUPPORTED-CRITICAL-PAYLOAD              1

            Sent if the payload has the "critical" bit set and the
            payload type is not recognised. Notification Data contains
            the one octet payload type.

        INVALID-COOKIE                            4

            Indicates an IKE message was received with an unrecognized
            destination cookie. This usually indicates that the
            recipient has rebooted and forgotten the existence of an
            IKE-SA.

        INVALID-MAJOR-VERSION                     5

            Indicates the recipient cannot handle the version of IKE
            specified in the header. The closest version number that the
            recipient can support will be in the reply header.

        INVALID-SYNTAX                            7

            Indicates the IKE message was received was invalid because
            some type, length, or value was out of range or because the
            request was rejected for policy reasons. To avoid a denial
            of service attack using forged messages, this status may
            only be returned for and in an encrypted packet if the
            MESSAGE-ID and cryptographic checksum were valid. To avoid
            leaking information to someone probing a node, this status
            MUST be sent in response to any error not covered by one of
            the other status codes. To aid debugging, more detailed
            error information SHOULD be written to a console or log.




IKEv2                                                      [Page 41]






INTERNET DRAFT                                              October 2002


        INVALID-MESSAGE-ID                        9

            Sent when an IKE MESSAGE-ID outside the negotiated window is
            received.  This Notify MUST NOT be sent in a response; the
            invalid request MUST NOT be acknowledged.  Instead, inform
            the other side by initiating an Informational exchange with
            Notification data containing the four octet invalid
            MESSAGE-ID.

        INVALID-SPI                              11

            MAY be sent in an IKE Informational Exchange when a node
            receives an ESP or AH packet with an invalid SPI. The
            Notification Data contains the SPI of the invalid packet.
            This usually indicates a node has rebooted and forgotten an
            SA.  If this Informational Message is sent outside the
            context of an IKE-SA, it should only be used by the
            recipient as a "hint" that something might be wrong (because
            it could easily be forged).

        NO-PROPOSAL-CHOSEN                       14

            None of the proposed crypto suites was acceptable.

        SINGLE-PAIR-REQUIRED                     34

            This error indicates that a Phase 2 SA request is
            unacceptable because the Responder is willing to accept
            traffic selectors specifying a single pair of addresses.
            The Initiator is expected to respond by requesting an SA for
            only the specific traffic he is trying to forward.

        NO-ADDITIONAL-SAS                        35

            This error indicates that a Phase 2 SA request is
            unacceptable because the Responder is unwilling to accept
            any more Child-SAs on this IKE-SA. Some minimal
            implementations may only accept a single Child-SA setup in
            the context of an initial IKE exchange and reject any
            subsequent attempts to add more.

        RESERVED TO IANA - Errors             36 - 8191

        Private Use - Errors                8192 - 16383



        NOTIFY MESSAGES - STATUS TYPES           Value



IKEv2                                                      [Page 42]






INTERNET DRAFT                                              October 2002


        ------------------------------           -----

        RESERVED                             16384 - 24577

        INITIAL-CONTACT                          24578

            This notification asserts that this IKE-SA is the only IKE-
            SA currently active between the authenticated identities. It
            MAY be sent when an IKE-SA is established after a crash, and
            the recipient MAY use this information to delete any other
            IKE-SAs it has to the same authenticated identity without
            waiting for a timeout if those IKE-SAs reside at the IP
            address from which this notification arrived.  This
            notification MUST NOT be sent by an entity that may be
            replicated (e.g. a roaming user's credentials where the user
            is allowed to connect to the corporate firewall from two
            remote systems at the same time).

        SET-WINDOW-SIZE                          24579

            This notification asserts that the sending endpoint is
            capable of keeping state for multiple outstanding Phase 2
            exchanges, permitting the recipient to send multiple Phase 2
            requests before getting a response to the first. The data
            associated with a SET-WINDOW-SIZE notification MUST be 4
            octets long an contain the big endian represention of the
            number of messages the sender promises to keep.

        ADDITIONAL-TS-POSSIBLE                   24580

            This notification asserts that the sending endpoint narrowed
            the proposed traffic selectors but that other traffic
            selectors would also have been acceptable, though only in a
            separate SA. There is no data associated with this notify
            type. It may only be sent as an additional payload in a
            message including accepted TSs.

        RESERVED                             24581 - 40959

        Private Use - STATUS                 40960 - 65535


5.11 Delete Payload

   The Delete Payload, denoted D in this memo, contains a protocol-
   specific security association identifier that the sender has removed
   from its security association database and is, therefore, no longer
   valid.  Figure 14 shows the format of the Delete Payload. It is



IKEv2                                                      [Page 43]






INTERNET DRAFT                                              October 2002


   possible to send multiple SPIs in a Delete payload, however, each SPI
   MUST be for the same protocol. Mixing of Protocol Identifiers MUST
   NOT be performed with the Delete payload. It is permitted, however,
   to include multiple Delete payloads in a single Informational
   Exchange where each Delete payload lists SPIs for a different
   protocol.

   Deletion of the IKE-SA is indicated by a Protocol-Id of 0 (IKE) but
   no SPIs.  Deletion of a Child-SA, such as ESP or AH, will contain the
   Protocol-Id of that protocol (e.g.  ESP, AH) and the SPI is the
   receiving entity's SPI(s).

   NOTE: What's the deal with IPcomp SAs. This mechanism is probably not
   appropriate for deleting them!!

   The Delete Payload is defined as follows:

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !  Protocol-Id  !   SPI Size    !           # of SPIs           !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~               Security Parameter Index(es) (SPI)              ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                  Figure 14:  Delete Payload Format

   o  Protocol-Id (1 octet) - Must be zero for an IKE-SA, 50 for
      ESP, 51 for AH, and 108 for IPcomp.

   o  SPI Size (1 octet) - Length in octets of the SPI as defined by
      the Protocol-Id.  Zero for IKE (SPI is in message header),
      four for AH and ESP, two for IPcomp.

   o  # of SPIs (2 octets) - The number of SPIs contained in the Delete
      payload.  The size of each SPI is defined by the SPI Size field.

   o  Security Parameter Index(es) (variable length) - Identifies the
      specific security association(s) to delete.
      The length of this field is
      determined by the SPI Size and # of SPIs fields.

      The payload type for the Delete Payload is twelve (12).




IKEv2                                                      [Page 44]






INTERNET DRAFT                                              October 2002


5.12 Vendor ID Payload

   The Vendor ID Payload contains a vendor defined constant.  The
   constant is used by vendors to identify and recognize remote
   instances of their implementations.  This mechanism allows a vendor
   to experiment with new features while maintaining backwards
   compatibility.

   The Vendor ID payload is not an announcement from the sender that it
   will send private payload types but rather an announcement of the
   sort of private payloads it is willing to accept. The implementation
   sending the Vendor ID MUST not make any assumptions about private
   payloads that it may send unless a Vendor ID of like stature is
   received as well.  Multiple Vendor ID payloads MAY be sent. An
   implementation is NOT REQUIRED to send any Vendor ID payload at all.

   A Vendor ID payload may be sent as part of any message.  Reception of
   a familiar Vendor ID payload allows an implementation to make use of
   Private USE numbers described throughout this memo-- private
   payloads, private exchanges, private notifications, etc. Unfamiliar
   Vendor IDs MUST be ignored.

   Writers of Internet-Drafts who wish to extend this protocol MUST
   define a Vendor ID payload to announce the ability to implement the
   extension in the Internet-Draft. It is expected that Internet-Drafts
   which gain acceptance and are standardized will be given "magic
   numbers" out of the Future Use range by IANA and the requirement to
   use a Vendor ID will go away.

   The Vendor ID Payload fields are defined as follows:

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                        Vendor ID (VID)                        ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                 Figure 15:  Vendor ID Payload Format

   o  Vendor ID (variable length) - It is the responsibility of
      the person choosing the Vendor ID to assure its uniqueness
      in spite of the absence of any central registry for IDs.
      Good practice is to include a company name, a person name
      or some such. If you want to show off, you might include



IKEv2                                                      [Page 45]






INTERNET DRAFT                                              October 2002


      the latitude and longitude and time where you were when
      you chose the ID and some random input. A message digest
      of a long unique string is preferable to the long unique
      string itself.

      The payload type for the Vendor ID Payload is thirteen (13).


5.13 Traffic Selector Payload

   The Traffic Selector Payload, denoted TS in this memo, allows peers
   to identify packet flows for processing by IPsec security services.
   The Traffic Selector Payload consists of the IKE generic header
   followed by individual traffic selectors as follows:

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Number of TSs !                 RESERVED                      !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                       <Traffic Selectors>                     ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               Figure 16:  Traffic Selectors Payload Format

   o  Number of TSs (1 octet) - Number of traffic selectors
      being provided.

   o  RESERVED - This field MUST be sent as zero and MUST be ignored.

   o  Traffic Selectors (variable length) - one or more individual
      traffic
      selectors.

   The length of the Traffic Selector payload includes the TS header and
   all the traffic selectors.
   The payload type for the Traffic Selector payload is fourteen (14).

5.13.1 Traffic Selector

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !   TS Type     !  Protocol ID  |       Selector Length         |



IKEv2                                                      [Page 46]






INTERNET DRAFT                                              October 2002


      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Start-Port          |           End-Port            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                         Starting Address                      ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                         Ending Address                        ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                  Figure 17: Traffic Selector

   o  TS Type (one octet) - Specifies the type of traffic selector.

   o  Protocol ID (1 octet) - Value specifying an associated IP
      protocol ID (e.g. UDP/TCP). A value of zero means that the
      Protocol ID is not relevant to this traffic selector--
      the SA can carry all protocols.

   o  Selector Length - Specifies the length of this Traffic
      Selector Substructure including the header.

   o  Start-Port (2 octets) - Value specifying the smallest port
      number allowed by this Traffic Selector. For protocols for
      which port is undefined, or if all ports are allowed by
      this Traffic Selector, this field MUST be zero.

   o  End-Port (2 octets) - Value specifying the largest port
      number allowed by this Traffic Selector. For protocols for
      which port is undefined, or it all ports are allowed by
      this Traffic Selector, this field MUST be 65535.

   o  Starting Address - The smallest address included in this
      Traffic Selector (length determined by TS type).

   o  Ending Address - The largest address included in this
      Traffic Selector (length determined by TS type).

   The following table lists the assigned values for the Traffic
   Selector Type field and the corresponding Address Selector Data.

      TS Type                           Value
      -------                           -----
      RESERVED                            0

      TS_IPV4_ADDR_RANGE                  7



IKEv2                                                      [Page 47]






INTERNET DRAFT                                              October 2002


            A range of IPv4 addresses, represented by two four (4) octet
            values.  The first value is the beginning IPv4 address
            (inclusive) and the second value is the ending IPv4 address
            (inclusive). All addresses falling between the two specified
            addresses are considered to be within the list.

      TS_IPV6_ADDR_RANGE                  8

            A range of IPv6 addresses, represented by two sixteen (16)
            octet values.  The first value is the beginning IPv6 address
            (inclusive) and the second value is the ending IPv6 address
            (inclusive). All addresses falling between the two specified
            addresses are considered to be within the list.

5.14 Encrypted Payload

   The Encrypted Payload, denoted SK{...} in this memo, contains other
   payloads in encrypted form. The Encrpted Payload, if present in a
   message, must be the last payload in the message. Often, it is the
   only payload in the message.

   The algorithms for encryption and integrity protection are negotiated
   during IKE-SA setup, and the keys are computed as specified in
   sections 4.14 and 4.17.

   The encryption and integrity protection algorithms are modelled after
   the ESP algorithms described in RFCs 2104, 2406, 2451. This document
   completely specifies the cryptographic processing of IKE data, but
   those documents should be consulted for design rationale. We assume a
   block cipher with a fixed block size and an integrity check algorithm
   that computes a fixed length checksum over a variable size message.
   The mandatory to implement algorithms are AES-128-CBC and HMAC-SHA1.

   The Payload Type for an Encrypted payload is fifteen (15).  The
   Encrypted Payload consists of the IKE generic header followed by
   individual fields as follows:

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                     Initialization Vector                     !
      !         (length is block size for encryption algorithm)       !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                    Encrypted IKE Payloads                     !
      +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !               !             Padding (0-255 octets)            !



IKEv2                                                      [Page 48]






INTERNET DRAFT                                              October 2002


      +-+-+-+-+-+-+-+-+                               +-+-+-+-+-+-+-+-+
      !                                               !  Pad Length   !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ~                    Integrity Checksum Data                    ~
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               Figure 9:  Encrypted Payload Format

   o  Next Payload - The payload type of the first embedded payload.
      Since the Encrypted payload must be last in a message, there
      is no need to specify a payload type for a payload beyond it.

   o  Payload Length - Includes the lengths of the IV, Padding, and
      Authentication data.

   o  Initialization Vector - A randomly chosen value whose length
      is equal to the block length of the underlying encryption
      algorithm. Recipients MUST accept any value. Senders SHOULD
      either pick this value pseudo-randomly and independently for
      each message or use the final ciphertext block of the previous
      message sent. Senders MUST NOT use the same value for each
      message, use a sequence of values with low hamming distance
      (e.g. a sequence number), or use ciphertext from a received
      message.

   o  IKE Payloads are as specified earlier in this section. This
      field is encrypted with the negotiated cipher.

   o  Padding may contain any value chosen by the sender, and must
      have a length that makes the combination of the Payloads, the
      Padding, and the Pad Length to be a multiple of the encryption
      block size. This field is encrypted with the negotiated
      cipher.

   o  Pad Length is the length of the Padding field. The sender
      SHOULD set the Pad Length to the minimum value that makes
      the combination of the Payloads, the Padding, and the Pad
      Length a multiple of the block size, but the recipient MUST
      accept any length that results in proper alignment. This
      field is encrypted with the negotiated cipher.

   o  Integrity Checksum Data is the cryptographic checksum of
      the entire message starting with the Fixed IKE Header
      through the Pad Length. The checksum MUST be computed over
      the encrypted message.

5.15 Other Payload Types




IKEv2                                                      [Page 49]






INTERNET DRAFT                                              October 2002


   Payload type values 16-127 are reserved to IANA for future assignment
   in IKE. Payload type values 128-255 are for private use among
   mutually consenting parties.

6 Conformance Requirements

   In order to assure that all implementations of IKEv2 can
   interoperate, there are MUST support requirements in addition to
   those listed elsewhere. Of course, IKEv2 is a security protocol, and
   one of its major functions is preventing the bad guys from
   interoperating with one's systems. So a particular implementation may
   be configured with any of a number of restrictions concerning
   algorithms and trusted authorities that will prevent universal
   interoperability. For an implementation to be called conforming to
   this specification, it MUST be possible to configure it to accept the
   following:

   X.509 certificates containing and signed by RSA keys of size 512,
   768, 1024, and 2048 bits. (It SHOULD accept RSA keys of any multiple
   of 8 bits in size from 512 bits to 4092 bits, and MAY accept RSA keys
   of any size).  If there is a limit on the size of an X.509
   certificate, it MUST be at least 8K. If there is a limit on the
   length of a certificate chain, it MUST be at least 10.

   X.509 certificates containing and signed by DSS keys of size 512,
   768, 1024, and 2048 bits. (It MAY accept DSS keys of any size).

   An implementation MUST be capable of accepting a shared key for
   authentication of any size from 1 - 255 bytes.

   An implementation MUST be capable of accepting IKE messages with
   sizes up to 16K bytes and SHOULD be capable of accepting IKE messages
   up to 64K bytes.

   An implementation MUST be capable of establishing an IKE-SA and a
   single CHILD-SA in the initial four message exchange. An
   implementation MAY reject subsequent requests to establish a CHILD-
   SA. An implementation MUST respond to valid phase 2 messages, but MAY
   otherwise ignore all such messages other than DELETE. There is no
   requirement that an implementation be capable of initiating phase 2
   exchanges.

   The above paragraph allows for a minimal implementation to only do
   the initial 4 message IKE exchange and respond to phase 2 pings and
   still interoperate with any compliant implementation. In support of
   this, and implementation that tries to rekey the IKE-SA by means of a
   CREATE_CHILD_SA exchange MUST be prepared to tear down the IKE-SA and
   establish a new one if the rekeying operation fails.



IKEv2                                                      [Page 50]






INTERNET DRAFT                                              October 2002


7 Security Considerations

   Repeated re-keying using Phase 2 without PFS can consume the entropy
   of the Diffie-Hellman shared secret. Implementers should take note of
   this fact and set a limit on Phase 2 Exchanges between
   exponentiations.  This memo does not prescribe such a limit.

   The strength of a key derived from a Diffie-Hellman exchange using
   any of the groups defined here depends on the inherent strength of
   the group, the size of the exponent used, and the entropy provided by
   the random number generator used. Due to these inputs it is difficult
   to determine the strength of a key for any of the defined groups.
   Diffie-Hellman group number two when used with a strong random number
   generator and an exponent no less than 160 bits is sufficient to use
   for 3DES.  Groups three through five provide greater security. Group
   one is for historic purposes only and does not provide sufficient
   strength to the required cipher (although it is sufficient for use
   with DES, which is also for historic use only). Implementations
   should make note of these conservative estimates when establishing
   policy and negotiating security parameters.

   Note that these limitations are on the Diffie-Hellman groups
   themselves.  There is nothing in IKE which prohibits using stronger
   groups nor is there anything which will dilute the strength obtained
   from stronger groups. In fact, the extensible framework of IKE
   encourages the definition of more groups; use of elliptical curve
   groups may greatly increase strength using much smaller numbers.

   It is assumed that the Diffie-Hellman exponents in this exchange are
   erased from memory after use. In particular, these exponents MUST NOT
   be derived from long-lived secrets like the seed to a pseudo-random
   generator that is not erased after use.

   The security of this protocol is critically dependent on the
   randomness of the Diffie-Hellman exponents, which should be generated
   by a strong random or properly seeded pseudo-random source (see
   RFC1715). While the protocol was designed to be secure even if the
   Nonces and other values specified as random are not strongly random,
   they should similarly be generated from a strong random source as
   part of a conservative design.

8 IANA Considerations

   This document contains many "magic numbers" to be maintained by the
   IANA.  This section explains the criteria to be used by the IANA to
   assign additional numbers in each of these lists.

8.1.2 Encryption Algorithm Transform Type



IKEv2                                                      [Page 51]






INTERNET DRAFT                                              October 2002


   Values of the Encryption Algorithm define an encryption algorithm to
   use when called for in this document. Requests for assignment of new
   encryption algorithm values must be accompanied by a reference to an
   RFC that describes how to use this algorithm with ESP.

8.1.4 Authentication Method Transform Type

   The only Authentication method defined in the memo is for digital
   signatures. Other methods of authentication are possible and MUST be
   accompanied by an RFC which defines the following:

       - the cryptographic method of authentication.
       - content of the Authentication Data in the Authentication
       Payload.
       - new payloads, their construction and processing, if needed.
       - additions of payloads to any messages, if needed.

8.1.5 Diffie-Hellman Groups

   Values of the Diffie-Hellman Group Transform types define a group in
   which a Diffie-Hellman key exchange can be completed.  Requests for
   assignment of a new Diffie-Hellman group type MUST be accompanied by
   a reference to an RFC which fully defines the group.

8.2 Exchange Types

   This memo defines three exchange types for use with IKEv2. Requests
   for assignment of new exchange types MUST be accompanied by an RFC
   which defines the following:

          - the purpose of and need for the new exchange.
          - the payloads (mandatory and optional) that accompany
          messages in the exchange.
          - the phase of the exchange.
          - requirements the new exchange has on existing
          exchanges which have assigned numbers.

8.3 Payload Types

   Payloads are defined in this memo to convey information between
   peers. New payloads may be required when defining a new
   authentication method or exchange. Requests for new payload types
   MUST be accompanied by an RFC which defines the physical layout of
   the payload and the fields it contains. All payloads MUST use the
   same generic header defined in Figure 2.

9 Acknowledgements




IKEv2                                                      [Page 52]






INTERNET DRAFT                                              October 2002


   This document is a collaborative effort of the entire IPsec WG. If
   there were no limit to the number of authors that could appear on an
   RFC, the following, in alphabetical order, would have been listed:
   Bill Aiello, Steve Bellovin, Sara Bitan, Matt Blaze, Ran Canetti, Dan
   Harkins, Paul Hoffman, J. Ioannidis, Steve Kent, Angelos Keromytis,
   Tero Kivinen, Hugo Krawczyk, Andrew Krywaniuk, Radia Perlman, O.
   Reingold. Many other people contributed to the design. Hugh Daniel
   suggested the feature of having the initiator, in message 3, specify
   a name for the responder, and gave the feature the cute name "You
   Tarzan, Me Jane". David Faucher and Valery Smyzlov helped refine the
   design of the traffic selector negotiation.

10 References

   [Bra96]  Bradner, S., "The Internet Standards Process -- Revision 3",
            BCP 9, RFC 2026, October 1996.

   [Bra97]  Bradner, S., "Key Words for use in RFCs to indicate
            Requirement Levels", BCP 14, RFC 2119, March 1997.

   [Ble98]  Bleichenbacher, D., "Chosen Ciphertext Attacks against
            Protocols Based on RSA Encryption Standard PKCS#1", Advances
            in Cryptology Eurocrypt '98, Springer-Verlag, 1998.

   [BR94]   Bellare, M., and Rogaway P., "Optimal Asymmetric
            Encryption", Advances in Cryptology Eurocrypt '94,
            Springer-Verlag, 1994.

   [DES]    ANSI X3.106, "American National Standard for Information
            Systems-Data Link Encryption", American National Standards
            Institute, 1983.

   [DH]     Diffie, W., and Hellman M., "New Directions in
            Cryptography", IEEE Transactions on Information Theory, V.
            IT-22, n. 6, June 1977.

   [DSS]    NIST, "Digital Signature Standard", FIPS 186, National
            Institute of Standards and Technology, U.S. Department of
            Commerce, May, 1994.

   [HC98]   Harkins, D., Carrel, D., "The Internet Key Exchange (IKE)",
            RFC 2409, November 1998.

   [IDEA]   Lai, X., "On the Design and Security of Block Ciphers," ETH
            Series in Information Processing, v. 1, Konstanz: Hartung-
            Gorre Verlag, 1992

   [Ker01]  Keronytis, A., Sommerfeld, B., "The 'Suggested ID' Extension



IKEv2                                                      [Page 53]






INTERNET DRAFT                                              October 2002


            for IKE", draft-keronytis-ike-id-00.txt, 2001


   [KBC96]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
            Hashing for Message Authentication", RFC 2104, February
            1997.

   [SKEME]  Krawczyk, H., "SKEME: A Versatile Secure Key Exchange
            Mechanism for Internet", from IEEE Proceedings of the 1996
            Symposium on Network and Distributed Systems Security.

   [MD5]    Rivest, R., "The MD5 Message Digest Algorithm", RFC 1321,
            April 1992.

   [MSST98] Maughhan, D., Schertler, M., Schneider, M., and Turner, J.
            "Internet Security Association and Key Management Protocol
            (ISAKMP)", RFC 2408, November 1998.

   [Orm96]  Orman, H., "The Oakley Key Determination Protocol", RFC
            2412, November 1998.

   [PFKEY]  McDonald, D., Metz, C., and Phan, B., "PFKEY Key Management
            API, Version 2", RFC2367, July 1998.

   [PKCS1]  Kaliski, B., and J. Staddon, "PKCS #1: RSA Cryptography
            Specifications Version 2", September 1998.

   [PK01]   Perlman, R., and Kaufman, C., "Analysis of the IPsec key
            exchange Standard", WET-ICE Security Conference, MIT, 2001,
            http://sec.femto.org/wetice-2001/papers/radia-paper.pdf.

   [Pip98]  Piper, D., "The Internet IP Security Domain Of
            Interpretation for ISAKMP", RFC 2407, November 1998.

   [RSA]    Rivest, R., Shamir, A., and Adleman, L., "A Method for
            Obtaining Digital Signatures and Public-Key Cryptosystems",
            Communications of the ACM, v. 21, n. 2, February 1978.

   [SHA]    NIST, "Secure Hash Standard", FIPS 180-1, National Institute
            of Standards and Technology, U.S. Department of Commerce,
            May 1994.










IKEv2                                                      [Page 54]






INTERNET DRAFT                                              October 2002


Appendix B: Diffie-Hellman Groups

   There are 5 groups different Diffie-Hellman groups defined for use in
   IKE. These groups were generated by Richard Schroeppel at the
   University of Arizona. Properties of these primes are described in
   [Orm96].

   The strength supplied by group one may not be sufficient for the
   mandatory-to-implement encryption algorithm and is here for historic
   reasons.

B.1 Group 1 - 768 Bit MODP

   IKE implementations MAY support a MODP group with the following prime
   and generator. This group is assigned id 1 (one).

   The prime is: 2^768 - 2 ^704 - 1 + 2^64 * { [2^638 pi] + 149686 }
   Its hexadecimal value is:

        FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
        8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
        302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
        A63A3620 FFFFFFFF FFFFFFFF

   The generator is 2.

B.2 Group 2 - 1024 Bit MODP

   IKE implementations SHOULD support a MODP group with the following
   prime and generator. This group is assigned id 2 (two).





















IKEv2                                                      [Page 55]






INTERNET DRAFT                                              October 2002


   The prime is 2^1024 - 2^960 - 1 + 2^64 * { [2^894 pi] + 129093 }.
   Its hexadecimal value is:

        FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
        8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
        302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
        A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6
        49286651 ECE65381 FFFFFFFF FFFFFFFF

   The generator is 2.

B.3 Group 3 - 155 Bit EC2N

   IKE implementations MAY support a EC2N group with the following
   characteristics. This group is assigned id 3 (three). The curve is
   based on the Galois Field GF[2^155]. The field size is 155. The
   irreducible polynomial for the field is:
      u^155 + u^62 + 1.
   The equation for the elliptic curve is:
      y^2 + xy = x^3 + ax^2 + b.

   Field Size:                         155
   Group Prime/Irreducible Polynomial:
                0x0800000000000000000000004000000000000001
   Group Generator One:                0x7b
   Group Curve A:                      0x0
   Group Curve B:                      0x07338f
   Group Order: 0x0800000000000000000057db5698537193aef944

   The data in the KE payload when using this group is the value x from
   the solution (x,y), the point on the curve chosen by taking the
   randomly chosen secret Ka and computing Ka*P, where * is the
   repetition of the group addition and double operations, P is the
   curve point with x coordinate equal to generator 1 and the y
   coordinate determined from the defining equation. The equation of
   curve is implicitly known by the Group Type and the A and B
   coefficients. There are two possible values for the y coordinate;
   either one can be used successfully (the two parties need not agree
   on the selection).












IKEv2                                                      [Page 56]






INTERNET DRAFT                                              October 2002


B.4 Group 4 - 185 Bit EC2N

   IKE implementations MAY support a EC2N group with the following
   characteristics. This group is assigned id 4 (four). The curve is
   based on the Galois Field GF[2^185]. The field size is 185. The
   irreducible polynomial for the field is:
      u^185 + u^69 + 1.

   The  equation for the elliptic curve is:
      y^2 + xy = x^3 + ax^2 + b.

   Field Size:                         185
   Group Prime/Irreducible Polynomial:
                0x020000000000000000000000000000200000000000000001
   Group Generator One:                0x18
   Group Curve A:                      0x0
   Group Curve B:                      0x1ee9
   Group Order: 0x01ffffffffffffffffffffffdbf2f889b73e484175f94ebc

   The data in the KE payload when using this group will be identical to
   that as when using Oakley Group 3 (three).

B.5 Group 5 - 1536 Bit MODP

   IKE implementations MUST support a MODP group with the following
   prime and generator. This group is assigned id 5 (five).

   The prime is 2^1536 - 2^1472 - 1 + 2^64 * {[2^1406 pi] + 741804}.
   Its hexadecimal value is

        FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
        8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
        302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
        A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6
        49286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8
        FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
        670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF

   The generator is 2.












IKEv2                                                      [Page 57]






INTERNET DRAFT                                              October 2002


Change History

H.1 Changes from IKEv2-00 to IKEv2-01 February 2002

   1) Changed Appendix B to specify the encryption and authentication
   processing for IKE rather than referencing ESP. Simplified the format
   by removing idiosyncracies not needed for IKE.

   2) Added option for authentication via a shared secret key.

   3) Specified different keys in the two directions of IKE messages.
   Removed requirement of different cookies in the two directions since
   now no longer required.

   4) Change the quantities signed by the two ends in AUTH fields to
   assure the two parties sign different quantities.

   5) Changed reference to AES to AES_128.

   6) Removed requirement that Diffie-Hellman be repeated when rekeying
   IKE SA.

   7) Fixed typos.

   8) Clarified requirements around use of port 500 at the remote end in
   support of NAT.

   9) Clarified required ordering for payloads.

   10) Suggested mechanisms for avoiding DoS attacks.

   11) Removed claims in some places that the first phase 2 piggybacked
   on phase 1 was optional.

H.2 Changes from IKEv2-01 to IKEv2-02 April 2002

   1) Moved the Initiator CERTREQ payload from message 1 to message 3.

   2) Added a second optional ID payload in message 3 for the Initiator
   to name a desired Responder to support the case where multiple named
   identities are served by a single IP address.

   3) Deleted the optimization whereby the Diffie-Hellman group did not
   need to be specified in phase 2 if it was the same as in phase 1 (it
   complicated the design with no meaningful benefit).

   4) Added a section on the implications of reusing Diffie-Hellman
   expontentials



IKEv2                                                      [Page 58]






INTERNET DRAFT                                              October 2002


   5) Changed the specification of sequence numbers to being at 0 in
   both directions.

   6) Many editorial changes and corrections, the most significant being
   a global replace of "byte" with "octet".

H.3 Changes from IKEv2-02 to IKEv2-03 October 2002

   1) Reorganized the document moving introductory material to the
   front.

   2) Simplified the specification of Traffic Selectors to allow only
   IPv4 and IPv6 address ranges, as was done in the JFK spec.

   3) Fixed the problem brought up by David Faucher with the fix
   suggested by Valery Smyslov. If Bob needs to narrow the selector
   range, but has more than one matching narrower range, then if Alice's
   first selector is a single address pair, Bob chooses the range that
   encompasses that.

   4) To harmonize with the JFK spec, changed the exchange so that the
   initial exchange can be completed in four messages even if the
   responder must invoke an anti-clogging defense and the initiator
   incorrectly anticipates the responder's choice of Diffie-Hellman
   group. This required changing the syntax of encrypted messages to
   allow messages that are partially encrypted.

   5) Replaced the hierarchical SA payload with a simplified version
   that only negotiates suites of cryptographic algorithms. Separated
   out negotiation of window size. Removed specifications of large
   numbers of rarely used algorithms.

   6) Changed the formulas for key derivation as proposed by Hugo
   Krawczyk.

   7) Added Comformance Requirements section.

Author's Address

   Charlie Kaufman charlie_kaufman@notesdev.ibm.com IBM











IKEv2                                                      [Page 59]





