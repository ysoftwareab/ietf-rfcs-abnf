evaluation = Evaluate(skS, pkS, blindToken)

issuedToken = Unblind(pkS, token, blindToken, evaluation)
output = Finalize(input, issuedToken, info)

contextString = I2OSP(modeBase, 1) || I2OSP(suite.ID, 2)
contextString = I2OSP(modeBase, 1) || I2OSP(suite.ID, 2)
contextString = I2OSP(modeVerifiable, 1) || I2OSP(suite.ID, 2)
contextString = I2OSP(modeVerifiable, 1) || I2OSP(suite.ID, 2)
BT = GG.Deserialize(blindToken)
Z = skS * BT
serializedElement = GG.Serialize(Z)

Ev = Evaluation{ element: serializedElement }

P = GG.HashToGroup(input)
T = skS * P
issuedToken = GG.serialize(T)

finalizeDST = "VOPRF05-Finalize-" || self.contextString
hashInput = I2OSP(len(input), 2) || input ||
                 I2OSP(len(issuedToken), 2) || issuedToken ||
                 I2OSP(len(info), 2) || info ||
                 I2OSP(len(finalizeDST), 2) || finalizeDST

T = GG.HashToGroup(input)
element = GG.Serialize(T)
issuedElement = Evaluate(skS, [element])
E = GG.Serialize(issuedElement)

finalizeDST = "VOPRF05-Finalize-" || self.contextString
hashInput = I2OSP(len(input), 2) || input ||
                 I2OSP(len(E), 2) || E ||
                 I2OSP(len(info), 2) || info ||
                 I2OSP(len(finalizeDST), 2) || finalizeDST

digest = Hash(hashInput)

BT = GG.Deserialize(blindToken)
Z = skS * BT
serializedElement = GG.Serialize(Z)

proof = GenerateProof(skS, pkS, blindToken, serializedElement)
Ev = Evaluation{ element: serializedElement, proof: proof }

blindTokenList = [blindToken]
elementList = [element]

a = ComputeComposites(pkS, blindTokenList, elementList)

M = GG.Deserialize(a[0])
r = GG.RandomScalar()
a2 = GG.Serialize(ScalarBaseMult(r))
a3 = GG.Serialize(r * M)

challengeDST = "VOPRF05-challenge-" || self.contextString
h2Input = I2OSP(len(pkS), 2) || pkS ||
               I2OSP(len(a[0]), 2) || a[0] ||
               I2OSP(len(a[1]), 2) || a[1] ||
               I2OSP(len(a2), 2) || a2 ||
               I2OSP(len(a3), 2) || a3 ||
               I2OSP(len(challengeDST), 2) || challengeDST

c = GG.HashToScalar(h2Input)
s = (r - c * skS) mod p

seedDST = "VOPRF05-seed-" || self.contextString
compositeDST = "VOPRF05-composite-" || self.contextString
h1Input = I2OSP(len(pkS), 2) || pkS ||
               I2OSP(len(blindTokens), 2) || blindTokens ||
               I2OSP(len(elements), 2) || elements ||
               I2OSP(len(seedDST), 2) || seedDST

seed = Hash(h1Input)
M = GG.Identity()
Z = GG.Identity()
h2Input = I2OSP(len(seed), 2) || seed || I2OSP(i, 2) ||
                 I2OSP(len(compositeDST), 2) || compositeDST
di = GG.HashToScalar(h2Input)
Mi = GG.Deserialize(blindTokens[i])
Zi = GG.Deserialize(elements[i])
M = di * Mi + M
Z = di * Zi + Z
r = GG.RandomScalar()
P = GG.HashToGroup(input)
blindToken = GG.Serialize(r * P)

token = Token{ data: input, blind: r }

r = token.blind
Z = GG.Deserialize(Ev.element)
N = (r^(-1)) * Z

issuedToken = GG.Serialize(N)

finalizeDST = "VOPRF05-Finalize-" || self.contextString
hashInput = I2OSP(len(token.data), 2) || token.data ||
                 I2OSP(len(issuedToken), 2) || issuedToken ||
                 I2OSP(len(info), 2) || info ||
                 I2OSP(len(finalizeDST), 2) || finalizeDST
blindTokenList = [blindToken]
elementList = [Ev.element]

a = ComputeComposites(pkS, blindTokenList, elementList)

a2 = GG.Serialize(A')
a3 = GG.Serialize(B')

challengeDST = "VOPRF05-challenge-" || self.contextString
h2Input = I2OSP(len(pkS), 2) || pkS ||
               I2OSP(len(a[0]), 2) || a[0] ||
               I2OSP(len(a[1]), 2) || a[1] ||
               I2OSP(len(a2), 2) || a2 ||
               I2OSP(len(a3), 2) || a3 ||
               I2OSP(len(challengeDST), 2) || challengeDST

c  = GG.HashToScalar(h2Input)

r = token.blind
Z = GG.Deserialize(Ev.element)
N = (r^(-1)) * Z

issuedToken = GG.Serialize(N)

PK = GG.Deserialize(pkS)
r = GG.RandomScalar()
blindedGenerator = GG.Serialize(ScalarBaseMult(r))
blindedPublicKey = GG.Serialize(r * PK)

preproc = PrepocessedBlind{
       blind: r,
       blindedGenerator: blindedGenerator,
       blindedPublicKey: blindedPublicKey,
Q = GG.Deserialize(preproc.blindedGenerator) /* Q = ScalarBaseMult(r) */
P = GG.HashToGroup(input)

token = Token{
    data: input,
    blind: preproc.blindedPublicKey
blindToken = GG.Serialize(P + Q)           /* P + ScalarBaseMult(r) */

PKR = GG.Deserialize(token.blind)
Z = GG.Deserialize(ev.element)
issuedToken = GG.Serialize(N)

