



RIFT Working Group                                      The RIFT Authors
Internet-Draft      "Heaven is under our feet as well as over our heads"
Intended status: Standards Track                        October 19, 2018
Expires: April 22, 2019


                       RIFT: Routing in Fat Trees
                        draft-ietf-rift-rift-03

Abstract

   This document outlines a specialized, dynamic routing protocol for
   Clos and fat-tree network topologies.  The protocol (1) deals with
   fully automatied construction of fat-tree topologies based on
   detection of links, (2) minimizes the amount of routing state held at
   each level, (3) automatically prunes and load balances topology
   flooding exchanges over a sufficient subset of links, (4) supports
   automatic disaggregation of prefixes on link and node failures to
   prevent black-holing and suboptimal routing, (5) allows traffic
   steering and re-routing policies, (6) allows loop-free non-ECMP
   forwarding, (7) automatically re-balances traffic towards the spines
   based on bandwidth available and finally (8) provides mechanisms to
   synchronize a limited key-value data-store that can be used after
   protocol convergence to e.g.  bootstrap higher levels of
   functionality on nodes.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on April 22, 2019.

Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.




The RIFT Authors         Expires April 22, 2019                 [Page 1]

Internet-Draft                    RIFT                      October 2018


   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Authors . . . . . . . . . . . . . . . . . . . . . . . . . . .   4
   2.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     2.1.  Requirements Language . . . . . . . . . . . . . . . . . .   6
   3.  Reference Frame . . . . . . . . . . . . . . . . . . . . . . .   6
     3.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   6
     3.2.  Topology  . . . . . . . . . . . . . . . . . . . . . . . .  10
   4.  Requirement Considerations  . . . . . . . . . . . . . . . . .  11
   5.  RIFT: Routing in Fat Trees  . . . . . . . . . . . . . . . . .  14
     5.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .  15
       5.1.1.  Properties  . . . . . . . . . . . . . . . . . . . . .  15
       5.1.2.  Generalized Topology View . . . . . . . . . . . . . .  15
       5.1.3.  Fallen Leaf Problem . . . . . . . . . . . . . . . . .  25
       5.1.4.  Discovering Fallen Leaves . . . . . . . . . . . . . .  27
       5.1.5.  Addressing the Fallen Leaves Problem  . . . . . . . .  28
     5.2.  Specification . . . . . . . . . . . . . . . . . . . . . .  29
       5.2.1.  Transport . . . . . . . . . . . . . . . . . . . . . .  29
       5.2.2.  Link (Neighbor) Discovery (LIE Exchange)  . . . . . .  30
       5.2.3.  Topology Exchange (TIE Exchange)  . . . . . . . . . .  32
         5.2.3.1.  Topology Information Elements . . . . . . . . . .  32
         5.2.3.2.  South- and Northbound Representation  . . . . . .  33
         5.2.3.3.  Flooding  . . . . . . . . . . . . . . . . . . . .  35
         5.2.3.4.  TIE Flooding Scopes . . . . . . . . . . . . . . .  36
         5.2.3.5.  Initial and Periodic Database Synchronization . .  38
         5.2.3.6.  Purging . . . . . . . . . . . . . . . . . . . . .  38
         5.2.3.7.  Southbound Default Route Origination  . . . . . .  39
         5.2.3.8.  Northbound TIE Flooding Reduction . . . . . . . .  40
       5.2.4.  Reachability Computation  . . . . . . . . . . . . . .  44
         5.2.4.1.  Northbound SPF  . . . . . . . . . . . . . . . . .  44
         5.2.4.2.  Southbound SPF  . . . . . . . . . . . . . . . . .  45
         5.2.4.3.  East-West Forwarding Within a Level . . . . . . .  45
       5.2.5.  Automatic Disaggregation on Link & Node Failures  . .  45
         5.2.5.1.  Positive, Non-transitive Disaggregation . . . . .  45
         5.2.5.2.  Negative, Transitive Disaggregation for Fallen
                   Leafs . . . . . . . . . . . . . . . . . . . . . .  49
       5.2.6.  Attaching Prefixes  . . . . . . . . . . . . . . . . .  51
       5.2.7.  Optional Zero Touch Provisioning (ZTP)  . . . . . . .  53



The RIFT Authors         Expires April 22, 2019                 [Page 2]

Internet-Draft                    RIFT                      October 2018


         5.2.7.1.  Terminology . . . . . . . . . . . . . . . . . . .  54
         5.2.7.2.  Automatic SystemID Selection  . . . . . . . . . .  55
         5.2.7.3.  Generic Fabric Example  . . . . . . . . . . . . .  55
         5.2.7.4.  Level Determination Procedure . . . . . . . . . .  56
         5.2.7.5.  Resulting Topologies  . . . . . . . . . . . . . .  58
       5.2.8.  Stability Considerations  . . . . . . . . . . . . . .  59
     5.3.  Further Mechanisms  . . . . . . . . . . . . . . . . . . .  60
       5.3.1.  Overload Bit  . . . . . . . . . . . . . . . . . . . .  60
       5.3.2.  Optimized Route Computation on Leafs  . . . . . . . .  60
       5.3.3.  Mobility  . . . . . . . . . . . . . . . . . . . . . .  60
         5.3.3.1.  Clock Comparison  . . . . . . . . . . . . . . . .  62
         5.3.3.2.  Interaction between Time Stamps and Sequence
                   Counters  . . . . . . . . . . . . . . . . . . . .  62
         5.3.3.3.  Anycast vs. Unicast . . . . . . . . . . . . . . .  63
         5.3.3.4.  Overlays and Signaling  . . . . . . . . . . . . .  63
       5.3.4.  Key/Value Store . . . . . . . . . . . . . . . . . . .  64
         5.3.4.1.  Southbound  . . . . . . . . . . . . . . . . . . .  64
         5.3.4.2.  Northbound  . . . . . . . . . . . . . . . . . . .  64
       5.3.5.  Interactions with BFD . . . . . . . . . . . . . . . .  64
       5.3.6.  Fabric Bandwidth Balancing  . . . . . . . . . . . . .  65
         5.3.6.1.  Northbound Direction  . . . . . . . . . . . . . .  65
         5.3.6.2.  Southbound Direction  . . . . . . . . . . . . . .  67
       5.3.7.  Label Binding . . . . . . . . . . . . . . . . . . . .  68
       5.3.8.  Segment Routing Support with RIFT . . . . . . . . . .  68
         5.3.8.1.  Global Segment Identifiers Assignment . . . . . .  68
         5.3.8.2.  Distribution of Topology Information  . . . . . .  68
       5.3.9.  Leaf to Leaf Procedures . . . . . . . . . . . . . . .  69
       5.3.10. Address Family and Multi Topology Considerations  . .  69
       5.3.11. Reachability of Internal Nodes in the Fabric  . . . .  69
       5.3.12. One-Hop Healing of Levels with East-West Links  . . .  70
   6.  Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  70
     6.1.  Normal Operation  . . . . . . . . . . . . . . . . . . . .  70
     6.2.  Leaf Link Failure . . . . . . . . . . . . . . . . . . . .  71
     6.3.  Partitioned Fabric  . . . . . . . . . . . . . . . . . . .  72
     6.4.  Northbound Partitioned Router and Optional East-West
           Links . . . . . . . . . . . . . . . . . . . . . . . . . .  74
     6.5.  Multi-Plane Fabric and Negative Disaggregation  . . . . .  75
   7.  Implementation and Operation: Further Details . . . . . . . .  75
     7.1.  Considerations for Leaf-Only Implementation . . . . . . .  75
     7.2.  Adaptations to Other Proposed Data Center Topologies  . .  76
     7.3.  Originating Non-Default Route Southbound  . . . . . . . .  77
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  77
     8.1.  General . . . . . . . . . . . . . . . . . . . . . . . . .  77
     8.2.  ZTP . . . . . . . . . . . . . . . . . . . . . . . . . . .  77
     8.3.  Lifetime  . . . . . . . . . . . . . . . . . . . . . . . .  78
   9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  78
   10. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  78
   11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  78



The RIFT Authors         Expires April 22, 2019                 [Page 3]

Internet-Draft                    RIFT                      October 2018


     11.1.  Normative References . . . . . . . . . . . . . . . . . .  78
     11.2.  Informative References . . . . . . . . . . . . . . . . .  81
   Appendix A.  Information Elements Schema  . . . . . . . . . . . .  83
     A.1.  common.thrift . . . . . . . . . . . . . . . . . . . . . .  84
     A.2.  encoding.thrift . . . . . . . . . . . . . . . . . . . . .  88
   Appendix B.  Finite State Machines and Precise Operational
                Specifications . . . . . . . . . . . . . . . . . . .  94
     B.1.  LIE FSM . . . . . . . . . . . . . . . . . . . . . . . . .  95
     B.2.  ZTP FSM . . . . . . . . . . . . . . . . . . . . . . . . . 101
     B.3.  Flooding Procedures . . . . . . . . . . . . . . . . . . . 105
       B.3.1.  FloodState Structure per Adjacency  . . . . . . . . . 106
       B.3.2.  TIDEs . . . . . . . . . . . . . . . . . . . . . . . . 107
         B.3.2.1.  TIDE Generation . . . . . . . . . . . . . . . . . 107
         B.3.2.2.  TIDE Processing . . . . . . . . . . . . . . . . . 108
       B.3.3.  TIREs . . . . . . . . . . . . . . . . . . . . . . . . 109
         B.3.3.1.  TIRE Generation . . . . . . . . . . . . . . . . . 109
         B.3.3.2.  TIRE Processing . . . . . . . . . . . . . . . . . 110
       B.3.4.  TIEs Processing on Flood State Adjacency  . . . . . . 110
       B.3.5.  TIEs Processing When LSDB Received Newer Version on
               Other Adjacencies . . . . . . . . . . . . . . . . . . 111
   Appendix C.  Constants  . . . . . . . . . . . . . . . . . . . . . 111
     C.1.  Configurable Protocol Constants . . . . . . . . . . . . . 111
   Appendix D.  TODO . . . . . . . . . . . . . . . . . . . . . . . . 113
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . . 113

1.  Authors

   This work is a product of a growing list of individuals.

           Tony Przygienda, Ed | Alankar Sharma | Pascal Thubert
           Juniper Networks    | Comcast        | Cisco

           Bruno Rijsman       | Ilya Vershkov  | Alia Atlas
           Individual          | Mellanox       | Individual

           Don Fedyk           | John Drake     |
           HPE                 | Juniper        |

                           Table 1: RIFT Authors

2.  Introduction

   Clos [CLOS] and Fat-Tree [FATTREE] have gained prominence in today's
   networking, primarily as result of the paradigm shift towards a
   centralized data-center based architecture that is poised to deliver
   a majority of computation and storage services in the future.
   Today's current routing protocols were geared towards a network with
   an irregular topology and low degree of connectivity originally but



The RIFT Authors         Expires April 22, 2019                 [Page 4]

Internet-Draft                    RIFT                      October 2018


   given they were the only available options, consequently several
   attempts to apply those protocols to Clos have been made.  Most
   successfully BGP [RFC4271] [RFC7938] has been extended to this
   purpose, not as much due to its inherent suitability but rather
   because the perceived capability to easily modify BGP and the
   immanent difficulties with link-state link-state [DIJKSTRA] based
   protocols to optimize topology exchange and converge quickly in large
   scale densely meshed topologies.  The incumbent protocols
   precondition normally extensive configuration or provisioning during
   bring up and re-dimensioning which is only viable for a set of
   organizations with according networking operation skills and budgets.
   For the majority of data center consumers a preferable protocol would
   be one that auto-configures itself and deals with failures and
   misconfigurations with a minimum of human intervention only.  Such a
   solution would allow local IP fabric bandwidth to be consumed in a
   standardized component fashion, i.e. provision it much faster and
   operate it at much lower costs, much like compute or storage is
   consumed today.

   In looking at the problem through the lens of data center
   requirements, an optimal approach does not seem however to be a
   simple modification of either a link-state (distributed computation)
   or distance-vector (diffused computation) approach but rather a
   mixture of both, colloquially best described as "link-state towards
   the spine" and "distance vector towards the leafs".  In other words,
   "bottom" levels are flooding their link-state information in the
   "northern" direction while each node generates under normal
   conditions a default route and floods it in the "southern" direction.
   This type of protocol allows highly desirable aggregation.  Alas,
   such aggregation could blackhole traffic in cases of misconfiguration
   or while failures are being resolved or even cause partial network
   partitioning and this has to be addressed.  The approach RIFT takes
   is described in Section 5.2.5 and is basically based on automatic,
   sufficient disaggregation of prefixes to prevent any possible
   problems.

   For the visually oriented reader, Figure 1 presents a first level
   simplified view of the resulting information and routes on a RIFT
   fabric.  The top of the fabric, is holding, in its link-state
   database the nodes below it and the routes to them.  In the second
   row of the database we indicate that partial information of other
   nodes in the same level is available as well.  The details of how
   this is achieved will be postponed for the moment.  When we look at
   the "bottom" of the fabric, the leafs, we see that the topology is
   basically empty and they only hold a load balanced default route to
   the next level.





The RIFT Authors         Expires April 22, 2019                 [Page 5]

Internet-Draft                    RIFT                      October 2018


   The balance of this document details the resulting protocol and fills
   in the missing details.

              .                                  [A,B,C,D]
              .                                  [E]
              .             +-----+      +-----+
              .             |  E  |      |  F  | A/32 @ [C,D]
              .             +-+-+-+      +-+-+-+ B/32 @ [C,D]
              .               | |          | |   C/32 @ C
              .               | |    +-----+ |   D/32 @ D
              .               | |    |       |
              .               | +------+     |
              .               |      | |     |
              .       [A,B] +-+---+  | | +---+-+ [A,B]
              .       [D]   |  C  +--+ +-+  D  | [C]
              .             +-+-+-+      +-+-+-+
              .  0/0  @ [E,F] | |          | |   0/0  @ [E,F]
              .  A/32 @ A     | |    +-----+ |   A/32 @ A
              .  B/32 @ B     | |    |       |   B/32 @ B
              .               | +------+     |
              .               |      | |     |
              .             +-+---+  | | +---+-+
              .             |  A  +--+ +-+  B  |
              . 0/0 @ [C,D] +-----+      +-----+ 0/0 @ [C,D]


                  Figure 1: RIFT information distribution

2.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

3.  Reference Frame

3.1.  Terminology

   This section presents the terminology used in this document.  It is
   assumed that the reader is thoroughly familiar with the terms and
   concepts used in OSPF [RFC2328] and IS-IS [ISO10589-Second-Edition],
   [ISO10589] as well as the according graph theoretical concepts of
   shortest path first (SPF) [DIJKSTRA] computation and directed acyclic
   graphs (DAG).

   Level:  Clos and Fat Tree networks are topologically partially
      ordered graphs and 'level' denotes the set of nodes at the same
      height in such a network, where the bottom level (leaf) is the



The RIFT Authors         Expires April 22, 2019                 [Page 6]

Internet-Draft                    RIFT                      October 2018


      level with lowest value.  A node has links to nodes one level down
      and/or one level up.  Under some circumstances, a node may have
      links to nodes at the same level.  As footnote: Clos terminology
      uses often the concept of "stage" but due to the folded nature of
      the Fat Tree we do not use it to prevent misunderstandings.

   Superspine/Aggregation or Spine/Edge Levels:  Traditional names in
      5-stages folded Clos for Level 2, 1 and 0 respectively.  Level 0
      is often called leaf as well.  We normalize this language to talk
      about leafs, spines and top-of-fabric (ToF).

   Point of Delivery (PoD):  A self-contained vertical slice or subset
      of a Clos or Fat Tree network containing normally only level 0 and
      level 1 nodes.  A node in a PoD communicates with nodes in other
      PoDs via the Top-of-Fabric.  We number PoDs to distinguish them
      and use PoD #0 to denote "undefined" PoD.

   Top of PoD (ToP):  The set of nodes that provide intra-PoD
      communication and have northbound adjacencies outside of the PoD,
      i.e. are at the "top" of the PoD.

   Top of Fabric (ToF):  The set of nodes that provide inter-PoD
      communication and have no northbound adjacencies, i.e. are at the
      "very top" of the fabric.  ToF nodes do not belong to any PoD and
      are assigned "undefined" PoD value to indicate the equivalent of
      "any" PoD.

   Spine:  Any nodes north of leafs and south of top-of-fabric nodes.
      Multiple layers of spines in a PoD are possible.

   Leaf:  A node without southbound adjacencies.  Its level is 0 (except
      cases where it is deriving its level via ZTP and is running
      without LEAF_ONLY which will be explained in Section 5.2.7).

   Top-of-fabric Plane or Partition:  In large fabrics top-of-fabric
      switches may not have enough ports to aggregate all switches south
      of them and with that, the ToF is 'split' into multiple
      independent planes.  Introduction and Section 5.1.2 explains the
      concept in more detail.  A plane is subset of ToF nodes that see
      each other through south reflection or E-W links.

   Radix:  A radix of a switch is basically number of switching ports it
      provides.  It's sometimes called fanout as well.

   North Radix:  Ports cabled northbound to higher level nodes.

   South Radix:  Ports cabled southbound to lower level nodes.




The RIFT Authors         Expires April 22, 2019                 [Page 7]

Internet-Draft                    RIFT                      October 2018


   South/Southbound and North/Northbound (Direction):  When describing
      protocol elements and procedures, we will be using in different
      situations the directionality of the compass.  I.e., 'south' or
      'southbound' mean moving towards the bottom of the Clos or Fat
      Tree network and 'north' and 'northbound' mean moving towards the
      top of the Clos or Fat Tree network.

   Northbound Link:  A link to a node one level up or in other words,
      one level further north.

   Southbound Link:  A link to a node one level down or in other words,
      one level further south.

   East-West Link:  A link between two nodes at the same level.  East-
      West links are normally not part of Clos or "fat-tree" topologies.

   Leaf shortcuts (L2L):  East-West links at leaf level will need to be
      differentiated from East-West links at other levels.

   Southbound representation:  Information sent towards a lower level
      representing only limited amount of information.

   South Reflection:  Often abbreviated just as "reflection" it defines
      a mechanism where South Node TIEs are "reflected" back up north to
      allow nodes in same level without E-W links to "see" each other.

   TIE:  This is an acronym for a "Topology Information Element".  TIEs
      are exchanged between RIFT nodes to describe parts of a network
      such as links and address prefixes.  A TIE can be thought of as
      largely equivalent to ISIS LSPs or OSPF LSA.  We will talk about
      N-TIEs when talking about TIEs in the northbound representation
      and S-TIEs for the southbound equivalent.

   Node TIE:  This is an acronym for a "Node Topology Information
      Element", largely equivalent to OSPF Router LSA, i.e. it contains
      all adjacencies the node discovered and information about node
      itself.

   Prefix TIE:  This is an acronym for a "Prefix Topology Information
      Element" and it contains all prefixes directly attached to this
      node in case of a N-TIE and in case of S-TIE the necessary default
      the node passes southbound.

   Key Value TIE:  A S-TIE that is carrying a set of key value pairs
      [DYNAMO].  It can be used to distribute information in the
      southbound direction within the protocol.





The RIFT Authors         Expires April 22, 2019                 [Page 8]

Internet-Draft                    RIFT                      October 2018


   TIDE:  Topology Information Description Element, equivalent to CSNP
      in ISIS.

   TIRE:  Topology Information Request Element, equivalent to PSNP in
      ISIS.  It can both confirm received and request missing TIEs.

   De-aggregation/Disaggregation:  Process in which a node decides to
      advertise certain prefixes it received in N-TIEs to prevent black-
      holing and suboptimal routing upon link failures.

   LIE:  This is an acronym for a "Link Information Element", largely
      equivalent to HELLOs in IGPs and exchanged over all the links
      between systems running RIFT to form adjacencies.  all the links
      between systems running RIFT to form adjacencies.

   Flooding Leader (FL):  Flooding Leader for a specific system has a
      dedicated role to flood on northbound TIEs sent by this system.
      Similar to MPR in OSLR.

   Bandwidth Adjusted Distance (BAD):  This is an acronym for Bandwidth
      Adjusted Distance.  Each RIFT node calculates the amount of
      northbound bandwidth available towards a node compared to other
      nodes at the same level and modifies the default route distance
      accordingly to allow for the lower level to adjust their load
      balancing towards spines.

   Overloaded:  Applies to a node advertising `overload` attribute as
      set.  The semantics closely follow the meaning of the same
      attribute in [ISO10589-Second-Edition].

   Interface:  A layer 3 entity over which RIFT control packets are
      exchanged.

   Adjacency:  RIFT tries to form a unique adjacency over an interface
      and exchange local configuration and necessary ZTP information.

   Neighbor:  Once a three way adjacency has been formed a neighborship
      relationship contains the neighbor's properties.  Multiple
      adjacencies can be formed to a neighbor via parallel interfaces
      but such adjacencies are NOT sharing a neighbor structure.  Saying
      "neighbor" is thus equivalent to saying "a three way adjacency".

   Cost:  The term signifies the weighted distance between two
      neighbors.

   Distance:  Sum of costs (bound by infinite distance) between two
      nodes.




The RIFT Authors         Expires April 22, 2019                 [Page 9]

Internet-Draft                    RIFT                      October 2018


   Metric:  Without going deeper into the mathematic differentiation, a
      metric is equivalent to distance.

3.2.  Topology

    .                +--------+          +--------+          ^ N
    .                |ToF   21|          |ToF   22|          |
    .Level 2         ++-+--+-++          ++-+--+-++        <-*-> E/W
    .                 | |  | |            | |  | |           |
    .             P111/2|  |P121          | |  | |         S v
    .                 ^ ^  ^ ^            | |  | |
    .                 | |  | |            | |  | |
    .  +--------------+ |  +-----------+  | |  | +---------------+
    .  |                |    |         |  | |  |                 |
    . South +-----------------------------+ |  |                 ^
    .  |    |           |    |         |    |  |              All TIEs
    .  0/0  0/0        0/0   +-----------------------------+     |
    .  v    v           v              |    |  |           |     |
    .  |    |           +-+    +<-0/0----------+           |     |
    .  |    |             |    |       |    |              |     |
    .+-+----++ optional +-+----++     ++----+-+           ++-----++
    .|       | E/W link |       |     |       |           |       |
    .|Spin111+----------+Spin112|     |Spin121|           |Spin122|
    .+-+---+-+          ++----+-+     +-+---+-+           ++---+--+
    .  |   |             |   South      |   |              |   |
    .  |   +---0/0--->-----+ 0/0        |   +----------------+ |
    . 0/0                | |  |         |                  | | |
    .  |   +---<-0/0-----+ |  v         |   +--------------+ | |
    .  v   |               |  |         |   |                | |
    .+-+---+-+          +--+--+-+     +-+---+-+          +---+-+-+
    .|       |  (L2L)   |       |     |       |  Level 0 |       |
    .|Leaf111~~~~~~~~~~~~Leaf112|     |Leaf121|          |Leaf122|
    .+-+-----+          +-+---+-+     +--+--+-+          +-+-----+
    .  +                  +    \        /   +              +
    .  Prefix111   Prefix112    \      /   Prefix121    Prefix122
    .                          multi-homed
    .                            Prefix
    .+---------- Pod 1 ---------+     +---------- Pod 2 ---------+


              Figure 2: A three level spine-and-leaf topology










The RIFT Authors         Expires April 22, 2019                [Page 10]

Internet-Draft                    RIFT                      October 2018


                    .+--------+  +--------+  +--------+  +--------+
                    .|ToF   A1|  |ToF   B1|  |ToF   B2|  |ToF   A2|
                    .++-+-----+  ++-+-----+  ++-+-----+  ++-+-----+
                    . | |         | |         | |         | |
                    . | |         | |         | +---------------+
                    . | |         | |         |           | |   |
                    . | |         | +-------------------------+ |
                    . | |         |           |           | | | |
                    . | +-----------------------+         | | | |
                    . |           |           | |         | | | |
                    . |           | +---------+ | +---------+ | |
                    . |           | |           | |       |   | |
                    . | +---------------------------------+   | |
                    . | |         | |           | |           | |
                    .++-+-----+  ++-+-----+  +--+-+---+  +----+-+-+
                    .|Spine111|  |Spine112|  |Spine121|  |Spine122|
                    .+-+---+--+  ++----+--+  +-+---+--+  ++---+---+
                    .  |   |      |    |       |   |      |   |
                    .  |   +--------+  |       |   +--------+ |
                    .  |          | |  |       |          | | |
                    .  |   -------+ |  |       |   +------+ | |
                    .  |   |        |  |       |   |        | |
                    .+-+---+-+   +--+--+-+   +-+---+-+  +---+-+-+
                    .|Leaf111|   |Leaf112|   |Leaf121|  |Leaf122|
                    .+-------+   +-------+   +-------+  +-------+


                  Figure 3: Topology with multiple planes

   We will use topology in Figure 2 (called commonly a fat tree/network
   in modern IP fabric considerations [VAHDAT08] as homonym to the
   original definition of the term [FATTREE]) in all further
   considerations.  This figure depicts a generic "single plane fat-
   tree" and the concepts explained using three levels apply by
   induction to further levels and higher degrees of connectivity.
   Further, this document will deal also with designs that provide only
   sparser connectivity and "partitioned spines" as shown in Figure 3
   and explained further in Section 5.1.2.

4.  Requirement Considerations

   [RFC7938] gives the original set of requirements augmented here based
   upon recent experience in the operation of fat-tree networks.

   REQ1:    The control protocol should discover the physical links
            automatically and be able to detect cabling that violates
            fat-tree topology constraints.  It must react accordingly to
            such mis-cabling attempts, at a minimum preventing



The RIFT Authors         Expires April 22, 2019                [Page 11]

Internet-Draft                    RIFT                      October 2018


            adjacencies between nodes from being formed and traffic from
            being forwarded on those mis-cabled links.  E.g.  connecting
            a leaf to a spine at level 2 should be detected and ideally
            prevented.

   REQ2:    A node without any configuration beside default values
            should come up at the correct level in any PoD it is
            introduced into.  Optionally, it must be possible to
            configure nodes to restrict their participation to the
            PoD(s) targeted at any level.

   REQ3:    Optionally, the protocol should allow to provision IP
            fabrics where the individual switches carry no configuration
            information and are all deriving their level from a "seed".
            Observe that this requirement may collide with the desire to
            detect cabling misconfiguration and with that only one of
            the requirements can be fully met in a chosen configuration
            mode.

   REQ4:    The solution should allow for minimum size routing
            information base and forwarding tables at leaf level for
            speed, cost and simplicity reasons.  Holding excessive
            amount of information away from leaf nodes simplifies
            operation and lowers cost of the underlay and allows to
            scale and introduce proper multi-homing down to the server
            level.  The routing solution should allow for easy
            instantiation of multiple routing planes.  Coupled with
            mobility defined in Paragraph 17 this should allow for
            "light-weight" overlays on an IP fabric with e.g. native
            IPv6 mobility support.

   REQ5:    Very high degree of ECMP must be supported.  Maximum ECMP is
            currently understood as the most efficient routing approach
            to maximize the throughput of switching fabrics
            [MAKSIC2013].

   REQ6:    Non equal cost anycast must be supported to allow for easy
            and robust multi-homing of services without regressing to
            careful balancing of link costs.

   REQ7:    Traffic engineering should be allowed by modification of
            prefixes and/or their next-hops.

   REQ8:    The solution should allow for access to link states of the
            whole topology to enable efficient support for modern
            control architectures like SPRING [RFC7855] or PCE
            [RFC4655].




The RIFT Authors         Expires April 22, 2019                [Page 12]

Internet-Draft                    RIFT                      October 2018


   REQ9:    The solution should easily accommodate opaque data to be
            carried throughout the topology to subsets of nodes.  This
            can be used for many purposes, one of them being a key-value
            store that allows bootstrapping of nodes based right at the
            time of topology discovery.  Another use is distributing MAC
            to L3 address binding from the leafs up north in case of
            e.g.  DHCP.

   REQ10:   Nodes should be taken out and introduced into production
            with minimum wait-times and minimum of "shaking" of the
            network, i.e.  radius of propagation (often called "blast
            radius") of changed information should be as small as
            feasible.

   REQ11:   The protocol should allow for maximum aggregation of carried
            routing information while at the same time automatically de-
            aggregating the prefixes to prevent black-holing in case of
            failures.  The de-aggregation should support maximum
            possible ECMP/N-ECMP remaining after failure.

   REQ12:   Reducing the scope of communication needed throughout the
            network on link and state failure, as well as reducing
            advertisements of repeating or idiomatic information in
            stable state is highly desirable since it leads to better
            stability and faster convergence behavior.

   REQ13:   Once a packet traverses a link in a "southbound" direction,
            it must not take any further "northbound" steps along its
            path to delivery to its destination under normal, i.e.
            fully converged, conditions.  Taking a path through the
            spine in cases where a shorter path is available is highly
            undesirable.

   REQ14:   Parallel links between same set of nodes must be
            distinguishable for SPF, failure and traffic engineering
            purposes.

   REQ15:   The protocol must not rely on interfaces having discernible
            unique addresses, i.e. it must operate in presence of
            unnumbered links (even parallel ones) or links of a single
            node having same addresses.

   REQ16:   It would be desirable to achieve fast re-balancing of flows
            when links, especially towards the spines are lost or
            provisioned without regressing to per flow traffic
            engineering which introduces significant amount of
            complexity while possibly not being reactive enough to
            account for short-lived flows.



The RIFT Authors         Expires April 22, 2019                [Page 13]

Internet-Draft                    RIFT                      October 2018


   REQ17:   The control plane should be able to unambiguously determine
            the current point of attachment (which port on which leaf
            node) of a prefix, even in a context of fast mobility, e.g.,
            when the prefix is a host address on a wireless node that 1)
            may associate to any of multiple access points (APs) that
            are attached to different ports on a same leaf node or to
            different leaf nodes, and 2) may move and reassociate
            several times to a different AP within a sub-second period.

   REQ18:   The protocol should provide security mechanisms that allow
            to restrict nodes, especially leafs without proper
            credentials from forming three-way adjacencies.

   Following list represents possible requirements and requirements
   under discussion:

   PEND1:   Supporting anything but point-to-point links is a non-
            requirement.  Questions remain: for connecting to the
            leaves, is there a case where multipoint is desirable?  One
            could still model it as point-to-point links; it seems there
            is no need for anything more than a NBMA-type construct.

   PEND2:   What is the maximum scale of number leaf prefixes we need to
            carry.  500'000 seems plenty even if we deploy RIFT down to
            servers as leafs.

   Finally, following are the non-requirements:

   NONREQ1:   Broadcast media support is unnecessary.  However,
              miscabling leading to multiple nodes on a broadcast
              segment must be operationally easily recognizable and
              operationally easily detectable while not taxing the
              protocol excessively.

   NONREQ2:   Purging link state elements is unnecessary given its
              fragility and complexity and today's large memory size on
              even modest switches and routers.

   NONREQ3:   Special support for layer 3 multi-hop adjacencies is not
              part of the protocol specification.  Such support can be
              easily provided by using tunneling technologies the same
              way IGPs today are solving the problem.

5.  RIFT: Routing in Fat Trees

   Derived from the above requirements we present a detailed outline of
   a protocol optimized for Routing in Fat Trees (RIFT) that in most
   abstract terms has many properties of a modified link-state protocol



The RIFT Authors         Expires April 22, 2019                [Page 14]

Internet-Draft                    RIFT                      October 2018


   [RFC2328][ISO10589-Second-Edition] when "pointing north" and path-
   vector [RFC4271] protocol when "pointing south".  While this is an
   unusual combination, it does quite naturally exhibit the desirable
   properties we seek.

5.1.  Overview

5.1.1.  Properties

   The most singular property of RIFT is that it floods flat link-state
   information northbound only so that each level obtains the full
   topology of levels south of it.  That information is never flooded
   East-West (we'll talk about exceptions later) or back South again.
   In the southbound direction the protocol operates like a "fully
   summarizing, unidirectional" path vector protocol or rather a
   distance vector with implicit split horizon whereas the information
   propagates one hop south and is 're-advertised' by nodes at next
   lower level, normally just the default route.  However, RIFT uses
   flooding in the southern direction as well to avoid the necessity to
   build an update per adjacency.  We omit describing the East-West
   direction out for the moment.

   Those information flow constraints create not only an anisotropic
   protocol (i.e. the information is not distributed "evenly" or
   "clumped" but summarized along the N-S gradient) but also a "smooth"
   information propagation where nodes do not receive the same
   information from multiple fronts which would force them to perform a
   diffused computation to tie-break the same reachability information
   arriving on arbitrary links and ultimately force hop-by-hop
   forwarding on shortest-paths only.

   To account for the "northern" and the "southern" information split
   the link state database is partitioned into "north representation"
   and "south representation" TIEs, whereas in simplest terms the N-TIEs
   contain a link state topology description of lower levels and and
   S-TIEs carry simply default routes.  This oversimplified view will be
   refined gradually in following sections while introducing protocol
   procedures aimed to fulfill the described requirements.

5.1.2.  Generalized Topology View

   This section will dwell on the topologies addresses by RIFT including
   multi plane fabrics and their related implications.  Readers that are
   only interested in single plane designs, i.e. all top-of-fabric nodes
   being topologically equal and initially connected to all the switches
   at the level below them can skip this section and resulting
   Section 5.2.5.2 as well.




The RIFT Authors         Expires April 22, 2019                [Page 15]

Internet-Draft                    RIFT                      October 2018


   Given the difficulty of visualizing multi plane design which are
   effectively multi-dimensional switching matrices we will introduce a
   methodology allowing us to visualize the connectivity in a two-
   dimensional document and leverage the fact that we are dealing
   basically with crossbar fabrics stacked on top of each other where
   ports also align "on top of each other" in a regular fashion.

   The typical topology for which RIFT is defined is built of a number P
   of PoDs, connected together by a number S of spine nodes.  A PoD node
   has a number of ports called Radix, with half of them (K=Radix/2)
   used to connect host devices from the south, and half to connect to
   interleaved PoD Top-Level switches to the north.  Ratio K can be
   chosen differently without loss of generality when port speeds differ
   or fabric is oversubscribed but K=R/2 allows for more readable
   representation whereby there are as many ports facing north as south
   on any intermediate node.  We represent a node hence in a schematic
   fashion with ports "sticking out" to its north and south rather than
   by the usual real-world front faceplate designs of the day.

   Figure 4 provides a view of a leaf node as seen from the north, i.e.
   showing ports that connect northbound and for lack of a better
   symbol, we have chosen to use the "HH" symbol as ASCII visualisation
   of a RJ45 jack.  Observe that the number of PoDs is not related to
   Radix unless the Spine Nodes are constrained to be the same as the
   PoD nodes in a particular deployment.  We set the radix of the leaf
   to K_LEAF, in this example 6 ports.

























The RIFT Authors         Expires April 22, 2019                [Page 16]

Internet-Draft                    RIFT                      October 2018


       Top view
        +----+
        |    |
        | HH |     e.g., Radix = 12, K_LEAF = 6
        |    |
        | HH |
        |    |      -------------------------
        | HH ------- Physical Port (Ethernet) ----+
        |    |      -------------------------     |
        | HH |                                    |
        |    |                                    |
        | HH |                                    |
        |    |                                    |
        | HH |                                    |
        |    |                                    |
        +----+                                    |

          ||              ||      ||      ||      ||      ||      ||
        +----+        +------------------------------------------------+
        |    |        |                                                |
        +----+        +------------------------------------------------+
          ||              ||      ||      ||      ||      ||      ||
              Side views


                      Figure 4: A Leaf Node, K_LEAF=6

   The Radix of a node on top of a PoD may be different than that of the
   leaf node, though more often than not a same type of node is used for
   both, effectively forming a square (K*K).  In the general case, we
   could have switches with K_TOP southern ports on nodes at the top of
   the PoD that is not necessarily the same as K_LEAF; for instance, in
   the representations below, we pick a K_LEAF of 6 and a K_TOP of 8.
   In order to form a crossbar, we need K_TOP Leaf Nodes as illustrated
   in Figure 5.
















The RIFT Authors         Expires April 22, 2019                [Page 17]

Internet-Draft                    RIFT                      October 2018


         +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+
         |    |  |    |  |    |  |    |  |    |  |    |  |    |  |    |
         | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |
         |    |  |    |  |    |  |    |  |    |  |    |  |    |  |    |
         | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |
         |    |  |    |  |    |  |    |  |    |  |    |  |    |  |    |
         | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |
         |    |  |    |  |    |  |    |  |    |  |    |  |    |  |    |
         | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |
         |    |  |    |  |    |  |    |  |    |  |    |  |    |  |    |
         | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |
         |    |  |    |  |    |  |    |  |    |  |    |  |    |  |    |
         | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |
         |    |  |    |  |    |  |    |  |    |  |    |  |    |  |    |
         +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+

                 Figure 5: Southern View of a PoD, K_TOP=8

   The K_TOP Leaf Nodes are fully interconnected with the K_LEAF PoD-top
   nodes, providing a connectivity that can be represented as a crossbar
   as seen from the north and illustrated in Figure 6.  The result is
   that, in the absence of a breakage, a packet entering the PoD from
   North on any port can be routed to any port on the south of the PoD
   and vice versa.



























The RIFT Authors         Expires April 22, 2019                [Page 18]

Internet-Draft                    RIFT                      October 2018


                                E<-*->W

     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+
     |    |  |    |  |    |  |    |  |    |  |    |  |    |  |    |
   +----------------------------------------------------------------+
   |   HH      HH      HH      HH      HH      HH      HH      HH   |
   +----------------------------------------------------------------+
   +----------------------------------------------------------------+
   |   HH      HH      HH      HH      HH      HH      HH      HH   |
   +----------------------------------------------------------------+
   +----------------------------------------------------------------+
   |   HH      HH      HH      HH      HH      HH      HH      HH   |
   +----------------------------------------------------------------+
   +----------------------------------------------------------------+
   |   HH      HH      HH      HH      HH      HH      HH      HH   |
   +----------------------------------------------------------------+
   +----------------------------------------------------------------+
   |   HH      HH      HH      HH      HH      HH      HH      HH   |<-+
   +----------------------------------------------------------------+  |
   +----------------------------------------------------------------+  |
   |   HH      HH      HH      HH      HH      HH      HH      HH   |  |
   +----------------------------------------------------------------+  |
     |    |  |    |  |    |  |    |  |    |  |    |  |    |  |    |    |
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+    |
                ^                                                      |
                |                                                      |
                |     ----------                ---------------------  |
                +----- Leaf Node                PoD top Node (Spine) --+
                      ----------                ---------------------

            Figure 6: Northern View of a PoD's Spines, K_TOP=8

   Side views of this PoD is illustrated in Figure 7 and Figure 8.


















The RIFT Authors         Expires April 22, 2019                [Page 19]

Internet-Draft                    RIFT                      October 2018


                       Connecting to Spine

       ||      ||      ||      ||      ||      ||      ||      ||
   +----------------------------------------------------------------+   N
   |                    PoD top Node seen sideways                  |   ^
   +----------------------------------------------------------------+   |
       ||      ||      ||      ||      ||      ||      ||      ||       *
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+     |
     |    |  |    |  |    |  |    |  |    |  |    |  |    |  |    |     v
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+     S
       ||      ||      ||      ||      ||      ||      ||      ||

                          Connecting to Client nodes


              Figure 7: Side View of a PoD, K_TOP=8, K_LEAF=6


                     Connecting to Spine

              ||      ||      ||      ||      ||      ||
            +----+  +----+  +----+  +----+  +----+  +----+              N
            |    |  |    |  |    |  |    |  |    |  |   PoD top Nodes   ^
            +----+  +----+  +----+  +----+  +----+  +----+              |
              ||      ||      ||      ||      ||      ||                *
          +------------------------------------------------+            |
          |              Leaf seen sideways                |            v
          +------------------------------------------------+            S
              ||      ||      ||      ||      ||      ||

                     Connecting to Client nodes


    Figure 8: Other side View of a PoD, K_TOP=8, K_LEAF=6, 90o turn in
                                 E-W Plane

   Note that a resulting PoD can be abstracted as a bigger node with a
   number K of K_POD= K_TOP * K_LEAF, and the design can recurse.

   It is critical at this junction that the concept and the picture of
   those "crossed crossbars" is clear before progressing further,
   otherwise following considerations will be difficult to comprehend.

   Further, the PoDs are interconnected with one another through a Top-
   of-Fabric at the very top or the north edge of the fabric.  The
   resulting ToF is NOT partitioned if and only if (IIF) every PoD top
   level node (spine) is connected to every ToF Node.  This is also
   referred to as a single plane configuration.  In order to reach a



The RIFT Authors         Expires April 22, 2019                [Page 20]

Internet-Draft                    RIFT                      October 2018


   1::1 connectivity ratio between the ToF and the Leaves, it results
   that there are K_TOP ToF nodes, because each port of a ToP node
   connects to a different ToF node, and K_LEAF ToP nodes for the same
   reason.  Consequently, it takes (P * K_LEAF) ports on a ToF node to
   connect to each of the K_LEAF ToP nodes of the P PoDs, as illustrated
   in Figure 9.


        [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] <-----+
         |   |   |   |   |   |   |   |        |
      [=================================]     |     -----------
         |   |   |   |   |   |   |   |        +----- Top-of-Fabric
        [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]       +----- Node      -------+
                                              |     -----------       |
                                              |                       v
        +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+ <-----+                      +-+
        | | | | | | | | | | | | | | | |                              | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]                            | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ] -------------------------  | |
      [ |H| |H| |H| |H| |H| |H| |H| |H<--- Physical Port (Ethernet)  | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ] -------------------------  | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]                            | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]                            | |
        | | | | | | | | | | | | | | | |                              | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]                            | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]      --------------        | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ] <---  PoD top level        | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]       node (Spine)  ---+   | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]      --------------    |   | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]                        |   | |
        | | | | | | | | | | | | | | | |  -+           +-   +-+   v   | |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ] |           |  --| |--[ ]--| |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ] |   -----   |  --| |--[ ]--| |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ] +--- PoD ---+  --| |--[ ]--| |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ] |   -----   |  --| |--[ ]--| |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ] |           |  --| |--[ ]--| |
      [ |H| |H| |H| |H| |H| |H| |H| |H| ] |           |  --| |--[ ]--| |
        | | | | | | | | | | | | | | | |  -+           +-   +-+       | |
        +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+                              +-+


      Figure 9: Fabric Spines and TOFs in Single Plane Design, 3 PoDs

   The top view can be collapsed into a third dimension where the hidden
   depth index is representing the PoD number.  So we can show one PoD
   as a class of PoDs and hence save one dimension in our
   representation.  The Spine Node expands in the depth and the vertical
   dimensions whereas the PoD top level Nodes are constrained in



The RIFT Authors         Expires April 22, 2019                [Page 21]

Internet-Draft                    RIFT                      October 2018


   horizontal dimension.  A port in the 2-D representation represents
   effectively the class of all the ports at the same position in all
   the PoDs that are projected in its position along the depth axis.
   This is shown in Figure 10.

            / / / / / / / / / / / / / / / /
           / / / / / / / / / / / / / / / /
          / / / / / / / / / / / / / / / /
         / / / / / / / / / / / / / / / /   ]
        +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+   ]]
        | | | | | | | | | | | | | | | |  ]   ---------------------------
      [ |H| |H| |H| |H| |H| |H| |H| |H| ] <-- PoD top level node (Spine)
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]    ---------------------------
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]]]]
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]]]     ^^
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]]     //  PoDs
      [ |H| |H| |H| |H| |H| |H| |H| |H| ]     // (in depth)
        | |/| |/| |/| |/| |/| |/| |/| |/     //
        +-+ +-+ +-+/+-+/+-+ +-+ +-+ +-+     //
                 ^
                 |     ----------------
                 +----- Top-of-Fabric Node
                       ----------------

   Figure 10: Collapsed Northern View of a Fabric for Any Number of PoDs

   This type of deployment introduces a "single plane limit" where the
   bound is the available radix of the ToF nodes, which limits (P *
   K_LEAF).  Nevertheless, a distinct advantage of a connected or
   unpartitioned Top-of-Fabric is that all failures can be resolved by
   simple, non-transitive, positive disaggregation described in
   Section 5.2.5.1 that propagates only within one level of the fabric.
   In other words unpartitoned ToF nodes can always reach nodes below or
   withdraw the routes from PoDs they cannot reach unambiguously.  To be
   more precise, all failures which still allow all the ToF nodes to see
   each other via south reflection as explained in Section 5.2.5.

   In order to scale beyond the "single plane limit", the Top-of-Fabric
   can be partitioned by a number N of identically wired planes, N being
   an integer divider of K_LEAF.  The 1::1 ratio and the desired
   symmetry are still served, this time with (K_TOP * N) ToF nodes, each
   of (P * K_LEAF / N) ports.  N=1 represents a non-partitioned Spine
   and N=K_LEAF is a maximally partitioned Spine.  Further, if R is any
   divisor of K_LEAF, then (N=K_LEAF/R) is a feasible number of planes
   and R a redundancy factor.  If proves convenient for deployments to
   use a radix for the leaf nodes that is a power of 2 so they can pick
   a number of planes that is a lower power of 2.  The example in
   Figure 11 splits the Spine in 2 planes with a redundancy factor R=3,



The RIFT Authors         Expires April 22, 2019                [Page 22]

Internet-Draft                    RIFT                      October 2018


   meaning that there are 3 non-intersecting paths between any leaf node
   and any ToF node.  A ToF node must have in this case at least 3*P
   ports, and be directly connected to 3 of the 6 PoD-ToP nodes (spines)
   in each PoD.

        +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
      | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | |
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
      | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | |
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
      | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | |
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
        +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+

      Plane 1
     ----------- . ------------ . ------------ . ------------ . --------
      Plane 2

        +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
      | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | |
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
      | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | |
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
      | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | |
      +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+
        +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+
                   ^
                   |
                   |     ----------------
                   +----- Top-of-Fabric node
                          "across" depth
                         ----------------

    Figure 11: Northern View of a Multi-Plane ToF Level, K_LEAF=6, N=2

   At the extreme end of the spectrum, it is even possible to fully
   partition the spine with N = K_LEAF and R=1, while maintaining
   connectivity between each leaf node and each Top-of-Fabric node.  In
   that case the ToF node connects to a single Port per PoD, so it
   appears as a single port in the projected view represented in
   Figure 12 and the number of ports required on the Spine Node is more
   or equal to P, the number of PoDs.



The RIFT Authors         Expires April 22, 2019                [Page 23]

Internet-Draft                    RIFT                      October 2018


   Plane 1
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+  -+
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |
   | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | | |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+   |
  ----------- . ------------ . ------------ . ------------ . -------- |
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+   |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |
   | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | | |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+   |
  ----------- . ------------ . ------------ . ------------ . -------- |
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+   |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |
   | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | | |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+   |
  ----------- . ------------ . ------------ . ------------ . -------- +<-+
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+   |  |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |  |
   | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | | |  |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |  |
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+   |  |
  ----------- . ------------ . ------------ . ------------ . -------- |  |
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+   |  |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |  |
   | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | | |  |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |  |
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+   |  |
  ----------- . ------------ . ------------ . ------------ . -------- |  |
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+   |  |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |  |
   | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | | |  |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |--|    |-+ |  |
     +----+  +----+  +----+  +----+  +----+  +----+  +----+  +----+  -+  |
   Plane 6      ^                                                        |
                |                                                        |
                |     ----------------                 --------------    |
                +-----  ToF       Node                 Class of PoDs  ---+
                      ----------------                 -------------

    Figure 12: Northern View of a Maximally Partitioned ToF Level, R=1








The RIFT Authors         Expires April 22, 2019                [Page 24]

Internet-Draft                    RIFT                      October 2018


5.1.3.  Fallen Leaf Problem

   As mentioned earlier, RIFT exhibits an anisotropic behavior tailored
   for fabrics with a North / South orientation and a high level of
   interleaving paths.  A non-partitioned fabric makes a total loss of
   connectivity between a Top-of-Fabric node at the north and a leaf
   node at the south a very rare but yet possible occasion that is fully
   healed by positive disaggregation described in Section 5.2.5.1.  In
   large fabrics or fabrics built from switches with low radix, the ToF
   ends often being partioned in planes which makes the occurrence of
   having a given leaf being only reachable from a subset of the ToF
   nodes more likely to happen.  This makes some further considerations
   necessary.

   We define a "Fallen Leaf" as a leaf that can be reached by only a
   subset of Top-of-Fabric nodes but cannot be reached by all due to
   missing connectivity.  If R is the redundancy factor, then it takes
   at least R breakages to reach a "Fallen Leaf" situation.

   In a maximally partitioned fabric, the redundancy factor R is 1, so
   any breakage may cause one or more fallen leaves, but not all cases
   require disaggregation.  The following cases do not require
   particular action:

      If the breakage is a southern link from a leaf Node going down,
      then connectivity to any node attached to the link is lost.  There
      is no need to disaggregate since the connectivity is lost for all
      spine nodes in a same fashion.

      If the breakage is a leaf Node going down, then connectivity
      through that leaf is lost for all nodes.  There is no need to
      disaggregate since the connectivity is lost for all spine nodes in
      a same fashion.

      If the breakage is a ToF Node going down, then northern traffic is
      routed via alternate ToF nodes in the same plane and there is no
      need to disaggregate routes.

   In a general manner, the mechanism of non-transitive positive
   disaggregation is sufficient when the disaggregating ToF nodes
   collectively connect to all the ToP nodes in the broken plane.  This
   happens in the following case:

      If the breakage is the last northern link from a ToP node to a ToF
      node going down, then the fallen leaf problem affects only The ToF
      node, and the connectivity to all the nodes in the PoD is lost
      from that ToF node.  This can be observed by other ToF nodes




The RIFT Authors         Expires April 22, 2019                [Page 25]

Internet-Draft                    RIFT                      October 2018


      within the plane where the ToP node is located and positively
      disaggregated within that plane.

   On the other hand, there is a need to disaggregate the routes to
   Fallen Leaves in a transitive fashion all the way to the other leaves
   in the following cases:

      If the breakage is the last northern link from a Leaf node within
      a plane - there is only one such link in a maximally partitioned
      fabric - that goes down, then connectivity to all unicast prefixes
      attached to the Leaf node is lost within the plane where the link
      is located.  Southern Reflection by a Leaf Node - e.g., between
      ToP nodes if the PoD has only 2 levels - happens in between
      planes, allowing the ToP nodes to detect the problem within the
      PoD where it occurs and positively disaggregate.  The breakage can
      be observed by the ToF nodes in the same plane through the
      flooding of N-TIEs from the ToP nodes, but the ToF nodes need to
      be aware of all the affected prefixes for the negative
      disaggregation to be fully effective.  The problem can also be
      observed by the ToF nodes in the other planes through the flooding
      of N-TIEs from the affected Leaf nodes, together with non-node
      N-TIEs which indicate the affected prefixes.  To be effective in
      that case, the positive disaggregation must reach down to the
      nodes that make the plane selection, which are typically the
      ingress Leaf nodes, and the information is not useful for routing
      in the intermediate levels.

      If the breakage is a ToP node in a maximally partitioned fabric -
      in which case it is the only ToP node serving that plane in that
      PoD - that goes down, then the connectivity to all the nodes in
      the PoD is lost within the plane where the ToP node is located -
      all leaves fall.  Since the Southern Reflection between the ToF
      nodes happens only within a plane, ToF nodes in other planes
      cannot discover the case of fallen leaves in a different plane,
      and cannot determine beyond their local plane whether a Leaf node
      that was initially reachable has become unreachable.  As above,
      the breakage can be observed by the ToF nodes in the plane where
      the breakage happened, and then again, the ToF nodes in the plane
      need to be aware of all the affected prefixes for the negative
      disaggregation to be fully effective.  The problem can also be
      observed by the ToF nodes in the other planes through the flooding
      of N-TIEs from the affected Leaf nodes, if there are only 3 levels
      and the ToP nodes are directly connected to the Leaf nodes, and
      then again it can only be effective it is propagated transitively
      to the Leaf, and useless above that level.

   For the sake of readability let us roll the abstractions back to a
   simplest example and observe that in Figure 3 the loss of link Spine



The RIFT Authors         Expires April 22, 2019                [Page 26]

Internet-Draft                    RIFT                      October 2018


   122 to Leaf 122 will make Leaf 122 a fallen leaf for Top-of-Fabric
   plane B.  Worse, if the cabling was never present in first place,
   plane B will not even be able to know that such a fallen leaf exists.
   Hence partitioning without further treatment results in two grave
   problems:

   o  Leaf111 trying to route to Leaf122 MUST choose Spine 111 in plane
      A as its next hop since plane B will inevitably blackhole the
      packet when forwarding using default routes or do excessive bow
      tie'ing, i.e.  this information must be in its routing table.

   o  any kind of "flooding" or distance vector trying to deal with the
      problem by distributing host routes will be able to converge only
      using paths through leafs, i.e. the flooding of information on
      Leaf122 will go up to Top-of-Fabric A and then "loopback" over
      other leafs to ToF B leading in extreme cases to traffic for
      Leaf122 when presented to plane B taking an "inverted fabric" path
      where leafs start to serve as TOFs.

5.1.4.  Discovering Fallen Leaves

   As we illustrate later and without further proof here, to deal with
   fallen leafs in multi-plane designs RIFT requires all the ToF nodes
   to share the same topology database.  This happens naturally in
   single plane design but needs additional considerations in multi-
   plane fabrics.  To satisfy this RIFT in multi-plane designs relies at
   the ToF Level on ring interconnection of switches in multiple planes.
   Other solutions are possible but they either need more cabling or end
   up having much longer flooding path or single points of failure.

   In more detail, by reserving two ports on each Top-of-Fabric node it
   is possible to connect them together in an interplane bi-directional
   ring as illustrated in Figure 13 (where we show a bi-directional ring
   connecting switches across planes).  The rings will exchange full
   topology information between planes and with that allow consequently
   by the means of transitive, negative disaggregation described in
   Section 5.2.5.2 to efficiently fix any possible fallen leaf scenario.
   Somewhat as a side-effect, the exchange of information fulfills the
   requirement to present full view of the fabric topology at the Top-
   of-Fabric level without the need to collate it from multiple points
   by additional complexity of technologies like [RFC7752].










The RIFT Authors         Expires April 22, 2019                [Page 27]

Internet-Draft                    RIFT                      October 2018


       +----+  +----+  +----+  +----+  +----+  +----+  +--------+
       |    |  |    |  |    |  |    |  |    |  |    |  |        |
       |       |       |       |       |       |       |        |
     +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+     |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |-+   |
   | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | |   | Plane A
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |-+   |
     +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+     |
       |       |       |       |       |       |       |        |
     +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+     |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |-+   |
   | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | |   | Plane B
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |-+   |
     +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+     |
       |       |       |       |       |       |       |        |
                                  ...                           |
       |       |       |       |       |       |       |        |
     +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+     |
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |-+   |
   | | HH |  | HH |  | HH |  | HH |  | HH |  | HH |  | HH | |   | Plane X
   +-|    |--|    |--|    |--|    |--|    |--|    |--|    |-+   |
     +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+  +-o--+     |
       |       |       |       |       |       |       |        |
       |    |  |    |  |    |  |    |  |    |  |    |  |        |
       +----+  +----+  +----+  +----+  +----+  +----+  +--------+




   Figure 13: Connecting Top-of-Fabric Nodes Across Planes by Two Rings

5.1.5.  Addressing the Fallen Leaves Problem

   One consequence of the Fallen Leaf problem is that some prefixes
   attached to the fallen leaf become unreachable from some of the ToF
   nodes.  RIFT proposes two methods to address this issue, the positive
   and the negative disaggregation.  Both methods flood S-TIEs to
   advertise the impacted prefix(es).

   When used for the operation of disaggregation, a positive S-TIE, as
   usual, indicates reachability to a prefix of given length and all
   addresses subsumed by it.  In contrast, a negative route
   advertisement indicates that the origin cannot route to the
   advertised prefix.

   The positive disaggregation is originated by a router that can still
   reach the advertised prefix, and the operation is not transitive,
   meaning that the receiver does not generate its own flooding south as



The RIFT Authors         Expires April 22, 2019                [Page 28]

Internet-Draft                    RIFT                      October 2018


   a consequence of receiving positive disaggregation advertisements
   from an higher level node.  The effect of a positive disaggregation
   is that the traffic to the impacted prefix will follow the prefix
   longest match and will be limited to the northbound routers that
   advertised the more specific route.

   In contrast, the negative disaggregation is transitive, and is
   propagated south when all the possible routes northwards are barred.
   A negative route advertisement is only actionable when the negative
   prefix is aggregated by a positive route advertisement for a shorter
   prefix.  In that case, the negative advertisement carves an exception
   to the positive route in the routing table (one could think of
   "punching a hole"), making the positive prefix reachable through the
   originator with the special consideration of the negative prefix
   removing certain next hop neighbors.

   When the ToF is not partitioned, the collective southern flooding of
   the positive disaggregation by the ToF nodes that can still reach the
   impacted prefix is in general enough to cover all the switches at the
   next level south, typically the ToP nodes.  If all those switches are
   aware of the disaggregation, they collectively create a ceiling that
   intercepts all the traffic north and forwards it to the ToF nodes
   that advertised the more specific route.  In that case, the positive
   disaggregation alone is sufficient to solve the fallen leaf problem.

   On the other hand, when the fabric is partitioned in planes, the
   positive disaggregation from ToF nodes in different planes do not
   reach the ToP switches in the affected plane and cannot solve the
   fallen leaves problem.  In other words, a breakage in a plane can
   only be solved in that plane.  Also, the selection of the plane for a
   packet typically occurs at the leaf level and the disaggregation must
   be transitive and reach all the leaves.  In that case, the negative
   disaggregation is necessary.  The details on the RIFT approach to
   deal with fallen leafs in an optimal way is specified in
   Section 5.2.5.2.

5.2.  Specification

5.2.1.  Transport

   All packet formats are defined in Thrift models in Appendix A.

   The serialized model is carried in an envelope within a UDP frame
   that provides security and allows validation/modification of several
   important fields without de-serialization for performance and
   security reasons.





The RIFT Authors         Expires April 22, 2019                [Page 29]

Internet-Draft                    RIFT                      October 2018


   The ultimate transport envelope, especially the placement of nonces
   is under active discussion.

+--------+----------+-------------+----------+-------------+---------+----------------+
| UDP    | TIE      | Fingerprint | Key ID   | Security    | Model   | Serialized     |
| Header | Lifetime | Type        |          | Fingerprint | Version | RIFT Model ... |
|        |          | (e.g. SHA)  |          |             |         | Object         |
+--------+----------+-------------+----------+-------------+---------+----------------+


                       Figure 14: Security Envelope

5.2.2.  Link (Neighbor) Discovery (LIE Exchange)

   LIE exchange happens over well-known administratively locally scoped
   and configured or otherwise well-known IPv4 multicast address
   [RFC2365] or link-local multicast scope [RFC4291] for IPv6 [RFC8200]
   using a configured or otherwise a well-known destination UDP port
   defined in Appendix C.1.  LIEs SHOULD be sent with a TTL of 1 to
   prevent RIFT information reaching beyond a single L3 next-hop in the
   topology.  LIEs SHOULD be sent with network control precedence.
   Originating port of the LIE has no further significance other than
   identifying the origination point.  LIEs are exchanged over all links
   running RIFT.  An implementation MAY listen and send LIEs on IPv4
   and/or IPv6 multicast addresses.  LIEs on same link are considered
   part of the same negotiation independent on the address family they
   arrive on.  Observe further that the LIE source address may not
   identify the peer uniquely in unnumbered or link-local address cases
   so the response transmission MUST occur over the same interface the
   LIEs have been received on.  A node CAN use any of the adjacency's
   source addresses it saw in LIEs on the specific interface during
   adjacency formation to send TIEs.  That implies that an
   implementation MUST be ready to accept TIEs on all addresses it used
   as source of LIE frames.

   Observe further that the protocol does NOT support selective
   disabling of address families or any local address changes in three
   way state, i.e. if a link has entered three way IPv4 and/or IPv6 with
   a neighbor on an adjacency and it wants to stop supporting one of the
   families or change any of its local addresses, it has to tear down
   and rebuild the adjacency.  It also has to remove any information it
   stored about adjacency's' LIE source addresses seen.

   All RIFT routers MUST support IPv4 forwarding and MAY support IPv6
   forwarding.  A three way adjacency over IPv6 addresses implies
   support for IPv4 forwarding.





The RIFT Authors         Expires April 22, 2019                [Page 30]

Internet-Draft                    RIFT                      October 2018


   Unless Section 5.2.7 is used, each node is provisioned with the level
   at which it is operating and its PoD (or otherwise a default level
   and "undefined" PoD are assumed; meaning that leafs do not need to be
   configured at all if initial configuration values are all left at 0).
   Nodes in the spine are configured with "any" PoD which has the same
   value "undefined" PoD hence we will talk about "undefined/any" PoD.
   This information is propagated in the LIEs exchanged.

   Further definitions of leaf flags are found in Section 5.2.7 given
   they have implications in terms of level and adjacency forming here.

   A node tries to form a three way adjacency if and only if

   1.  the node is in the same PoD or either the node or the neighbor
       advertises "undefined/any" PoD membership (PoD# = 0) AND

   2.  the neighboring node is running the same MAJOR schema version AND

   3.  the neighbor is not member of some PoD while the node has a
       northbound adjacency already joining another PoD AND

   4.  the neighboring node uses a valid System ID AND

   5.  the neighboring node uses a different System ID than the node
       itself

   6.  the advertised MTUs match on both sides AND

   7.  both nodes advertise defined level values AND

   8.  [

          i) the node is at level 0 and has no three way adjacencies
          already to HAT nodes with level different than the adjacent
          node OR

          ii) the node is not at level 0 and the neighboring node is at
          level 0 OR

          iii) both nodes are at level 0 AND both indicate support for
          Section 5.3.9 OR

          iv) neither node is at level 0 and the neighboring node is at
          most one level away

       ].





The RIFT Authors         Expires April 22, 2019                [Page 31]

Internet-Draft                    RIFT                      October 2018


   The rule in Paragraph 3 MAY be optionally disregarded by a node if
   PoD detection is undesirable or has to be disregarded.

   A node configured with "undefined" PoD membership MUST, after
   building first northbound three way adjacencies to a node being in a
   defined PoD, advertise that PoD as part of its LIEs.  In case that
   adjacency is lost, from all available northbound three way
   adjacencies the node with the highest System ID and defined PoD is
   chosen.  That way the northmost defined PoD value (normally the top
   spines in a PoD) can diffuse southbound towards the leafs "forcing"
   the PoD value on any node with "undefined" PoD.

   LIEs arriving with a TTL larger than 1 MUST be ignored.

   A node SHOULD NOT send out LIEs without defined level in the header
   but in certain scenarios it may be beneficial for trouble-shooting
   purposes.

   LIE exchange uses three way handshake mechanism which is a cleaned up
   version of [RFC5303].  Observe that for easier comprehension the
   terminology of one/two and three-way states does NOT align with OSPF
   or ISIS FSMs albeit they use roughly same mechanisms.  LIE packets
   reflect nonces and may contain an SHA-1 [RFC6234] over nonces and
   some of the LIE data which prevents corruption and replay attacks.

5.2.3.  Topology Exchange (TIE Exchange)

5.2.3.1.  Topology Information Elements

   Topology and reachability information in RIFT is conveyed by the
   means of TIEs which have good amount of commonalities with LSAs in
   OSPF.

   The TIE exchange mechanism uses the port indicated by each node in
   the LIE exchange and the interface on which the adjacency has been
   formed as destination.  It SHOULD use TTL of 1 as well.

   TIEs contain sequence numbers, lifetimes and a type.  Each type has a
   large identifying number space and information is spread across
   possibly many TIEs of a certain type by the means of a hash function
   that a node or deployment can individually determine.  One extreme
   design choice is a prefix per TIE which leads to more BGP-like
   behavior where small increments are only advertised on route changes
   vs. deploying with dense prefix packing into few TIEs leading to more
   traditional IGP trade-off with fewer TIEs.  An implementation may
   even rehash prefix to TIE mapping at any time at the cost of
   significant amount of re-advertisements of TIEs.




The RIFT Authors         Expires April 22, 2019                [Page 32]

Internet-Draft                    RIFT                      October 2018


   More information about the TIE structure can be found in the schema
   in Appendix A.

5.2.3.2.  South- and Northbound Representation

   A central concept of RIFT is that each node represents itself
   differently depending on the direction in which it is advertising
   information.  More precisely, a spine node represents two different
   databases over its adjacencies depending whether it advertises TIEs
   to the north or to the south/sideways.  We call those differing TIE
   databases either south- or northbound (S-TIEs and N-TIEs) depending
   on the direction of distribution.

   The N-TIEs hold all of the node's adjacencies and local prefixes
   while the S-TIEs hold only all of the node's adjacencies, the default
   prefix with necessary disaggregated prefixes and local prefixes.  We
   will explain this in detail further in Section 5.2.5.

   The TIE types are symmetric in both directions and Table 2 provides a
   quick reference to main TIE types including direction and their
   function.

   +----------+--------------------------------------------------------+
   | TIE-Type | Content                                                |
   +----------+--------------------------------------------------------+
   | node     | node properties, adjacencies and information helping   |
   | N-TIE    | in complex disaggregation scenarios                    |
   +----------+--------------------------------------------------------+
   | node     | same content as node N-TIE except the information to   |
   | S-TIE    | help disaggregation                                    |
   +----------+--------------------------------------------------------+
   | Prefix   | contains nodes' directly reachable prefixes            |
   | N-TIE    |                                                        |
   +----------+--------------------------------------------------------+
   | Prefix   | contains originated defaults and de-aggregated         |
   | S-TIE    | prefixes                                               |
   +----------+--------------------------------------------------------+
   | KV       | contains nodes northbound KVs                          |
   | N-TIE    |                                                        |
   +----------+--------------------------------------------------------+
   | KV       | contains nodes southbound KVs                          |
   | S-TIE    |                                                        |
   +----------+--------------------------------------------------------+

                            Table 2: TIE Types

   As an example illustrating a databases holding both representations,
   consider the topology in Figure 2 with the optional link between



The RIFT Authors         Expires April 22, 2019                [Page 33]

Internet-Draft                    RIFT                      October 2018


   spine 111 and spine 112 (so that the flooding on an East-West link
   can be shown).  This example assumes unnumbered interfaces.  First,
   here are the TIEs generated by some nodes.  For simplicity, the key
   value elements which may be included in their S-TIEs or N-TIEs are
   not shown.


        Spine21 S-TIEs:
        Node S-TIE:
          NodeElement(level=2, neighbors((Spine 111, level 1, cost 1),
          (Spine 112, level 1, cost 1), (Spine 121, level 1, cost 1),
          (Spine 122, level 1, cost 1)))
        Prefix S-TIE:
          SouthPrefixesElement(prefixes(0/0, cost 1), (::/0, cost 1))

        Spine 111 S-TIEs:
        Node S-TIE:
          NodeElement(level=1, neighbors((Spine21, level 2, cost 1, links(...)),
          (Spine22, level 2, cost 1, links(...)),
          (Spine 112, level 1, cost 1, links(...)),
          (Leaf111, level 0, cost 1, links(...)),
          (Leaf112, level 0, cost 1, links(...))))
        Prefix S-TIE:
          SouthPrefixesElement(prefixes(0/0, cost 1), (::/0, cost 1))

        Spine 111 N-TIEs:
        Node N-TIE:
          NodeElement(level=1,
          neighbors((Spine21, level 2, cost 1, links(...)),
          (Spine22, level 2, cost 1, links(...)),
          (Spine 112, level 1, cost 1, links(...)),
          (Leaf111, level 0, cost 1, links(...)),
          (Leaf112, level 0, cost 1, links(...))))
        Prefix N-TIE:
          NorthPrefixesElement(prefixes(Spine 111.loopback)

        Spine 121 S-TIEs:
        Node S-TIE:
          NodeElement(level=1, neighbors((Spine21,level 2,cost 1),
          (Spine22, level 2, cost 1), (Leaf121, level 0, cost 1),
          (Leaf122, level 0, cost 1)))
        Prefix S-TIE:
          SouthPrefixesElement(prefixes(0/0, cost 1), (::/0, cost 1))

        Spine 121 N-TIEs:
        Node N-TIE:
          NodeElement(level=1,
          neighbors((Spine21, level 2, cost 1, links(...)),



The RIFT Authors         Expires April 22, 2019                [Page 34]

Internet-Draft                    RIFT                      October 2018


          (Spine22, level 2, cost 1, links(...)),
          (Leaf121, level 0, cost 1, links(...)),
          (Leaf122, level 0, cost 1, links(...))))
        Prefix N-TIE:
          NorthPrefixesElement(prefixes(Spine 121.loopback)

        Leaf112 N-TIEs:
        Node N-TIE:
          NodeElement(level=0,
          neighbors((Spine 111, level 1, cost 1, links(...)),
          (Spine 112, level 1, cost 1, links(...))))
        Prefix N-TIE:
          NorthPrefixesElement(prefixes(Leaf112.loopback, Prefix112,
          Prefix_MH))


       Figure 15: example TIES generated in a 2 level spine-and-leaf
                                 topology

5.2.3.3.  Flooding

   The mechanism used to distribute TIEs is the well-known (albeit
   modified in several respects to address fat tree requirements)
   flooding mechanism used by today's link-state protocols.  Although
   flooding is initially more demanding to implement it avoids many
   problems with update style used in diffused computation such as path
   vector protocols.  Since flooding tends to present an unscalable
   burden in large, densely meshed topologies (fat trees being
   unfortunately such a topology) we provide as solution a close to
   optimal global flood reduction and load balancing optimization in
   Section 5.2.3.8.

   As described before, TIEs themselves are transported over UDP with
   the ports indicated in the LIE exchanges and using the destination
   address on which the LIE adjacency has been formed.  For unnumbered
   IPv4 interfaces same considerations apply as in equivalent OSPF case.

   On reception of a TIE with an undefined level value in the packet
   header the node SHOULD issue a warning and indiscriminately discard
   the packet.

   Precise finite state machines and procedures can be found in
   Appendix B.3.








The RIFT Authors         Expires April 22, 2019                [Page 35]

Internet-Draft                    RIFT                      October 2018


5.2.3.4.  TIE Flooding Scopes

   In a somewhat analogous fashion to link-local, area and domain
   flooding scopes, RIFT defines several complex "flooding scopes"
   depending on the direction and type of TIE propagated.

   Every N-TIE is flooded northbound, providing a node at a given level
   with the complete topology of the Clos or Fat Tree network underneath
   it, including all specific prefixes.  This means that a packet
   received from a node at the same or lower level whose destination is
   covered by one of those specific prefixes may be routed directly
   towards the node advertising that prefix rather than sending the
   packet to a node at a higher level.

   A node's Node S-TIEs, consisting of all node's adjacencies and prefix
   S-TIEs limited to those related to default IP prefix and
   disaggregated prefixes, are flooded southbound in order to allow the
   nodes one level down to see connectivity of the higher level as well
   as reachability to the rest of the fabric.  In order to allow an E-W
   disconnected node in a given level to receive the S-TIEs of other
   nodes at its level, every *NODE* S-TIE is "reflected" northbound to
   level from which it was received.  It should be noted that East-West
   links are included in South TIE flooding; those TIEs need to be
   flooded to satisfy algorithms in Section 5.2.4.  In that way nodes at
   same level can learn about each other without a lower level, e.g. in
   case of leaf level.  The precise flooding scopes are given in
   Table 3.  Those rules govern as well what SHOULD be included in TIDEs
   on the adjacency.  East-West flooding scopes are identical to South
   flooding scopes except in case of ToF East-West links (rings).

   Node S-TIE "south reflection" allows to support positive
   disaggregation on failures describes in Section 5.2.5 and flooding
   reduction in Section 5.2.3.8.


















The RIFT Authors         Expires April 22, 2019                [Page 36]

Internet-Draft                    RIFT                      October 2018


   +-----------+---------------------+---------------+-----------------+
   | Type /    | South               | North         | East-West       |
   | Direction |                     |               |                 |
   +-----------+---------------------+---------------+-----------------+
   | node      | flood if level of   | flood if      | flood only if   |
   | S-TIE     | originator is equal | level of      | this node is    |
   |           | to this node        | originator is | not ToF         |
   |           |                     | higher than   |                 |
   |           |                     | this node     |                 |
   +-----------+---------------------+---------------+-----------------+
   | non-node  | flood self-         | flood only if | flood only if   |
   | S-TIE     | originated only     | neighbor is   | self-originated |
   |           |                     | originator of | and this node   |
   |           |                     | TIE           | is not ToF      |
   +-----------+---------------------+---------------+-----------------+
   | all       | never flood         | flood always  | flood only if   |
   | N-TIEs    |                     |               | this node is    |
   |           |                     |               | ToF             |
   +-----------+---------------------+---------------+-----------------+
   | TIDE      | include at least    | include at    | if this node is |
   |           | all non-self        | least all     | ToF then        |
   |           | originated N-TIE    | node S-TIEs   | include all     |
   |           | headers and self-   | and all       | N-TIEs,         |
   |           | originated S-TIE    | S-TIEs        | otherwise only  |
   |           | headers and node    | originated by | self-originated |
   |           | S-TIEs of nodes at  | peer and all  | TIEs            |
   |           | same level          | N-TIEs        |                 |
   +-----------+---------------------+---------------+-----------------+
   | TIRE as   | request all N-TIEs  | request all   | if this node is |
   | Request   | and all peer's      | S-TIEs        | ToF then apply  |
   |           | self-originated     |               | North scope     |
   |           | TIEs and all node   |               | rules,          |
   |           | S-TIEs              |               | otherwise South |
   |           |                     |               | scope rules     |
   +-----------+---------------------+---------------+-----------------+
   | TIRE as   | Ack all received    | Ack all       | Ack all         |
   | Ack       | TIEs                | received TIEs | received TIEs   |
   +-----------+---------------------+---------------+-----------------+

                         Table 3: Flooding Scopes

   If the TIDE includes additional TIE headers beside the ones
   specified, the receiving neighbor must apply according filter to the
   received TIDE strictly and MUST NOT request the extra TIE headers
   that were not allowed by the flooding scope rules in its direction.

   As an example to illustrate these rules, consider using the topology
   in Figure 2, with the optional link between spine 111 and spine 112,



The RIFT Authors         Expires April 22, 2019                [Page 37]

Internet-Draft                    RIFT                      October 2018


   and the associated TIEs given in Figure 15.  The flooding from
   particular nodes of the TIEs is given in Table 4.

   +-------------+----------+------------------------------------------+
   | Router      | Neighbor | TIEs                                     |
   | floods to   |          |                                          |
   +-------------+----------+------------------------------------------+
   | Leaf111     | Spine    | Leaf111 N-TIEs, Spine 111 node S-TIE     |
   |             | 112      |                                          |
   | Leaf111     | Spine    | Leaf111 N-TIEs, Spine 112 node S-TIE     |
   |             | 111      |                                          |
   |             |          |                                          |
   | Spine 111   | Leaf111  | Spine 111 S-TIEs                         |
   | Spine 111   | Leaf112  | Spine 111 S-TIEs                         |
   | Spine 111   | Spine    | Spine 111 S-TIEs                         |
   |             | 112      |                                          |
   | Spine 111   | Spine21  | Spine 111 N-TIEs, Leaf111 N-TIEs,        |
   |             |          | Leaf112 N-TIEs, Spine22 node S-TIE       |
   | Spine 111   | Spine22  | Spine 111 N-TIEs, Leaf111 N-TIEs,        |
   |             |          | Leaf112 N-TIEs, Spine21 node S-TIE       |
   |             |          |                                          |
   | ...         | ...      | ...                                      |
   | Spine21     | Spine    | Spine21 S-TIEs                           |
   |             | 111      |                                          |
   | Spine21     | Spine    | Spine21 S-TIEs                           |
   |             | 112      |                                          |
   | Spine21     | Spine    | Spine21 S-TIEs                           |
   |             | 121      |                                          |
   | Spine21     | Spine    | Spine21 S-TIEs                           |
   |             | 122      |                                          |
   | ...         | ...      | ...                                      |
   +-------------+----------+------------------------------------------+

             Table 4: Flooding some TIEs from example topology

5.2.3.5.  Initial and Periodic Database Synchronization

   The initial exchange of RIFT is modeled after ISIS with TIDE being
   equivalent to CSNP and TIRE playing the role of PSNP.  The content of
   TIDEs and TIREs is governed by Table 3.

5.2.3.6.  Purging

   RIFT does not purge information that has been distributed by the
   protocol.  Purging mechanisms in other routing protocols have proven
   to be complex and fragile over many years of experience.  Abundant
   amounts of memory are available today even on low-end platforms.  The
   information will age out and all computations will deliver correct



The RIFT Authors         Expires April 22, 2019                [Page 38]

Internet-Draft                    RIFT                      October 2018


   results if a node leaves the network due to the new information
   distributed by its adjacent nodes.

   Once a RIFT node issues a TIE with an ID, it MUST preserve the ID as
   long as feasible (also when the protocol restarts), even if the TIE
   looses all content.  The re-advertisement of empty TIE fulfills the
   purpose of purging any information advertised in previous versions.
   The originator is free to not re-originate the according empty TIE
   again or originate an empty TIE with relatively short lifetime to
   prevent large number of long-lived empty stubs polluting the network.
   Each node MUST timeout and clean up the according empty TIEs
   independently.

   Upon restart a node MUST, as any link-state implementation, be
   prepared to receive TIEs with its own system ID and supercede them
   with equivalent, newly generated, empty TIEs with a higher sequence
   number.  As above, the lifetime can be relatively short since it only
   needs to exceed the necessary propagation and processing delay by all
   the nodes that are within the TIE's flooding scope.

5.2.3.7.  Southbound Default Route Origination

   Under certain conditions nodes issue a default route in their South
   Prefix TIEs with costs as computed in Section 5.3.6.1.

   A node X that

   1.  is NOT overloaded AND

   2.  has southbound or East-West adjacencies

   originates in its south prefix TIE such a default route IIF

   1.  all other nodes at X's' level are overloaded OR

   2.  all other nodes at X's' level have NO northbound adjacencies OR

   3.  X has computed reachability to a default route during N-SPF.

   The term "all other nodes at X's' level" describes obviously just the
   nodes at the same level in the PoD with a viable lower level
   (otherwise the node S-TIEs cannot be reflected and the nodes in e.g.
   PoD 1 and PoD 2 are "invisible" to each other).

   A node originating a southbound default route MUST install a default
   discard route if it did not compute a default route during N-SPF.





The RIFT Authors         Expires April 22, 2019                [Page 39]

Internet-Draft                    RIFT                      October 2018


5.2.3.8.  Northbound TIE Flooding Reduction

   Section 1.4 of the Optimized Link State Routing Protocol [RFC3626]
   (OLSR) introduces the concept of a "multipoint relay" (MPR) that
   minimize the overhead of flooding messages in the network by reducing
   redundant retransmissions in the same region.

   A similar technique is applied to RIFT to control northbound
   flooding.  Important observations first:

   1.  a node MUST flood self-originated N-TIE to all the reachable
       nodes at the level above which we call the node's "parents";

   2.  it is typically not necessary that all parents reflood the N-TIEs
       to achieve a complete flooding of all the reachable nodes two
       levels above which we choose to call the node's "grandparents";

   3.  to control the volume of its flooding two hops North and yet keep
       it robust enough, it is advantageous for a node to select a
       subset of its parents as "Flood Repeaters" (FRs), which combined
       together deliver two or more copies of its flooding to all of its
       parents, i.e. the originating node's grandparents;

   4.  nodes at the same level do NOT have to agree on a specific
       algorithm to select the FRs, but overall load balancing should be
       achieved so that different nodes at the same level should tend to
       select different parents as FRs;

   5.  there are usually many solutions to the problem of finding a set
       of FRs for a given node; the problem of finding the minimal set
       is (similar to) a NP-Complete problem and a globally optimal set
       may not be the minimal one if load-balancing with other nodes is
       an important consideration;

   6.  it is expected that there will be often sets of equivalent nodes
       at a level L, defined as having a common set of parents at L+1.
       Applying this observation at both L and L+1, an algorithm may
       attempt to split the larger problem in a sum of smaller separate
       problems;

   7.  it is another expectation that there will be from time to time a
       broken link between a parent and a grandparent, and in that case
       the parent is probably a poor FR due to its lower reliability.
       An algorithm may attempt to eliminate parents with broken
       northbound adjacencies first in order to reduce the number of
       FRs.  Albeit it could be argued that relying on higher fanout FRs
       will slow flooding due to higher replication load reliability of
       FR's links seems to be a more pressing concern.



The RIFT Authors         Expires April 22, 2019                [Page 40]

Internet-Draft                    RIFT                      October 2018


   In a fully connected Clos Network, this means that a node selects one
   arbitrary parent as FR and then a second one for redundancy.  The
   computation can be kept relatively simple and completely distributed
   without any need for synchronization amongst nodes.  In a "PoD"
   structure, where the Level L+2 is partitioned in silos of equivalent
   grandparents that are only reachable from respective parents, this
   means treating each silo as a fully connected Clos Network and solve
   the problem within the silo.

   In terms of signaling, a node has enough information to select its
   set of FRs; this information is derived from the node's parents' Node
   S-TIEs, which indicate the parent's reachable northbound adjacencies
   to its own parents, i.e. the node's grandparents.  An optional
   boolean information `you_are_flood_repeater` in a LIE packet to a
   parent is set to indicate whether the parent lost its flood repeater
   leadership and with that SHOULD NOT reflood N-TIEs.

   This specification proposes a simple default algorithm that SHOULD be
   implemented and used by default on every RIFT node.

   o  let |NA(Node) be the set of Northbound adjacencies of node Node
      and CN(Node) be the cardinality of |NA(Node);

   o  let |SA(Node) be the set of Southbound adjacencies of node Node
      and CS(Node) be the cardinality of |SA(Node);

   o  let |P(Node) be the set of node Node's parents;

   o  let |G(Node) be the set of node Node's grandparents.  Observe
      that |G(Node) = |P(|P(Node));

   o  let N be the child node at level L computing a set of FR;

   o  let P be a node at level L+1 and a parent node of N, i.e. bi-
      directionally reachable over adjacency A(N, P);

   o  let G be a grandparent node of N, reachable transitively via a
      parent P over adjacencies ADJ(N, P) and ADJ(P, G).  Observe that N
      does not have enough information to check bidirectional
      reachability of A(P, G);

   o  let R be a redundancy constant integer; a value of 2 or higher for
      R is RECOMMENDED;

   o  let S be a similarity constant integer; a value in range 0 .. 2
      for S is RECOMMENDED, the value of 1 SHOULD be used.  Two
      cardinalities are considered as equivalent if their absolute
      difference is less than or equal to S, i.e.  |a-b|<=S.



The RIFT Authors         Expires April 22, 2019                [Page 41]

Internet-Draft                    RIFT                      October 2018


   o  let RND be a 64-bit random number generated by the system once on
      startup.

   The algorithm consists of the following steps:

   1.  derive a 64-bits number by XOR'ing 'N's system ID with RND and
       then

   2.  derive a 16-bits pseudo-random unsigned integer PR(N) from the
       resulting 64-bits number by splitting it in 16-bits-long words
       W1, W2, ..., Wn and then XOR'ing the circularly shifted resulting
       words together, and casting the resulting representation:

       1.  (unsigned integer) (W1<<1 xor (W2<<2) xor ... xor (Wn<<n) );

       and then

   3.  sort the parents by decreasing number of northbound adjacencies:
       sort |P(N) by decreasing CN(P), for all P in |P(N), as ordered
       array |A(N) and then

   4.  partition |A(N) in subarrays |A_k(N) of parents with equivalent
       cardinality of northbound adjacencies (in other words with
       equivalent number of grandparents they can reach):

       1.  set k=0; // k is the ID of the subarrray

       2.  set i=0;

       3.  while i < CN(N) do

           1.  set k=k+1;

           2.  set j=i;

           3.  while CN(|A(N)[j]) - CN(|A(N)[i]) <= S

               1.  place |A(N)[i] in |A_k(N) // abstract action, maybe
                   noop

               2.  set i=i+1;

           /* At this point j is the index in |A(N) of the first member
           of |A_k(N) and (i-j) is C_k(N) defined as the cardinality
           of |A_k(N) */

       /* At this point k is the total number of subarrays, initialized
       for the shuffling operation below */



The RIFT Authors         Expires April 22, 2019                [Page 42]

Internet-Draft                    RIFT                      October 2018


   5.  shuffle individually each subarrays |A_k(N) of cardinality C_k(N)
       within |A(N) using a Fisher-Yates method that depends on N's
       System ID:

       1.  while k > 0 do

           1.  for i from C_k(N)-1 to 1 decrementing by 1 do

               1.  set j to PR(N) modulo i;

               2.  exchange |A_k[j] and |A_k[i];

           2.  set k=k-1;

   6.  for each grandparent, initialize a counter with the number of its
       Southbound adjacencies :

       1.  for each G in |G(N) set c(G) = CS(G);

       and

   7.  finally keep as FRs only parents that are needed to maintain the
       number of adjacencies between the FRs and any grandparent G equal
       or above the redundancy constant R:

       1.  for each P in reshuffled |A(N);

           1.  if there exists an adjacency ADJ(P, G) in |NA(P) such
               that c(G) <= R then

               1.  place P in FR set;

           2.  else

               1.  for all adjacencies ADJ(P, G) in |NA(P)

                   1.  decrement c(G);

   The algorithm MUST be re-evaluated by a node on every change of local
   adjacencies or reception of a parent S-TIE with changed adjacencies.
   A node MAY apply a hysteresis to prevent excessive amount of
   computation during periods of network instability just like in case
   of reachability computation.

   A node SHOULD send out LIEs that grant leadership before LIEs that
   revoke it on leadership changes to prevent transient behavior where
   the full coverage of grand parents is not guaranteed.  Albeit the
   condition will correct in positively stable manner due to LIE



The RIFT Authors         Expires April 22, 2019                [Page 43]

Internet-Draft                    RIFT                      October 2018


   retransmission and periodic TIDEs, it can slow down flooding
   convergence on leadership changes.

5.2.4.  Reachability Computation

   A node has three sources of relevant information.  A node knows the
   full topology south from the received N-TIEs.  A node has the set of
   prefixes with associated distances and bandwidths from received
   S-TIEs.

   To compute reachability, a node runs conceptually a northbound and a
   southbound SPF.  We call that N-SPF and S-SPF.

   Since neither computation can "loop", it is possible to compute non-
   equal-cost or even k-shortest paths [EPPSTEIN] and "saturate" the
   fabric to the extent desired.

5.2.4.1.  Northbound SPF

   N-SPF uses northbound and East-West adjacencies in the computing
   node's node N-TIEs (since if the node is a leaf it may not have
   generated a node S-TIE) when starting Dijkstra.  Observe that N-SPF
   is really just a one hop variety since Node S-TIEs are not re-flooded
   southbound beyond a single level (or East-West) and with that the
   computation cannot progress beyond adjacent nodes.

   Once progressing, we are using the next level's node S-TIEs to find
   according adjacencies to verify backlink connectivity.  Just as in
   case of IS-IS or OSPF, two unidirectional links are associated
   together to confirm bidirectional connectivity.

   Default route found when crossing an E-W link is used IIF

   1.  the node itself does NOT have any northbound adjacencies AND

   2.  the adjacent node has one or more northbound adjacencies

   This rule forms a "one-hop default route split-horizon" and prevents
   looping over default routes while allowing for "one-hop protection"
   of nodes that lost all northbound adjacencies except at Top-of-Fabric
   where the links are used exclusively to flood topology information in
   multi-plane designs.

   Other south prefixes found when crossing E-W link MAY be used IIF

   1.  no north neighbors are advertising same or supersuming non-
       default prefix AND




The RIFT Authors         Expires April 22, 2019                [Page 44]

Internet-Draft                    RIFT                      October 2018


   2.  the node does not originate a non-default supersuming prefix
       itself.

   i.e. the E-W link can be used as the gateway of last resort for a
   specific prefix only.  Using south prefixes across E-W link can be
   beneficial e.g.  on automatic de-aggregation in pathological fabric
   partitioning scenarios.

   A detailed example can be found in Section 6.4.

5.2.4.2.  Southbound SPF

   S-SPF uses only the southbound adjacencies in the node S-TIEs, i.e.
   progresses towards nodes at lower levels.  Observe that E-W
   adjacencies are NEVER used in the computation.  This enforces the
   requirement that a packet traversing in a southbound direction must
   never change its direction.

   S-SPF uses northbound adjacencies in node N-TIEs to verify backlink
   connectivity.

5.2.4.3.  East-West Forwarding Within a Level

   Ultimately, it should be observed that in presence of a "ring" of E-W
   links in a level neither SPF will provide a "ring protection" scheme
   since such a computation would have to deal necessarily with breaking
   of "loops" in generic Dijkstra sense; an application for which RIFT
   is not intended.  It is outside the scope of this document how an
   underlay can be used to provide a full-mesh connectivity between
   nodes in the same level that would allow for N-SPF to provide
   protection for a single node loosing all its northbound adjacencies
   (as long as any of the other nodes in the level are northbound
   connected).

   Using south prefixes over horizontal links is optional and can
   protect against pathological fabric partitioning cases that leave
   only paths to destinations that would necessitate multiple changes of
   forwarding direction between north and south.

5.2.5.  Automatic Disaggregation on Link & Node Failures

5.2.5.1.  Positive, Non-transitive Disaggregation

   Under normal circumstances, node's S-TIEs contain just the
   adjacencies and a default route.  However, if a node detects that its
   default IP prefix covers one or more prefixes that are reachable
   through it but not through one or more other nodes at the same level,
   then it MUST explicitly advertise those prefixes in an S-TIE.



The RIFT Authors         Expires April 22, 2019                [Page 45]

Internet-Draft                    RIFT                      October 2018


   Otherwise, some percentage of the northbound traffic for those
   prefixes would be sent to nodes without according reachability,
   causing it to be black-holed.  Even when not black-holing, the
   resulting forwarding could 'backhaul' packets through the higher
   level spines, clearly an undesirable condition affecting the blocking
   probabilities of the fabric.

   We refer to the process of advertising additional prefixes southbound
   as 'positive de-aggregation' or 'positive dis-aggregation'.

   A node determines the set of prefixes needing de-aggregation using
   the following steps:

   1.  A DAG computation in the southern direction is performed first,
       i.e. the N-TIEs are used to find all of prefixes it can reach and
       the set of next-hops in the lower level for each of them.  Such a
       computation can be easily performed on a fat tree by e.g. setting
       all link costs in the southern direction to 1 and all northern
       directions to infinity.  We term set of those prefixes |R, and
       for each prefix, r, in |R, we define its set of next-hops to
       be |H(r).

   2.  The node uses reflected S-TIEs to find all nodes at the same
       level in the same PoD and the set of southbound adjacencies for
       each.  The set of nodes at the same level is termed |N and for
       each node, n, in |N, we define its set of southbound adjacencies
       to be |A(n).

   3.  For a given r, if the intersection of |H(r) and |A(n), for any n,
       is null then that prefix r must be explicitly advertised by the
       node in an S-TIE.

   4.  Identical set of de-aggregated prefixes is flooded on each of the
       node's southbound adjacencies.  In accordance with the normal
       flooding rules for an S-TIE, a node at the lower level that
       receives this S-TIE will not propagate it south-bound.  Neither
       is it necessary for the receiving node to reflect the
       disaggregated prefixes back over its adjacencies to nodes at the
       level from which it was received.

   To summarize the above in simplest terms: if a node detects that its
   default route encompasses prefixes for which one of the other nodes
   in its level has no possible next-hops in the level below, it has to
   disaggregate it to prevent black-holing or suboptimal routing through
   such nodes.  Hence a node X needs to determine if it can reach a
   different set of south neighbors than other nodes at the same level,
   which are connected to it via at least one common south neighbor.  If
   it can, then prefix disaggregation may be required.  If it can't,



The RIFT Authors         Expires April 22, 2019                [Page 46]

Internet-Draft                    RIFT                      October 2018


   then no prefix disaggregation is needed.  An example of
   disaggregation is provided in Section 6.3.

   A possible algorithm is described last:

   1.  Create partial_neighbors = (empty), a set of neighbors with
       partial connectivity to the node X's level from X's perspective.
       Each entry is a list of south neighbor of X and a list of nodes
       of X.level that can't reach that neighbor.

   2.  A node X determines its set of southbound neighbors
       X.south_neighbors.

   3.  For each S-TIE originated from a node Y that X has which is at
       X.level, if Y.south_neighbors is not the same as
       X.south_neighbors but the nodes share at least one southern
       neighbor, for each neighbor N in X.south_neighbors but not in
       Y.south_neighbors, add (N, (Y)) to partial_neighbors if N isn't
       there or add Y to the list for N.

   4.  If partial_neighbors is empty, then node X does not to
       disaggregate any prefixes.  If node X is advertising
       disaggregated prefixes in its S-TIE, X SHOULD remove them and re-
       advertise its according S-TIEs.

   A node X computes reachability to all nodes below it based upon the
   received N-TIEs first.  This results in a set of routes, each
   categorized by (prefix, path_distance, next-hop-set).  Alternately,
   for clarity in the following procedure, these can be organized by
   next-hop-set as ( (next-hops), {(prefix, path_distance)}).  If
   partial_neighbors isn't empty, then the following procedure describes
   how to identify prefixes to disaggregate.



















The RIFT Authors         Expires April 22, 2019                [Page 47]

Internet-Draft                    RIFT                      October 2018


            disaggregated_prefixes = { empty }
            nodes_same_level = { empty }
            for each S-TIE
              if (S-TIE.level == X.level and
                  X shares at least one S-neighbor with X)
                add S-TIE.originator to nodes_same_level
                end if
              end for

            for each next-hop-set NHS
              isolated_nodes = nodes_same_level
              for each NH in NHS
                if NH in partial_neighbors
                  isolated_nodes = intersection(isolated_nodes,
                                                partial_neighbors[NH].nodes)
                  end if
                end for

              if isolated_nodes is not empty
                for each prefix using NHS
                  add (prefix, distance) to disaggregated_prefixes
                  end for
                end if
              end for

            copy disaggregated_prefixes to X's S-TIE
            if X's S-TIE is different
              schedule S-TIE for flooding
              end if


             Figure 16: Computation of Disaggregated Prefixes

   Each disaggregated prefix is sent with the according path_distance.
   This allows a node to send the same S-TIE to each south neighbor.
   The south neighbor which is connected to that prefix will thus have a
   shorter path.

   Finally, to summarize the less obvious points partially omitted in
   the algorithms to keep them more tractable:

   1.  all neighbor relationships MUST perform backlink checks.

   2.  overload bits as introduced in Section 5.3.1 have to be respected
       during the computation.

   3.  all the lower level nodes are flooded the same disaggregated
       prefixes since we don't want to build an S-TIE per node and



The RIFT Authors         Expires April 22, 2019                [Page 48]

Internet-Draft                    RIFT                      October 2018


       complicate things unnecessarily.  The PoD containing the prefix
       will prefer southbound anyway.

   4.  positively disaggregated prefixes do NOT have to propagate to
       lower levels.  With that the disturbance in terms of new flooding
       is contained to a single level experiencing failures.

   5.  disaggregated prefix S-TIEs are not "reflected" by the lower
       level, i.e.  nodes within same level do NOT need to be aware
       which node computed the need for disaggregation.

   6.  The fabric is still supporting maximum load balancing properties
       while not trying to send traffic northbound unless necessary.

   To close this section it is worth to observe that in a single plane
   ToF this disaggregation prevents blackholing up to (K_LEAF * P) link
   failures in terms of Section 5.1.2 or in other terms, it takes at
   minimum that many link failures to partition the ToF into multiple
   planes.

5.2.5.2.  Negative, Transitive Disaggregation for Fallen Leafs

   As explained in Section 5.1.3 failures in multi-plane Top-of-Fabric
   or more than (K_LEAF * P) links failing in single plane design can
   generate fallen leafs.  Such scenario cannot be addressed by positive
   disaggregation only and needs a further mechanism.

5.2.5.2.1.  Cabling of Multiple Top-of-Fabric Planes

   Let us return in this section to designs with multiple planes as
   shown in Figure 3.  Figure 17 highlights how the ToF is cabled in
   case of two planes by the means of dual-rings to distribute all the
   N-TIEs within both planes.  For people familiar with traditional
   link-state routing protocols ToF level can be considered equivalent
   to area 0 in OSPF or level-2 in ISIS which need to be "connected" as
   well for the protocol to operate correctly.















The RIFT Authors         Expires April 22, 2019                [Page 49]

Internet-Draft                    RIFT                      October 2018


             .     ++==========++          ++==========++
             .     II          II          II          II
             .+----++--+  +----++--+  +----++--+  +----++--+
             .|ToF   A1|  |ToF   B1|  |ToF   B2|  |ToF   A2|
             .++-+-++--+  ++-+-++--+  ++-+-++--+  ++-+-++--+
             . | | II      | | II      | | II      | | II
             . | | ++==========++      | | ++==========++
             . | |         | |         | |         | |
             .
             . ~~~ Highlighted ToF of the previous multi-plane figure ~~


                 Figure 17: Topologically connected planes

   As described in Section 5.1.3 failures in multi-plane fabrics can
   lead to blackholes which normal positive disaggregation cannot fix.
   The mechanism of negative, transitive disaggregation incorporated in
   RIFT provides the according solution.

5.2.5.2.2.  Transitive Advertisement of Negative Disaggregates

   A ToF node that discovers that it cannot reach a fallen leaf
   disaggregates all the prefixes of such leafs.  It uses for that
   purpose negative prefix S-TIEs that are, as usual, flooded southwards
   with the scope defined in Section 5.2.3.4.

   Transitively, a node explicitly loses connectivity to a prefix when
   none of its children advertises it and when the prefix is negatively
   disaggregated by all of its parents.  When that happens, the node
   originates the negative prefix further down south.  Since the
   mechanism applies recursively south the negative prefix may propagate
   transitively all the way down to the leaf.  This is necessary since
   leafs connected to multiple planes by means of disjoint paths may
   have to choose the correct plane already at the very bottom of the
   fabric to make sure that they don't send traffic towards another leaf
   using a plane where it is "fallen" at which in point a blackhole is
   unavoidable.

   When the connectivity is restored, a node that disaggregated a prefix
   withdraws the negative disaggregation by the usual mechanism of re-
   advertising TIEs omitting the negative prefix.

5.2.5.2.3.  Computation of Negative Disaggregates

   The document omitted so far the description of the computation
   necessary to generate the correct set of negative prefixes.  Negative
   prefixes can in fact be advertised due to two different triggers.  We
   describe them consecutively.



The RIFT Authors         Expires April 22, 2019                [Page 50]

Internet-Draft                    RIFT                      October 2018


   The first origination reason is a computation that uses all the node
   N-TIEs to build the set of all reachable nodes by reachability
   computation over the complete graph.  The computation uses the node
   itself as root.  This is compared with the result of the normal
   southbound SPF as described in Section 5.2.4.2.  The difference are
   the fallen leafs and all their attached prefixes are advertised as
   negative prefixes southbound if the node does not see the prefix
   being reachable within southbound SPF.

   The second mechanism hinges on the understanding how the negative
   prefixes are used within the computation as described in Figure 18.
   When attaching the negative prefixes at certain point in time the
   negative prefix may find itself with all the viable nodes from the
   shorter match nexthop being pruned.  In other words, all its
   northbound neighbors provided a negative prefix advertisement.  This
   is the trigger to advertise this negative prefix transitively south
   and normally caused by the node being in a plane where the prefix
   belongs to a fabric leaf that has "fallen" in this plane.  Obviously,
   when one of the northbound switches withdraws its negative
   advertisement, the node has to withdraw its transitively provided
   negative prefix as well.

5.2.6.  Attaching Prefixes

   After the SPF is run, it is necessary to attach according prefixes.
   For S-SPF, prefixes from an N-TIE are attached to the originating
   node with that node's next-hop set and a distance equal to the
   prefix's cost plus the node's minimized path distance.  The RIFT
   route database, a set of (prefix, type=spf, path_distance, next-hop
   set), accumulates these results.  Obviously, the prefix retains its
   type which is used to tie-break between the same prefix advertised
   with different types.

   In case of N-SPF prefixes from each S-TIE need to also be added to
   the RIFT route database.  The N-SPF is really just a stub so the
   computing node needs simply to determine, for each prefix in an S-TIE
   that originated from adjacent node, what next-hops to use to reach
   that node.  Since there may be parallel links, the next-hops to use
   can be a set; presence of the computing node in the associated Node
   S-TIE is sufficient to verify that at least one link has
   bidirectional connectivity.  The set of minimum cost next-hops from
   the computing node X to the originating adjacent node is determined.

   Each prefix has its cost adjusted before being added into the RIFT
   route database.  The cost of the prefix is set to the cost received
   plus the cost of the minimum distance next-hop to that neighbor while
   taking into account its attributes such as mobility per Section 5.3.3
   necessary.  Then each prefix can be added into the RIFT route



The RIFT Authors         Expires April 22, 2019                [Page 51]

Internet-Draft                    RIFT                      October 2018


   database with the next_hop_set; ties are broken based upon type first
   and then distance and further attributes.  RIFT route preferences are
   normalized by the according thrift model type.

   An exemplary implementation for node X follows:


  for each S-TIE
     if S-TIE.level > X.level
        next_hop_set = set of minimum cost links to the S-TIE.originator
        next_hop_cost = minimum cost link to S-TIE.originator
        end if
     for each prefix P in the S-TIE
        P.cost = P.cost + next_hop_cost
        if P not in route_database:
          add (P, type=DistVector, P.cost, next_hop_set) to route_database
          end if
        if (P in route_database):
          if route_database[P].cost > P.cost):
            update route_database[P] with (P, DistVector, P.cost, next_hop_set)
          else if route_database[P].cost == P.cost
            update route_database[P] with (P, DistVector, P.cost,
               merge(next_hop_set, route_database[P].next_hop_set))
          else
            // Not preferred route so ignore
            end if
          end if
        end for
     end for


    Figure 18: Adding Routes from S-TIE Positive and Negative Prefixes

   After the positive prefixes are attached and tie-broken, negative
   prefixes are attached and used in case of northbound computation,
   ideally from the shortest length to the longest.  The nexthop
   adjacencies for a negative prefix are inherited from the longest
   prefix that aggregates it, and subsequently adjacencies to nodes that
   advertised negative for this prefix are removed.  As an example, if a
   hypothetical RIFT routing table contains A.1/16 @ [A,B], A.1.1/24 @
   [C,D] it will on reception of negative A.1.1.1/32 from D include the
   entry A.1.1.1/32 @ [C] resulting from computation inheriting A.1.1/24
   nexthops (C and D) and pruning all the nodes that advertised this
   negative prefix (which is D in this case).

   The rule of inheritance MUST be maintained when the nexthop list for
   a prefix is modified, as the modification may affect the entries for
   matching negative prefixes of immediate longer prefix length.  For



The RIFT Authors         Expires April 22, 2019                [Page 52]

Internet-Draft                    RIFT                      October 2018


   instance, if a nexthop is added, then by inheritance it must be added
   to all the negative routes of immediate longer prefixes length unless
   it is pruned due to a negative advertisement for the same next hop.
   Similarily, if a nexthop is deleted for a given prefix, then it is
   deleted for all the immediately aggregated negative routes.  This
   will recurse in the case of nested negative prefix aggregations.

   The rule of inheritance must also be maintained when a new prefix of
   intermediate length is inserted, or when the immediately aggregating
   prefix is deleted from the routing table, making an even shorter
   aggregating prefix the one from which the negative routes now inherit
   their adjacencies.  As the aggregating prefix changes, all the
   negative routes must be recomputed, and then again the process may
   recurse in case of nested negative prefix aggregations.

   Observe that despite seeming quite computationally expensive the
   operations are only necessary if the only available advertisements
   for a prefix are negative since tie-breaking always prefers positive
   information for the prefix which stops any kind of recursion since
   positive information never inherits next hops.

5.2.7.  Optional Zero Touch Provisioning (ZTP)

   Each RIFT node can optionally operate in zero touch provisioning
   (ZTP) mode, i.e. it has no configuration (unless it is a Top-of-
   Fabric at the top of the topology or the must operate in the topology
   as leaf and/or support leaf-2-leaf procedures) and it will fully
   configure itself after being attached to the topology.  Configured
   nodes and nodes operating in ZTP can be mixed and will form a valid
   topology if achievable.

   The derivation of the level of each node happens based on offers
   received from its neighbors whereas each node (with possibly
   exceptions of configured leafs) tries to attach at the highest
   possible point in the fabric.  This guarantees that even if the
   diffusion front reaches a node from "below" faster than from "above",
   it will greedily abandon already negotiated level derived from nodes
   topologically below it and properly peers with nodes above.

   The fabric is very conciously numbered from the top to allow for PoDs
   of different heights and minimize number of provisioning necessary,
   in this case just a TOP_OF_FABRIC flag.

   This section describes the necessary concepts and procedures for ZTP
   operation.






The RIFT Authors         Expires April 22, 2019                [Page 53]

Internet-Draft                    RIFT                      October 2018


5.2.7.1.  Terminology

   The interdependencies between the different flags and the configured
   level can be somewhat vexing at first and it may take multiple reads
   of the glossary to make sense.

   Automatic Level Derivation:  Procedures which allow nodes without
      level configured to derive it automatically.  Only applied if
      CONFIGURED_LEVEL is undefined.

   UNDEFINED_LEVEL:  An imaginary value that indicates that the level
      has not beeen determined and has not been configured.  Schemas
      normally indicate that by a missing optional value without an
      available defined default.

   LEAF_ONLY:  An optional configuration flag that can be configured on
      a node to make sure it never leaves the "bottom of the hierarchy".
      TOP_OF_FABRIC flag and CONFIGURED_LEVEL cannot be defined at the
      same time as this flag.  It implies CONFIGURED_LEVEL value of 0.

   TOP_OF_FABRIC flag:  Configuration flag provided to all Top-of-Fabric
      nodes.  LEAF_FLAG and CONFIGURED_LEVEL cannot be defined at the
      same time as this flag.  It implies a CONFIGURED_LEVEL value.  In
      fact, it is basically a shortcut for configuring same level at all
      Top-of-Fabric nodes which is unavoidable since an initial 'seed'
      is needed for other ZTP nodes to derive their level in the
      topology.  The flag plays an important role in fabrics with
      multiple planes to enable successful negative disaggregation
      (Section 5.2.5.2).

   CONFIGURED_LEVEL:  A level value provided manually.  When this is
      defined (i.e. it is not an UNDEFINED_LEVEL) the node is not
      participating in ZTP.  TOP_OF_FABRIC flag is ignored when this
      value is defined.  LEAF_ONLY can be set only if this value is
      undefined or set to 0.

   DERIVED_LEVEL:  Level value computed via automatic level derivation
      when CONFIGURED_LEVEL is equal to UNDEFINED_LEVEL.

   LEAF_2_LEAF:  An optional flag that can be configured on a node to
      make sure it supports procedures defined in Section 5.3.9.  In a
      strict sense it is a capability that implies LEAF_ONLY and the
      according restrictions.  TOP_OF_FABRIC flag is ignored when set at
      the same time as this flag.

   LEVEL_VALUE:  In ZTP case the original definition of "level" in
      Section 3.1 is both extended and relaxed.  First, level is defined
      now as LEVEL_VALUE and is the first defined value of



The RIFT Authors         Expires April 22, 2019                [Page 54]

Internet-Draft                    RIFT                      October 2018


      CONFIGURED_LEVEL followed by DERIVED_LEVEL.  Second, it is
      possible for nodes to be more than one level apart to form
      adjacencies if any of the nodes is at least LEAF_ONLY.

   Valid Offered Level (VOL):  A neighbor's level received on a valid
      LIE (i.e. passing all checks for adjacency formation while
      disregarding all clauses involving level values) persisting for
      the duration of the holdtime interval on the LIE.  Observe that
      offers from nodes offering level value of 0 do not constitute VOLs
      (since no valid DERIVED_LEVEL can be obtained from those and
      consequently `not_a_ztp_offer` MUST be ignored).  Offers from LIEs
      with `not_a_ztp_offer` being true are not VOLs either.  If a node
      maintains parallel adjacencies to the neighbor, VOL on each
      adjacency is considered as equivalent, i.e. the newest VOL from
      any such adjacency updates the VOL received from the same node.

   Highest Available Level (HAL):  Highest defined level value seen from
      all VOLs received.

   Highest Available Level Systems (HALS):  Set of nodes offering HAL
      VOLs.

   Highest Adjacency Three Way (HAT):  Highest neigbhor level of all the
      formed three way adjacencies for the node.

5.2.7.2.  Automatic SystemID Selection

   RIFT identifies each node via a SystemID which is a 64 bits wide
   integer.  It is relatively simple to derive a, for all practical
   purposes collision free, value for each node on startup.  For that
   purpose, a node MUST use as system ID EUI-64 MA-L format [EUI64]
   where the organizationally governed 24 bits can be used to generate
   system IDs for multiple RIFT instances running on the system.

   As matter of operational concern, the router MUST ensure that such
   identifier is not changing very frequently (or at least not without
   sending all its TIEs with fairly short lifetimes) since otherwise the
   network may be left with large amounts of stale TIEs in other nodes
   (though this is not necessarily a serious problem if the procedures
   described in Section 8 are implemented).

5.2.7.3.  Generic Fabric Example

   ZTP forces us to think about miscabled or unusually cabled fabric and
   how such a topology can be forced into a "lattice" structure which a
   fabric represents (with further restrictions).  Let us consider a
   necessary and sufficient physical cabling in Figure 19.  We assume
   all nodes being in the same PoD.



The RIFT Authors         Expires April 22, 2019                [Page 55]

Internet-Draft                    RIFT                      October 2018


          .        +---+
          .        | A |                      s   = TOP_OF_FABRIC
          .        | s |                      l   = LEAF_ONLY
          .        ++-++                      l2l = LEAF_2_LEAF
          .         | |
          .      +--+ +--+
          .      |       |
          .   +--++     ++--+
          .   | E |     | F |
          .   |   +-+   |   +-----------+
          .   ++--+ |   ++-++           |
          .    |    |    | |            |
          .    | +-------+ |            |
          .    | |  |      |            |
          .    | |  +----+ |            |
          .    | |       | |            |
          .   ++-++     ++-++           |
          .   | I +-----+ J |           |
          .   |   |     |   +-+         |
          .   ++-++     +--++ |         |
          .    | |         |  |         |
          .    +---------+ |  +------+  |
          .      |       | |         |  |
          .      +-----------------+ |  |
          .              | |       | |  |
          .             ++-++     ++-++ |
          .             | X +-----+ Y +-+
          .             |l2l|     | l |
          .             +---+     +---+


               Figure 19: Generic ZTP Cabling Considerations

   First, we must anchor the "top" of the cabling and that's what the
   TOP_OF_FABRIC flag at node A is for.  Then things look smooth until
   we have to decide whether node Y is at the same level as I, J or at
   the same level as Y and consequently, X is south of it.  This is
   unresolvable here until we "nail down the bottom" of the topology.
   To achieve that we choose to use in this example the leaf flags.  We
   will see further then whether Y chooses to form adjacencies to F or
   I, J successively.

5.2.7.4.  Level Determination Procedure

   A node starting up with UNDEFINED_VALUE (i.e. without a
   CONFIGURED_LEVEL or any leaf or TOP_OF_FABRIC flag) MUST follow those
   additional procedures:




The RIFT Authors         Expires April 22, 2019                [Page 56]

Internet-Draft                    RIFT                      October 2018


   1.  It advertises its LEVEL_VALUE on all LIEs (observe that this can
       be UNDEFINED_LEVEL which in terms of the schema is simply an
       omitted optional value).

   2.  It computes HAL as numerically highest available level in all
       VOLs.

   3.  It chooses then MAX(HAL-1,0) as its DERIVED_LEVEL.  The node then
       starts to advertise this derived level.

   4.  A node that lost all adjacencies with HAL value MUST hold down
       computation of new DERIVED_LEVEL for a short period of time
       unless it has no VOLs from southbound adjacencies.  After the
       holddown expired, it MUST discard all received offers, recompute
       DERIVED_LEVEL and announce it to all neighbors.

   5.  A node MUST reset any adjacency that has changed the level it is
       offering and is in three way state.

   6.  A node that changed its defined level value MUST readvertise its
       own TIEs (since the new `PacketHeader` will contain a different
       level than before).  Sequence number of each TIE MUST be
       increased.

   7.  After a level has been derived the node MUST set the
       `not_a_ztp_offer` on LIEs towards all systems extending a VOL for
       HAL.

   A node starting with LEVEL_VALUE being 0 (i.e. it assumes a leaf
   function by being configured with the appropriate flags or has a
   CONFIGURED_LEVEL of 0) MUST follow those additional procedures:

   1.  It computes HAT per procedures above but does NOT use it to
       compute DERIVED_LEVEL.  HAT is used to limit adjacency formation
       per Section 5.2.2.

   It MAY also follow modified procedures:

   1.  It may pick a different strategy to choose VOL, e.g.  use the VOL
       value with highest number of VOLs.  Such strategies are only
       possible since the node always remains "at the bottom of the
       fabric" while another layer could "invert" the fabric by picking
       its prefered VOL in a different fashion than always trying to
       achieve the highest viable level.







The RIFT Authors         Expires April 22, 2019                [Page 57]

Internet-Draft                    RIFT                      October 2018


5.2.7.5.  Resulting Topologies

   The procedures defined in Section 5.2.7.4 will lead to the RIFT
   topology and levels depicted in Figure 20.

                      .        +---+
                      .        | As|
                      .        | 24|
                      .        ++-++
                      .         | |
                      .      +--+ +--+
                      .      |       |
                      .   +--++     ++--+
                      .   | E |     | F |
                      .   | 23+-+   | 23+-----------+
                      .   ++--+ |   ++-++           |
                      .    |    |    | |            |
                      .    | +-------+ |            |
                      .    | |  |      |            |
                      .    | |  +----+ |            |
                      .    | |       | |            |
                      .   ++-++     ++-++           |
                      .   | I +-----+ J |           |
                      .   | 22|     | 22|           |
                      .   ++--+     +--++           |
                      .    |           |            |
                      .    +---------+ |            |
                      .              | |            |
                      .             ++-++     +---+ |
                      .             | X |     | Y +-+
                      .             | 0 |     | 0 |
                      .             +---+     +---+


              Figure 20: Generic ZTP Topology Autoconfigured

   In case we imagine the LEAF_ONLY restriction on Y is removed the
   outcome would be very different however and result in Figure 21.
   This demonstrates basically that auto configuration makes miscabling
   detection hard and with that can lead to undesirable effects in cases
   where leafs are not "nailed" by the accordingly configured flags and
   arbitrarily cabled.

   A node MAY analyze the outstanding level offers on its interfaces and
   generate warnings when its internal ruleset flags a possible
   miscabling.  As an example, when a node's sees ZTP level offers that
   differ by more than one level from its chosen level (with proper
   accounting for leaf's being at level 0) this can indicate miscabling.



The RIFT Authors         Expires April 22, 2019                [Page 58]

Internet-Draft                    RIFT                      October 2018


                       .        +---+
                       .        | As|
                       .        | 24|
                       .        ++-++
                       .         | |
                       .      +--+ +--+
                       .      |       |
                       .   +--++     ++--+
                       .   | E |     | F |
                       .   | 23+-+   | 23+-------+
                       .   ++--+ |   ++-++       |
                       .    |    |    | |        |
                       .    | +-------+ |        |
                       .    | |  |      |        |
                       .    | |  +----+ |        |
                       .    | |       | |        |
                       .   ++-++     ++-++     +-+-+
                       .   | I +-----+ J +-----+ Y |
                       .   | 22|     | 22|     | 22|
                       .   ++-++     +--++     ++-++
                       .    | |         |       | |
                       .    | +-----------------+ |
                       .    |           |         |
                       .    +---------+ |         |
                       .              | |         |
                       .             ++-++        |
                       .             | X +--------+
                       .             | 0 |
                       .             +---+



              Figure 21: Generic ZTP Topology Autoconfigured

5.2.8.  Stability Considerations

   The autoconfiguration mechanism computes a global maximum of levels
   by diffusion.  The achieved equilibrium can be disturbed massively by
   all nodes with highest level either leaving or entering the domain
   (with some finer distinctions not explained further).  It is
   therefore recommended that each node is multi-homed towards nodes
   with respective HAL offerings.  Fortuntately, this is the natural
   state of things for the topology variants considered in RIFT.








The RIFT Authors         Expires April 22, 2019                [Page 59]

Internet-Draft                    RIFT                      October 2018


5.3.  Further Mechanisms

5.3.1.  Overload Bit

   Overload Bit MUST be respected in all according reachability
   computations.  A node with overload bit set SHOULD NOT advertise any
   reachability prefixes southbound except locally hosted ones.  A node
   in overload SHOULD advertise all its locally hosted prefixes north
   and southbound.

   The leaf node SHOULD set the 'overload' bit on its node TIEs, since
   if the spine nodes were to forward traffic not meant for the local
   node, the leaf node does not have the topology information to prevent
   a routing/forwarding loop.

5.3.2.  Optimized Route Computation on Leafs

   Since the leafs do see only "one hop away" they do not need to run a
   full SPF but can simply gather prefix candidates from their neighbors
   and build the according routing table.

   A leaf will have no N-TIEs except its own and optionally from its
   East-West neighbors.  A leaf will have S-TIEs from its neighbors.

   Instead of creating a network graph from its N-TIEs and neighbor's
   S-TIEs and then running an SPF, a leaf node can simply compute the
   minimum cost and next_hop_set to each leaf neighbor by examining its
   local adjacencies, determining bi-directionality from the associated
   N-TIE, and specifying the neighbor's next_hop_set set and cost from
   the minimum cost local adjacency to that neighbor.

   Then a leaf attaches prefixes as in Section 5.2.6.

5.3.3.  Mobility

   It is a requirement for RIFT to maintain at the control plane a real
   time status of which prefix is attached to which port of which leaf,
   even in a context of mobility where the point of attachement may
   change several times in a subsecond period of time.

   There are two classical approaches to maintain such knowledge in an
   unambiguous fashion:

   time stamp:  With this method, the infrastructure memorizes the
      precise time at which the movement is observed.  One key advantage
      of this technique is that it has no dependency on the mobile
      device.  One drawback is that the infrastructure must be precisely
      synchronized to be able to compare time stamps as observed by the



The RIFT Authors         Expires April 22, 2019                [Page 60]

Internet-Draft                    RIFT                      October 2018


      various points of attachment, e.g., using the variation of the
      Precision Time Protocol (PTP) IEEE Std. 1588 [IEEEstd1588],
      [IEEEstd8021AS] designed for bridged LANs IEEE Std. 802.1AS
      [IEEEstd8021AS].  Both the precision of the synchronisation
      protocol and the resolution of the time stamp must beat the
      highest possible roaming time on the fabric.  Another drawback is
      that the presence of the mobile device may be observed only
      asynchronously, e.g., after it starts using an IP protocol such as
      ARP [RFC0826], IPv6 Neighbor Discovery [RFC4861][RFC4862], or DHCP
      [RFC2131][RFC3315].

   sequence counter:  With this method, a mobile node notifies its point
      of attachment on arrival with a sequence counter that is
      incremented upon each movement.  On the positive side, this method
      does not have a dependency on a precise sense of time, since the
      sequence of movements is kept in order by the device.  The
      disadvantage of this approach is the lack of support for protocols
      that may be used by the mobile node to register its presence to
      the leaf node with the capability to provide a sequence counter.
      Well-known issues with wrapping sequence counters must be
      addressed properly, and many forms of sequence counters that vary
      in both wrapping rules and comparison rules.  A particular
      knowledge of the source of the sequence counter is required to
      operate it, and the comparison between sequence counters from
      heterogeneous sources can be hard to impossible.

   RIFT supports a hybrid approach contained in an optional
   `PrefixSequenceType` prefix attribute that we call a `monotonic
   clock` consisting of a timestamp and optional sequence number.  In
   case of presence of the attribute:

   o  The leaf node MUST advertise a time stamp of the latest sighting
      of a prefix, e.g., by snooping IP protocols or the node using the
      time at which it advertised the prefix.  RIFT transports the time
      stamp within the desired prefix N-TIEs as 802.1AS timestamp.

   o  RIFT may interoperate with the "update to 6LoWPAN Neighbor
      Discovery" [I-D.ietf-6lo-rfc6775-update], which provides a method
      for registering a prefix with a sequence counter called a
      Transaction ID (TID).  RIFT transports in such case the TID in its
      native form.

   o  RIFT also defines an abstract negative clock (ANSC) that compares
      as less than any other clock.  By default, the lack of a
      `PrefixSequenceType` in a Prefix N-TIE is interpreted as ANSC.  We
      call this also an `undefined` clock.





The RIFT Authors         Expires April 22, 2019                [Page 61]

Internet-Draft                    RIFT                      October 2018


   o  Any prefix present on the fabric in multiple nodes that has the
      `same` clock is considered as anycast.  ASNC is always considered
      smaller than any defined clock.

   o  RIFT implementation assumes by default that all nodes are being
      synchronized to 200 milliseconds precision which is easily
      achievable even in very large fabrics using [RFC5905].  An
      implementation MAY provide a way to reconfigure a domain to a
      different value.  We call this variable MAXIMUM_CLOCK_DELTA.

5.3.3.1.  Clock Comparison

   All monotonic clock values are comparable to each other using the
   following rules:

   1.  ASNC is older than any other value except ASNC AND

   2.  Clock with timestamp differing by more than MAXIMUM_CLOCK_DELTA
       are comparable by using the timestamps only AND

   3.  Clocks with timestamps differing by less than MAXIMUM_CLOCK_DELTA
       are comparable by using their TIDs only AND

   4.  An undefined TID is always older than any other TID AND

   5.  TIDs are compared using rules of [I-D.ietf-6lo-rfc6775-update].

5.3.3.2.  Interaction between Time Stamps and Sequence Counters

   For slow movements that occur less frequently than e.g. once per
   second, the time stamp that the RIFT infrastruture captures is enough
   to determine the freshest discovery.  If the point of attachement
   changes faster than the maximum drift of the time stamping mechanism
   (i.e.  MAXIMUM_CLOCK_DELTA), then a sequence counter is required to
   add resolution to the freshness evaluation, and it must be sized so
   that the counters stay comparable within the resolution of the time
   stampling mechanism.

   The sequence counter in [I-D.ietf-6lo-rfc6775-update] is encoded as
   one octet, wraps after 127 increments, and, by default, values are
   defined as comparable as long as they are less than SEQUENCE_WINDOW =
   16 apart.  An implementation MAY allow this to be configurable
   throughout the domain, and the number can be pushed up to 64 and
   still preserve the capability to discover an error situation where
   counters are not comparable.

   Within the resolution of MAXIMUM_CLOCK_DELTA the sequence counters
   captured during 2 sequential values of the time stamp must be



The RIFT Authors         Expires April 22, 2019                [Page 62]

Internet-Draft                    RIFT                      October 2018


   comparable.  This means with default values that a node may move up
   to 16 times during a 200 milliseconds period and the clocks remain
   still comparable thus allowing the infrastructure to assert the
   freshest advertisement with no ambiguity.

5.3.3.3.  Anycast vs. Unicast

   A unicast prefix can be attached to at most one leaf, whereas an
   anycast prefix may be reachable via more than one leaf.

   If a monotonic clock attribute is provided on the prefix, then the
   prefix with the `newest` clock value is strictly prefered.  An
   anycast prefix does not carry a clock or all clock attributes MUST be
   the same under the rules of Section 5.3.3.1.

   Observe that it is important that in mobility events the leaf is re-
   flooding as quickly as possible the absence of the prefix that moved
   away.

   Observe further that without support for
   [I-D.ietf-6lo-rfc6775-update] movements on the fabric within
   intervals smaller than 100msec will be seen as anycast.

5.3.3.4.  Overlays and Signaling

   RIFT is agnostic whichever the overlay technology [MIP, LISP, VxLAN,
   NVO3] and the associated signaling is deployed over it.  But it is
   expected that leaf nodes, and possibly Top-of-Fabric nodes can
   perform the according encapsulation.

   In the context of mobility, overlays provide a classical solution to
   avoid injecting mobile prefixes in the fabric and improve the
   scalability of the solution.  It makes sense on a data center that
   already uses overlays to consider their applicability to the mobility
   solution; as an example, a mobility protocol such as LISP may inform
   the ingress leaf of the location of the egress leaf in real time.

   Another possibility is to consider that mobility as an underlay
   service and support it in RIFT to an extent.  The load on the fabric
   augments with the amount of mobility obviously since a move forces
   flooding and computation on all nodes in the scope of the move so
   tunneling from leaf to the Top-of-Fabric may be desired.  Future
   versions of this document may describe support for such tunneling in
   RIFT.







The RIFT Authors         Expires April 22, 2019                [Page 63]

Internet-Draft                    RIFT                      October 2018


5.3.4.  Key/Value Store

5.3.4.1.  Southbound

   The protocol supports a southbound distribution of key-value pairs
   that can be used to e.g. distribute configuration information during
   topology bring-up.  The KV S-TIEs can arrive from multiple nodes and
   hence need tie-breaking per key.  We use the following rules

   1.  Only KV TIEs originated by a node to which the receiver has an
       adjacency are considered.

   2.  Within all valid KV S-TIEs containing the key, the value of the
       KV S-TIE for which the according node S-TIE is present, has the
       highest level and within the same level has highest originating
       system ID is preferred.  If keys in the most preferred TIEs are
       overlapping, the behavior is undefined.

   Observe that if a node goes down, the node south of it looses
   adjacencies to it and with that the KVs will be disregarded and on
   tie-break changes new KV re-advertised to prevent stale information
   being used by nodes further south.  KV information in southbound
   direction is not result of independent computation of every node but
   a diffused computation.

5.3.4.2.  Northbound

   Certain use cases seem to necessitate distribution of essentialy KV
   information that is generated in the leafs in the northbound
   direction.  Such information is flooded in KV N-TIEs.  Since the
   originator of northbound KV is preserved during northbound flooding,
   overlapping keys could be used.  However, to omit further protocol
   complexity, only the value of the key in TIE tie-broken in same
   fashion as southbound KV TIEs is used.

5.3.5.  Interactions with BFD

   RIFT MAY incorporate BFD [RFC5881] to react quickly to link failures.
   In such case following procedures are introduced:

      After RIFT three way hello adjacency convergence a BFD session MAY
      be formed automatically between the RIFT endpoints without further
      configuration using the exchanged discriminators.

      In case established BFD session goes Down after it was Up, RIFT
      adjacency should be re-initialized started from Init.





The RIFT Authors         Expires April 22, 2019                [Page 64]

Internet-Draft                    RIFT                      October 2018


      In case of parallel links between nodes each link may run its own
      independent BFD session or they may share a session.

      In case RIFT changes link identifiers both the hello as well as
      the BFD sessions SHOULD be brought down and back up again.

      Multiple RIFT instances MAY choose to share a single BFD session
      (in such case it is undefined what discriminators are used albeit
      RIFT CAN advertise the same link ID for the same interface in
      multiple instances and with that "share" the discriminators).

      BFD TTL follows [RFC5082].

5.3.6.  Fabric Bandwidth Balancing

   A well understood problem in fabrics is that in case of link losses
   it would be ideal to rebalance how much traffic is offered to
   switches in the next level based on the ingress and egress bandwidth
   they have.  Current attempts rely mostly on specialized traffic
   engineering via controller or leafs being aware of complete topology
   with according cost and complexity.

   RIFT can support a very light weight mechanism that can deal with the
   problem in an approximative way based on the fact that RIFT is loop-
   free.

5.3.6.1.  Northbound Direction

   Every RIFT node SHOULD compute the amount of northbound bandwith
   available through neighbors at higher level and modify distance
   received on default route from this neighbor.  Those different
   distances SHOULD be used to support weighted ECMP forwarding towards
   higher level when using default route.  We call such a distance
   Bandwidth Adjusted Distance or BAD.  This is best illustrated by a
   simple example.
















The RIFT Authors         Expires April 22, 2019                [Page 65]

Internet-Draft                    RIFT                      October 2018


                             .   100  x             100 100 MBits
                             .    |   x              |   |
                             .  +-+---+-+          +-+---+-+
                             .  |       |          |       |
                             .  |Spin111|          |Spin112|
                             .  +-+---+++          ++----+++
                             .    |x  ||           ||    ||
                             .    ||  |+---------------+ ||
                             .    ||  +---------------+| ||
                             .    ||               || || ||
                             .    ||               || || ||
                             .   -----All Links 10 MBit-------
                             .    ||               || || ||
                             .    ||               || || ||
                             .    ||  +------------+| || ||
                             .    ||  |+------------+ || ||
                             .    |x  ||              || ||
                             .  +-+---+++          +--++-+++
                             .  |       |          |       |
                             .  |Leaf111|          |Leaf112|
                             .  +-------+          +-------+



                      Figure 22: Balancing Bandwidth

   All links from Leafs in Figure 22 are assumed to 10 MBit/s bandwidth
   while the uplinks one level further up are assumed to be 100 MBit/s.
   Further, in Figure 22 we assume that Leaf111 lost one of the parallel
   links to Spine 111 and with that wants to possibly push more traffic
   onto Spine 112.  Leaf 112 has equal bandwidth to Spine 111 and Spine
   112 but Spine 111 lost one of its uplinks.

   The local modification of the received default route distance from
   upper level is achieved by running a relatively simple algorithm
   where the bandwidth is weighted exponentially while the distance on
   the default route represents a multiplier for the bandwidth weight
   for easy operational adjustements.

   On a node L use Node TIEs to compute for each non-overloaded
   northbound neighbor N three values:

      L_N_u: as sum of the bandwidth available to N

      N_u: as sum of the uplink bandwidth available on N

      T_N_u: as sum of L_N_u * OVERSUBSCRIPTION_CONSTANT + N_u




The RIFT Authors         Expires April 22, 2019                [Page 66]

Internet-Draft                    RIFT                      October 2018


   For all T_N_u determine the according M_N_u as
   log_2(next_power_2(T_N_u)) and determine MAX_M_N_u as maximum value
   of all M_N_u.

   For each advertised default route from a node N modify the advertised
   distance D to BAD = D * (1 + MAX_M_N_u - M_N_u) and use BAD instead
   of distance D to weight balance default forwarding towards N.

   For the example above a simple table of values will help the
   understanding.  We assume the default route distance is advertised
   with D=1 everywhere and OVERSUBSCRIPTION_CONSTANT = 1.

               +---------+-----------+-------+-------+-----+
               | Node    | N         | T_N_u | M_N_u | BAD |
               +---------+-----------+-------+-------+-----+
               | Leaf111 | Spine 111 | 110   | 7     | 2   |
               +---------+-----------+-------+-------+-----+
               | Leaf111 | Spine 112 | 220   | 8     | 1   |
               +---------+-----------+-------+-------+-----+
               | Leaf112 | Spine 111 | 120   | 7     | 2   |
               +---------+-----------+-------+-------+-----+
               | Leaf112 | Spine 112 | 220   | 8     | 1   |
               +---------+-----------+-------+-------+-----+

                         Table 5: BAD Computation

   All the multiplications and additions are saturating, i.e. when
   exceeding range of the bandwidth type are set to highest possible
   value of the type.

   BAD is only computed for default routes.  A node MAY compute and use
   BAD for any disaggregated prefixes or other RIFT routes.

   Observe further that a change in available bandwidth will only affect
   at maximum two levels down in the fabric, i.e. blast radius of
   bandwidth changes is contained no matter its height.

5.3.6.2.  Southbound Direction

   Due to its loop free properties a node could take during S-SPF into
   account the available bandwidth on the nodes in lower levels and
   modify the amount of traffic offered to next level's "southbound"
   nodes based as what it sees is the total achievable maximum flow
   through those nodes.  It is worth observing that such computations
   will work better if standardized but does not have to be necessarily.
   As long the packet keeps on heading south it will take one of the
   available paths and arrive at the intended destination.




The RIFT Authors         Expires April 22, 2019                [Page 67]

Internet-Draft                    RIFT                      October 2018


   Future versions of this document will fill in more details.

5.3.7.  Label Binding

   A node MAY advertise on its TIEs a locally significant, downstream
   assigned label for the according interface.  One use of such label is
   a hop-by-hop encapsulation allowing to easily distinguish forwarding
   planes served by a multiplicity of RIFT instances.

5.3.8.  Segment Routing Support with RIFT

   Recently, alternative architecture to reuse labels as segment
   identifiers [I-D.ietf-spring-segment-routing] has gained traction and
   may present use cases in IP fabric that would justify its deployment.
   Such use cases will either precondition an assignment of a label per
   node (or other entities where the mechanisms are equivalent) or a
   global assignment and a knowledge of topology everywhere to compute
   segment stacks of interest.  We deal with the two issues separately.

5.3.8.1.  Global Segment Identifiers Assignment

   Global segment identifiers are normally assumed to be provided by
   some kind of a centralized "controller" instance and distributed to
   other entities.  This can be performed in RIFT by attaching a
   controller to the Top-of-Fabric nodes at the top of the fabric where
   the whole topology is always visible, assign such identifiers and
   then distribute those via the KV mechanism towards all nodes so they
   can perform things like probing the fabric for failures using a stack
   of segments.

5.3.8.2.  Distribution of Topology Information

   Some segment routing use cases seem to precondition full knowledge of
   fabric topology in all nodes which can be performed albeit at the
   loss of one of highly desirable properties of RIFT, namely minimal
   blast radius.  Basically, RIFT can function as a flat IGP by
   switching off its flooding scopes.  All nodes will end up with full
   topology view and albeit the N-SPF and S-SPF are still performed
   based on RIFT rules, any computation with segment identifiers that
   needs full topology can use it.

   Beside blast radius problem, excessive flooding may present
   significant load on implementations.








The RIFT Authors         Expires April 22, 2019                [Page 68]

Internet-Draft                    RIFT                      October 2018


5.3.9.  Leaf to Leaf Procedures

   RIFT can optionally allow special leaf East-West adjacencies under
   additional set of rules.  The leaf supporting those procedures MUST:

      advertise the LEAF_2_LEAF flag in node capabilities AND

      set the overload bit on all leaf's node TIEs AND

      flood only node's own north and south TIEs over E-W leaf
      adjacencies AND

      always use E-W leaf adjacency in both north as well as south
      computation AND

      install a discard route for any advertised aggregate in leaf's
      TIEs AND

      never form southbound adjacencies.

   This will allow the E-W leaf nodes to exchange traffic strictly for
   the prefixes advertised in each other's north prefix TIEs (since the
   southbound computation will find the reverse direction in the other
   node's TIE and install its north prefixes).

5.3.10.  Address Family and Multi Topology Considerations

   Multi-Topology (MT)[RFC5120] and Multi-Instance (MI)[RFC6822] is used
   today in link-state routing protocols to support several domains on
   the same physical topology.  RIFT supports this capability by
   carrying transport ports in the LIE protocol exchanges.  Multiplexing
   of LIEs can be achieved by either choosing varying multicast
   addresses or ports on the same address.

   BFD interactions in Section 5.3.5 are implementation dependent when
   multiple RIFT instances run on the same link.

5.3.11.  Reachability of Internal Nodes in the Fabric

   RIFT does not precondition that its nodes have reachable addresses
   albeit for operational purposes this is clearly desirable.  Under
   normal operating conditions this can be easily achieved by e.g.
   injecting the node's loopback address into North Prefix TIEs.

   Things get more interesting in case a node looses all its northbound
   adjacencies but is not at the top of the fabric.  That is outside the
   scope of this document and may be covered in a separate document
   about policy guided prefixes [PGP reference].



The RIFT Authors         Expires April 22, 2019                [Page 69]

Internet-Draft                    RIFT                      October 2018


5.3.12.  One-Hop Healing of Levels with East-West Links

   Based on the rules defined in Section 5.2.4, Section 5.2.3.7 and
   given presence of E-W links, RIFT can provide a one-hop protection of
   nodes that lost all their northbound links or in other complex link
   set failure scenarios except at Top-of-Fabric where the links are
   used exclusively to flood topology information in multi-plane
   designs.  Section 6.4 explains the resulting behavior based on one
   such example.

6.  Examples

6.1.  Normal Operation

   This section describes RIFT deployment in the example topology
   without any node or link failures.  We disregard flooding reduction
   for simplicity's sake.

   As first step, the following bi-directional adjacencies will be
   created (and any other links that do not fulfill LIE rules in
   Section 5.2.2 disregarded):

   1.  Spine 21 (PoD 0) to Spine 111, Spine 112, Spine 121, and Spine
       122

   2.  Spine 22 (PoD 0) to Spine 111, Spine 112, Spine 121, and Spine
       122

   3.  Spine 111 to Leaf 111, Leaf 112

   4.  Spine 112 to Leaf 111, Leaf 112

   5.  Spine 121 to Leaf 121, Leaf 122

   6.  Spine 122 to Leaf 121, Leaf 122

   Consequently, N-TIEs would be originated by Spine 111 and Spine 112
   and each set would be sent to both Spine 21 and Spine 22.  N-TIEs
   also would be originated by Leaf 111 (w/ Prefix 111) and Leaf 112 (w/
   Prefix 112 and the multi-homed prefix) and each set would be sent to
   Spine 111 and Spine 112.  Spine 111 and Spine 112 would then flood
   these N-TIEs to Spine 21 and Spine 22.

   Similarly, N-TIEs would be originated by Spine 121 and Spine 122 and
   each set would be sent to both Spine 21 and Spine 22.  N-TIEs also
   would be originated by Leaf 121 (w/ Prefix 121 and the multi-homed
   prefix) and Leaf 122 (w/ Prefix 122) and each set would be sent to




The RIFT Authors         Expires April 22, 2019                [Page 70]

Internet-Draft                    RIFT                      October 2018


   Spine 121 and Spine 122.  Spine 121 and Spine 122 would then flood
   these N-TIEs to Spine 21 and Spine 22.

   At this point both Spine 21 and Spine 22, as well as any controller
   to which they are connected, would have the complete network
   topology.  At the same time, Spine 111/112/121/122 hold only the
   N-ties of level 0 of their respective PoD.  Leafs hold only their own
   N-TIEs.

   S-TIEs with adjacencies and a default IP prefix would then be
   originated by Spine 21 and Spine 22 and each would be flooded to
   Spine 111, Spine 112, Spine 121, and Spine 122.  Spine 111, Spine
   112, Spine 121, and Spine 122 would each send the S-TIE from Spine 21
   to Spine 22 and the S-TIE from Spine 22 to Spine 21.  (S-TIEs are
   reflected up to level from which they are received but they are NOT
   propagated southbound.)

   A S-TIE with a default IP prefix would be originated by Node 111 and
   Spine 112 and each would be sent to Leaf 111 and Leaf 112.

   Similarly, an S-TIE with a default IP prefix would be originated by
   Node 121 and Spine 122 and each would be sent to Leaf 121 and Leaf
   122.  At this point IP connectivity with maximum possible ECMP has
   been established between the leafs while constraining the amount of
   information held by each node to the minimum necessary for normal
   operation and dealing with failures.

6.2.  Leaf Link Failure

                    .  |   |              |   |
                    .+-+---+-+          +-+---+-+
                    .|       |          |       |
                    .|Spin111|          |Spin112|
                    .+-+---+-+          ++----+-+
                    .  |   |             |    |
                    .  |   +---------------+  X
                    .  |                 | |  X Failure
                    .  |   +-------------+ |  X
                    .  |   |               |  |
                    .+-+---+-+          +--+--+-+
                    .|       |          |       |
                    .|Leaf111|          |Leaf112|
                    .+-------+          +-------+
                    .      +                  +
                    .     Prefix111     Prefix112


                    Figure 23: Single Leaf link failure



The RIFT Authors         Expires April 22, 2019                [Page 71]

Internet-Draft                    RIFT                      October 2018


   In case of a failing leaf link between spine 112 and leaf 112 the
   link-state information will cause re-computation of the necessary SPF
   and the higher levels will stop forwarding towards prefix 112 through
   spine 112.  Only spines 111 and 112, as well as both spines will see
   control traffic.  Leaf 111 will receive a new S-TIE from spine 112
   and reflect back to spine 111.  Spine 111 will de-aggregate prefix
   111 and prefix 112 but we will not describe it further here since de-
   aggregation is emphasized in the next example.  It is worth observing
   however in this example that if leaf 111 would keep on forwarding
   traffic towards prefix 112 using the advertised south-bound default
   of spine 112 the traffic would end up on Top-of-Fabric 21 and ToF 22
   and cross back into pod 1 using spine 111.  This is arguably not as
   bad as black-holing present in the next example but clearly
   undesirable.  Fortunately, de-aggregation prevents this type of
   behavior except for a transitory period of time.

6.3.  Partitioned Fabric


































The RIFT Authors         Expires April 22, 2019                [Page 72]

Internet-Draft                    RIFT                      October 2018


   .                +--------+          +--------+   S-TIE of Spine21
   .                |        |          |        |   received by
   .                |ToF   21|          |ToF   22|   south reflection of
   .                ++-+--+-++          ++-+--+-++   spines 112 and 111
   .                 | |  | |            | |  | |
   .                 | |  | |            | |  | 0/0
   .                 | |  | |            | |  | |
   .                 | |  | |            | |  | |
   .  +--------------+ |  +--- XXXXXX +  | |  | +---------------+
   .  |                |    |         |  | |  |                 |
   .  |    +-----------------------------+ |  |                 |
   .  0/0  |           |    |         |    |  |                 |
   .  |    0/0       0/0    +- XXXXXXXXXXXXXXXXXXXXXXXXX -+     |
   .  |  1.1/16        |              |    |  |           |     |
   .  |    |           +-+    +-0/0-----------+           |     |
   .  |    |             |   1.1./16  |    |              |     |
   .+-+----++          +-+-----+     ++-----0/0          ++----0/0
   .|       |          |       |     |    1.1/16         |   1.1/16
   .|Spin111|          |Spin112|     |Spin121|           |Spin122|
   .+-+---+-+          ++----+-+     +-+---+-+           ++---+--+
   .  |   |             |    |         |   |              |   |
   .  |   +---------------+  |         |   +----------------+ |
   .  |                 | |  |         |                  | | |
   .  |   +-------------+ |  |         |   +--------------+ | |
   .  |   |               |  |         |   |                | |
   .+-+---+-+          +--+--+-+     +-+---+-+          +---+-+-+
   .|       |          |       |     |       |          |       |
   .|Leaf111|          |Leaf112|     |Leaf121|          |Leaf122|
   .+-+-----+          ++------+     +-----+-+          +-+-----+
   .  +                 +                  +              +
   .  Prefix111    Prefix112             Prefix121     Prefix122
   .                                       1.1/16


                        Figure 24: Fabric partition

   Figure 24 shows the arguably most catastrophic but also the most
   interesting case.  Spine 21 is completely severed from access to
   Prefix 121 (we use in the figure 1.1/16 as example) by double link
   failure.  However unlikely, if left unresolved, forwarding from leaf
   111 and leaf 112 to prefix 121 would suffer 50% black-holing based on
   pure default route advertisements by Top-of-Fabric 21 and ToF 22.

   The mechanism used to resolve this scenario is hinging on the
   distribution of southbound representation by Top-of-Fabric 21 that is
   reflected by spine 111 and spine 112 to ToF 22.  Spine 22, having
   computed reachability to all prefixes in the network, advertises with
   the default route the ones that are reachable only via lower level



The RIFT Authors         Expires April 22, 2019                [Page 73]

Internet-Draft                    RIFT                      October 2018


   neighbors that ToF 21 does not show an adjacency to.  That results in
   spine 111 and spine 112 obtaining a longest-prefix match to prefix
   121 which leads through ToF 22 and prevents black-holing through ToF
   21 still advertising the 0/0 aggregate only.

   The prefix 121 advertised by Top-of-Fabric 22 does not have to be
   propagated further towards leafs since they do no benefit from this
   information.  Hence the amount of flooding is restricted to ToF 21
   reissuing its S-TIEs and south reflection of those by spine 111 and
   spine 112.  The resulting SPF in ToF 22 issues a new prefix S-TIEs
   containing 1.1/16.  None of the leafs become aware of the changes and
   the failure is constrained strictly to the level that became
   partitioned.

   To finish with an example of the resulting sets computed using
   notation introduced in Section 5.2.5, Top-of-Fabric 22 constructs the
   following sets:

      |R = Prefix 111, Prefix 112, Prefix 121, Prefix 122

      |H (for r=Prefix 111) = Spine 111, Spine 112

      |H (for r=Prefix 112) = Spine 111, Spine 112

      |H (for r=Prefix 121) = Spine 121, Spine 122

      |H (for r=Prefix 122) = Spine 121, Spine 122

      |A (for Spine 21) = Spine 111, Spine 112

   With that and |H (for r=prefix 121) and |H (for r=prefix 122) being
   disjoint from |A (for Top-of-Fabric 21), ToF 22 will originate an
   S-TIE with prefix 121 and prefix 122, that is flooded to spines 112,
   112, 121 and 122.

6.4.  Northbound Partitioned Router and Optional East-West Links















The RIFT Authors         Expires April 22, 2019                [Page 74]

Internet-Draft                    RIFT                      October 2018


         .   +                  +                  +
         .   X N1               | N2               | N3
         .   X                  |                  |
         .+--+----+          +--+----+          +--+-----+
         .|       |0/0>  <0/0|       |0/0>  <0/0|        |
         .|  A01  +----------+  A02  +----------+  A03   | Level 1
         .++-+-+--+          ++--+--++          +---+-+-++
         . | | |              |  |  |               | | |
         . | | +----------------------------------+ | | |
         . | |                |  |  |             | | | |
         . | +-------------+  |  |  |  +--------------+ |
         . |               |  |  |  |  |          | |   |
         . | +----------------+  |  +-----------------+ |
         . | |             |     |     |          | | | |
         . | | +------------------------------------+ | |
         . | | |           |     |     |          |   | |
         .++-+-+--+        | +---+---+ |        +-+---+-++
         .|       |        +-+       +-+        |        |
         .|  L01  |          |  L02  |          |  L03   | Level 0
         .+-------+          +-------+          +--------+


                    Figure 25: North Partitioned Router

   Figure 25 shows a part of a fabric where level 1 is horizontally
   connected and A01 lost its only northbound adjacency.  Based on N-SPF
   rules in Section 5.2.4.1 A01 will compute northbound reachability by
   using the link A01 to A02 (whereas A02 will NOT use this link during
   N-SPF).  Hence A01 will still advertise the default towards level 0
   and route unidirectionally using the horizontal link.

   As further consideration, the moment A02 looses link N2 the situation
   evolves again.  A01 will have no more northbound reachability while
   still seeing A03 advertising northbound adjacencies in its south node
   tie.  With that it will stop advertising a default route due to
   Section 5.2.3.7.

6.5.  Multi-Plane Fabric and Negative Disaggregation

   TODO

7.  Implementation and Operation: Further Details

7.1.  Considerations for Leaf-Only Implementation

   Ideally RIFT can be stretched out to the loWest level in the IP
   fabric to integrate ToRs or even servers.  Since those entities would




The RIFT Authors         Expires April 22, 2019                [Page 75]

Internet-Draft                    RIFT                      October 2018


   run as leafs only, it is worth to observe that a leaf only version is
   significantly simpler to implement and requires much less resources:

   1.  Under normal conditions, the leaf needs to support a multipath
       default route only.  In worst partitioning case it has to be
       capable of accommodating all the leaf routes in its own PoD to
       prevent black-holing.

   2.  Leaf nodes hold only their own N-TIEs and S-TIEs of Level 1 nodes
       they are connected to; so overall few in numbers.

   3.  Leaf node does not have to support flooding reduction or any type
       of de-aggregation computation or propagation.

   4.  Unless optional leaf-2-leaf procedures are desired default route
       origination and S-TIE origination is unnecessary.

7.2.  Adaptations to Other Proposed Data Center Topologies

                         .  +-----+        +-----+
                         .  |     |        |     |
                         .+-+ S0  |        | S1  |
                         .| ++---++        ++---++
                         .|  |   |          |   |
                         .|  | +------------+   |
                         .|  | | +------------+ |
                         .|  | |              | |
                         .| ++-+--+        +--+-++
                         .| |     |        |     |
                         .| | A0  |        | A1  |
                         .| +-+--++        ++---++
                         .|   |  |          |   |
                         .|   |  +------------+ |
                         .|   | +-----------+ | |
                         .|   | |             | |
                         .| +-+-+-+        +--+-++
                         .+-+     |        |     |
                         .  | L0  |        | L1  |
                         .  +-----+        +-----+


                         Figure 26: Level Shortcut

   Strictly speaking, RIFT is not limited to Clos variations only.  The
   protocol preconditions only a sense of 'compass rose direction'
   achieved by configuration (or derivation) of levels and other
   topologies are possible within this framework.  So, conceptually, one
   could include leaf to leaf links and even shortcut between levels but



The RIFT Authors         Expires April 22, 2019                [Page 76]

Internet-Draft                    RIFT                      October 2018


   certain requirements in Section 4 will not be met anymore.  As an
   example, shortcutting levels illustrated in Figure 26 will lead
   either to suboptimal routing when L0 sends traffic to L1 (since using
   S0's default route will lead to the traffic being sent back to A0 or
   A1) or the leafs need each other's routes installed to understand
   that only A0 and A1 should be used to talk to each other.

   Whether such modifications of topology constraints make sense is
   dependent on many technology variables and the exhausting treatment
   of the topic is definitely outside the scope of this document.

7.3.  Originating Non-Default Route Southbound

   Obviously, an implementation may choose to originate southbound
   instead of a strict default route (as described in Section 5.2.3.7) a
   shorter prefix P' but in such a scenario all addresses carried within
   the RIFT domain must be contained within P'.

8.  Security Considerations

8.1.  General

   The protocol has provisions for nonces and can include authentication
   mechanisms in the future comparable to [RFC5709] and [RFC7987].

   One can consider additionally attack vectors where a router may
   reboot many times while changing its system ID and pollute the
   network with many stale TIEs or TIEs are sent with very long
   lifetimes and not cleaned up when the routes vanishes.  Those attack
   vectors are not unique to RIFT.  Given large memory footprints
   available today those attacks should be relatively benign.  Otherwise
   a node SHOULD implement a strategy of discarding contents of all TIEs
   that were not present in the SPF tree over a certain, configurable
   period of time.  Since the protocol, like all modern link-state
   protocols, is self-stabilizing and will advertise the presence of
   such TIEs to its neighbors, they can be re-requested again if a
   computation finds that it sees an adjacency formed towards the system
   ID of the discarded TIEs.

8.2.  ZTP

   Section 5.2.7 presents many attack vectors in untrusted environments,
   starting with nodes that oscillate their level offers to the
   possiblity of a node offering a three way adjacency with the highest
   possible level value with a very long holdtime trying to put itself
   "on top of the lattice" and with that gaining access to the whole
   southbound topology.  Session authentication mechanisms are necessary
   in environments where this is possible.



The RIFT Authors         Expires April 22, 2019                [Page 77]

Internet-Draft                    RIFT                      October 2018


8.3.  Lifetime

   The protocol uses in TIE flooding the traditional lifetime approach
   that is vulnerable to sophisticated attack vectors under normal
   circumstances.  However, on IP fabrics with some kind of, even
   coarse, clock synchronization, RIFT allows to recognize such attacks
   by including optional, protected information at origin.

9.  IANA Considerations

   This specification will request at an opportune time multiple
   registry points to exchange protocol packets in a standardized way,
   amongst them multicast address assignments and standard port numbers.
   The schema itself defines many values and codepoints which can be
   considered registries themselves.

10.  Acknowledgments

   Many thanks to Naiming Shen for some of the early discussions around
   the topic of using IGPs for routing in topologies related to Clos.
   Russ White to be especially acknowledged for the key conversation on
   epistomology that allowed to tie current asynchronous distributed
   systems theory results to a modern protocol design presented here.
   Adrian Farrel, Joel Halpern, Jeffrey Zhang, Krzysztof Szarkowicz,
   Nagendra Kumar provided thoughtful comments that improved the
   readability of the document and found good amount of corners where
   the light failed to shine.  Kris Price was first to mention single
   router, single arm default considerations.  Jeff Tantsura helped out
   with some initial thoughts on BFD interactions while Jeff Haas
   corrected several misconceptions about BFD's finer points.  Artur
   Makutunowicz pointed out many possible improvements and acted as
   sounding board in regard to modern protocol implementation techniques
   RIFT is exploring.  Barak Gafni formalized first time clearly the
   problem of partitioned spine and fallen leafs on a (clean) napkin in
   Singapore that led to the very important part of the specification
   centered around multiple Top-of-Fabric planes and negative
   disaggregation.

11.  References

11.1.  Normative References

   [I-D.ietf-6lo-rfc6775-update]
              Thubert, P., Nordmark, E., Chakrabarti, S., and C.
              Perkins, "Registration Extensions for 6LoWPAN Neighbor
              Discovery", draft-ietf-6lo-rfc6775-update-21 (work in
              progress), June 2018.




The RIFT Authors         Expires April 22, 2019                [Page 78]

Internet-Draft                    RIFT                      October 2018


   [ISO10589]
              ISO "International Organization for Standardization",
              "Intermediate system to Intermediate system intra-domain
              routeing information exchange protocol for use in
              conjunction with the protocol for providing the
              connectionless-mode Network Service (ISO 8473), ISO/IEC
              10589:2002, Second Edition.", Nov 2002.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC2328]  Moy, J., "OSPF Version 2", STD 54, RFC 2328,
              DOI 10.17487/RFC2328, April 1998,
              <https://www.rfc-editor.org/info/rfc2328>.

   [RFC2365]  Meyer, D., "Administratively Scoped IP Multicast", BCP 23,
              RFC 2365, DOI 10.17487/RFC2365, July 1998,
              <https://www.rfc-editor.org/info/rfc2365>.

   [RFC3626]  Clausen, T., Ed. and P. Jacquet, Ed., "Optimized Link
              State Routing Protocol (OLSR)", RFC 3626,
              DOI 10.17487/RFC3626, October 2003,
              <https://www.rfc-editor.org/info/rfc3626>.

   [RFC4271]  Rekhter, Y., Ed., Li, T., Ed., and S. Hares, Ed., "A
              Border Gateway Protocol 4 (BGP-4)", RFC 4271,
              DOI 10.17487/RFC4271, January 2006,
              <https://www.rfc-editor.org/info/rfc4271>.

   [RFC4291]  Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, DOI 10.17487/RFC4291, February
              2006, <https://www.rfc-editor.org/info/rfc4291>.

   [RFC4655]  Farrel, A., Vasseur, J., and J. Ash, "A Path Computation
              Element (PCE)-Based Architecture", RFC 4655,
              DOI 10.17487/RFC4655, August 2006,
              <https://www.rfc-editor.org/info/rfc4655>.

   [RFC5082]  Gill, V., Heasley, J., Meyer, D., Savola, P., Ed., and C.
              Pignataro, "The Generalized TTL Security Mechanism
              (GTSM)", RFC 5082, DOI 10.17487/RFC5082, October 2007,
              <https://www.rfc-editor.org/info/rfc5082>.







The RIFT Authors         Expires April 22, 2019                [Page 79]

Internet-Draft                    RIFT                      October 2018


   [RFC5120]  Przygienda, T., Shen, N., and N. Sheth, "M-ISIS: Multi
              Topology (MT) Routing in Intermediate System to
              Intermediate Systems (IS-ISs)", RFC 5120,
              DOI 10.17487/RFC5120, February 2008,
              <https://www.rfc-editor.org/info/rfc5120>.

   [RFC5303]  Katz, D., Saluja, R., and D. Eastlake 3rd, "Three-Way
              Handshake for IS-IS Point-to-Point Adjacencies", RFC 5303,
              DOI 10.17487/RFC5303, October 2008,
              <https://www.rfc-editor.org/info/rfc5303>.

   [RFC5709]  Bhatia, M., Manral, V., Fanto, M., White, R., Barnes, M.,
              Li, T., and R. Atkinson, "OSPFv2 HMAC-SHA Cryptographic
              Authentication", RFC 5709, DOI 10.17487/RFC5709, October
              2009, <https://www.rfc-editor.org/info/rfc5709>.

   [RFC5881]  Katz, D. and D. Ward, "Bidirectional Forwarding Detection
              (BFD) for IPv4 and IPv6 (Single Hop)", RFC 5881,
              DOI 10.17487/RFC5881, June 2010,
              <https://www.rfc-editor.org/info/rfc5881>.

   [RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              "Network Time Protocol Version 4: Protocol and Algorithms
              Specification", RFC 5905, DOI 10.17487/RFC5905, June 2010,
              <https://www.rfc-editor.org/info/rfc5905>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <https://www.rfc-editor.org/info/rfc6234>.

   [RFC6822]  Previdi, S., Ed., Ginsberg, L., Shand, M., Roy, A., and D.
              Ward, "IS-IS Multi-Instance", RFC 6822,
              DOI 10.17487/RFC6822, December 2012,
              <https://www.rfc-editor.org/info/rfc6822>.

   [RFC7752]  Gredler, H., Ed., Medved, J., Previdi, S., Farrel, A., and
              S. Ray, "North-Bound Distribution of Link-State and
              Traffic Engineering (TE) Information Using BGP", RFC 7752,
              DOI 10.17487/RFC7752, March 2016,
              <https://www.rfc-editor.org/info/rfc7752>.

   [RFC7855]  Previdi, S., Ed., Filsfils, C., Ed., Decraene, B.,
              Litkowski, S., Horneffer, M., and R. Shakir, "Source
              Packet Routing in Networking (SPRING) Problem Statement
              and Requirements", RFC 7855, DOI 10.17487/RFC7855, May
              2016, <https://www.rfc-editor.org/info/rfc7855>.




The RIFT Authors         Expires April 22, 2019                [Page 80]

Internet-Draft                    RIFT                      October 2018


   [RFC7938]  Lapukhov, P., Premji, A., and J. Mitchell, Ed., "Use of
              BGP for Routing in Large-Scale Data Centers", RFC 7938,
              DOI 10.17487/RFC7938, August 2016,
              <https://www.rfc-editor.org/info/rfc7938>.

   [RFC7987]  Ginsberg, L., Wells, P., Decraene, B., Przygienda, T., and
              H. Gredler, "IS-IS Minimum Remaining Lifetime", RFC 7987,
              DOI 10.17487/RFC7987, October 2016,
              <https://www.rfc-editor.org/info/rfc7987>.

   [RFC8200]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", STD 86, RFC 8200,
              DOI 10.17487/RFC8200, July 2017,
              <https://www.rfc-editor.org/info/rfc8200>.

11.2.  Informative References

   [CLOS]     Yuan, X., "On Nonblocking Folded-Clos Networks in Computer
              Communication Environments", IEEE International Parallel &
              Distributed Processing Symposium, 2011.

   [DIJKSTRA]
              Dijkstra, E., "A Note on Two Problems in Connexion with
              Graphs", Journal Numer. Math. , 1959.

   [DOT]      Ellson, J. and L. Koutsofios, "Graphviz: open source graph
              drawing tools", Springer-Verlag , 2001.

   [DYNAMO]   De Candia et al., G., "Dynamo: amazon's highly available
              key-value store", ACM SIGOPS symposium on Operating
              systems principles (SOSP '07), 2007.

   [EPPSTEIN]
              Eppstein, D., "Finding the k-Shortest Paths", 1997.

   [EUI64]    IEEE, "Guidelines for Use of Extended Unique Identifier
              (EUI), Organizationally Unique Identifier (OUI), and
              Company ID (CID)", IEEE EUI,
              <http://standards.ieee.org/develop/regauth/tut/eui.pdf>.

   [FATTREE]  Leiserson, C., "Fat-Trees: Universal Networks for
              Hardware-Efficient Supercomputing", 1985.

   [I-D.ietf-spring-segment-routing]
              Filsfils, C., Previdi, S., Ginsberg, L., Decraene, B.,
              Litkowski, S., and R. Shakir, "Segment Routing
              Architecture", draft-ietf-spring-segment-routing-15 (work
              in progress), January 2018.



The RIFT Authors         Expires April 22, 2019                [Page 81]

Internet-Draft                    RIFT                      October 2018


   [IEEEstd1588]
              IEEE, "IEEE Standard for a Precision Clock Synchronization
              Protocol for Networked Measurement and Control Systems",
              IEEE Standard 1588,
              <https://ieeexplore.ieee.org/document/4579760/>.

   [IEEEstd8021AS]
              IEEE, "IEEE Standard for Local and Metropolitan Area
              Networks - Timing and Synchronization for Time-Sensitive
              Applications in Bridged Local Area Networks",
              IEEE Standard 802.1AS,
              <https://ieeexplore.ieee.org/document/5741898/>.

   [ISO10589-Second-Edition]
              International Organization for Standardization,
              "Intermediate system to Intermediate system intra-domain
              routeing information exchange protocol for use in
              conjunction with the protocol for providing the
              connectionless-mode Network Service (ISO 8473)", Nov 2002.

   [MAKSIC2013]
              Maksic et al., N., "Improving Utilization of Data Center
              Networks", IEEE Communications Magazine, Nov 2013.

   [RFC0826]  Plummer, D., "An Ethernet Address Resolution Protocol: Or
              Converting Network Protocol Addresses to 48.bit Ethernet
              Address for Transmission on Ethernet Hardware", STD 37,
              RFC 826, DOI 10.17487/RFC0826, November 1982,
              <https://www.rfc-editor.org/info/rfc826>.

   [RFC2131]  Droms, R., "Dynamic Host Configuration Protocol",
              RFC 2131, DOI 10.17487/RFC2131, March 1997,
              <https://www.rfc-editor.org/info/rfc2131>.

   [RFC3315]  Droms, R., Ed., Bound, J., Volz, B., Lemon, T., Perkins,
              C., and M. Carney, "Dynamic Host Configuration Protocol
              for IPv6 (DHCPv6)", RFC 3315, DOI 10.17487/RFC3315, July
              2003, <https://www.rfc-editor.org/info/rfc3315>.

   [RFC4861]  Narten, T., Nordmark, E., Simpson, W., and H. Soliman,
              "Neighbor Discovery for IP version 6 (IPv6)", RFC 4861,
              DOI 10.17487/RFC4861, September 2007,
              <https://www.rfc-editor.org/info/rfc4861>.

   [RFC4862]  Thomson, S., Narten, T., and T. Jinmei, "IPv6 Stateless
              Address Autoconfiguration", RFC 4862,
              DOI 10.17487/RFC4862, September 2007,
              <https://www.rfc-editor.org/info/rfc4862>.



The RIFT Authors         Expires April 22, 2019                [Page 82]

Internet-Draft                    RIFT                      October 2018


   [VAHDAT08]
              Al-Fares, M., Loukissas, A., and A. Vahdat, "A Scalable,
              Commodity Data Center Network Architecture", SIGCOMM ,
              2008.

Appendix A.  Information Elements Schema

   This section introduces the schema for information elements.

   On schema changes that

   1.  change field numbers or

   2.  add new required fields or

   3.  remove fields or

   4.  change lists into sets, unions into structures or

   5.  change multiplicity of fields or

   6.  changes name of any field or

   7.  change datatypes of any field or

   8.  adds, changes or removes a default value of any field or

   9.  removes or changes any defined constant or constant value

   major version of the schema MUST increase.  All other changes MUST
   increase minor version within the same major.

   Observe however that introducing an optional field of a structure
   type without a default does not cause a major version increase even
   if the fields inside the structure are optional with defaults.

   Thrift serializer/deserializer MUST not discard optional, unknown
   fields but preserve and serialize them again when re-flooding whereas
   missing optional fields MAY be replaced with according default values
   if present.

   All signed integer as forced by Thrift support must be cast for
   internal purposes to equivalent unsigned values without discarding
   the signedness bit.  An implementation SHOULD try to avoid using the
   signedness bit when generating values.

   The schema is normative.




The RIFT Authors         Expires April 22, 2019                [Page 83]

Internet-Draft                    RIFT                      October 2018


A.1.  common.thrift


/**
    Thrift file with common definitions for RIFT
*/

/** @note MUST be interpreted in implementation as unsigned 64 bits.
 *        The implementation SHOULD NOT use the MSB.
 */
typedef i64      SystemIDType
typedef i32      IPv4Address
/** this has to be of length long enough to accomodate prefix */
typedef binary   IPv6Address
/** @note MUST be interpreted in implementation as unsigned 16 bits */
typedef i16      UDPPortType
/** @note MUST be interpreted in implementation as unsigned 32 bits */
typedef i32      TIENrType
/** @note MUST be interpreted in implementation as unsigned 32 bits */
typedef i32      MTUSizeType
/** @note MUST be interpreted in implementation as unsigned 32 bits */
typedef i32      SeqNrType
/** @note MUST be interpreted in implementation as unsigned 32 bits */
typedef i32      LifeTimeInSecType
/** @note MUST be interpreted in implementation as unsigned 16 bits */
typedef i16      LevelType
/** @note MUST be interpreted in implementation as unsigned 32 bits */
typedef i32      PodType
/** @note MUST be interpreted in implementation as unsigned 16 bits */
typedef i16      VersionType
/** @note MUST be interpreted in implementation as unsigned 32 bits */
typedef i32      MetricType
/** @note MUST be interpreted in implementation as unstructured 64 bits */
typedef i64      RouteTagType
/** @note MUST be interpreted in implementation as unstructured 32 bits label value */
typedef i32      LabelType
/** @note MUST be interpreted in implementation as unsigned 32 bits */
typedef i32      BandwithInMegaBitsType
typedef string   KeyIDType
/** node local, unique identification for a link (interface/tunnel
  * etc. Basically anything RIFT runs on). This is kept
  * at 32 bits so it aligns with BFD [RFC5880] discriminator size.
  */
typedef i32    LinkIDType
typedef string KeyNameType
typedef i8     PrefixLenType
/** timestamp in seconds since the epoch */
typedef i64    TimestampInSecsType



The RIFT Authors         Expires April 22, 2019                [Page 84]

Internet-Draft                    RIFT                      October 2018


/** security nonce */
typedef i64    NonceType
/** LIE FSM holdtime type */
typedef i16    TimeIntervalInSecType
/** Transaction ID type for prefix mobility as specified by RFC6550,  value
    MUST be interpreted in implementation as unsigned  */
typedef i8     PrefixTransactionIDType
/** timestamp per IEEE 802.1AS, values MUST be interpreted in implementation as unsigned  */
struct IEEE802_1ASTimeStampType {
    1: required     i64     AS_sec;
    2: optional     i32     AS_nsec;
}

/** Flags indicating nodes behavior in case of ZTP and support
    for special optimization procedures. It will force level to `leaf_level` or
    `top-of-fabric` level accordingly and enable according procedures
 */
enum HierarchyIndications {
    leaf_only                            = 0,
    leaf_only_and_leaf_2_leaf_procedures = 1,
    top_of_fabric                        = 2,
}

/** This MUST be used when node is configured as top of fabric in ZTP.
    This is kept reasonably low to alow for fast ZTP convergence on
    failures. */
const LevelType   top_of_fabric_level              = 24
/** default bandwidth on a link */
const BandwithInMegaBitsType  default_bandwidth    = 100
/** fixed leaf level when ZTP is not used */
const LevelType   leaf_level                  = 0
const LevelType   default_level               = leaf_level
const PodType     default_pod                 = 0
const LinkIDType  undefined_linkid            = 0

/** default distance used */
const MetricType  default_distance         = 1
/** any distance larger than this will be considered infinity */
const MetricType  infinite_distance       = 0x7FFFFFFF
/** represents invalid distance */
const MetricType  invalid_distance        = 0
const bool overload_default               = false
const bool flood_reduction_default        = true
/** default LIE FSM holddown time */
const TimeIntervalInSecType   default_lie_holdtime  = 3
/** default ZTP FSM holddown time */
const TimeIntervalInSecType   default_ztp_holdtime  = 1
/** by default LIE levels are ZTP offers */



The RIFT Authors         Expires April 22, 2019                [Page 85]

Internet-Draft                    RIFT                      October 2018


const bool default_not_a_ztp_offer        = false
/** by default e'one is repeating flooding */
const bool default_you_are_flood_repeater = true
/** 0 is illegal for SystemID */
const SystemIDType IllegalSystemID        = 0
/** empty set of nodes */
const set<SystemIDType> empty_set_of_nodeids = {}
/** default lifetime is one week */
const LifeTimeInSecType default_lifetime      = 604800
/** any `TieHeader` that has a smaller lifetime difference
    than this constant is equal (if other fields equal) */
const LifeTimeInSecType lifetime_diff2ignore  = 300

/** default UDP port to run LIEs on */
const UDPPortType     default_lie_udp_port       =  911
/** default UDP port to receive TIEs on, that can be peer specific */
const UDPPortType     default_tie_udp_flood_port =  912

/** default MTU link size to use */
const MTUSizeType     default_mtu_size           =  1400

/** indicates whether the direction is northbound/east-west
  * or southbound */
enum TieDirectionType {
    Illegal           = 0,
    South             = 1,
    North             = 2,
    DirectionMaxValue = 3,
}

enum AddressFamilyType {
   Illegal                = 0,
   AddressFamilyMinValue  = 1,
   IPv4     = 2,
   IPv6     = 3,
   AddressFamilyMaxValue  = 4,
}

struct IPv4PrefixType {
    1: required IPv4Address    address;
    2: required PrefixLenType  prefixlen;
}

struct IPv6PrefixType {
    1: required IPv6Address    address;
    2: required PrefixLenType  prefixlen;
}




The RIFT Authors         Expires April 22, 2019                [Page 86]

Internet-Draft                    RIFT                      October 2018


union IPAddressType {
    1: optional IPv4Address   ipv4address;
    2: optional IPv6Address   ipv6address;
}

union IPPrefixType {
    1: optional IPv4PrefixType   ipv4prefix;
    2: optional IPv6PrefixType   ipv6prefix;
}

/** @note: Sequence of a prefix. Comparison function:
    if diff(timestamps) < 200msecs better transactionid wins
    else better time wins
 */
struct PrefixSequenceType {
    1: required IEEE802_1ASTimeStampType  timestamp;
    2: optional PrefixTransactionIDType   transactionid;
}

enum TIETypeType {
    Illegal                             = 0,
    TIETypeMinValue                     = 1,
    /** first legal value */
    NodeTIEType                         = 2,
    PrefixTIEType                       = 3,
    PositiveDisaggregationPrefixTIEType = 4,
    NegativeDisaggregationPrefixTIEType = 5,
    PGPrefixTIEType                     = 6,
    KeyValueTIEType                     = 7,
    ExternalPrefixTIEType               = 8,
    TIETypeMaxValue                     = 9,
}

/** @note: route types which MUST be ordered on their preference
 *  PGP prefixes are most preferred attracting
 *  traffic north (towards spine) and then south
 *  normal prefixes are attracting traffic south (towards leafs),
 *  i.e. prefix in NORTH PREFIX TIE is preferred over SOUTH PREFIX TIE
 *
 *  @todo: external routes
 *  @note: The only purpose of those values is to introduce an
 *         ordering whereas an implementation can choose internally
 *         any other values as long the ordering is preserved
 */
enum RouteType {
    Illegal               = 0,
    RouteTypeMinValue     = 1,
    /** First legal value. */



The RIFT Authors         Expires April 22, 2019                [Page 87]

Internet-Draft                    RIFT                      October 2018


    /** Discard routes are most prefered */
    Discard               = 2,

    /** Local prefixes are directly attached prefixes on the
     *  system such as e.g. interface routes.
     */
    LocalPrefix           = 3,
    /** advertised in S-TIEs */
    SouthPGPPrefix        = 4,
    /** advertised in N-TIEs */
    NorthPGPPrefix        = 5,
    /** advertised in N-TIEs */
    NorthPrefix           = 6,
    /** advertised in S-TIEs, either normal prefix or positive disaggregation */
    SouthPrefix           = 7,
    /** externally imported north */
    NorthExternalPrefix   = 8,
    /** externally imported south */
    SouthExternalPrefix   = 9,
    /** negative, transitive are least preferred of
        local variety */
    NegativeSouthPrefix   = 10,
    RouteTypeMaxValue     = 11,
}

A.2.  encoding.thrift


/**
    Thrift file for packet encodings for RIFT
*/

include "common.thrift"

/** represents protocol encoding schema major version */
const i32 protocol_major_version = 19
/** represents protocol encoding schema minor version */
const i32 protocol_minor_version = 0

/** common RIFT packet header */
struct PacketHeader {
    1: required common.VersionType major_version = protocol_major_version;
    2: required common.VersionType minor_version = protocol_minor_version;
    /** this is the node sending the packet, in case of LIE/TIRE/TIDE
        also the originator of it */
    3: required common.SystemIDType  sender;
    /** level of the node sending the packet, required on everything except
      * LIEs. Lack of presence on LIEs indicates UNDEFINED_LEVEL and is used



The RIFT Authors         Expires April 22, 2019                [Page 88]

Internet-Draft                    RIFT                      October 2018


      * in ZTP procedures.
     */
    4: optional common.LevelType     level;
}

/** Community serves as community for PGP purposes */
struct Community {
    1: required i32          top;
    2: required i32          bottom;
}

/** Neighbor structure  */
struct Neighbor {
    1: required common.SystemIDType        originator;
    2: required common.LinkIDType          remote_id;
}

/** Capabilities the node supports */
struct NodeCapabilities {
    /** can this node participate in flood reduction */
    1: optional bool                           flood_reduction =
            common.flood_reduction_default;
    /** does this node restrict itself to be top-of-fabric or
        leaf only (in ZTP) and does it support leaf-2-leaf procedures */
    2: optional common.HierarchyIndications    hierarchy_indications;
}

/** RIFT LIE packet

    @note this node's level is already included on the packet header */
struct LIEPacket {
    /** optional node or adjacency name */
    1: optional string                    name;
    /** local link ID */
    2: required common.LinkIDType         local_id;
    /** UDP port to which we can receive flooded TIEs */
    3: required common.UDPPortType        flood_port =
            common.default_tie_udp_flood_port;
    /** layer 3 MTU, used to discover to mismatch */
    4: optional common.MTUSizeType        link_mtu_size =
            common.default_mtu_size;
    /** local link bandwidth on the interface */
    5: optional common.BandwithInMegaBitsType link_bandwidth =
            common.default_bandwidth;
    /** this will reflect the neighbor once received to provid
        3-way connectivity */
    6: optional Neighbor                  neighbor;
    7: optional common.PodType            pod = common.default_pod;



The RIFT Authors         Expires April 22, 2019                [Page 89]

Internet-Draft                    RIFT                      October 2018


    /** optional local nonce used for security computations */
    8: optional common.NonceType          nonce;
    /** optional neighbor's reflected nonce for security purposes. Significant delta
        in nonces seen compared to current local nonce can be used to prevent replays */
    9: optional common.NonceType          last_neighbor_nonce;
    /** optional node capabilities shown in the LIE. The capabilies
        MUST match the capabilities shown in the Node TIEs, otherwise
        the behavior is unspecified. A node detecting the mismatch
        SHOULD generate according error.
     */
   10: optional NodeCapabilities          capabilities;
    /** required holdtime of the adjacency, i.e. how much time
        MUST expire without LIE for the adjacency to drop
     */
   11: required common.TimeIntervalInSecType  holdtime =
            common.default_lie_holdtime;
    /** indicates that the level on the LIE MUST NOT be used
        to derive a ZTP level by the receiving node. */
   12: optional bool                      not_a_ztp_offer =
            common.default_not_a_ztp_offer;
   /** indicates to northbound neighbor that it should
       be reflooding this node's N-TIEs to achieve flood reducuction and
       balancing for northbound flooding. To be ignored if received from a
       northbound adjacency. */
   13: optional bool                      you_are_flood_repeater =
             common.default_you_are_flood_repeater;
   /** optional downstream assigned locally significant label
       value for the adjacency. */
   14: optional common.LabelType          label;
}

/** LinkID pair describes one of parallel links between two nodes */
struct LinkIDPair {
    /** node-wide unique value for the local link */
    1: required common.LinkIDType      local_id;
    /** received remote link ID for this link */
    2: required common.LinkIDType      remote_id;
    /** more properties of the link can go in here */
}

/** ID of a TIE

    @note: TIEID space is a total order achieved by comparing the elements
           in sequence defined and comparing each value as an
           unsigned integer of according length.
*/
struct TIEID {
    /** indicates direction of the TIE */



The RIFT Authors         Expires April 22, 2019                [Page 90]

Internet-Draft                    RIFT                      October 2018


    1: required common.TieDirectionType    direction;
    /** indicates originator of the TIE */
    2: required common.SystemIDType        originator;
    3: required common.TIETypeType         tietype;
    4: required common.TIENrType           tie_nr;
}

/** Header of a TIE.

   @note: TIEID space is a total order achieved by comparing the elements
              in sequence defined and comparing each value as an
              unsigned integer of according length. `origination_time` is
              disregarded for comparison purposes.
*/
struct TIEHeader {
    2: required TIEID                             tieid;
    3: required common.SeqNrType                  seq_nr;
    /** remaining lifetime that expires down to 0 just like in ISIS.
        TIEs with lifetimes differing by less than `lifetime_diff2ignore` MUST
        be considered EQUAL. */
    4: required common.LifeTimeInSecType          remaining_lifetime;
    /** optional absolute timestamp when the TIE
        was generated. This can be used on fabrics with
        synchronized clock to prevent lifetime modification attacks. */
   10: optional common.IEEE802_1ASTimeStampType   origination_time;
   /** optional original lifetime when the TIE
       was generated. This can be used on fabrics with
       synchronized clock to prevent lifetime modification attacks. */
   12: optional common.LifeTimeInSecType          origination_lifetime;
}

/** A TIDE with sorted TIE headers, if headers unsorted, behavior is undefined */
struct TIDEPacket {
    /** all 00s marks starts */
    1: required TIEID           start_range;
    /** all FFs mark end */
    2: required TIEID           end_range;
    /** _sorted_ list of headers */
    3: required list<TIEHeader> headers;
}

/** A TIRE packet */
struct TIREPacket {
    1: required set<TIEHeader> headers;
}

/** Neighbor of a node */
struct NodeNeighborsTIEElement {



The RIFT Authors         Expires April 22, 2019                [Page 91]

Internet-Draft                    RIFT                      October 2018


    /** Level of neighbor */
    1: required common.LevelType              level;
    /**  Cost to neighbor.

         @note: All parallel links to same node
         incur same cost, in case the neighbor has multiple
         parallel links at different cost, the largest distance
         (highest numerical value) MUST be advertised
         @note: any neighbor with cost <= 0 MUST be ignored in computations */
    3: optional common.MetricType               cost = common.default_distance;
    /** can carry description of multiple parallel links in a TIE */
    4: optional set<LinkIDPair>                 link_ids;

    /** total bandwith to neighbor, this will be normally sum of the
        bandwidths of all the parallel links. */
    5: optional common.BandwithInMegaBitsType   bandwidth =
            common.default_bandwidth;
}

/** Flags the node sets */
struct NodeFlags {
    /** node is in overload, do not transit traffic through it */
    1: optional bool         overload = common.overload_default;
}

/** Description of a node.

    It may occur multiple times in different TIEs but if either
        * capabilities values do not match or
        * flags values do not match or
        * neighbors repeat with different values or
        * visible in same level/having partition upper do not match
    the behavior is undefined and a warning SHOULD be generated.
    Neighbors can be distributed across multiple TIEs however if
    the sets are disjoint.

    @note: observe that absence of fields implies defined defaults
*/
struct NodeTIEElement {
    1: required common.LevelType            level;
    /** if neighbor systemID repeats in other node TIEs of same node
        the behavior is undefined. Equivalent to |A_(n,s)(N) in spec. */
    2: required map<common.SystemIDType,
                NodeNeighborsTIEElement>    neighbors;
    3: optional NodeCapabilities            capabilities;
    4: optional NodeFlags                   flags;
    /** optional node name for easier operations */
    5: optional string                      name;



The RIFT Authors         Expires April 22, 2019                [Page 92]

Internet-Draft                    RIFT                      October 2018


}

struct PrefixAttributes {
    2: required common.MetricType            metric = common.default_distance;
    /** generic unordered set of route tags, can be redistributed to other protocols or use
        within the context of real time analytics */
    3: optional set<common.RouteTagType>     tags;
    /** optional monotonic clock for mobile addresses */
    4: optional common.PrefixSequenceType    monotonic_clock;
}

/** multiple prefixes */
struct PrefixTIEElement {
    /** prefixes with the associated attributes.
        if the same prefix repeats in multiple TIEs of same node
        behavior is unspecified */
    1: required map<common.IPPrefixType, PrefixAttributes> prefixes;
}

/** keys with their values */
struct KeyValueTIEElement {
    /** if the same key repeats in multiple TIEs of same node
        or with different values, behavior is unspecified */
    1: required map<common.KeyIDType,string>    keyvalues;
}

/** single element in a TIE. enum common.TIETypeType
    in TIEID indicates which elements MUST be present
    in the TIEElement. In case of mismatch the unexpected
    elements MUST be ignored. In case of lack of expected
    element the TIE an error MUST be reported and the TIE
    MUST be ignored.
 */
union TIEElement {
    /** in case of enum common.TIETypeType.NodeTIEType */
    1: optional NodeTIEElement            node;
    /** in case of enum common.TIETypeType.PrefixTIEType */
    2: optional PrefixTIEElement          prefixes;
    /** positive prefixes (always southbound)
        It MUST NOT be advertised within a North TIE.
    */
    3: optional PrefixTIEElement          positive_disaggregation_prefixes;
    /** transitive, negative prefixes (always southbound) which
        MUST be aggregated and propagated
        according to the specification
        southwards towards lower levels to heal
        pathological upper level partitioning, otherwise
        blackholes may occur in multiplane fabrics.



The RIFT Authors         Expires April 22, 2019                [Page 93]

Internet-Draft                    RIFT                      October 2018


        It MUST NOT be advertised within a North TIE.
    */
    4: optional PrefixTIEElement          negative_disaggregation_prefixes;
    /** externally reimported prefixes */
    5: optional PrefixTIEElement          external_prefixes;
    /** Key-Value store elements */
    6: optional KeyValueTIEElement        keyvalues;
    /** @todo: policy guided prefixes */
}

/** @todo: flood header separately in UDP to allow changing lifetime and SHA without reserialization

 */
struct TIEPacket {
    1: required TIEHeader  header;
    2: required TIEElement element;
}

union PacketContent {
    1: optional LIEPacket     lie;
    2: optional TIDEPacket    tide;
    3: optional TIREPacket    tire;
    4: optional TIEPacket     tie;
}

/** protocol packet structure */
struct ProtocolPacket {
    1: required PacketHeader  header;
    2: required PacketContent content;
}

Appendix B.  Finite State Machines and Precise Operational
             Specifications

   Some FSM figures are provided as [DOT] description due to limitations
   of ASCII art.

   On Entry action is performed every time and right before the
   according state is entered, i.e. after any transitions from previous
   state.

   On Exit action is performed every time and immediately when a state
   is exited, i.e. before any transitions towards target state are
   performed.

   Any attempt to transition from a state towards another on reception
   of an event where no action is specified MUST be considered an
   unrecoverable error.



The RIFT Authors         Expires April 22, 2019                [Page 94]

Internet-Draft                    RIFT                      October 2018


   The FSMs and procedures are NOT normative in the sense that an
   implementation MUST implement them literally (which would be
   overspecification) but an implementation MUST exhibit externally
   observable behavior that is identical to the execution of the
   specified FSMs.

   Where a FSM representation is inconvenient, i.e. the amount of
   procedures and kept state exceeds the amount of transitions, we defer
   to a more procedural description on data structures.

B.1.  LIE FSM

   Initial state is `OneWay`.

   Event `MultipleNeighbors` occurs normally when more than two nodes
   see each other on the same link or a remote node is quickly
   reconfigured or rebooted without regressing to `OneWay` first.  Each
   occurence of the event SHOULD generate a clear, according
   notification to help operational deployments.

   The machine sends LIEs on several transitions to accelerate adjacency
   bring-up without waiting for the timer tic.

digraph Ga556dde74c30450aae125eaebc33bd57 {
    Nd16ab5092c6b421c88da482eb4ae36b6[label="ThreeWay"][shape="oval"];
    N54edd2b9de7641688608f44fca346303[label="OneWay"][shape="oval"];
    Nfeef2e6859ae4567bd7613a32cc28c0e[label="TwoWay"][shape="oval"];
    N7f2bb2e04270458cb5c9bb56c4b96e23[label="Enter"][style="invis"][shape="plain"];
    N292744a4097f492f8605c926b924616b[label="Enter"][style="dashed"][shape="plain"];
    Nc48847ba98e348efb45f5b78f4a5c987[label="Exit"][style="invis"][shape="plain"];
    Nd16ab5092c6b421c88da482eb4ae36b6 -> N54edd2b9de7641688608f44fca346303
    [label="|NeighborChangedLevel|\n|NeighborChangedAddress|\n|UnacceptableHeader|\n|MTUMismatch|\n|PODMismatch|\n|HoldtimeExpired|\n|MultipleNeighbors|"]
    [color="black"][arrowhead="normal" dir="both" arrowtail="none"];
    Nd16ab5092c6b421c88da482eb4ae36b6 -> Nd16ab5092c6b421c88da482eb4ae36b6
    [label="|TimerTick|\n|LieRcvd|\n|SendLie|"][color="black"]
    [arrowhead="normal" dir="both" arrowtail="none"];
    Nfeef2e6859ae4567bd7613a32cc28c0e -> Nfeef2e6859ae4567bd7613a32cc28c0e
    [label="|TimerTick|\n|LieRcvd|\n|SendLie|"][color="black"]
    [arrowhead="normal" dir="both" arrowtail="none"];
    N54edd2b9de7641688608f44fca346303 -> Nd16ab5092c6b421c88da482eb4ae36b6
    [label="|ValidReflection|"][color="red"][arrowhead="normal" dir="both" arrowtail="none"];
    Nd16ab5092c6b421c88da482eb4ae36b6 -> Nd16ab5092c6b421c88da482eb4ae36b6
    [label="|HALChanged|\n|HATChanged|\n|HALSChanged|\n|UpdateZTPOffer|"][color="blue"]
    [arrowhead="normal" dir="both" arrowtail="none"];
    Nd16ab5092c6b421c88da482eb4ae36b6 -> Nd16ab5092c6b421c88da482eb4ae36b6
    [label="|ValidReflection|"][color="red"][arrowhead="normal" dir="both" arrowtail="none"];
    Nfeef2e6859ae4567bd7613a32cc28c0e -> N54edd2b9de7641688608f44fca346303
    [label="|LevelChanged|"][color="blue"][arrowhead="normal" dir="both" arrowtail="none"];



The RIFT Authors         Expires April 22, 2019                [Page 95]

Internet-Draft                    RIFT                      October 2018


    Nfeef2e6859ae4567bd7613a32cc28c0e -> N54edd2b9de7641688608f44fca346303
    [label="|NeighborChangedLevel|\n|NeighborChangedAddress|\n|UnacceptableHeader|\n|MTUMismatch|\n|PODMismatch|\n|HoldtimeExpired|\n|MultipleNeighbors|"]
    [color="black"][arrowhead="normal" dir="both" arrowtail="none"];
    Nfeef2e6859ae4567bd7613a32cc28c0e -> Nd16ab5092c6b421c88da482eb4ae36b6
    [label="|ValidReflection|"][color="red"][arrowhead="normal" dir="both" arrowtail="none"];
    N54edd2b9de7641688608f44fca346303 -> N54edd2b9de7641688608f44fca346303
    [label="|TimerTick|\n|LieRcvd|\n|NeighborChangedLevel|\n|NeighborChangedAddress|\n|UnacceptableHeader|\n|MTUMismatch|\n|PODMismatch|\n|HoldtimeExpired|\n|SendLie|"]
    [color="black"][arrowhead="normal" dir="both" arrowtail="none"];
    N292744a4097f492f8605c926b924616b -> N54edd2b9de7641688608f44fca346303
    [label=""][color="black"][arrowhead="normal" dir="both" arrowtail="none"];
    Nd16ab5092c6b421c88da482eb4ae36b6 -> N54edd2b9de7641688608f44fca346303
    [label="|LevelChanged|"][color="blue"][arrowhead="normal" dir="both" arrowtail="none"];
    N54edd2b9de7641688608f44fca346303 -> Nfeef2e6859ae4567bd7613a32cc28c0e
    [label="|NewNeighbor|"][color="black"][arrowhead="normal" dir="both" arrowtail="none"];
    N54edd2b9de7641688608f44fca346303 -> N54edd2b9de7641688608f44fca346303
    [label="|LevelChanged|\n|HALChanged|\n|HATChanged|\n|HALSChanged|\n|UpdateZTPOffer|"]
    [color="blue"][arrowhead="normal" dir="both" arrowtail="none"];
    Nfeef2e6859ae4567bd7613a32cc28c0e -> Nfeef2e6859ae4567bd7613a32cc28c0e
    [label="|HALChanged|\n|HATChanged|\n|HALSChanged|\n|UpdateZTPOffer|"]
    [color="blue"][arrowhead="normal" dir="both" arrowtail="none"];
    Nd16ab5092c6b421c88da482eb4ae36b6 -> Nfeef2e6859ae4567bd7613a32cc28c0e
    [label="|NeighborDroppedReflection|"]
    [color="red"][arrowhead="normal" dir="both" arrowtail="none"];
    N54edd2b9de7641688608f44fca346303 -> N54edd2b9de7641688608f44fca346303
    [label="|NeighborDroppedReflection|"][color="red"]
    [arrowhead="normal" dir="both" arrowtail="none"];
}

                                LIE FSM DOT


   .. To be updated ..


                              LIE FSM Figure

   Events

   o  TimerTick: one second timer tic

   o  LevelChanged: node's level has been changed by ZTP or
      configuration

   o  HALChanged: best HAL computed by ZTP has changed

   o  HATChanged: HAT computed by ZTP has changed





The RIFT Authors         Expires April 22, 2019                [Page 96]

Internet-Draft                    RIFT                      October 2018


   o  HALSChanged: set of HAL offering systems computed by ZTP has
      changed

   o  LieRcvd: received LIE

   o  NewNeighbor: new neighbor parsed

   o  ValidReflection: received own reflection from neighbor

   o  NeighborDroppedReflection: lost previous own reflection from
      neighbor

   o  NeighborChangedLevel: neighbor changed advertised level

   o  NeighborChangedAddress: neighbor changed IP address

   o  UnacceptableHeader: unacceptable header seen

   o  MTUMismatch: MTU mismatched

   o  PODMismatch: Unacceptable PoD seen

   o  HoldtimeExpired: adjacency hold down expired

   o  MultipleNeighbors: more than one neighbor seen on interface

   o  SendLie: send a LIE out

   o  UpdateZTPOffer: update this node's ZTP offer

   Actions

      on TimerTick in TwoWay finishes in TwoWay: PUSH SendLie event, if
      holdtime expired PUSH HoldtimeExpired event

      on HALChanged in TwoWay finishes in TwoWay: store new HAL

      on MTUMismatch in ThreeWay finishes in OneWay: no action

      on HALChanged in ThreeWay finishes in ThreeWay: store new HAL

      on ValidReflection in TwoWay finishes in ThreeWay: no action

      on ValidReflection in OneWay finishes in ThreeWay: no action

      on NeighborDroppedReflection in ThreeWay finishes in TwoWay: no
      action




The RIFT Authors         Expires April 22, 2019                [Page 97]

Internet-Draft                    RIFT                      October 2018


      on LieRcvd in ThreeWay finishes in ThreeWay: PROCESS_LIE

      on MultipleNeighbors in TwoWay finishes in OneWay: no action

      on UnacceptableHeader in ThreeWay finishes in OneWay: no action

      on MTUMismatch in TwoWay finishes in OneWay: no action

      on LevelChanged in OneWay finishes in OneWay: update level with
      event value, PUSH SendLie event

      on UnacceptableHeader in TwoWay finishes in OneWay: no action

      on HALSChanged in TwoWay finishes in TwoWay: store HALS

      on UpdateZTPOffer in TwoWay finishes in TwoWay: send offer to ZTP
      FSM

      on NeighborChangedLevel in TwoWay finishes in OneWay: no action

      on NewNeighbor in OneWay finishes in TwoWay: PUSH SendLie event

      on NeighborChangedAddress in ThreeWay finishes in OneWay: no
      action

      on HALChanged in OneWay finishes in OneWay: store new HAL

      on NeighborChangedLevel in OneWay finishes in OneWay: no action

      on HoldtimeExpired in TwoWay finishes in OneWay: no action

      on SendLie in TwoWay finishes in TwoWay: SEND_LIE

      on LevelChanged in TwoWay finishes in OneWay: update level with
      event value

      on NeighborChangedAddress in OneWay finishes in OneWay: no action

      on HATChanged in TwoWay finishes in TwoWay: store HAT

      on LieRcvd in TwoWay finishes in TwoWay: PROCESS_LIE

      on MultipleNeighbors in ThreeWay finishes in OneWay: no action

      on MTUMismatch in OneWay finishes in OneWay: no action

      on SendLie in OneWay finishes in OneWay: SEND_LIE




The RIFT Authors         Expires April 22, 2019                [Page 98]

Internet-Draft                    RIFT                      October 2018


      on LieRcvd in OneWay finishes in OneWay: PROCESS_LIE

      on TimerTick in ThreeWay finishes in ThreeWay: PUSH SendLie event,
      if holdtime expired PUSH HoldtimeExpired event

      on TimerTick in OneWay finishes in OneWay: PUSH SendLie event

      on PODMismatch in ThreeWay finishes in OneWay: no action

      on LevelChanged in ThreeWay finishes in OneWay: update level with
      event value

      on NeighborChangedLevel in ThreeWay finishes in OneWay: no action

      on UpdateZTPOffer in OneWay finishes in OneWay: send offer to ZTP
      FSM

      on UpdateZTPOffer in ThreeWay finishes in ThreeWay: send offer to
      ZTP FSM

      on HATChanged in OneWay finishes in OneWay: store HAT

      on HATChanged in ThreeWay finishes in ThreeWay: store HAT

      on HoldtimeExpired in OneWay finishes in OneWay: no action

      on UnacceptableHeader in OneWay finishes in OneWay: no action

      on PODMismatch in OneWay finishes in OneWay: no action

      on SendLie in ThreeWay finishes in ThreeWay: SEND_LIE

      on NeighborChangedAddress in TwoWay finishes in OneWay: no action

      on ValidReflection in ThreeWay finishes in ThreeWay: no action

      on HALSChanged in OneWay finishes in OneWay: store HALS

      on HoldtimeExpired in ThreeWay finishes in OneWay: no action

      on HALSChanged in ThreeWay finishes in ThreeWay: store HALS

      on NeighborDroppedReflection in OneWay finishes in OneWay: no
      action

      on PODMismatch in TwoWay finishes in OneWay: no action

      on Entry into OneWay: CLEANUP



The RIFT Authors         Expires April 22, 2019                [Page 99]

Internet-Draft                    RIFT                      October 2018


   Following words are used for well known procedures:

   1.  PUSH Event: pushes an event to be executed by the FSM upon exit
       of this action

   2.  CLEANUP: neighbor MUST be reset to unknown

   3.  SEND_LIE: create a new LIE packet

       1.  reflecting the neighbor if known and valid and

       2.  setting the necessary `not_a_ztp_offer` variable if level was
           derived from last known neighbor on this interface and

       3.  setting `you_are_not_flood_repeater` to computed value

   4.  PROCESS_LIE:

       1.  if lie has wrong major version OR our own system ID or
           invalid system ID then CLEANUP else

       2.  if lie has non matching MTUs then CLEANUP, PUSH
           UpdateZTPOffer, PUSH MTUMismatch else

       3.  if PoD rules do not allow adjacency forming then CLEANUP,
           PUSH PODMismatch, PUSH MTUMismatch else

       4.  if lie has undefined level OR my level is undefined OR this
           node is leaf and remote level lower than HAT OR (lie's level
           is not leaf AND its difference is more than one from my
           level) then CLEANUP, PUSH UpdateZTPOffer, PUSH
           UnacceptableHeader else

       5.  PUSH UpdateZTPOffer, construct temporary new neighbor
           structure with values from lie, if no current neighbor exists
           then set neighbor to new neighbor, PUSH NewNeighbor event,
           CHECK_THREE_WAY else

           1.  if current neighbor system ID differs from lie's system
               ID then PUSH MultipleNeighbors else

           2.  if current neighbor stored level differs from lie's level
               then PUSH NeighborChangedLevel else

           3.  if current neighbor stored IPv4/v6 address differs from
               lie's address then PUSH NeighborChangedAddress else





The RIFT Authors         Expires April 22, 2019               [Page 100]

Internet-Draft                    RIFT                      October 2018


           4.  if any of neighbor's flood address port, name, local
               linkid changed then PUSH NeighborChangedMinorFields and

           5.  CHECK_THREE_WAY

   5.  CHECK_THREE_WAY: if current state is one-way do nothing else

       1.  if lie packet does not contain neighbor then if current state
           is three-way then PUSH NeighborDroppedReflection else

       2.  if packet reflects this system's ID and local port and state
           is three-way then PUSH event ValidReflection else PUSH event
           MultipleNeighbors

B.2.  ZTP FSM

   Initial state is ComputeBestOffer.

digraph G04743cd825cc40c5b93de0616ffb851b {
N29e7db3976644f62b6f3b2801bccb854[label="Enter"]
[style="dashed"][shape="plain"];
N33df4993a1664be18a2196001c27a64c[label="HoldingDown"][shape="oval"];
N839f77189e324c82b21b8a709b4b021d[label="ComputeBestOffer"][shape="oval"];
Nc97f2b02808d4751afcc630687bf7421[label="UpdatingClients"][shape="oval"];
N7ad21867360c44709be20a99f33dd1f7[label="Enter"]
[style="dashed"][shape="plain"];
N33df4993a1664be18a2196001c27a64c -> N33df4993a1664be18a2196001c27a64c
[label="|ComputationDone|"][color="green"]
[arrowhead="normal" dir="both" arrowtail="none"];
N29e7db3976644f62b6f3b2801bccb854 -> Nc97f2b02808d4751afcc630687bf7421
[label=""]
[color="black"][arrowhead="normal" dir="both" arrowtail="none"];
N839f77189e324c82b21b8a709b4b021d -> N839f77189e324c82b21b8a709b4b021d
[label="|NeighborOffer|\n|WithdrawNeighborOffer|"]
[color="blue"][arrowhead="normal" dir="both" arrowtail="none"];
N33df4993a1664be18a2196001c27a64c -> N839f77189e324c82b21b8a709b4b021d
[label="|ChangeLocalLeafIndications|\n|ChangeLocalConfiguredLevel|"]
[color="gold"]
[arrowhead="normal" dir="both" arrowtail="none"];
N839f77189e324c82b21b8a709b4b021d -> N839f77189e324c82b21b8a709b4b021d
[label="|BetterHAL|\n|BetterHAT|\n|LostHAT|"]
[color="red"][arrowhead="normal" dir="both" arrowtail="none"];
N33df4993a1664be18a2196001c27a64c -> N33df4993a1664be18a2196001c27a64c
[label="|NeighborOffer|\n|WithdrawNeighborOffer|"][color="blue"]
[arrowhead="normal" dir="both" arrowtail="none"];
Nc97f2b02808d4751afcc630687bf7421 -> N839f77189e324c82b21b8a709b4b021d
[label="|BetterHAL|\n|BetterHAT|\n|LostHAT|"][color="red"]
[arrowhead="normal" dir="both" arrowtail="none"];



The RIFT Authors         Expires April 22, 2019               [Page 101]

Internet-Draft                    RIFT                      October 2018


N33df4993a1664be18a2196001c27a64c -> N33df4993a1664be18a2196001c27a64c
[label="|ShortTic|"][color="black"][arrowhead="normal" dir="both"
arrowtail="none"];
Nc97f2b02808d4751afcc630687bf7421 -> Nc97f2b02808d4751afcc630687bf7421
[label="|NeighborOffer|\n|WithdrawNeighborOffer|"][color="blue"]
[arrowhead="normal" dir="both" arrowtail="none"];
N33df4993a1664be18a2196001c27a64c -> N33df4993a1664be18a2196001c27a64c
[label="|BetterHAL|\n|BetterHAT|\n|LostHAL|\n|LostHAT|"][color="red"]
[arrowhead="normal" dir="both" arrowtail="none"];
N839f77189e324c82b21b8a709b4b021d -> N33df4993a1664be18a2196001c27a64c
[label="|LostHAL|"][color="red"][arrowhead="normal" dir="both"
arrowtail="none"];
N7ad21867360c44709be20a99f33dd1f7 -> N839f77189e324c82b21b8a709b4b021d
[label=""][color="black"][arrowhead="normal" dir="both" arrowtail="none"];
N839f77189e324c82b21b8a709b4b021d -> Nc97f2b02808d4751afcc630687bf7421
[label="|ComputationDone|"][color="green"][arrowhead="normal" dir="both"
arrowtail="none"];
N839f77189e324c82b21b8a709b4b021d -> N839f77189e324c82b21b8a709b4b021d
[label="|ChangeLocalLeafIndications|\n|ChangeLocalConfiguredLevel|"]
[color="gold"]
[arrowhead="normal" dir="both" arrowtail="none"];
Nc97f2b02808d4751afcc630687bf7421 -> N33df4993a1664be18a2196001c27a64c
[label="|LostHAL|"]
[color="red"][arrowhead="normal" dir="both" arrowtail="none"];
N33df4993a1664be18a2196001c27a64c -> N839f77189e324c82b21b8a709b4b021d
[label="|HoldDownExpired|"][color="green"][arrowhead="normal" dir="both"
arrowtail="none"];
Nc97f2b02808d4751afcc630687bf7421 -> N839f77189e324c82b21b8a709b4b021d
[label="|ChangeLocalLeafIndications|\n|ChangeLocalConfiguredLevel|"]
[color="gold"]
[arrowhead="normal" dir="both" arrowtail="none"];
}


                                ZTP FSM DOT

   Events

   o  ChangeLocalLeafIndications: node configured with new leaf flags

   o  ChangeLocalConfiguredLevel: node locally configured with a defined
      level

   o  NeighborOffer: a new neighbor offer with optional level and
      neighbor state

   o  WithdrawNeighborOffer: a neighbor's offer withdrawn




The RIFT Authors         Expires April 22, 2019               [Page 102]

Internet-Draft                    RIFT                      October 2018


   o  BetterHAL: better HAL computed internally

   o  BetterHAT: better HAT computed internally

   o  LostHAL: lost last HAL in computation

   o  LostHAT: lost HAT in computation

   o  ComputationDone: computation performed

   o  HoldDownExpired: holddown expired

   Actions

      on LostHAT in ComputeBestOffer finishes in ComputeBestOffer:
      LEVEL_COMPUTE

      on LostHAT in HoldingDown finishes in HoldingDown: no action

      on LostHAL in HoldingDown finishes in HoldingDown:

      on ChangeLocalLeafIndications in UpdatingClients finishes in
      ComputeBestOffer: store leaf flags

      on LostHAT in UpdatingClients finishes in ComputeBestOffer: no
      action

      on BetterHAT in HoldingDown finishes in HoldingDown: no action

      on NeighborOffer in ComputeBestOffer finishes in ComputeBestOffer:

         if no level offered REMOVE_OFFER else

         if level > leaf then UPDATE_OFFER else REMOVE_OFFER

      on BetterHAT in UpdatingClients finishes in ComputeBestOffer: no
      action

      on ChangeLocalConfiguredLevel in HoldingDown finishes in
      ComputeBestOffer: store configured level

      on BetterHAL in ComputeBestOffer finishes in ComputeBestOffer:
      LEVEL_COMPUTE

      on HoldDownExpired in HoldingDown finishes in ComputeBestOffer:
      PURGE_OFFERS





The RIFT Authors         Expires April 22, 2019               [Page 103]

Internet-Draft                    RIFT                      October 2018


      on ShortTic in HoldingDown finishes in HoldingDown: if holddown
      timer expired PUSH_EVENT HoldDownExpired

      on ComputationDone in ComputeBestOffer finishes in
      UpdatingClients: no action

      on LostHAL in UpdatingClients finishes in HoldingDown: if any
      southbound adjacencies present update holddown timer to normal
      duration else fire holddown timer immediately

      on NeighborOffer in UpdatingClients finishes in UpdatingClients:

         if no level offered REMOVE_OFFER else

         if level > leaf then UPDATE_OFFER else REMOVE_OFFER

      on ChangeLocalConfiguredLevel in ComputeBestOffer finishes in
      ComputeBestOffer: store configured level and LEVEL_COMPUTE

      on NeighborOffer in HoldingDown finishes in HoldingDown:

         if no level offered REMOVE_OFFER else

         if level > leaf then UPDATE_OFFER else REMOVE_OFFER

      on LostHAL in ComputeBestOffer finishes in HoldingDown: if any
      southbound adjacencies present update holddown timer to normal
      duration else fire holddown timer immediately

      on BetterHAT in ComputeBestOffer finishes in ComputeBestOffer:
      LEVEL_COMPUTE

      on WithdrawNeighborOffer in ComputeBestOffer finishes in
      ComputeBestOffer: REMOVE_OFFER

      on ChangeLocalLeafIndications in ComputeBestOffer finishes in
      ComputeBestOffer: store leaf flags and LEVEL_COMPUTE

      on BetterHAL in HoldingDown finishes in HoldingDown: no action

      on WithdrawNeighborOffer in HoldingDown finishes in HoldingDown:
      REMOVE_OFFER

      on ChangeLocalLeafIndications in HoldingDown finishes in
      ComputeBestOffer: store leaf flags

      on ChangeLocalConfiguredLevel in UpdatingClients finishes in
      ComputeBestOffer: store level



The RIFT Authors         Expires April 22, 2019               [Page 104]

Internet-Draft                    RIFT                      October 2018


      on ComputationDone in HoldingDown finishes in HoldingDown:

      on BetterHAL in UpdatingClients finishes in ComputeBestOffer: no
      action

      on WithdrawNeighborOffer in UpdatingClients finishes in
      UpdatingClients: REMOVE_OFFER

      on Entry into UpdatingClients: update all LIE FSMs with
      computation results

      on Entry into ComputeBestOffer: LEVEL_COMPUTE

   Following words are used for well known procedures:

   1.  PUSH Event: pushes an event to be executed by the FSM upon exit
       of this action

   2.  COMPARE_OFFERS: checks whether based on current offers and held
       last results the events BetterHAL/LostHAL/BetterHAT/LostHAT are
       necessary and returns them

   3.  UPDATE_OFFER: store current offer and COMPARE_OFFERS, PUSH
       according events

   4.  LEVEL_COMPUTE: compute best offered or configured level and HAL/
       HAT, if anything changed PUSH ComputationDone

   5.  REMOVE_OFFER: remove the according offer and COMPARE_OFFERS, PUSH
       according events

   6.  PURGE_OFFERS: REMOVE_OFFER for all held offers, COMPARE OFFERS,
       PUSH according events

B.3.  Flooding Procedures

   Flooding Procedures are described in terms of a flooding state of an
   adjacency and resulting operations on it driven by packet arrivals.
   The FSM has basically a single state and is not well suited to
   represent the behavior.

   RIFT does not specify any kind of flood rate limiting since such
   specifications always assume particular points in available
   technology speeds and feeds and those points are shifting at faster
   and faster rate (speed of light holding for the moment).  The
   implementation is well served to react accordingly to losses or
   overruns which are easily detected by raising retransmission rates.




The RIFT Authors         Expires April 22, 2019               [Page 105]

Internet-Draft                    RIFT                      October 2018


   Flooding of all according topology exchange elements SHOULD be
   performed at highest feasible rate whereas the rate of transmission
   MUST be throttled by reacting to adequate features of the system such
   as e.g. queue lengths.

B.3.1.  FloodState Structure per Adjacency

   The structure contains conceptually the following elements.  The word
   collection or queue indicates a set of elements that can be iterated:

   TIES_TX:  Collection containing all the TIEs to transmit on the
      adjacency.

   TIES_ACK:  Collection containing all the TIEs that have to be
      acknowledged on the adjacency.

   TIES_REQ:  Collection containing all the TIE headers that have to be
      requested on the adjacency.

   TIES_RTX:  Collection containing all TIEs that need retransmission
      with the according time to retransmit.

   LAST_RCVD_TIDE_END:  last received TIE ID in last received TIDE.

   Following words are used for well known procedures operating on this
   structure:

   is_flood_reduced(TIE):  returns whether a TIE can be flood reduced or
      not.

   is_tide_entry_filtered(TIE):  returns whether a header should be
      propagated in TIDE according to flooding scopes.

   is_request_filtered(TIE):  returns whether a TIE request should be
      propagated to neighbor or not according to flooding scopes.

   is_flood_filtered(TIE):  returns whether a TIE requested be flooded
      to neighbor or not according to flooding scopes.

   try_to_transmit_tie(TIE):

      A.  if not is_flood_filtered(TIE) then

          1.  remove TIE from TIES_RTX if present

          2.  if TIE" with same key on TIES_ACK then

              a.  if TIE" same or newer than TIE do nothing else



The RIFT Authors         Expires April 22, 2019               [Page 106]

Internet-Draft                    RIFT                      October 2018


              b.  remove TIE" from TIES_ACK and add TIE to TIES_TX

          3.  else insert TIE into TIES_TX

   ack_tie(TIE):  remove TIE from all collections and then insert TIE
      into TIES_ACK.

   tie_been_acked(TIE):  remove TIE from all collections.

   remove_from_all_queues(TIE):  same as `tie_been_acked`.

   request_tie(TIE):  if not is_request_filtered(TIE) then
      remove_from_all_queues(TIE) and add to TIES_REQ.

   move_to_rtx_list(TIE):  remove TIE from TIES_TX and then add to
      TIES_RTX using TIE retransmission interval.

   clear_requests(TIEs):  remove all TIEs from TIES_REQ.

   bump_own_tie(TIE):  for self-originated TIE originate an empty or re-
      generate with version number higher then the one in TIE.

   The collection SHOULD be served with following priorities if the
   system cannot process all the collections in real time:

      Elements on TIES_ACK should be processed with highest priority

      TIES_TX

      TIES_REQ and TIES_RTX

B.3.2.  TIDEs

   `TIEID` and `TIEHeader` space forms a strict total order which
   implies that a comparison relation is possible between two elements.
   With that it is implictly possible to compare TIEs, TIEHeaders and
   TIEIDs to each other whereas the shortest viable key is always
   implied.

B.3.2.1.  TIDE Generation

   As given by timer constant, periodically generate TIDEs by:

      NEXT_TIDE_ID: ID of next TIE to be sent in TIDE.

      TIDE_START: Begin of TIDE packet range.

   a.  NEXT_TIDE_ID = MIN_TIEID



The RIFT Authors         Expires April 22, 2019               [Page 107]

Internet-Draft                    RIFT                      October 2018


   b.  while NEXT_TIDE_ID not equal to MAX_TIEID do

       1.  TIDE_START = NEXT_TIDE_ID

       2.  HEADERS = At most TIRDEs_PER_PKT headers in TIEDB starting at
           NEXT_TIDE_ID or higher that SHOULD be filtered by
           is_tide_entry_filtered

       3.  if HEADERS is empty then START = MIN_TIEID else START = first
           element in HEADERS

       4.  if HEADERS' size less than TIRDEs_PER_PKT then END =
           MAX_TIEID else END = last element in HEADERS

       5.  send sorted HEADERS as TIDE setting START and END as its
           range

       6.  NEXT_TIDE_ID = END

   The constant `TIRDEs_PER_PKT` SHOULD be generated and used by the
   implementation to limit the amount of TIE headers per TIDE so the
   sent TIDE PDU does not exceed interface MTU.

   TIDE PDUs SHOULD be spaced on sending to prevent packet drops.

B.3.2.2.  TIDE Processing

   On reception of TIDEs the following processing is performed:

      TXKEYS: Collection of TIE Headers to be send after processing of
      the packet

      REQKEYS: Collection of TIEIDs to be requested after processing of
      the packet

      CLEARKEYS: Collection of TIEIDs to be removed from flood state
      queues

      LASTPROCESSED: Last processed TIEID in TIDE

      DBTIE: TIE in the LSDB if found

   a.  if TIDE.start_range > LAST_RCVD_TIDE_END then add all HEADERs in
       LSDB where (TIE >= LAST_RCVD_TIDE_END and TIE < TIDE.start_range)
       to TXKEYS

   b.  LASTPROCESSED = TIDE.start_range




The RIFT Authors         Expires April 22, 2019               [Page 108]

Internet-Draft                    RIFT                      October 2018


   c.  for every HEADER in TIDE do

       1.  DBTIE = find HEADER in current LSDB

       2.  if HEADER < LASTPROCESSED then report error and reset
           adjacency and return

       3.  put all TIEs in LSDB where (TIE.HEADER > LASTPROCESSED and
           TIE.HEADER < HEADER) into TXKEYS

       4.  LASTPROCESSED = HEADER

       5.  if DBTIE not found then

           1.  if originator is this node then bump_own_tie else put
               HEADER into REQKEYS

       6.  if DBTIE.HEADER < HEADER then

           1.  if originator is this node then bump_own_tie else put
               HEADER into REQKEYS

       7.  if DBTIE.HEADER > HEADER then put DBTIE.HEADER into TXKEYS

       8.  if DBTIE.HEADER = HEADER then put DBTIE.HEADER into CLEARKEYS

   d.  put all TIEs in LSDB where (TIE.HEADER > LASTPROCESSED and
       TIE.HEADER <= TIDE.end_range) into TXKEYS

   e.  LAST_RCVD_TIDE_END = (if TIDE.end_range == MAX_TIEID then
       MIN_TIEID else TIDE.end_range)

   f.  for all TIEs in TXKEYS try_to_transmit_tie(TIE)

   g.  for all TIEs in REQKEYS request_tie(TIE)

   h.  for all TIEs in CLEARKEYS remove_from_all_queues(TIE)

B.3.3.  TIREs

B.3.3.1.  TIRE Generation

   There is not much to say here.  Elements from both TIES_REQ and
   TIES_ACK MUST be collected and sent out as fast as feasible as TIREs.







The RIFT Authors         Expires April 22, 2019               [Page 109]

Internet-Draft                    RIFT                      October 2018


B.3.3.2.  TIRE Processing

   On reception of TIREs the following processing is performed:

      TXKEYS: Collection of TIE Headers to be send after processing of
      the packet

      REQKEYS: Collection of TIEIDs to be requested after processing of
      the packet

      ACKKEYS: Collection of TIEIDs that have been acked

      DBTIE: TIE in the LSDB if found

   a.  for every HEADER in TIRE do

       1.  DBTIE = find HEADER in current LSDB

       2.  if DBTIE not found then do nothing

       3.  if DBTIE.HEADER < HEADER then put HEADER into REQKEYS

       4.  if DBTIE.HEADER > HEADER then put DBTIE.HEADER into TXKEYS

       5.  if DBTIE.HEADER = HEADER then put DBTIE.HEADER into ACKKEYS

   b.  for all TIEs in TXKEYS try_to_transmit_tie(TIE)

   c.  for all TIEs in REQKEYS request_tie(TIE)

   d.  for all TIEs in ACKKEYS tie_been_acked(TIE)

B.3.4.  TIEs Processing on Flood State Adjacency

   On reception of TIEs the following processing is performed:

      ACKTIE: TIE to acknowledge

      TXTIE: TIE to transmit

      DBTIE: TIE in the LSDB if found

   a.  DBTIE = find TIE in current LSDB

   b.  if DBTIE not found then

       1.  if originator is this node then bump_own_tie with a short
           remaining lifetime



The RIFT Authors         Expires April 22, 2019               [Page 110]

Internet-Draft                    RIFT                      October 2018


       2.  else insert TIE into LSDB and ACKTIE = TIE

       else

       1.  if DBTIE.HEADER = TIE.HEADER then ACKTIE = TIE

       2.  if DBTIE.HEADER < TIE.HEADER then

           i.     if originator is this node then bump_own_tie

           ii.    else insert TIE into LSDB and ACKTIE = TIE

       3.  if DBTIE.HEADER > TIE.HEADER then TXTIE = TIE

   c.  if TXTIE is set then try_to_transmit_tie(TXTIE)

   d.  if ACKTIE is set then ack_tie(TIE)

B.3.5.  TIEs Processing When LSDB Received Newer Version on Other
        Adjacencies

   The Link State Database can be considered to be a switchboard that
   does not need any flooding procedures but can be given new versions
   of TIEs by a peer.  Consecutively, a peer receives from the LSDB
   newer versions of TIEs received by other peeers and processes them
   (without any filtering) just like receving TIEs from its remote peer.
   This publisher model can be implemented in many ways.

Appendix C.  Constants

C.1.  Configurable Protocol Constants

   This section gather constants that are provided in the schema files
   and the document.

















The RIFT Authors         Expires April 22, 2019               [Page 111]

Internet-Draft                    RIFT                      October 2018


   +----------------+--------------+-----------------------------------+
   |                | Type         | Value                             |
   +----------------+--------------+-----------------------------------+
   | LIE IPv4       | Default      | 224.0.0.120 or all-rift-routers   |
   | Multicast      | Value,       | to be assigned in IPv4 Multicast  |
   | Address        | Configurable | Address Space Registry in Local   |
   |                |              | Network Control Block             |
   +----------------+--------------+-----------------------------------+
   | LIE IPv6       | Default      | FF02::A1F7 or all-rift-routers to |
   | Multicast      | Value,       | be assigned in IPv6 Multicast     |
   | Address        | Configurable | Address Assignments               |
   +----------------+--------------+-----------------------------------+
   | LIE            | Default      | 911                               |
   | Destination    | Value,       |                                   |
   | Port           | Configurable |                                   |
   +----------------+--------------+-----------------------------------+
   | Level value    | Constant     | 24                                |
   | for            |              |                                   |
   | TOP_OF_FABRIC  |              |                                   |
   | flag           |              |                                   |
   +----------------+--------------+-----------------------------------+
   | Default LIE    | Default      | 3 seconds                         |
   | Holdtime       | Value,       |                                   |
   |                | Configurable |                                   |
   +----------------+--------------+-----------------------------------+
   | TIE            | Default      | 1 second                          |
   | Retransmission | Value        |                                   |
   | Interval       |              |                                   |
   +----------------+--------------+-----------------------------------+
   | TIDE           | Default      | 3 seconds                         |
   | Generation     | Value,       |                                   |
   | Interval       | Configurable |                                   |
   +----------------+--------------+-----------------------------------+
   | MIN_TIEID      | Constant     | TIE Key with minimal values:      |
   | signifies      |              | TIEID(originator=0,               |
   | start of TIDEs |              | tietype=TIETypeMinValue,          |
   |                |              | tie_nr=0, direction=South)        |
   +----------------+--------------+-----------------------------------+
   | MAX_TIEID      | Constant     | TIE Key with maximal values:      |
   | signifies end  |              | TIEID(originator=MAX_UINT64,      |
   | of TIDEs       |              | tietype=TIETypeMaxValue,          |
   |                |              | tie_nr=MAX_UINT64,                |
   |                |              | direction=North)                  |
   +----------------+--------------+-----------------------------------+

                          Table 6: all_constants





The RIFT Authors         Expires April 22, 2019               [Page 112]

Internet-Draft                    RIFT                      October 2018


Appendix D.  TODO

   o  explain what needs implemented for leaf/spine/superspine/ToF
      version in detail

   o  section on E-W superspine/ToF flooding scope to connect partitions

   o  finish security envelope, move remaining lifetime out the TIE
      packet so it can be modified independently of the SHA-1'd TIE

   o  move adjacency formation rules onto FSM text and remove 2.4.2

   o  add an intermediate state on multiple neighbors

   o  write negative disaggregation example

   o  deal with the case of stale north TIEs stuck more than one level
      up (propagate header description southbound)

Author's Address

   The RIFT Team
   "Heaven is under our feet as well as over our heads"




























The RIFT Authors         Expires April 22, 2019               [Page 113]
