lumas-parameter  =  simple-param / compound-param /
                          reference-param

simple-param = simple-type WS name [ OWS cardinality ] 
                                         [ WS "as" WS explicit-tag ]
                                         [ WS "plugin" ] OWS ";" OWS

simple-type = "void" / "bool" / integer-type / float-type / 
                    "ipv4" / "ipv6" / "date" / "time" / "oid" / 
                    string-type / const-type / bytes-type /
                    embedded-type

integer-type  =  "int" OWS "<" OWS int-constraint OWS ">"

float-type  =  "float" OWS [ "<" OWS float-constraint OWS ">" ]

string-type  =  ( "ascii" / "unquoted-ascii" / "unicode" ) 
                      [ OWS "<" OWS string-constraint OWS ">" ]

const-type = "const" OWS "<" first-safe-char *( safe-char ) ">"
                       ; See the section 'Notes on Comments' below

bytes-type = "bytes" [ OWS "<" OWS length-constraint OWS ">" ]

embedded-type = "embedded" [OWS "<" OWS length-constraint OWS ">"]
int-constraint = min-int-constraint OWS ".." OWS max-int-constraint 
                             [ OWS use-leading-zero-marker ]
min-int-constraint  =  ["-"] pos-number
max-int-constraint  =  ["-"] pos-number
use-leading-zero-marker = "z"

float-constraint = "single" / "double" 

string-constraint = length-constraint [ OWS pattern-constraint ]

length-constraint = 
                [ min-len-constraint OWS ".." OWS ] max-len-constraint
min-len-constraint  =  pos-number
max-len-constraint  =  pos-number  /  "*"

pos-number = 1*DIGIT         ; Decimal number
                   / "0x" 1*HEX    ; Hex number
                   / 1*DIGIT "b"   ; Specifies number of binary bits

pattern-constraint = "/" sub-pattern *( "|" sub-pattern ) "/"
sub-pattern = *pattern-element
pattern-element = pattern-char [ quantifier ]
pattern-char = %x20-29 / %0x2C-2E / %x30-3E / %x40-5A
                         / %x5D-7A / %x7D-FF  ;not \/|[?*+{
                     / escaped-char / special-char / character-class
escaped-char = "\\"     ; Matches \
                   / "\/"     ; Matches /
                   / "\|"     ; Matches |
                   / "\["     ; Matches [
                   / "\?"     ; Matches ?
                   / "\*"     ; Matches *
                   / "\+"     ; Matches +
                   / "\{"     ; Matches {
                   / "\."     ; Matches .
special-char = "\r"     ; Matches the return character
                   / "\n"     ; Matches the new line character
                   / "\t"     ; Matches the tab character
                   / "\f"     ; Matches the form feed character
                   / "\s"     ; Matches white space [ \t\r\n\f]
                   / "\d"     ; Matches any digit [0-9]
                   / "\w"     ; Matches any word character [a-zA-Z_0-9]
                   / "\S"     ; Matches anything not matched by \s
                   / "\D"     ; Matches anything not matched by \d
                   / "\W"     ; Matches anything not matched by \w
                   / "."      ; Matches any character
character-class = matching-character-class / inverse-character-class
matching-character-class = "[" *(class-char / class-range) "]"
                   ; For a successful match, the character in the string 
                   ; being matched must be one of the characters 
                   ; specified in the matching-character-class.
inverse-character-class = "[^" *(class-char / class-range) "]"
                   ; For a successful match, the character in the string 
                   ; being matched must NOT be one of the characters 
                   ; specified in the inverse-character-class.

class-char = class-single-char / class-escaped-char 
                   / escaped-char / special-char 
class-single-char = %x20-2C / %x2E-5B / %x5E-FF ; not - ] \
class-escaped-char = 
                   "\-"       ; Matches -
                   / "\]"     ; Matches ]
                   ; /|[?*+{. need not be escaped within character-class
class-range = first-range-char "-" last-range-char
                   ; The class-range matches all character that have 
                   ; an ASCII value greater or equal to that of 
                   ; first-range-char and less than or equal to 
                   ; last-range-char.
first-range-char = class-single-char / class-escaped-char 
                   / escaped-char
last-range-char = class-single-char / class-escaped-char 
                   / escaped-char

quantifier = "?" / "*" / "+" 
                   / "{" quant-min-occurs [ "," [ quant-max-occurs ] ] "}"
                   ; The absence of a quantifier indicates once and only 
                   ; once
quant-min-occurs = 1*DIGIT
quant-max-occurs = 1*DIGIT

name  =  ALPHA  *(  ALPHA / DIGIT  /  "-"  /  "_"  )

cardinality = "[" ( cardinality-range / "?" / "*" / "+" ) "]"
                      ; [?] short hand for [0..1]
                      ; [*] short hand for [0..*]
                      ; [+] short hand for [1..*]
cardinality-range = [ min-occurrences ".." ] max-occurrences
min-occurrences  =  1*DIGIT
max-occurrences  =  1*DIGIT / "*"

explicit-tag = [ "?" ] tag  ; tag defined in common definitions

reference-param = reference-name WS name [ OWS cardinality ] 
                                         [ WS "as" WS explicit-tag ]
                                         [ WS "plugin" ] OWS ";" OWS
reference-name = [ module-name "::" ] name

compound-param = struct-param / union-param / combined-param

struct-param = "struct" WS name [ OWS cardinality ] 
                                        [ WS "as" WS explicit-tag ] 
                                        [ WS "pluggable" ]
                                        [ WS "plugin" ] 
                                WS "{" struct-body "}" OWS ";" OWS

struct-body = *( untagged-lumas-parameter )
                    *( lumas-parameter ) 
                    *( struct-extension )

untagged-lumas-parameter  =  untagged-simple-param  / 
                                      untagged-compound-param /
                                      untagged-reference-param

untagged-simple-type = simple-type WS name [ OWS cardinality ] 
                                             WS "as" WS "?" OWS ";" OWS

untagged-compound-param = untagged-struct-param / 
                                     untagged-union-param /
                                     untagged-combined-param

untagged-struct-param = 
                           "struct" WS name [ OWS cardinality ] 
                                     WS "as" WS "?"  
                                     [ WS "pluggable" ]
                                     WS "{" struct-body "}" OWS ";" OWS

untagged-union-param = "union" WS name [ OWS cardinality ] 
                                     WS "as" WS "?"
                                     [ WS "pluggable" ]
                                     WS "{" union-body  "}" OWS ";" OWS

untagged-combined-param = 
                              "combi" WS name [ OWS cardinality ] 
                                     WS "as" WS "?"
                                     WS "{" combined-body  "}" OWS ";" OWS

untagged-reference-param = reference-name WS name [ OWS cardinality ] 
                                         OWS ";" OWS

struct-extension = "[" OWS 1*( lumas-parameter ) "]" OWS

union-param = "union" name [ OWS cardinality ] 
                                        [ WS "as" WS explicit-tag ]
                                        [ WS "pluggable" ]
                                        [ WS "plugin" ]
                                WS "{" union-body "}" OWS ";" OWS

select = 12

select = *

union-body = [ integer-type WS name WS "as" WS "?" OWS ";" OWS ]
                   *( singular-lumas-parameter ) 
                   *( union-extension )
      

singular-lumas-parameter  =  singular-simple-param  / 
                                   singular-compound-param /
                                   singlular-reference-param

singular-simple-param = simple-type WS name 
                                        [ WS "as" WS explicit-tag ] 
                                        [ WS  "plugin"  ] OWS ";" OWS

singular-compound-param = singular-struct-param / 
                                singular-union-param /
                                singular-combined-param

singular-struct-param = "struct" WS name [ WS "as" WS explicit-tag ]
                                               [ WS "pluggable" ]
                                               [ WS "plugin" ] 
                                OWS "{" struct-body "}" OWS  ";" OWS

singular-union-param = "union" WS name [ WS "as" WS explicit-tag ] 
                                             [ WS "pluggable" ]
                                             [ WS "plugin" ]
                                OWS "{" union-body "}" OWS ";" OWS

singular-combined-param = "combi" WS name 
                                             [ WS "as" WS explicit-tag ] 
                                             [ WS "plugin" ]
                                OWS "{" combined-body "}" OWS ";" OWS

singular-reference-param = reference-name WS name 
                                         [ WS "as" WS explicit-tag ]
                                         [ WS "plugin" ] OWS ";" OWS

union-extension = "[" OWS 1*( singular-lumas-parameter ) "]" OWS

combined-param = "combi" name [ OWS cardinality ] 
                                        [ WS "as" WS explicit-tag ]
                                        [ WS "plugin" ]
                                WS "{" combined-body "}" OWS ";" OWS

combined-body = *( combined-simple-type WS name ";" )

combined-simple-type = integer-type / const-type / 
                       "unquoted-ascii" OWS "<" 1*DIGIT ">"

referenced-lumas-parameter  =  referenced-simple-param / 
                                   referenced-compound-param /
                                   referenced-reference-param

referenced-simple-param = simple-type WS name OWS ";" OWS

referenced-compound-param = referenced-struct-param / 
                                 referenced-union-param /
                                 referenced-combined-param

referenced-struct-param = "struct" WS name [ WS "pluggable" ]
                                OWS "{" struct-body "}" OWS ";" OWS

referenced-union-param = "union" WS name [ WS "pluggable" ]
                                OWS "{" union-body "}" OWS ";" OWS

referenced-combined-param = "combi" WS name
                                OWS "{" combined-body "}" OWS ";" OWS

referenced-reference-param = reference-name WS name OWS ";" OWS

external-extension = 
                       "plug" WS
                           ( external-struct-extension / 
                             extenal-union-extension )
                       WS "into" WS into-name
                             *( OWS COMMA OWS into-name ) OWS ";" OWS
into-name = [ module-name "::" ] hierarchical-name
hierarchical-name = *( name "." ) name

external-struct-extension = 1*lumas-parameter
external-union-extension = 1*singular-lumas-parameter
      

lumas-directives =
            [ [ "lumas" WS ] "module" WS module-name OWS ";" OWS ]
            [ "extends" WS module-name [ WS "as" WS alias ] OWS ";" OWS ]
            *( "import" WS module-name [ WS "as" WS alias ] OWS ";" OWS )

module-name = [ "+" ] name *( "." name )
alias = name
      

lumas-definition  =  OWS lumas-directives
                              *external-extension
                              *referenced-lumas-parameter

tag  =  value

tag  =  value, value, value

join = { "Alice" }  
msg = { to = 2, 5, 8, 58  
msg = "Where are we going for dinner"
font = 'Arial' }  

lumas-text-message  = struct-body
                          / union-body

struct-body = OWS
                    *( value *( COMMA value ) WS ); Untagged values
                    *( ( tag WS )                 ; For a void parameter
                       / ( tag EQUAL value *( COMMA  value ) WS ) )
                    ; WS not required if it's the last item

union-body =  OWS ( integer-value WS
                         / tag WS                ; For a void parameter
                         / ( tag EQUAL value WS ) )

value = simple-value / compound-value

simple-value = bool-value / integer-value / float-value / 
                     ipv4-value / ipv6-value /   
                     date-value / time-value  / oid-value /
                     ascii-value / unquoted-ascii-value / unicode-value /
                     const-value / bytes-value / embedded-value

bool-value = "True" / "False" / "T" / "F"

integer-value = [ "-" ] 1*DIGIT
float-value = float-number  
                    / "NaN"       ; IEEE 754 Not a Number
                    / "INF"       ; Positive infinity
                    / "-INF"      ; Negative infinity
                    ; Note that "-0" is included in float-number
float-number   = float-mantissa [ ("e"/"E") float-exponent ]
float-mantissa = ["-"] 1*DIGIT ["." 1*DIGIT]
float-exponent = ["-"/"+"] 1*DIGIT

oid-value = 1*DIGIT *( "~" 1*DIGIT )    

ipv4-value = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT

ipv6-value = hexseq / hexseq "::" [ hexseq ] / "::" [ hexseq ]
hexseq         =  hex4 *( ":" hex4)
hex4           =  1*4HEXDIG

date-value = date-year "-" date-month "-" date-day-of-month
date-year = 4DIGIT            ; e.g. 2002
date-month = 2DIGIT           ; With leading zeros, 01 to 12
date-day-of-month = 2DIGIT    ; With leading zeros, 01 to 31

time-value = time-hours ":" time-minutes [ ":" time-seconds ]
time-hours = 2DIGIT         ; With leading zeros, e.g. 00 to 23
time-minutes = 2DIGIT       ; With leading zeros, e.g. 00 to 59
time-seconds = 2DIGIT       ; With leading zeros, e.g. 00 to 59

unquoted-ascii-value =  first-safe-char *( safe-char )
                       ; See the section 'Notes on Comments' below

ascii-value = 
           "'" *( %x00-26 / %x28-5B / %x2D-x7F / "\\" / "\'" ) "'"

unicode-value = DQUOTE
                 *( %x00-21 / %x23-5B / %x5D-xFF / "\\" / "\" DQUOTE ) 
                  DQUOTE
                             ; DQUOTE defined in [ABNF]

bytes-value = "[" OWSNC base64-line *( WSNC base64-line ) OWSNC "]"
base64-line = 0*18( 4BASE64-CHAR ) 
                     ( 
                     ( 4BASE64-CHAR ) /
                     ( 3BASE64-CHAR "=" ) /
                     ( 2BASE64-CHAR "=" "=" )
                     )
BASE64-CHAR = ALPHA / DIGIT / "+" / "/"

const-value = first-safe-char *( safe-char )
                       ; See the section 'Notes on Comments' below

embedded-value = "(" *(%x00-FF) ")" 

compound-value = struct-value / union-value / combined-value

struct-value = "{" struct-body "}" 

union-value = union-body

combined-value = first-safe-char *( safe-char )

EQUAL = OWS "=" OWS
COMMA = OWS "," OWS

delimited-lumas-text-message = lumas-text-message ( "}" / ")" )

my-bool = True

my-int = 5643

my-float = 102.4519

my-ipv4 = 10.0.0.1

my-ipv6 = 201:123::

my-date = 2002-02-28

my-time = 12:00:00

my-oid = 1~2~840~113549~2~5

my-ascii = 'Lumas'

my-unquoted-ascii = Lumas
my-unicode = "Lumas"

my-const = Lumas

my-bytes = [ 01AF3C== ]

my-embedded = ( my-other-int=5 single-closing-bracket-text=')' )

my-struct = { 5434 All time=98787654654 }

my-union = 5434

my-union = Switch

my-union = Volume = 11

tag = first-tag-safe-char 0*62( safe-char )
                         ; Tag MUST NOT exceed 63 characters in length

first-tag-safe-char = %x21 / 
                  ; Not "
                  %x23-26 / 
                  ; Not ' ( )
                  %x28-2B
                  ; Not , -
                  %x2E-2F /
                  ; Not 0 1 2 3 4 5 6 7 8 9
                  %x3A-3C / 
                  ; Not =
                  %x3E-5A
                  ; Not [
                  %x5C-7A /
                  ; Not {
                  %x7C /
                  ; Not }
                  %x7E-7F
                  ; Visible characters except = , " ' { } ( ) [ -
                  ; and digits (tags must not get confused with integers)

first-safe-char = first-tag-safe-char / DIGIT / "-"

safe-char = first-safe-char / DQUOTE / "'" / "{" / "(" / "["
                        ; Not = } ) ,
WS = 1*( comment / SP / HTAB / CR / LF )  
                                  ; HTAB, CR, LF defined in [ABNF]
OWS = [ WS ]                ; Optional white space

WSNC = 1*( SP / HTAB / CR / LF )    ; Whitespace - no comment
OWSNC = [ WSNC ]            ; Optional white space - no comment

comment = c-comment / cpp-comment
c-comment = "/*" <any except */> (nested-end / hard-end )
nested-end = "*/"
hard-end = "**/"
cpp-comment = "//" *( HTAB / %x20-7F ) ( CR / LF )
                ; A comment is treated as a single space during parsing

ascii-value = /*This-is-a-comment*/This-is-the-value

ascii-value = and-//this-is-part-of-the-value

