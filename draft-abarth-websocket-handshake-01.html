<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>The WebSocket protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="The WebSocket protocol">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">HyBi Working Group</td><td class="header">A. Barth</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Google, Inc.</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">November 9, 2010</td></tr>
<tr><td class="header">Expires: May 13, 2011</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />The WebSocket protocol<br />draft-abarth-websocket-handshake-01</h1>

<h3>Abstract</h3>

<p>The WebSocket protocol enables two-way communication between a user
      agent running untrusted code running in a controlled environment to a
      remote host that has opted-in to communications from that code. The
      security model used for this is the Origin-based security model commonly
      used by Web browsers. The protocol consists of an initial handshake
      followed by basic message framing, layered over TCP. The goal of this
      technology is to provide a mechanism for browser-based applications that
      need two-way communication with servers that does not rely on opening
      multiple HTTP connections (e.g. using XMLHttpRequest or &lt;iframe&gt;s
      and long polling).
</p>
<p>Please send feedback to the hybi@ietf.org mailing list.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on May 13, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#handshake">1.</a>&nbsp;
Opening Handshake<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">1.1.</a>&nbsp;
Client Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.2.</a>&nbsp;
Server-side requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.1.</a>&nbsp;
Reading the client&#039;s opening handshake<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.2.2.</a>&nbsp;
Sending the server&#039;s opening handshake<br />
<a href="#rfc.references1">2.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="handshake"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Opening Handshake</h3>

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Client Requirements</h3>

<p>
          User agents running in controlled environments, e.g. browsers on
          mobile handsets tied to specific carriers, may offload the
          management of the connection to another agent on the network. In
          such a situation, the user agent for the purposes of conformance
          is considered to include both the handset software and any such
          agents.
        
</p>
<p>
          When the user agent is to <strong>establish a WebSocket
          connection</strong> to a host /host/, on a port /port/, from an origin
          whose ASCII serialization is /origin/, with a flag /secure/, with a
          string giving a /resource name/, with a (possibly empty) list of
          strings giving the /protocols/, and optionally with a /defer cookies/
          flag, it must run the following steps. <a class='info' href='#ORIGIN'>[ORIGIN]<span> (</span><span class='info'>Barth, A., Jackson, C., and I. Hickson, &ldquo;The HTTP Origin Header,&rdquo; September&nbsp;2009.</span><span>)</span></a>
        
</p>
<p>
          </p>
<ol class="text">
<li>
              Verify that the WebSocket URL and its components are valid
              according to ???. If any of the requirements are not met, the
              client MUST fail the WebSocket connection and abort these steps.
            
</li>
<li>
              If the user agent already has a WebSocket connection to the
              remote host (IP address) identified by /host/, even if known by
              another name, wait until that connection has been established or
              for that connection to have failed. If multiple connections to
              the same IP address are attempted simultaneously, the user agent
              must serialize them so that there is no more than one connection
              at a time running through the following steps.
              <br />
<br />

              If the user agent cannot determine the IP address of the remote
              host (for example because all communication is being done through
              a proxy server that performs DNS queries itself), then the user
              agent must assume for the purposes of this step that each host
              name refers to a distinct remote host, but should instead limit
              the total number of simultaneous connections that are not
              established to a reasonably low number (e.g., in a Web browser, to
              the number of tabs the user has open).
              <br />
<br />

              NOTE: This makes it harder for a script to perform a denial of
              service attack by just opening a large number of WebSocket
              connections to a remote host. A server can further
              reduce the load on itself when attacked by making use of this by
              pausing before closing the connection, as that will reduce the
              rate at which the client reconnects.
              <br />
<br />

              NOTE: There is no limit to the number of established WebSocket
              connections a user agent can have with a single remote host.
              Servers can refuse to connect users with an excessive number of
              connections, or disconnect resource-hogging users when suffering
              high load.
            
</li>
<li>
              <em>Connect</em>: If the user agent is
              configured to use a proxy when using the WebSocket protocol to
              connect to host /host/ and/or port /port/, then connect to that
              proxy and ask it to open a TCP connection to the host given by
              /host/ and the port given by /port/.
<blockquote class="text">
<p>
                  EXAMPLE: For example, if the user agent uses an HTTP proxy
                  for all traffic, then if it was to try to connect to port 80
                  on server example.com, it might send the following lines to
                  the proxy server:<br />
<br />

                  </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
</pre></div><p>

                
</p>
<p>
                  If there was a password, the connection might look
                  like:<br />
<br />

                  </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
           Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=
</pre></div><p>

                
</p>
</blockquote>
              Otherwise, if the user agent is not configured to use a proxy,
              then open a TCP connection to the host given by /host/ and the
              port given by /port/.
              <br />
<br />

              NOTE: Implementations that do not expose explicit UI for
              selecting a proxy for WebSocket connections separate from other
              proxies are encouraged to use a SOCKS proxy for WebSocket
              connections, if available, or failing that, to prefer the proxy
              configured for HTTPS connections over the proxy configured for
              HTTP connections.
              <br />
<br />

              For the purpose of proxy autoconfiguration scripts, the URL to
              pass the function must be constructed from /host/, /port/,
              /resource name/, and the /secure/ flag using the steps to
              construct a WebSocket URL.
              <br />
<br />

              NOTE: The WebSocket protocol can be identified in proxy
              autoconfiguration scripts from the scheme (&quot;ws:&quot; for
              unencrypted connections and &quot;wss:&quot; for encrypted
              connections).
            
</li>
<li>If the connection could not be opened, then fail the WebSocket
            connection and abort these steps.
</li>
<li>
              If /secure/ is true, perform a TLS handshake over the connection.
              If this fails (e.g. the server&#039;s certificate could not be
              verified), then fail the WebSocket connection and abort these
              steps. Otherwise, all further communication on this channel must
              run through the encrypted tunnel. <a class='info' href='#RFC2246'>[RFC2246]<span> (</span><span class='info'>Dierks, T. and C. Allen, &ldquo;The TLS Protocol Version 1.0,&rdquo; January&nbsp;1999.</span><span>)</span></a>
              <br />
<br />

              User agents must use the Server Name Indication extension in the
              TLS handshake. <a class='info' href='#RFC4366'>[RFC4366]<span> (</span><span class='info'>Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, &ldquo;Transport Layer Security (TLS) Extensions,&rdquo; April&nbsp;2006.</span><span>)</span></a>
            
</li>
<li>
              Let the client-nonce be a 16 byte sequence chosen uniformly at random.
            
</li>
<li>
              Send the following strings (in order):
              
<ol class="text">
<li>Send the UTF-8 string &quot;CONNECT websocket.invalid:443 HTTP/1.1&quot;.
</li>
<li>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).
</li>
<li>Send the UTF-8 string &quot;Host: websocket.invalid:443&quot;.
</li>
<li>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).
</li>
<li>Send the UTF-8 string &quot;Sec-WebSocket-Key: &quot;.
</li>
<li>Send the client-nonce encoded in base64.
</li>
<li>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).
</li>
<li>Send the UTF-8 string &quot;Sec-WebSocket-Metadata: &quot;.
</li>
</ol>
            
</li>
<li>Let /hostport/ be an empty string.
</li>
<li>Append the /host/ value, converted to ASCII lowercase, to /hostport/.
</li>
<li>If /secure/ is false, and /port/ is not 80, or if /secure/ is
            true, and /port/ is not 443, then append a U+003A COLON character
            (:) followed by the value of /port/, expressed as a base-ten
            integer, to /hostport/.
</li>
<li>
              Let the metadata-dictionary be the following dictionary:
              
<ol class="text">
<li>Key "resource_name" maps to value /resource name/.
</li>
<li>Key "host" maps to value /host/.
</li>
<li>Key "origin" maps to value /origin/.
</li>
<li>Key "protocols" maps to the array containing each protocol in /protocols/.
</li>
<li>If the client has any cookies that would be relevant to a
                resource accessed over HTTP, if /secure/ is false, or HTTPS,
                if it is true, on host /host/, port /port/, with /resource
                name/ as the path (and possibly query parameters), then key
                "cookie" maps to the cookie-string for that resource (including
                http-only cookies).
</li><a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a><a class='info' href='#RFC2109'>[RFC2109]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; February&nbsp;1997.</span><span>)</span></a><a class='info' href='#RFC2965'>[RFC2965]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; October&nbsp;2000.</span><span>)</span></a>
</ol>
            
</li>
<li>
              Let the metadata-string be the JSON serialization of the
              metadata-dictionary in UTF-8.
            
</li>
<li>
              Let the handshake-mask be the HMAC-SHA1 of the UTF-8 string
              &quot;C1BA787A-0556-49F3-B6AE-32E5376F992B&quot; keyed with the
              client-nonce.
            
</li>
<li>
              Let the masked-metadata be a sequence of bytes where the /i/th
              byte is the XOR of the /i/th byte of the metadata-string with the
              /i mod 20/th byte of the handshake-mask.
            
</li>
<li>
              Send the following strings (in order):
              
<ol class="text">
<li>Send the masked metadata encoded in base64.
</li>
<li>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).
</li>
<li>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).
</li>
</ol>
            
</li>
<li>
              Read bytes from the server until either the connection closes or
              until 17 bytes are read.  If the read bytes are not exactly the
              UTF-8 string &quot;HTTP/1.1 200 OK&quot; followed by a
              UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character
              pair (CRLF), then <em>fail the WebSocket
              connection</em> and abort these steps.
              <br />
<br />

              User agents may apply a timeout to this step, failing the
              WebSocket connection if the server does not send back data in a
              suitable time period.
            
</li>
<li>Let /fields/ be a list of name-value pairs, initially empty.
</li>
<li>
              <em>Field</em>: Let /name/ and /value/ be empty byte arrays.
            
</li>
<li>
              Read bytes from the server.
              <br />
<br />

              If the connection closes before this byte is received, then fail the WebSocket connection and abort these steps.
              <br />
<br />

              Otherwise, handle the byte as described in the appropriate entry below:
<blockquote class="text"><dl>
<dt>-> If the byte is 0x0D (UTF-8 CR)</dt>
<dd>
                  If the /name/ byte array is empty, then jump to the fields processing step. Otherwise, fail the WebSocket connection and abort these steps.
                
</dd>
<dt>-> If the byte is 0x0A (UTF-8 LF)</dt>
<dd>
                  Fail the WebSocket connection and abort these steps.
                
</dd>
<dt>-> If the byte is 0x3A (UTF-8 :)</dt>
<dd>
                  Move on to the next step.
                
</dd>
<dt>-> If the byte is in the range 0x41 to 0x5A (UTF-8 A-Z)</dt>
<dd>
                  Append a byte whose value is the byte&#039;s value plus 0x20 to the /name/ byte array and redo this step for the next byte.
                
</dd>
<dt>-> Otherwise</dt>
<dd>
                  Append the byte to the /name/ byte array and redo this step for the next byte.
                
</dd>
</dl></blockquote>
              NOTE: This reads a field name, terminated by a colon, converting upper-case  letters in the range A-Z to lowercase, and aborting if a stray CR or LF is found.
            
</li>
<li>
              Let /count/ equal 0.
              <br />
<br />

              NOTE: This is used in the next step to skip past a space character after the colon, if necessary.
            
</li>
<li>
              Read a byte from the server and increment /count/ by 1.
              <br />
<br />

              If the connection closes before this byte is received, then fail the WebSocket connection and abort these steps.
              <br />
<br />

              Otherwise, handle the byte as described in the appropriate entry below:
<blockquote class="text"><dl>
<dt>-> If the byte is 0x20 (UTF-8 space) and /count/ equals 1</dt>
<dd>
                  Ignore the byte and redo this step for the next byte.
                
</dd>
<dt>-> If the byte is 0x0D (UTF-8 CR)</dt>
<dd>
                  Move on to the next step.
                
</dd>
<dt>-> If the byte is 0x0A (UTF-8 LF)</dt>
<dd>
                  Fail the WebSocket connection and abort these steps.
                
</dd>
<dt>-> Otherwise</dt>
<dd>
                  Append the byte to the /value/ byte array and redo this step for the next byte.
                
</dd>
</dl></blockquote>
              NOTE: This reads a field value, terminated by a CRLF, skipping past a single space after the colon if there is one.
            
</li>
<li>
              Read a byte from the server.
              <br />
<br />

              If the connection closes before this byte is received, or if the byte is not a 0x0A byte (UTF-8 LF), then fail the WebSocket connection and abort these steps.
              <br />
<br />

              NOTE: This skips past the LF byte of the CRLF after the field.
            
</li>
<li>Append an entry to the /fields/ list that has the name given by the string obtained by interpreting the /name/ byte array as a UTF-8 byte stream and the value given by the string obtained by interpreting the /value/ byte array as a UTF-8 byte stream.
</li>
<li>Return to the &quot;Field&quot; step above.
</li>
<li>
              <em>Fields processing</em>: Read a byte from the server.
              <br />
<br />

              If the connection closes before this byte is received, or if the byte is not a 0x0A byte (UTF-8 LF), then fail the WebSocket connection and abort these steps.
              <br />
<br />

              NOTE: This skips past the LF byte of the CRLF after the blank line after the fields.
            
</li>
<li>
              Let the /list of cookies/ be empty.
            
</li>
<li>
              If there is not exactly one entry in the /fields/ list whose
              name is &quot;sec-websocket-accept&quot;, or if there is not exactly one
              entry in the /fields/ list whose name is &quot;sec-websocket-key&quot;,
              or if there is not exactly one entry in the /fields/ list whose
              name is &quot;sec-websocket-origin&quot;, or if there is not
              exactly one entry in the /fields/ list whose name is
              &quot;sec-websocket-location&quot;, or if the /protocol/ was
              specified but there is not exactly one entry in the /fields/
              list whose name is &quot;sec-websocket-protocol&quot;, or if
              there are any entries in the /fields/ list whose names are the
              empty string, then fail the WebSocket connection and abort these
              steps. Otherwise, handle each entry in the /fields/ list as
              follows:
              
<blockquote class="text"><dl>
<dt>-> If the entry&apos;s name is &quot;sec-websocket-accept&quot;</dt>
<dd>
                  If the value is not exactly equal to
                  the base64 encoding of the HMAC-SHA1 of the UTF-8 string
                  &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; keyed with
                  the client-nonce, then <em>fail the
                  WebSocket connection</em> and abort these steps.
                
</dd>
<dt>-> If the entry&apos;s name is &quot;sec-websocket-key&quot;</dt>
<dd>
                  
                  If the read bytes are not the base64 encoding of a 16 byte
                  sequence, then <em>fail the WebSocket
                  connection</em> and abort these steps.  Otherwise, let
                  the server-nonce be that 16 byte sequence.  If the
                  server-nonce is identical to the client-nonce, then <em>fail the WebSocket connection</em> and abort
                  these steps.
                
</dd>
<dt>-> If the entry&apos;s name is &quot;sec-websocket-origin&quot;</dt>
<dd>
                  If the value is not exactly equal to /origin/, then fail the WebSocket connection and abort these steps. <a class='info' href='#ORIGIN'>[ORIGIN]<span> (</span><span class='info'>Barth, A., Jackson, C., and I. Hickson, &ldquo;The HTTP Origin Header,&rdquo; September&nbsp;2009.</span><span>)</span></a>
                
</dd>
<dt>-> If the entry&apos;s name is &quot;sec-websocket-location&quot;</dt>
<dd>
                  If the value is not exactly equal to a string obtained from the steps to construct a WebSocket URL from /host/, /port/, /resource name/, and the /secure/ flag, then fail the WebSocket connection and abort these steps.
                
</dd>
<dt>-> If the entry&apos;s name is &quot;sec-websocket-protocol&quot;</dt>
<dd>
                  If there was a /protocols/ string specified, and the value is not exactly equal to one of the items in /protocols/, then fail the WebSocket connection and abort these steps. (If no /protocols/ was specified, the field is ignored.)
                
</dd>
<dt>-> If the entry&apos;s name is &quot;set-cookie&quot; or &quot;set-cookie2&quot; or another cookie-related field name</dt>
<dd>
                  If the relevant specification is supported by the user agent, add the cookie, interpreted as defined by the appropriate specification, to the /list of cookies/, with the resource being the one with the host /host/, the port /port/, the path (and possibly query parameters) /resource name/, and the scheme |http| if /secure/ is false and |https| if /secure/ is true. <a class='info' href='#RFC2109'>[RFC2109]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; February&nbsp;1997.</span><span>)</span></a> <a class='info' href='#RFC2965'>[RFC2965]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; October&nbsp;2000.</span><span>)</span></a>
                  <br />
<br />

                  If the relevant specification is not supported by the user agent, then the field must be ignored.
                  <br />
<br />

                  The cookies added to the /list of cookies/ are discarded if the connection fails to be established. Only if and when the connection is established do the cookies actually get applied.
                
</dd>
<dt>-> Any other name</dt>
<dd>
                  Ignore it.
                
</dd>
</dl></blockquote>
              <br />
<br />

            
</li>
<li>
              If the /defer cookies/ flag is not set, apply the cookies in the /list of cookies/.
            
</li>
<li>
              The <strong>WebSocket connection is
              established</strong>. Now the user agent must send and receive to
              and from the connection as described in the next section.  The
              handshake has established two keys:
              
<ul class="text">
<li>The client-to-server-mask is the intial 16 bytes of the
                HMAC-SHA1 of the UTF-8 string
                &quot;363A6078-74D2-4C0B-8CBC-1E6A36E83442&quot; keyed with
                the concatenation of the client-nonce and the
                server-nonce.
</li>
<li>The server-to-client-mask is the initial 16 bytes of the
                HMAC-SHA1 of the UTF-8 string
                &quot;2306C3BE-0ACF-42C0-B69E-DFFE02CFA346&quot; keyed with
                the concatentation of the client-nonce and the
                server-nonce.
</li>
</ul>
              All subsequent bytes sent from the user agent to the server are
              masked as follows:
              
<ol class="text">
<li>The /i/th byte is XORed with the /i mod 20/th byte of the
                client-to-server-mask.
</li>
</ol>
              All subsequence bytes read by the user agent from the
              server are unmasked as follows:
              
<ol class="text">
<li>The /i/th byte is XORed with the /i mod 20/th byte of the
                server-to-client-mask.
</li>
</ol>
            
</li>
<li>
              If the /defer cookies/ flag is set, store the /list of cookies/ for use by the component that invoked this algorithm.
            
</li>
</ol><p>
        
</p>
<p>
          Where the algorithm above requires that a user agent fail the
          WebSocket connection, the user agent may first read an arbitrary
          number of further bytes from the connection (and then discard them)
          before actually <strong>failing the WebSocket
          connection</strong>.  Similarly, if a user agent can show that the
          bytes read from the connection so far are such that there is no
          subsequent sequence of bytes that the server can send that would not
          result in the user agent being required to <strong>fail
          the WebSocket connection</strong>, the user agent may immediately
          <strong>fail the WebSocket connection</strong> without
          waiting for those bytes.
        
</p>
<p>
          NOTE: The previous paragraph is intended to make it conforming for
          user agents to implement the algorithm in subtlely different ways
          that are equivalent in all ways except that they terminate the
          connection at earlier or later points. For example, it enables an
          implementation to buffer the entire handshake response before
          checking it, or to verify each field as it is received rather than
          collecting all the fields and then checking them as a block.
        
</p>
<p>
          When the user agent is to &quot;apply the cookies&quot; in a /list of
          cookies/, it must handle each cookie in the /list of cookies/ as
          defined by the appropriate specification. <a class='info' href='#RFC2109'>[RFC2109]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; February&nbsp;1997.</span><span>)</span></a>
          <a class='info' href='#RFC2965'>[RFC2965]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; October&nbsp;2000.</span><span>)</span></a>
        
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Server-side requirements</h3>

<p>
          <em>This section only applies to servers.</em>
        
</p>
<p>
          Servers may offload the management of the connection to other
          agents on the network, for example load balancers and reverse
          proxies. In such a situation, the server for the purposes of
          conformance is considered to include all parts of the server-side
          infrastructure from the first device to terminate the TCP connection
          all the way to the server that processes requests and sends
          responses.
        
</p>
<p>
          EXAMPLE: For example, a data center might have a server that responds to
          Web Socket requests with an appropriate handshake, and then passes
          the connection to another server to actually process the data
          frames. For the purposes of this specification, the "server" is the
          combination of both computers.
        
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.1"></a><h3>1.2.1.&nbsp;
Reading the client&#039;s opening handshake</h3>

<p>When a client starts a WebSocket connection, it sends its part of
          the opening handshake. The server must parse at least part of this
          handshake in order to obtain the necessary information to generate
          the server part of the handshake.
</p>
<p>
            The client handshake consists of the following parts. If the
            server, while reading the handshake, finds that the client did not
            send a handshake that matches the description below, the server
            should abort the WebSocket connection.
            </p>
<ol class="text">
<li>The UTF-8 string &quot;CONNECT websocket.invalid:443 HTTP/1.1&quot;.
</li>
<li>A UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).
</li>
<li>The UTF-8 string &quot;Host: websocket.invalid:443&quot;.
</li>
<li>A UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).
</li>
<li>The UTF-8 string &quot;Sec-WebSocket-Key: &quot;.
</li>
<li>A string of base64 encoded bytes terminated by a
              UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character
              pair (CRLF). The decoded bytes are the client-nonce.
</li>
<li>The UTF-8 string &quot;Sec-WebSocket-Metadata: &quot;.
</li>
<li>A string of base64 encoded bytes terminated by a
              UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character
              pair (CRLF). The decoded bytes are the masked-metadata.
</li>
</ol><p>
          
</p>
<p>
            Let the handshake-mask be the HMAC-SHA1 of the UTF-8 string
            &quot;C1BA787A-0556-49F3-B6AE-32E5376F992B&quot; keyed with the
            client-nonce.
          
</p>
<p>
            Let the metadata-string be the masked-metadata unmasked by XORing
            the /i/th byte of the masked-metadata with the /i mod 20/th byte of
            the handshake-mask.
          
</p>
<p>
            Let the metadata-dictionary by the result of parsing the
            metadata-string as a UTF-8 encoded JSON string.
          
</p>
<p>
            The expected dictionary keys, and the meaning of their
            corresponding values, are as follows.
            </p>
<blockquote class="text"><dl>
<dt>|host|</dt>
<dd>
                The value gives the hostname that the
                client intended to use when opening the WebSocket. It would be
                of interest in particular to virtual hosting environments,
                where one server might serve multiple hosts, and might
                therefore want to return different data.
                <br />
<br />

                Can be safely ignored, though the server should abort the
                WebSocket connection if this field is absent or has a value
                that does not match the server&#039;s host name, to avoid
                vulnerability to cross-protocol attacks and DNS rebinding
                attacks.
              
</dd>
<dt>|origin|</dt>
<dd>
                The value gives the scheme, hostname,
                and port (if it&#039;s not the default port for the given
                scheme) of the page that asked the client to open the
                WebSocket. It would be interesting if the server&#039;s
                operator had deals with operators of other sites, since the
                server could then decide how to respond (or indeed, <em>whether</em> to respond) based on which site
                was requesting a connection. <a class='info' href='#ORIGIN'>[ORIGIN]<span> (</span><span class='info'>Barth, A., Jackson, C., and I. Hickson, &ldquo;The HTTP Origin Header,&rdquo; September&nbsp;2009.</span><span>)</span></a>
                <br />
<br />

                Can be safely ignored, though the server should abort the
                WebSocket connection if this field is absent or has a value
                that does not match one of the origins the server is expecting
                to communicate with, to avoid vulnerability to cross-protocol
                attacks and cross-site scripting attacks.
              
</dd>
<dt>|protocols|</dt>
<dd>
                The value gives an array of the
                subprotocols that the client is intending to select. It would
                be interesting if the server supports multiple protocols or
                protocol versions.
                <br />
<br />

                Can be safely ignored, though the server may abort the
                WebSocket connection if the field is absent but the conventions
                for communicating with the server are such that the field is
                expected; and the server should abort the WebSocket connection
                if the field has a value that does not match one of the
                subprotocols that the server supports, to avoid integrity
                errors once the connection is established.
              
</dd>
<dt>Other keys</dt>
<dd>
                Other fields can be used, such as
                &quot;cookie&quot;, for authentication purposes. Their
                semantics are equivalent to the semantics of the HTTP headers
                with the same names.
              
</dd>
</dl></blockquote><p>
          
</p>
<p>Unrecognized fields can be safely ignored, and are probably either
          the result of clients that support future versions of the protocol
          offering options that the server doesn&#039;t support.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.2"></a><h3>1.2.2.&nbsp;
Sending the server&#039;s opening handshake</h3>

<p>
            When a client establishes a WebSocket connection to a server, the
            server must run the following steps.
            </p>
<ol class="text">
<li>
                If the server supports encryption, perform a TLS handshake over
                the connection. If this fails (e.g. the client indicated a host
                name in the extended client hello &quot;server_name&quot;
                extension that the server does not host), then close the
                connection; otherwise, all further communication for the
                connection (including the server handshake) must run through
                the encrypted tunnel. <a class='info' href='#RFC2246'>[RFC2246]<span> (</span><span class='info'>Dierks, T. and C. Allen, &ldquo;The TLS Protocol Version 1.0,&rdquo; January&nbsp;1999.</span><span>)</span></a>
              
</li>
<li>
                Establish the following information:
<blockquote class="text"><dl>
<dt>/host/</dt>
<dd>
                    The host name or IP address of the
                    WebSocket server, as it is to be addressed by clients. The
                    host name must be punycode-encoded if necessary. If the
                    server can respond to requests to multiple hosts (e.g. in a
                    virtual hosting environment), then the value should be
                    derived from the client&#039;s handshake, specifically from
                    the &quot;Host&quot; field. The /host/ value must be
                    lowercase (not containing characters in the range U+0041
                    LATIN CAPITAL LETTER A to U+005A LATIN CAPITAL LETTER Z).
                  
</dd>
<dt>/port/</dt>
<dd>
                    The port number on which the server
                    expected and/or received the connection.
                  
</dd>
<dt>/resource name/</dt>
<dd>
                    An identifier for the service
                    provided by the server. If the server provides multiple
                    services, then the value should be derived from the
                    resource name given in the client&#039;s handshake.
                  
</dd>
<dt>/secure flag/</dt>
<dd>
                    
                  
</dd>
<dt></dt>
<dd>
                    True if the connection is encrypted
                    or if the server expected it to be encrypted; false
                    otherwise.
                  
</dd>
<dt>/origin/</dt>
<dd>
                    The ASCII serialization of the
                    origin that the server is willing to communicate with,
                    converted to ASCII lowercase. If the server can respond to
                    requests from multiple origins (or indeed, all origins),
                    then the value should be derived from the client&#039;s
                    handshake, specifically from the &quot;Origin&quot; field.
                    <a class='info' href='#ORIGIN'>[ORIGIN]<span> (</span><span class='info'>Barth, A., Jackson, C., and I. Hickson, &ldquo;The HTTP Origin Header,&rdquo; September&nbsp;2009.</span><span>)</span></a>
                  
</dd>
<dt>/subprotocol/</dt>
<dd>
                    Either null, or a string
                    representing the subprotocol the server is ready to use. If
                    the server supports multiple subprotocols, then the value
                    should be derived from the client&#039;s handshake,
                    specifically by selecting one of the values from the
                    &quot;protocols&quot; array. The absence of such a field is
                    equivalent to the null value. The empty string is not the
                    same as the null value for these purposes.
                  
</dd>
</dl></blockquote>
              
</li>
<li>Let /location/ be the string that results from constructing a
              WebSocket URL from /host/, /port/, /resource name/, and /secure flag/.
</li>
<li>
                Let acceptance-proof be the base64 encoding of the HMAC-SHA1 of the UTF-8 string
                &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; keyed with the client-nonce.
              
</li>
<li>
                Let server-nonce be a sequence of 16 bytes chosen uniformly at
                random.
              
</li>
<li>
                Send the following line, terminated by the two characters
                U+000D CARRIAGE RETURN and U+000A LINE FEED (CRLF) and encoded
                as UTF-8, to the client:<br />
<br />

                <div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        HTTP/1.1 200 OK</pre></div>
              
</li>
<li>
                Send the following fields to the client. Each field must be
                sent as a line consisting of the field name, which must be an
                ASCII case-insensitive match for the field name in the list
                below, followed by a U+003A COLON character (:) and a U+0020
                SPACE character, followed by the field value as specified in
                the list below, followed by the two characters U+000D CARRIAGE
                RETURN and U+000A LINE FEED (CRLF). The lines must be encoded
                as UTF-8. The lines may be sent in any order.
<blockquote class="text"><dl>
<dt>|Sec-WebSocket-Accept|</dt>
<dd>
                    The value must be the acceptance-proof.
                  
</dd>
<dt>|Sec-WebSocket-Key|</dt>
<dd>
                    The value must be the server-nonce encoded in base64.
                  
</dd>
<dt>|Sec-WebSocket-Location|</dt>
<dd>
                    The value must be /location/
                  
</dd>
<dt>|Sec-WebSocket-Origin|</dt>
<dd>
                    The value must be /origin/
                  
</dd>
<dt>|Sec-WebSocket-Protocol|</dt>
<dd>
                    This field must be included if
                    /subprotocol/ is not null, and must not be included if
                    /subprotocol/ is null.
                    <br />
<br />

                    If included, the value must be /subprotocol/
                  
</dd>
</dl></blockquote>
                Optionally, include &quot;Set-Cookie&quot;,
                &quot;Set-Cookie2&quot;, or other cookie-related fields, with
                values equal to the values that would be used for the
                identically named HTTP headers. <a class='info' href='#RFC2109'>[RFC2109]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; February&nbsp;1997.</span><span>)</span></a> <a class='info' href='#RFC2965'>[RFC2965]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; October&nbsp;2000.</span><span>)</span></a>
              
</li>
<li>Send two bytes 0x0D 0x0A (UTF-8 CRLF).
</li>
<li>Send /response/.
</li>
</ol><p>
          
</p>
<p>This completes the server&#039;s handshake. If the server
          finishes these steps without aborting the WebSocket connection, and
          if the client does not then fail the WebSocket connection, then the
          connection is established and the server may begin sending and
          receiving data, as described in the next section.  The handshake has
          established two keys:
          </p>
<ul class="text">
<li>The client-to-server-mask is the HMAC-SHA1 of the UTF-8 string
            &quot;363A6078-74D2-4C0B-8CBC-1E6A36E83442&quot; keyed with
            the concatenation of the client-nonce and the
            server-nonce.
</li>
<li>The server-to-client-mask is the HMAC-SHA1 of the UTF-8 string
            &quot;2306C3BE-0ACF-42C0-B69E-DFFE02CFA346&quot; keyed with
            the concatentation of the client-nonce and the
            server-nonce.
</li>
</ul><p>
          All subsequent bytes read by the server from the user agent are
          unmasked as follows:
          </p>
<blockquote class="text">
<p>The /i/th byte is XORed with the /i mod 20/th byte of the
            client-to-server-mask.
</p>
</blockquote><p>
          All subsequence bytes sent from the server to the user agent are
          masked as follows:
          </p>
<blockquote class="text">
<p>The /i/th byte is XORed with the /i mod 20/th byte of the
            server-to-client-mask.
</p>
</blockquote><p>
          
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>2.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="HTML">[HTML]</a></td>
<td class="author-text">Hickson, I., &ldquo;<a href="http://whatwg.org/html5">HTML</a>,&rdquo; August&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="ORIGIN">[ORIGIN]</a></td>
<td class="author-text">Barth, A., Jackson, C., and I. Hickson, &ldquo;<a href="http://tools.ietf.org/html/draft-abarth-origin">The HTTP Origin Header</a>,&rdquo; draft-abarth-origin (work in progress), September&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="ANSI.X3-4.1986">[ANSI.X3-4.1986]</a></td>
<td class="author-text">American National Standards Institute, &ldquo;Coded Character Set - 7-bit American Standard Code for Information Interchange,&rdquo; ANSI&nbsp;X3.4, 1986.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1321">[RFC1321]</a></td>
<td class="author-text"><a href="mailto:rivest@theory.lcs.mit.edu">Rivest, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>,&rdquo; RFC&nbsp;1321, April&nbsp;1992 (<a href="http://www.rfc-editor.org/rfc/rfc1321.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1951">[RFC1951]</a></td>
<td class="author-text"><a href="mailto:ghost@aladdin.com">Deutsch, P.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1951">DEFLATE Compressed Data Format Specification version 1.3</a>,&rdquo; RFC&nbsp;1951, May&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1951.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc1951.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc1951.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2109">[RFC2109]</a></td>
<td class="author-text"><a href="mailto:dmk@bell-labs.com">Kristol, D.</a> and <a href="mailto:montulli@netscape.com">L. Montulli</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2109">HTTP State Management Mechanism</a>,&rdquo; RFC&nbsp;2109, February&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2109.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2109.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2109.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2246">[RFC2246]</a></td>
<td class="author-text"><a href="mailto:tdierks@certicom.com">Dierks, T.</a> and <a href="mailto:callen@certicom.com">C. Allen</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2246">The TLS Protocol Version 1.0</a>,&rdquo; RFC&nbsp;2246, January&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2616">[RFC2616]</a></td>
<td class="author-text"><a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, <a href="mailto:jg@w3.org">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com">Mogul, J.</a>, <a href="mailto:frystyk@w3.org">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com">Leach, P.</a>, and <a href="mailto:timbl@w3.org">T. Berners-Lee</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>,&rdquo; RFC&nbsp;2616, June&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2616.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.pdf">PDF</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2616.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2616.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2965">[RFC2965]</a></td>
<td class="author-text"><a href="mailto:dmk@bell-labs.com">Kristol, D.</a> and <a href="mailto:lou@montulli.org">L. Montulli</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2965">HTTP State Management Mechanism</a>,&rdquo; RFC&nbsp;2965, October&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2965.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2965.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2965.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3490">[RFC3490]</a></td>
<td class="author-text">Faltstrom, P., Hoffman, P., and A. Costello, &ldquo;<a href="http://tools.ietf.org/html/rfc3490">Internationalizing Domain Names in Applications (IDNA)</a>,&rdquo; RFC&nbsp;3490, March&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3490.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3629">[RFC3629]</a></td>
<td class="author-text">Yergeau, F., &ldquo;<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>,&rdquo; STD&nbsp;63, RFC&nbsp;3629, November&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3629.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3864">[RFC3864]</a></td>
<td class="author-text">Klyne, G., Nottingham, M., and J. Mogul, &ldquo;<a href="http://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>,&rdquo; BCP&nbsp;90, RFC&nbsp;3864, September&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3864.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3986">[RFC3986]</a></td>
<td class="author-text"><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com">Fielding, R.</a>, and <a href="mailto:LMM@acm.org">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>,&rdquo; STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3986.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3986.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3986.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3987">[RFC3987]</a></td>
<td class="author-text">Duerst, M. and M. Suignard, &ldquo;<a href="http://tools.ietf.org/html/rfc3987">Internationalized Resource Identifiers (IRIs)</a>,&rdquo; RFC&nbsp;3987, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3987.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4366">[RFC4366]</a></td>
<td class="author-text">Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, &ldquo;<a href="http://tools.ietf.org/html/rfc4366">Transport Layer Security (TLS) Extensions</a>,&rdquo; RFC&nbsp;4366, April&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4366.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5234">[RFC5234]</a></td>
<td class="author-text">Crocker, D. and P. Overell, &ldquo;<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>,&rdquo; STD&nbsp;68, RFC&nbsp;5234, January&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5234.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="WSAPI">[WSAPI]</a></td>
<td class="author-text">Hickson, I., &ldquo;<a href="http://dev.w3.org/html5/websockets/">The Web Sockets API</a>,&rdquo; August&nbsp;2010.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Adam Barth</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google, Inc.</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ietf@adambarth.com">ietf@adambarth.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.adambarth.com/">http://www.adambarth.com/</a></td></tr>
</table>
</body></html>
