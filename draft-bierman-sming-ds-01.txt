






Internet Draft                                             Andy Bierman
                                                     Cisco Systems, Inc.
                                                       12 November 2001


                  Structure of Management Information:
                            Data Structures


                    <draft-bierman-sming-ds-01.txt>





Status of this Memo

This document is an Internet-Draft and is in full conformance with all
provisions of Section 10 of RFC2026 [RFC2026].

Internet-Drafts are working documents of the Internet Engineering Task
Force (IETF), its areas, and its working groups.  Note that other groups
may also distribute working documents as Internet-Drafts.

Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any
time.  It is inappropriate to use Internet- Drafts as reference material
or to cite them other than as "work in progress".

The list of current Internet-Drafts can be accessed at
http://www.ietf.org/ietf/1id-abstracts.txt

The list of Internet-Draft Shadow Directories can be accessed at
http://www.ietf.org/shadow.html.

Distribution of this document is unlimited. Please send comments to the
SMIng WG mailing list <sming@ops.ietf.org>.

1.  Copyright Notice

Copyright (C) The Internet Society (2001).  All Rights Reserved.















Internet Draft             SMI Data Structures         November 12, 2001


2.  Abstract

This memo defines a portion of the Structure of Management Information
(SMI) for use with network management protocols in the Internet
community.  In particular, it describes a new structure and naming
scheme for network management information, allowing the specification of
arbitrarily complex hierarchical data structures.

3.  Table of Contents

1 Copyright Notice ................................................    1
2 Abstract ........................................................    2
3 Table of Contents ...............................................    2
4 The SNMP Network Management Framework ...........................    2
5 Overview ........................................................    3
5.1 Terms .........................................................    4
5.2 Design Objectives .............................................    5
5.3 Module Declarations ...........................................    6
5.4 Data Structure Constructs .....................................    6
5.5 Hierarchical Instance Naming ..................................    7
5.5.1 Data Structure Naming Algorithm .............................    8
5.6 SMI-DS Data Object Usage Examples .............................   11
5.6.1 InetAddress Example .........................................   11
5.6.2 Generic High Capacity Counter Example .......................   14
5.7 AUGMENTS for Data Structures ..................................   16
5.7.1 STRUCT AUGMENTS Example .....................................   16
5.7.2 UNION AUGMENTS Example ......................................   18
5.7.3 ARRAY AUGMENTS Example ......................................   21
5.8 Complete MODULE Example .......................................   27
6 Definitions .....................................................   37
6.1 Namespaces ....................................................   37
6.2 Syntax ........................................................   37
7 Intellectual Property ...........................................   44
8 Acknowledgements ................................................   44
9 Appendix A: Discussion of SMIng Objectives ......................   45
10 References .....................................................   60
11 Security Considerations ........................................   62
12 Author's Address ...............................................   63
13 Full Copyright Statement .......................................   64

4.  The SNMP Network Management Framework

   The SNMP Management Framework presently consists of five major
   components:






Expires May 12, 2002                                            [Page 2]





Internet Draft             SMI Data Structures         November 12, 2001


    o   An overall architecture, described in RFC 2571 [RFC2571].

    o   Mechanisms for describing and naming objects and events for the
        purpose of management. The first version of this Structure of
        Management Information (SMI) is called SMIv1 and described in
        RFC 1155 [RFC1155], RFC 1212 [RFC1212] and RFC 1215 [RFC1215].
        The second version, called SMIv2, is described in RFC 2578
        [RFC2578], RFC 2579 [RFC2579] and RFC 2580 [RFC2580].

    o   Message protocols for transferring management information. The
        first version of the SNMP message protocol is called SNMPv1 and
        described in RFC 1157 [RFC1157]. A second version of the SNMP
        message protocol, which is not an Internet standards track
        protocol, is called SNMPv2c and described in RFC 1901 [RFC1901]
        and RFC 1906 [RFC1906].  The third version of the message
        protocol is called SNMPv3 and described in RFC 1906 [RFC1906],
        RFC 2572 [RFC2572] and RFC 2574 [RFC2574].

    o   Protocol operations for accessing management information. The
        first set of protocol operations and associated PDU formats is
        described in RFC 1157 [RFC1157]. A second set of protocol
        operations and associated PDU formats is described in RFC 1905
        [RFC1905].

    o   A set of fundamental applications described in RFC 2573
        [RFC2573] and the view-based access control mechanism described
        in RFC 2575 [RFC2575].

   A more detailed introduction to the current SNMP Management Framework
   can be found in RFC 2570 [RFC2570].

   Managed objects are accessed via a virtual information store, termed
   the Management Information Base or MIB.  Objects in the MIB are
   defined using the mechanisms defined in the SMI.

   This memo does not specify a MIB module.

5.  Overview

There is a need for a standardized way of defining complex data
structures for the representation of management information, which can
be utilized with existing versions of SNMP. The current SMIv2 design
model is based on groups of rectangular tables, which are related
because they share one or more index components. This model provides a
single containment layer (per table), because all the objects in a





Expires May 12, 2002                                            [Page 3]





Internet Draft             SMI Data Structures         November 12, 2001


conceptual row must be simple types (e.g., Integer32, SnmpAdminString,
Counter64).

The practice of spreading a multi-layer data structure across several
rectangular tables causes MIB modules to be much too verbose, and hard
to understand.  The containment relationships between tables are usually
described in INDEX clauses and various DESCRIPTION clauses.

This practice also has a negative impact on agent implementations, which
are harder to implement and test, due to row creation and row activation
ordering issues.  These issues add complexity to management application
development as well.

Software development and human readability would benefit from a data
definition language and associated naming scheme which more closely
represents the basic data structures that exist in almost all
programming languages.

[ed. - this initial version is meant to introduce the new SMI Data
Structure concepts and is not yet defined in sufficient detail to be
suitable as a formal specification.]

5.1.  Terms

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119. [RFC2119]

This document uses some terms that need introduction:

Complex Data Object
     This term refers to any data object which provides some sort of
     containment for other data objects, which is any variable construct
     other than SCALAR (e.g. ARRAY, UNION, or STRUCT).

Data Object
     This term refers to any (new) SMI Data Structure variable
     declaration, at any level of containment.

MIB Object
     This term generically refers to a SMIv2 OBJECT-TYPE macro
     definition.  It does not refer to an SMI Data Structure definition.

Scalar
     This term refers to a non-tabular SMIv2 MIB object.





Expires May 12, 2002                                            [Page 4]





Internet Draft             SMI Data Structures         November 12, 2001


SCALAR
     This term refers to any accessible data object with a syntax that
     resolves to a SMI base type. To avoid confusion, the term appears
     in capital letters when referring to a data object definition.

SMI Data Structure (SMI-DS)
     This term refers to the concepts and definitions defined in this
     document.

5.2.  Design Objectives

The working group objectives for this work are detailed in the SMIng
Objectives document [SMING-OBJ].  (Refer to Appendix A for a detailed
discussion of each accepted objective.)

The primary high-level design goals of this work are:

   - Significantly enhance the usefulness of the SMI as a network
     management data definition language.

   - Significantly enhance SMI object instance naming to support complex
     hierarchical data structures, and optimize OBJECT IDENTIFIER
     component order for Set, GetNext, and GetBulk SNMP PDUs efficiency.

   - Preserve as much of SMIv2 mechanisms and 'installed knowledge-base'
     as possible (if it ain't broke, then we don't fix it).

   - Get rid of as much textual cruft as possible (if it don't help,
     then we don't need it).

   - Make sure accessible data objects (i.e. SCALARs) can be used with
     existing versions of SNMP.

There are two significant WG design objectives that are not addressed:

   - This document does not attempt to decouple object and instance
     naming from the object definitions, to allow for multiple naming
     schemes.  The creation and maintenance of separate modules for
     definitions and protocol-specific name mappings will add
     unwarranted complexity to the documents and dramatically increase
     the opportunity to introduce bugs into these documents.  The
     differences between SMI and SPPI row instance naming do not even
     apply to a data structure oriented design model.







Expires May 12, 2002                                            [Page 5]





Internet Draft             SMI Data Structures         November 12, 2001


   - This document does not attempt to introduce any object-oriented
     methodologies into the management framework.  Instead, some basic
     data structure constructs (e.g., arrays, unions, and structures
     available in the C Programming Language) are introduced.  Direct
     inheritance is achieved by including the 'base type' in a new
     STRUCT TYPEDEF definition, and add new data objects to the STRUCT
     as desired. An AUGMENTS mechanism is also available to extend data
     object definitions over time, similar the the SMIv2 AUGMENTS for
     tables.

5.3.  Module Declarations

The type of declarations that can be made in an SMI-DS module do not
really change at all.  Textual conventions become typedefs, and MIB
object definitions become data object declarations. Notifications are
not changed at all.

Most of the constructs (macros and their clauses) in SMI-DS are
identical in semantic content as their SMIv2 counterparts. The syntax
for some macros are slightly different, in that multi-part macros now
have opening and closing curly braces ('{' and '}'), to help manage the
increased containment complexity.  Many constructs do not change at all,
such as the IMPORTS, MODULE-IDENTITY, NOTIFICATION-TYPE, MODULE-
COMPLIANCE, OBJECT-GROUP, and NOTIFICATION-GROUP macros.

5.4.  Data Structure Constructs

There are four basic constructs available in the SMI-DS language for the
definition of data objects.

SCALAR
     This construct is conceptually equivalent to an OBJECT-TYPE macro
     definition for an accessible MIB object in SMIv2, except a SCALAR
     can be defined at any level of containment. A SCALAR type
     definition or variable declaration resolves to any SMIng base type.
     In SMI-DS, all other constructs must eventually resolve to some
     number of these objects, and only SCALAR data objects are actually
     accessible via a management protocol.

ARRAY
     This construct provides a multi-dimensional array structure,
     similar to the SEQUENCE construct in SMIv2.  However, instead of
     one flat 'row' consisting of only accessible base-type MIB objects,
     an ARRAY can consist of an arbitrary mix of any of the four types
     of data object constructs.  Conceptually, the INDEX structure for





Expires May 12, 2002                                            [Page 6]





Internet Draft             SMI Data Structures         November 12, 2001


     an ARRAY is the same as for a SEQUENCE, except the SMI-DS naming
     scheme is different.  Only base type data objects can be used in an
     ARRAY INDEX clause (the same ones as in SMIv2), and the rules for
     encoding INDEX clause base types in OBJECT IDENTIFIERs are the same
     as for SMIv2.  An ARRAY can be defined without containing any
     objects, for placeholder purposes only.

UNION
     This construct provides a mechanism to conceptually allow a single
     object definition to contain one of potentially several different
     construct definitions.  Only one of these constructs is actually
     instantiated at any time by the agent. Unlike a union in the C
     language, the unused union members cannot be accessed at all (no
     'cast' operator in SMI).  A UNION can be defined without containing
     any objects, for placeholder purposes only.

STRUCT
     This construct provides a mechanism to group an arbitrary number of
     data constructs (of any type), allowing a theoretically unlimited
     number of data containment layers.  It is similar to the ARRAY
     construct, except there is no INDEX clause.  A STRUCT can be
     defined without containing any objects, for placeholder purposes
     only.

5.5.  Hierarchical Instance Naming

In order to fully utilize the capabilities of arbitrary containment, a
new way of naming object instances is needed, which is designed for
hierarchical data structures instead of tables.  It is also desirable to
preserve naming containment, even for augmented data structures.

With SMIv2, it is possible that related object instances exist in
multiple sub-trees, due the AUGMENTS clause and the use of "associated"
cascading tables.  A new naming scheme is proposed which allows naming
containment to be preserved for AUGMENTS.

SMIv2 naming in non-optimal for GetNext and GetBulk retrievals, even
from the same table, because the instance identifier components (the
fields interesting for sorting or subsetted retrieval) are all at the
end, after all the base (static) object identifier components.

SMIv2 lexinext ordering is optimized for retrieving multiple (unrelated)
instances of a single data attribute. SMI-DS lexinext ordering is
optimized for retrieving multiple (related) data attributes for a single
instance.





Expires May 12, 2002                                            [Page 7]





Internet Draft             SMI Data Structures         November 12, 2001


The GetBulk PDU is designed to minimize this deficiency by allowing
multiple 'GetNext start points' to be requested, but this adds
complexity for both the agent and the application (especially when these
multiple 'GetNext threads' get out of sync).  A new naming scheme is
proposed which is optimized for retrieving related data objects for a
single instance, no matter how complicated the object structure.

Since it's possible for accessible (SCALAR) objects to exist in the same
containment structure as non-accessible (e.g., ARRAY, UNION, or STRUCT)
objects, it is not possible to name SMI-DS objects with a 'flat' model.
SMIv2 assumes all accessible objects in the same containment structure
(SEQUENCE) have the same number of object identifier components, and the
exact same format (INDEX structure) for all instance identifier
components.  This assumption cannot be made for SMI-DS object naming.

In the SMIv2 framework, it makes sense to group all object components on
the left, and group all instance components on the right.  Although SNMP
does not make this distinction, conceptually a MIB object which contains
an OBJECT IDENTIFIER, either refers to an object definition (object
pointer), or some subset of instances (instance pointer), depending on
how many OBJECT IDENTIFIER components are present.

Instead of grouping all the instance identifiers and appending them to a
fixed-length object identifier, instance identifiers and object node
identifiers are combined in layers, depending on the data object
definition.

Note that this new naming scheme can also help reduce implementation
complexity for agent and application developers for SNMP Set operations.
Currently, associated attributes can be spread across multiple tables,
(possibly sharing major indices) each with their own RowStatus and set
of 'SNMP callback' functions. This design approach can get relatively
complicated, especially if 'createAndWait' and 'notInService' RowStatus
values are supported.  By allowing complex containment instead of
unfolding data structures into tables, and insuring that all associated
objects for a given set of instances are located in the 'same place' in
the MIB sub-tree (even for AUGMENTS), implementation of high-level Set
operations can be simplified for both agent and application developers.

5.5.1.  Data Structure Naming Algorithm

The basic format of an OBJECT IDENTIFIER for an SMI-DS data object is as
follows:

Basic Data Object Name Format:





Expires May 12, 2002                                            [Page 8]





Internet Draft             SMI Data Structures         November 12, 2001


   <oidBase>.<oidNode> [.<childNodes> ...]

 where:

  <oidBase> is a well-formed OBJECT IDENTIFIER base fragment

  <oidNode> is the first data object node identifier, which
     must be an INTEGER between 1 and 4294967295

  <childNodes> is based on the data construct of the current
     parent node (<oidNode>).
     For SCALAR:
        there are no child nodes
     For ARRAY:
        <indexNodes>.<augmentNode>.<childNode>
       where:
        <indexNodes> contains the INDEX encoding
           of each INDEX object (in order), encoded
           exactly the same as for an SMIv2 INDEX.
        <augmentNode> contains the augmentation identifier
           for the <childNode>.

           The value zero indicates a <childNode> which is
           defined in the original TYPEDEF, regardless of the
           naming authority.

           A non-zero value indicates an augmentation node which
           is actually two fields encoded into one sub-identifier,
           as follows:

           <augmentNode> =
              (<augmentEnterprise> * MAX_AUGMENT_ID) + <augmentID>

           <augmentEnterprise>
              The naming authority for this augmentation.
              The value zero is reserved for IETF MIB modules.
              A non-zero value indicates the Private Enterprise
              Number [IANA_ENT] of the naming authority.
              The constant MAX_AUGMENT_ID is defined to be 1000,
              which provides for 4294965 different Enterprise
              numbers. (As of November 7, 2001, there are 11407
              such numbers actually assigned.)
           <augmentID>
              The identifier for this augmentation. This value
              is only unique for a given value of





Expires May 12, 2002                                            [Page 9]





Internet Draft             SMI Data Structures         November 12, 2001


              <augmentEnterprise>, and must be an INTEGER between
              (1 .. MAX_AUGMENT_ID-1). This provides for 999
              augmentations per naming authority, per TYPEDEF.
              The value zero is reserved for child nodes defined
              in the original TYPEDEF.
        <childNode> contains the node identifier for the
           child node, which must be an INTEGER between
           1 and 4294967295. It is only unique within the
           scope of a particular <augmentNode> value.
     For UNION and STRUCT:
        <augmentNode>.<childNode>
       where:
        <augmentNode> is defined the same as for an ARRAY.
        <childNode> is defined the same as for an ARRAY.

The expansion algorithm for <childNodes> is repeated if the current
<childNode> represents a complex data object. The current <childNode>
replaces the current <oidNode> in the algorithm, before <childNodes> is
expanded again. The algorithm terminates when either a SCALAR data
object or no accessible object is encountered.

The following example demonstrates hierarchical naming, using a simple
array of first and last name pairs.

C Language Representation:

    typedef struct Name_ {
        char first_name[MAX_STRING_LEN];
        char last_name[MAX_STRING_LEN];
    } Name;

    Name nameList[MAX_NAMES];

Hierarchical Naming Representation:

    nameList                  ::= { someRoot 1 }

    nameList[N]               ::= { nameList N }

    nameList[N].first_name    ::= { nameList N 0 1 }

    nameList[N].last_name     ::= { nameList N 0 2 }

Note 1) In order to support arbitrary containment, it is not possible or
desirable to group all the instance components together on the right. It





Expires May 12, 2002                                           [Page 10]





Internet Draft             SMI Data Structures         November 12, 2001


is important to correctly represent all layers of containment, to allow
for certain conceptual references (e.g., 'nameList[N]' in the example
above).

Note 2) An OID component of zero is inserted before the component for
the 'first_name' or 'last_name' fields.  This node is used for potential
augmentations to this data type, in order to identify their namespace.
The data objects defined within a TYPEDEF are always assigned the
namespace value zero.

Note 3) The instance naming algorithm for SCALAR data types is similar
to SMIv2, except there is never an extra component with a value of zero
added for non-tabular objects. SCALAR data types cannot be augmented or
extended, so there is no need for an augmentation node either.

5.6.  SMI-DS Data Object Usage Examples

The following sections introduce some examples of simple data structures
that are currently achieved with relatively verbose text in TEXTUAL-
CONVENTION and OBJECT-TYPE DESCRIPTION clauses using SMIv2.

5.6.1.  InetAddress Example

The Internet Address textual conventions defined in the "Textual
Conventions for Internet Network Addresses" MIB module [RFC2851] defines
several variants of an Internet address (InetAddress), and a control
object (InetAddressType) to distinguish which variant is actually
present in an InetAddress object instance.  This construct may be more
concisely and properly represented in SMI-DS by a structure containing
the control object and a union of all the address variants.

-- a union of all the InetAddress types

TYPEDEF UNION InetAddressUnion {
    DESCRIPTION
       "Internet address in 4 different representations."

    SCALAR ipUnknown {
       SYNTAX      OCTET STRING (SIZE (0..65535))
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "Represents an Internet address using an externally
            defined format. The associated InetAddressType
            object value is 'unknown(0)'."





Expires May 12, 2002                                           [Page 11]





Internet Draft             SMI Data Structures         November 12, 2001


    } ::= 1

    SCALAR ipv4Addr {
       SYNTAX      InetAddressIPv4
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "Represents an IPv4 Internet address. The
            associated InetAddressType object value
            is 'ipv4(1)'."
    } ::= 2

    SCALAR ipv6Addr {
       SYNTAX      InetAddressIPv6
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "Represents an IPv6 Internet address. The
            associated InetAddressType object value
            is 'ipv6(2)'."
    } ::= 3

    SCALAR ipDnsAddr {
       SYNTAX      InetAddressDNS
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "Represents an DNS domain name.  The associated
            InetAddressType object value is 'dns(16)'."
    } ::= 4
}

TYPEDEF STRUCT HostInetAddress {
    DESCRIPTION
       "Internet address for an end-station host, adhering
        to the SMIv2 'associated objects' design approach."

    SCALAR addrType {
       SYNTAX      InetAddressType
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "The type of Internet address."
    } ::= 1






Expires May 12, 2002                                           [Page 12]





Internet Draft             SMI Data Structures         November 12, 2001


    UNION addr {
       SYNTAX      InetAddressUnion
       STATUS      current
       DESCRIPTION
           "The Internet address."
    } ::= 2
}

STRUCT myAddress {
    SYNTAX      HostInetAddress
    STATUS      current
    DESCRIPTION
        "Internet address of this host."
} ::= { someBase 1 }

UNION newAddress {
    SYNTAX      InetAddressUnion
    STATUS      current
    DESCRIPTION
        "Example of the new way to represent a union variable,
         without the use of an associated InetAddressType object."
} ::= { someBase 2 }

Note 1) The accessible object instances defined within this structure
(addrType, ipUnknown, ipv4Addr, ipv6Addr, etc.)  have different lengths:

  myAddress                ::= { someBase 1 }
  myAddress.addrType       ::= { myAddress 0 1 }
  myAddress.addr           ::= { myAddress 0 2 }
  myAddress.addr.ipUnknown ::= { myAddress 0 2 0 1 }
  myAddress.addr.ipv4Addr  ::= { myAddress 0 2 0 2 }
  myAddress.addr.ipv6Addr  ::= { myAddress 0 2 0 3 }
  myAddress.addr.dnsAddr   ::= { myAddress 0 2 0 4 }

  newAddress               ::= { someBase 2 }
  newAddress.ipUnknown     ::= { newAddress 0 1 }
  newAddress.ipv4Addr      ::= { newAddress 0 2 }
  newAddress.ipv6Addr      ::= { newAddress 0 3 }
  newAddress.dnsAddr       ::= { newAddress 0 4 }


Note 2) The addrType field is not actually needed for simple variable
declarations, because UNION constructs are instantiated with at most one
accessible member.  In the example above, a GetNext Request for
'myAddress.addr' or 'newAddress' will return only one type of





Expires May 12, 2002                                           [Page 13]





Internet Draft             SMI Data Structures         November 12, 2001


InetAddress string from the InetAddressUnion.  The associated
InetAddressType variable is needed only when used together with the
InetAddress (generic string form) as INDEX components in an ARRAY.

Note 3) Just like a TEXTUAL-CONVENTION in SMIv2, a TYPEDEF has no
instances associated with it and therefore no MIB root assigned.
However, accessible data objects (SCALARs) can be defined within a
TYPEDEF, which are numbered hierarchically relative to the start of the
TYPEDEF.  It is only when a a variable of a particular type is declared
(and therefore assigned a MIB root) that the full OBJECT IDENTIFIER for
a data object is known.

5.6.2.  Generic High Capacity Counter Example

There are many MIBs that contain up to the three OBJECT-TYPE macro
definitions for every high capacity counter, in order to accommodate
SNMPv1 implementations without support for Counter64 and 32-bit
implementations without any high capacity support at all.

A type definition (GenericCounter) for a union that contains an object
for each of the three scenarios would better represent the intended
semantics of this design, and use less text within data structure
definitions than an SMIv2 version. Note that a discriminator object is
not needed for a union, because the agent (or management application)
will instantiate at most one of the variants.

TYPEDEF UNION GenericCounter {
    DESCRIPTION
       "Generic counter for all versions of SNMP."

    SCALAR c32 {
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "The Counter32 representation of the counter."
    } ::= 1

    SCALAR c64 {
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "The Counter64 representation of the counter."
    } ::= 2





Expires May 12, 2002                                           [Page 14]





Internet Draft             SMI Data Structures         November 12, 2001


    STRUCT c32pair {
        DESCRIPTION
            "Pair of Counter32 objects to represent a 64-bit
             counter."

        SCALAR c32low {
            SYNTAX      Counter32
            MAX-ACCESS  read-only
            STATUS      deprecated
            DESCRIPTION
                "The lower 32 bits of a 64 bit counter."
        } ::= 1

        SCALAR c32hi {
            SYNTAX      Counter32
            MAX-ACCESS  read-only
            STATUS      deprecated
            DESCRIPTION
                "The upper 32 bits of a 64 bit counter."
        } ::= 2
    } ::= 3
}

UNION myCounter {
    SYNTAX      GenericCounter
    STATUS      current
    DESCRIPTION
       "An example generic counter variable."
} ::= { someBase 1 }

Note 1) Inline vs. external type definition: The 'c32pair' STRUCT could
have been defined as a separate type and a STRUCT declared with a SYNTAX
clause that referenced that type (e.g.  <struct-type-decl> form of the
STRUCT declaration).  The instance numbering works out the same either
way, even though only complex data objects defined with a separate
TYPEDEF can be augmented. This simplifies SNMP engine implementations,
which may not know which variant of the complex data object TYPEDEF was
used in the MIB definition.  In other words. an augmentation identifier
OBJECT IDENTIFIER component is encoded for all complex data objects,
just before the child node identifier.

The following OBJECT IDENTIFIERs would be possible for the 'myCounter'
variable declaration:

   myCounter                ::= { someBase 1 }





Expires May 12, 2002                                           [Page 15]





Internet Draft             SMI Data Structures         November 12, 2001


   myCounter.c32            ::= { myCounter 0 1 }
   myCounter.c64            ::= { myCounter 0 2 }
   myCounter.c32pair        ::= { myCounter 0 3 }
   myCounter.c32pair.c32low ::= { myCounter 0 3 0 1 }
   myCounter.c32pair.c32hi  ::= { myCounter 0 3 0 2 }

Note 2) Even though only one node of a UNION can be instantiated at any
given time, a GetNext Request for a UNION which contains other complex
data objects can cause multiple instances to be returned from that sub-
tree, as with the 'c32low' and 'c32hi' SCALARs in the example above.

Note 3) Only the STATUS clauses for SCALAR data object definitions are
relevant for compliance section usage.  However, the above example
raises issues regarding a complex data object which contains a mixture
of current, deprecated, and obsolete SCALARs. (Is the STATUS of the
GenericCounter UNION itself current or deprecated?)

5.7.  AUGMENTS for Data Structures

SMIv2 allows for MIB tables (SEQUENCEs) to be conceptually extended over
time, without touching the original MIB table definition.  This is
usually done to avoid editing a 'stable' RFC, and it causes related
objects of the same conceptual row to be spread across different MIB
sub-trees.

In SMI-DS, the concept of AUGMENTS is preserved and adapted for use with
complex data objects, instead of SEQUENCE definitions.

The following examples demonstrate how each of the complex data object
types can be augmented over time in a manner that is consistent with the
semantics of SMIv2, except that the naming containment is preserved for
the augmenting objects.  An AUGMENTS can be defined without containing
any objects, for placeholder purposes only.  Just as with SMIv2, SCALAR
objects cannot be augmented.

5.7.1.  STRUCT AUGMENTS Example

The AUGMENTS clause is applied to a STRUCT TYPEDEF in order to add
additional fields to a base STRUCT type, instead of redefining the
STRUCT type.

The following trivial example shows how a 2 dimensional point might be
augmented to represent a 3 dimensional point.

TYPEDEF STRUCT Point {





Expires May 12, 2002                                           [Page 16]





Internet Draft             SMI Data Structures         November 12, 2001


    DESCRIPTION
        "A 2 dimensional point."

    SCALAR x {
       SYNTAX      Unsigned32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The X-axis coordinate value for the point."
    } ::= 1

    SCALAR y {
       SYNTAX      Unsigned32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The Y-axis coordinate value for the point."
    } ::= 2
}

AUGMENTS STRUCT Point {
    DESCRIPTION
        "Adds 1 more coordinate for a  3 dimensional point."

    SCALAR z {
       SYNTAX      Unsigned32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The Z-axis coordinate value for the point."
    } ::= 1
} ::= 1

STRUCT myPoint {
    SYNTAX      Point
    STATUS      current
    DESCRIPTION
       "An example variable instance of a point."
} ::= { someBase 1 }

Note 1) The OBJECT IDENTIFIER values for each of the fields in the
'myPoint' variable are listed below.

For an agent which supports only the base type, without the
augmentation, the following OBJECT IDENTIFIERs would be defined:





Expires May 12, 2002                                           [Page 17]





Internet Draft             SMI Data Structures         November 12, 2001


   myPoint        ::=   { someBase 1 }
   myPoint.x      ::=   { myPoint 0 1 }
   myPoint.y      ::=   { myPoint 0 2 }

For an agent which supports the base type with this augmentation, the
following OBJECT IDENTIFIER would also be defined:

   myPoint.z      ::=   { myPoint 1 1 }

Note 2) Augmentations have to be assigned a relative root within the
parent data structure, and also that augmentations cannot be defined for
other augmentations.  A maximum of 4 billion (minus 1) different
augmentations for the same data type can be defined. Since AUGMENTS are
used relatively rarely, and usually in a controlled way, it is not
unreasonable to coordinate the augmentation node identifiers for each
augmented TYPEDEF.

Note 3) A GetNext or GetBulk sweep of 'myPoint' object would return all
the fields in the same sub-tree, allowing the agent support for the
augmentation to be easily discovered by an application.

Note 4) Only TYPEDEFs can be augmented, not variable declarations. This
eliminates the implementation complexity of managing different namespace
definitions for each complex data object definition.  It is recommended
that data object definitions be made using a TYPEDEF, rather than with
an 'inline' complex object declaration, in order to allow for future
augmentations to the data object.

5.7.2.  UNION AUGMENTS Example

The AUGMENTS clause is applied to the UNION data object in a similar
manner as a STRUCT, in order to define additional UNION choices without
redefining the data type.  Only one node defined in a UNION (regardless
of the number of augmentations) is allowed to be instantiated at any
given time.

The following trivial example shows how the InetAddressUnion type
(defined above) might be augmented to add new InetAddress types defined
in the RFC 2851 update draft [INET_TC].  Note that just as with SMIv2,
it is up to the MIB designer(s) to decide whether to edit a base data
type or augment it instead. This example is not meant to suggest that
AUGMENTS should have been used in the case of the InetAddress, even if
that were possible with SMIv2.

-- see the Usage Examples section for the TYPEDEF for





Expires May 12, 2002                                           [Page 18]





Internet Draft             SMI Data Structures         November 12, 2001


-- the InetAddressUnion type

AUGMENTS UNION InetAddressUnion {
    DESCRIPTION
       "Adding two InetAddress types to match new
        InetAddressType enumerations."

    SCALAR ipv4zAddr {
       SYNTAX      InetAddressIPv4z
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "Represents an IPv4 Internet address and its zone
            index.  The associated InetAddressType object
            value is 'ipv4z(3)'."
    } ::= 1

    SCALAR ipv6zAddr {
       SYNTAX      InetAddressIPv6z
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "Represents an IPv6 Internet address and its zone
            index. The associated InetAddressType object value
            is 'ipv6z(4)'."
    } ::= 2
} ::= 1

-- the following example shows a proprietary augmentation
-- to the HostInetAddress type definition by the Acme Corp.
-- who has enterprise ID number 12043

TYPEDEF STRUCT AcmeAddressInfo {
    DESCRIPTION
        "Adds a proprietary address type and administrative
         role string."

    SCALAR acmeAddrType
        SYNTAX      Unsigned32
        MAX-ACCESS  read-only
        STATUS      current
        DESCRIPTION
            "The corresponding Acme Address type for this
             address."
    } ::= 1





Expires May 12, 2002                                           [Page 19]





Internet Draft             SMI Data Structures         November 12, 2001


    SCALAR acmeAddrRole
        SYNTAX      SnmpAdminString (SIZE (0..64))
        MAX-ACCESS  read-write
        STATUS      current
        DESCRIPTION
            "The Acme Administrative Role String assigned to
             this address."
    } ::= 2
}

-- Acme augmentation '001' to HostInetAddress TYPEDEF

AUGMENTS STRUCT HostInetAddress {
    DESCRIPTION
        "Adds Acme-specific address info to each host address."

    STRUCT acmeInfo {
        SYNTAX  AcmeAddressInfo
        STATUS  current
        DESCRIPTION
            "The Acme Address Info for this host address."
    } ::= 1
} ::= 12043001

--
-- variable declarations from previous example

STRUCT myAddress {
    SYNTAX      HostInetAddress
    STATUS      current
    DESCRIPTION
        "Internet address of this host."
} ::= { someBase 1 }

UNION newAddress {
    SYNTAX      InetAddressUnion
    STATUS      current
    DESCRIPTION
        "Example of the new way to represent a union variable,
         without the use of an associated InetAddressType object."
} ::= { someBase 2 }

Note 1) The following table lists the OBJECT IDENTIFIER component values
for each of the fields in the 'myAddress' and 'newAddress' variables in
the example above.





Expires May 12, 2002                                           [Page 20]





Internet Draft             SMI Data Structures         November 12, 2001


For an agent which supports only the base type, without the
augmentation, the following OBJECT IDENTIFIERs would be defined:

  myAddress                ::= { someBase 1 }
  myAddress.addrType       ::= { myAddress 0 1 }
  myAddress.addr           ::= { myAddress 0 2 }
  myAddress.addr.ipUnknown ::= { myAddress 0 2 0 1 }
  myAddress.addr.ipv4Addr  ::= { myAddress 0 2 0 2 }
  myAddress.addr.ipv6Addr  ::= { myAddress 0 2 0 3 }
  myAddress.addr.dnsAddr   ::= { myAddress 0 2 0 4 }

  newAddress               ::= { someBase 2 }
  newAddress.ipUnknown     ::= { newAddress 0 1 }
  newAddress.ipv4Addr      ::= { newAddress 0 2 }
  newAddress.ipv6Addr      ::= { newAddress 0 3 }
  newAddress.dnsAddr       ::= { newAddress 0 4 }


For an agent which supports the base type with the InetAddressUnion
augmentation, the following additional OBJECT IDENTIFIERs would be
defined:

  myAddress.addr.ipv4zAddr ::= { myAddress 0 2 1 1 }
  myAddress.addr.ipv6zAddr ::= { myAddress 0 2 1 2 }

  newAddress.ipv4zAddr     ::= { newAddress 1 1 }
  newAddress.ipv6zAddr     ::= { newAddress 1 2 }

For an Acme agent which supported the AcmeAddressInfo augmentation, the
following additional OBJECT IDENTIFIERs would be defined:

  myAddress.acmeInfo       ::= { myAddress 12043001 1 }

  myAddress.acmeInfo.acmeAddrType ::=
                               { myAddress 12043001 1 0 1 }

  myAddress.acmeInfo.acmeAddrRole ::=
                               { myAddress 12043001 1 0 2 }


5.7.3.  ARRAY AUGMENTS Example

The AUGMENTS clause is applied to an ARRAY TYPEDEF in order to add
additional fields to a base ARRAY type, instead of redefining the ARRAY
TYPEDEF.  It is similar to a traditional SMIv2 SEQUENCE AUGMENTS, except





Expires May 12, 2002                                           [Page 21]





Internet Draft             SMI Data Structures         November 12, 2001


naming containment is preserved and the augmentations are not limited to
base type objects.

The INDEX clause of an ARRAY macro cannot be augmented, to reduce
implementation complexity.  Instead, a new TYPEDEF has to be defined or
the existing TYPEDEF has to be edited (just like SMIv2).

The following trivial example shows how some high-capacity counters and
time-related attributes might be added to an existing array of packet
statistics.

TYPEDEF ARRAY InetHostStats {
    DESCRIPTION
        "Example of a IP host stats table."

    INDEX  {
        SYNTAX  InterfaceIndex       -- range of the INDEX
        SIZE    (0..2147483647)      -- range of the instances
        DESCRIPTION
            "The interface source for these statistics."
    }

    INDEX  {
        SYNTAX  InetAddressType
        SIZE    (0..65535)
        DESCRIPTION
            "The IP address type for the array entry.
             The InetAddressType values 'unknown(1)' and
             'dns(16)' are not allowed."
    }

    INDEX  {
        SYNTAX  InetAddress
        SIZE    (0..65535)
        DESCRIPTION
            "The IP address for the array entry."
    }

    SCALAR inPkts {
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The number of packets received by the specified host
           on the specified interface."





Expires May 12, 2002                                           [Page 22]





Internet Draft             SMI Data Structures         November 12, 2001


    } ::= 1

    SCALAR outPkts {
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The number of packets transmitted by the specified
           host on the specified interface."
    } ::= 2

    SCALAR inOctets {
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The number of octets received by the specified host
           on the specified interface."
    } ::= 3

    SCALAR outOctets {
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The number of octets transmitted by the specified
           host on the specified interface."
    } ::= 4
}

-- a struct containing additional information for each
-- set of counters

TYPEDEF STRUCT HostStatsTimeData {
    DESCRIPTION
        "Add some times related objects associated with
         each set of counters."

    SCALAR createTime {
       SYNTAX      TimeStamp
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The value of sysUpTime at the time this set of
           counters was created."





Expires May 12, 2002                                           [Page 23]





Internet Draft             SMI Data Structures         November 12, 2001


    } ::= 1

    SCALAR updateInterval {
       SYNTAX      Unsigned32
       UNITS       "milliseconds"
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The average amount of time that elapses between
           internal polling intervals for this counter set.
           A value of zero indicates that the counter set
           values are not polled internally."
    } ::= 2
}

-- Augment the InetHostStats TYPEDEF with 4 counters and
-- a HostStatsTimeData STRUCT

AUGMENTS ARRAY InetHostStats {
    DESCRIPTION
        "Adds HC counters and additional information to
         the statistics entry."

    SCALAR inHCPkts {
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The number of packets received by the specified host
           on the specified interface."
    } ::= 1

    SCALAR outHCPkts {
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The number of packets transmitted by the specified
           host on the specified interface."
    } ::= 2

    SCALAR inHCOctets {
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current





Expires May 12, 2002                                           [Page 24]





Internet Draft             SMI Data Structures         November 12, 2001


       DESCRIPTION
          "The number of octets received by the specified host
           on the specified interface."
    } ::= 3

    SCALAR outHCOctets {
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The number of octets transmitted by the specified
           host on the specified interface."
    } ::= 4

    STRUCT timeData {
       SYNTAX      HostStatsTimeData
       STATUS      current
       DESCRIPTION
          "Additional time-related information."
    } ::= 5
} ::= 1

-- variable declaration for a InetHostStats data collection

ARRAY ipStats {
    SYNTAX      InetHostStats
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
       "The IP host statistics for this network device."
} ::= { someBase 1 }

Note 1) The following example lists the OBJECT IDENTIFIER values for
each of the fields in the 'myStats' variable in the example above.

For an agent which supports only the base type, without the
augmentation, the following OBJECT IDENTIFIERs would be defined. In this
example only the instances for interface 17, InetAddressType 'ipv4(1)',
and InetAddress '192.168.0.1' are shown.

   ipStats                     ::=   { someBase 1 }
   ipStats[17]                 ::=   { ipStats 17 }
   ipStats[17][1]              ::=   { ipStats 17 1 }

   ipStats[17][1][192.168.0.1] ::=





Expires May 12, 2002                                           [Page 25]





Internet Draft             SMI Data Structures         November 12, 2001


       { ipStats 17 1 4 192 168 0 1 }

   ipStats[17][1][192.168.0.1].inPkts ::=
       { ipStats 17 1 4 192 168 0 1 0 1 }

   ipStats[17][1][192.168.0.1].outPkts ::=
       { ipStats 17 1 4 192 168 0 1 0 2 }

   ipStats[17][1][192.168.0.1].inOctets ::=
       { ipStats 17 1 4 192 168 0 1 0 3 }

   ipStats[17][1][192.168.0.1].outOctets ::=
       { ipStats 17 1 4 192 168 0 1 0 4 }

For an agent which supports the base type with the augmentation, the
following additional OBJECT IDENTIFIERs would be defined:

   ipStats[17][1][192.168.0.1].inHCPkts ::=
       { ipStats 17 1 4 192 168 0 1 1 1 }

   ipStats[17][1][192.168.0.1].outHCPkts ::=
       { ipStats 17 1 4 192 168 0 1 1 2 }

   ipStats[17][1][192.168.0.1].inHCOctets ::=
       { ipStats 17 1 4 192 168 0 1 1 3 }

   ipStats[17][1][192.168.0.1].outHCOctets ::=
       { ipStats 17 1 4 192 168 0 1 1 4 }

   ipStats[17][1][192.168.0.1].timeData ::=
       { ipStats 17 1 4 192 168 0 1 1 5 }

   ipStats[17][1][192.168.0.1].timeData.createTime ::=
       { ipStats 17 1 4 192 168 0 1 1 5 0 1 }

   ipStats[17][1][192.168.0.1].timeData.updateInterval ::=
       { ipStats 17 1 4 192 168 0 1 1 5 0 2 }

Note 1) Although arbitrary levels of nested containment are
theoretically possible, SNMP varbind size limitations set practical
limits on the complexity of data object definitions, especially ARRAYs.

Note 2) The SPPI provides an EXTENDS mechanism, which allows new SCALAR
objects to be defined in a table which conceptually adds INDEX
components to an existing table. This mechanism is accomplished by





Expires May 12, 2002                                           [Page 26]





Internet Draft             SMI Data Structures         November 12, 2001


defining an additional ARRAY (with the new INDEX components and objects)
in an AUGMENTS for an ARRAY TYPEDEF.

5.8.  Complete MODULE Example

The following example shows a complete MIB module, converted from the
Remote Monitoring Extensions for Differentiated Services document
[DSMON-MIB].  Refer to that document to compare the SMIv2 and SMI-DS
definitions for the same objects.

-- the MODULE starts out differently than SMIv2 so MIB
-- compilers can tell immediately the type of module

MODULE DSMON-MIB {

-- partial IMPORTS, only for the aggregation control objects

IMPORTS
        MODULE-IDENTITY, Integer32, Counter32
                FROM SNMPv2-SMI
        MODULE-COMPLIANCE, OBJECT-GROUP
                FROM SNMPv2-CONF
        RowStatus, TimeStamp, TruthValue
                FROM SNMPv2-TC
        OwnerString, rmon
                FROM RMON-MIB
        SnmpAdminString
                FROM SNMP-FRAMEWORK-MIB
        Dscp
                FROM DIFFSERV-DSCP-TC;

-- the MODULE-IDENTITY macro is not changed at all

dsmonMIB MODULE-IDENTITY
    LAST-UPDATED    "200111050000Z"
    ORGANIZATION    "IETF RMONMIB Working Group"
    CONTACT-INFO
            "        Andy Bierman
                     Cisco Systems, Inc.
                     RMONMIB WG Chair and DSMON MIB Editor

             Postal: 170 West Tasman Drive
                     San Jose, CA USA 95134
                Tel: +1 408 527-3711
             E-mail: abierman@cisco.com





Expires May 12, 2002                                           [Page 27]





Internet Draft             SMI Data Structures         November 12, 2001


             Send comments to <rmonmib@ietf.org>
             Mailing list subscription info:
                 http://www.ietf.org/mailman/listinfo/rmonmib "
    DESCRIPTION
            "This module defines Remote Monitoring MIB extensions for
            Differentiated Services enabled networks.

             RMON DIFFSERV DSCP statistics
              * Per Aggregation Group
              * Per Protocol Per Aggregation Group
              * Per Aggregation Group Per Host
              * Per Aggregation Group Per Host-Pair

            In order to maintain the RMON 'look-and-feel' and semantic
            consistency, some of the text from the RMON-2 and HC-RMON
            MIBs by Steve Waldbusser has been adapted for use in this
            MIB."
    REVISION  "200111050000Z"
       DESCRIPTION
            "Initial version of the DSMON MIB module.  This version
            published as RFC xxxx (to be assigned by the RFC Editor)."
  ::= { rmon 26 }


-- a NODES clause is added to formalize and more easily find
-- the OBJECT IDENTIFIER MIB root nodes defined in a MIB MODULE
-- this list is allowed to be empty

NODES {
    dsmonObjects       OBJECT IDENTIFIER ::= { dsmonMIB 1 }
    dsmonNotifications OBJECT IDENTIFIER ::= { dsmonMIB 2 }
    dsmonConformance   OBJECT IDENTIFIER ::= { dsmonMIB 3 }

    dsmonAggObjects    OBJECT IDENTIFIER ::= { dsmonObjects 1 }

    -- the following objects removed from the example
    dsmonStatsObjects  OBJECT IDENTIFIER ::= { dsmonObjects 2 }
    dsmonPdistObjects  OBJECT IDENTIFIER ::= { dsmonObjects 3 }
    dsmonHostObjects   OBJECT IDENTIFIER ::= { dsmonObjects 4 }
    dsmonCapsObjects   OBJECT IDENTIFIER ::= { dsmonObjects 5 }
    dsmonMatrixObjects OBJECT IDENTIFIER ::= { dsmonObjects 6 }
}

-- converted DsmonAggGroupIndex TC to a TYPEDEF






Expires May 12, 2002                                           [Page 28]





Internet Draft             SMI Data Structures         November 12, 2001


TYPEDEF SCALAR DsmonAggGroupIndex {
    SYNTAX Integer32 (0..2147483647)
    STATUS current
    DESCRIPTION
       "This TC describes a data type which identifies a DSMON
        aggregation group, which is an arbitrary grouping of DSCP
        values, for monitoring purposes only. The range for this
        data type begins with zero (instead of one), to allow for a
        direct mapping between DSCP and aggregation group values."
}

-- converted DsmonAggProfileIndex TC to a TYPEDEF

TYPEDEF SCALAR DsmonAggProfileIndex {
    SYNTAX Integer32 (1..2147483647)
    STATUS current
    DESCRIPTION
            "This TC describes a data type which identifies a DSMON
            aggregation profile, which is a set of aggregation group
            assignments for each of the 64 DSCP values, for a particular
            statistical collection."
}

--
-- this object could have been defined as an ARRAY,
-- or wrappered (as it is) inside STRUCT definition,
-- which can be extended over time.
--

-- converted dsmonAggProfileTable

TYPEDEF STRUCT DsmonAggProfile {
    DESCRIPTION
        "Controls the setup of a single aggregation profile,
         for which every DSCP value MUST be configured
         into exactly one aggregation group.

         This object MUST NOT be modified if the dsmonAggControlLocked
         object is equal to 'true'.

         If the agent supports non-volatile configuration of this
         object, then upon system initialization, this object SHOULD be
         initialized with the saved values."

    ARRAY aggGroupMapping {





Expires May 12, 2002                                           [Page 29]





Internet Draft             SMI Data Structures         November 12, 2001


        DESCRIPTION
            "A set of 64 DSCP to Aggregation Group Index mappings."

        INDEX  {
            SYNTAX  Dscp
            SIZE    (64)     -- fixed array of 64 entries
            DESCRIPTION
                "The specific DSCP value which is configured in an
                aggregation group by this entry."
        }
        -- more INDEX clauses may be present, for multi-dimensional arrays

        SCALAR dsmonAggGroupIndex {
            SYNTAX      DsmonAggGroupIndex
            MAX-ACCESS  read-write
            STATUS      current
            DESCRIPTION
                "The aggregation group which contains this DSCP value.  Upon
                creation of a new sub-tree (set of 64 entries with the same
                dsmonAggControlIndex value) in this object, the agent SHOULD
                initialize all related instances of this object to the value
                zero.

                This object MUST NOT be modified if the
                dsmonAggControlLocked object is equal to 'true'."
            DEFVAL { 0 }
        } ::= 1
   } ::= 1
}

-- following is done as an inline array instead of a
-- separate struct definition (like DsmonAggProfile) for
-- demonstration purposes

-- converted dsmonAggGroupTable

TYPEDEF ARRAY DsmonAggGroup {
    DESCRIPTION
        "Controls the setup of a single aggregation profile,
         for which every DSCP value MUST be configured
         into exactly one aggregation group.

         This object MUST NOT be modified if the
         dsmonAggControlLocked object is equal to 'true'.






Expires May 12, 2002                                           [Page 30]





Internet Draft             SMI Data Structures         November 12, 2001


         If the agent supports non-volatile configuration of this
         object, then upon system initialization, this object SHOULD be
         initialized with the saved values."

    INDEX  {
        SYNTAX  DsmonAggGroupIndex   -- range of the INDEX
        SIZE    (0..2147483647)      -- range of the instances
        DESCRIPTION
            "The specific Aggregation Group which is represented
             group by each entry."
    }

    SCALAR dsmonAggGroupDescr {
        SYNTAX      SnmpAdminString (SIZE(0..64))
        MAX-ACCESS  read-create
        STATUS      current
        DESCRIPTION
            "An administratively assigned description of the
             aggregation group identified by this entry.

             Upon first creation of an instance of this object,
             the agent SHOULD set this object to the empty string.

             This object MUST NOT be modified if the associated
             dsmonAggGroupStatus object is equal to 'active', or the
             dsmonAggControlLocked object is equal to 'true'."
    } ::= 1
}

-- converted dsmonAggControlTable

TYPEDEF STRUCT DsmonAggControl {
    DESCRIPTION
        "Provides an overall description and control
      point for a single aggregation control configuration.

         This object MUST NOT be modified if the dsmonAggControlLocked
         object is equal to 'true'."

    SCALAR dsmonAggControlDescr {
        SYNTAX      SnmpAdminString (SIZE(0..64))
        MAX-ACCESS  read-create
        STATUS      current
        DESCRIPTION
            "An administratively assigned description of the aggregation





Expires May 12, 2002                                           [Page 31]





Internet Draft             SMI Data Structures         November 12, 2001


            profile identified by this entry.

            Upon first creation of an instance of this object, the agent
            SHOULD set this object to the empty string.  If the agent
            supports non-volatile storage, then this object SHOULD be
            re-initialized with its stored value after a system reboot.

            This object MUST NOT be modified if the associated
            dsmonAggControlStatus object is equal to 'active', or the
            dsmonAggControlLocked object is equal to 'true'."
    } ::= 1

    STRUCT aggProfile {
        SYNTAX DsmonAggProfile
        STATUS      current
        DESCRIPTION
           "A set of DSCP to Aggregation Group mappings."
    } ::= 2

    ARRAY aggGroup {
        SYNTAX      DsmonAggGroup
        STATUS      current
        DESCRIPTION
            "An array of Aggregation Group descriptions."
    } ::= 3

    SCALAR dsmonAggControlOwner {
        SYNTAX     OwnerString
        MAX-ACCESS read-create
        STATUS     current
        DESCRIPTION
            "The entity that configured this object and is therefore
            using the resources assigned to it."
    } ::= 4

    SCALAR dsmonAggControlStatus {
        SYNTAX      RowStatus
        MAX-ACCESS  read-create
        STATUS      current
        DESCRIPTION
            "The status of this entire aggregation control object.

            An entry MUST NOT exist in the active state unless all
            objects in the entry have an appropriate value.






Expires May 12, 2002                                           [Page 32]





Internet Draft             SMI Data Structures         November 12, 2001


            This object MUST NOT be modified if the
            dsmonAggControlLocked object is equal to 'true'."
    } ::= 5
}

--
-- variable declarations for the 4 scalars in this group
--

SCALAR dsmonMaxAggGroups {
    SYNTAX      Integer32 (2..64)
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
        "The maximum number of aggregation groups that this agent
         can support.
         (Rest of text removed to keep the example shorter.)"
} ::= { dsmonAggObjects 1 }

SCALAR dsmonAggControlLocked {
    SYNTAX      TruthValue
    MAX-ACCESS  read-write
    STATUS      current
    DESCRIPTION
        "Controls the setup of aggregation groups for this agent.
         (Rest of text removed to keep the example shorter.)"
} ::= { dsmonAggObjects 2 }

SCALAR dsmonAggControlChanges {
    SYNTAX      Counter32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
        "This object counts the number of times the value of the
         dsmonAggControlLocked object has changed.
         (Rest of text removed to keep the example shorter.)"
} ::= { dsmonAggObjects 3 }

SCALAR dsmonAggControlLastChangeTime {
    SYNTAX      TimeStamp
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
        "This object identifies the value of sysUpTime at the moment
         the dsmonAggControlLocked object was last modified.





Expires May 12, 2002                                           [Page 33]





Internet Draft             SMI Data Structures         November 12, 2001


         (Rest of text removed to keep the example shorter.)"
} ::= { dsmonAggObjects 4 }

-- finishing the dsmonAggControlTable by allowing multiple
-- instances of an aggregation control block

ARRAY dsmonAggProfiles {
    STATUS      current
    DESCRIPTION
        "A collection of DSMON aggregation control profiles.

         This object MUST NOT be modified if the dsmonAggControlLocked
         object is equal to 'true'.

         If the agent supports non-volatile configuration of this
         object, then upon system initialization, this object SHOULD be
         initialized with the saved values."
    INDEX  {
        SYNTAX  DsmonAggProfileIndex
        SIZE    (1..2147483647)      -- variable sized array
        DESCRIPTION
            "The specific Aggregation Profile which is represented
             group by each entry."
    }

    STRUCT aggControl {
        SYNTAX DsmonAggControl
        STATUS current
        DESCRIPTION
           "The DSMON Aggregation Control entry for each profile."
    } ::= 1
} ::= { dsmonAggObjects 5 }

-- No NOTIFICATION-TYPE macros defined in this module

-- Compliance section (unchanged from SMIv2)

dsmonAggControlCompliance MODULE-COMPLIANCE
    STATUS  current
    DESCRIPTION
            "Example compliance for the aggregation control
             portion of the DSMON-MIB module."
    MODULE  -- this module
        MANDATORY-GROUPS { dsmonAggControlGroup }






Expires May 12, 2002                                           [Page 34]





Internet Draft             SMI Data Structures         November 12, 2001


    ::= { dsmonCompliances 1 }

dsmonAggControlGroup OBJECT-GROUP
    OBJECTS {
             dsmonMaxAggGroups,
             dsmonAggControlLocked,
             dsmonAggControlChanges,
             dsmonAggControlLastChangeTime,
             dsmonAggControlDescr,
             dsmonAggControlOwner,
             dsmonAggControlStatus,
             dsmonAggGroupIndex,
             dsmonAggGroupDescr
    }
    STATUS  current
    DESCRIPTION
            "A collection of objects used to configure and manage
            aggregation groups for DSMON collection purposes."
    ::= { dsmonGroups 1 }

}   -- END DSMON-MIB MODULE

Note 1) The following example shows the difference between SMIv2 naming
and SMI-DS naming, for the OBJECT IDENTIFIERS in the DSMON-MIB module
example above.

 Object Instance Examples
------------------------------
 O=Old (SMIv2), N=New (SMI-DS)

dsmonAggGroup scalars:
   dsmonMaxAggGroups
     O: dsmonAggObjects.1.0
     N: dsmonAggObjects.1
   dsmonAggControlLocked
     O: dsmonAggObjects.2.0
     N: dsmonAggObjects.2
   dsmonAggControlChanges
     O: dsmonAggObjects.3.0
     N: dsmonAggObjects.3
   dsmonAggControlLastChangeTime
     O: dsmonAggObjects.4.0
     N: dsmonAggObjects.4

dsmonAggControlTable example for row 77:





Expires May 12, 2002                                           [Page 35]





Internet Draft             SMI Data Structures         November 12, 2001


   dsmonAggControlDescr
     O: dsmonAggObjects.5.1.2.77
     N: dsmonAggObjects.5.77.0.1.0.1
   dsmonAggControlOwner
     O: dsmonAggObjects.5.1.3.77
     N: dsmonAggObjects.5.77.0.1.0.4
   dsmonAggControlStatus
     O: dsmonAggObjects.5.1.3.77
     N: dsmonAggObjects.5.77.0.1.0.5

dsmonAggProfileTable example for row 77.22:
   dsmonAggGroupIndex
     O: dsmonAggObjects.6.1.2.77.22
     N: dsmonAggObjects.5.77.0.1.0.2.0.1.22.0.1

dsmonAggGroupTable example for row 77.44:
   dsmonAggGroupDescr
     O: dsmonAggObjects.7.1.1.77.44
     N: dsmonAggObjects.5.77.0.1.0.3.44.0.1
   dsmonAggGroupStatus
     O: dsmonAggObjects.7.1.2.77.44
     N: not needed because dsmonAggControlStatus
        controls the entire object



























Expires May 12, 2002                                           [Page 36]





Internet Draft             SMI Data Structures         November 12, 2001


6.  Definitions

The follow sections specify the SMI Data Structures syntax and
semantics.

[ed. -- this section is intentionally incomplete, because the first
draft is meant to introduce the SMI Data Structures concepts, syntax,
and examples.  Complete specification to the level of SMIv2 is TBD.]

6.1.  Namespaces

The type names and variable names used in SMI Data Structures are
contained is the same namespace, similar to the SMIv2 namespace for
OBJECT-TYPE descriptors, but not shared with SMIv2.

Ideally, every data object containment level would define its own
namespace, in a truly hierarchical fashion.  However, this would not be
compatible with existing SMIv2 practices, and would require changes to
the IMPORTS, MODULE-COMPLIANCE and OBJECT-GROUP macros to support.

[ed. - further definition of namespaces TBD]

6.2.  Syntax

[ed. - the following ad-hoc syntax definition is a first-pass attempt,
and obviously needs ABNF definition, and a detailed mappings and rules
section for each construct.]

<module> ::=

    "MODULE" <module-name> "{"
        <imports-decl>
        <module-identity-decl>
        [<nodes-decl>]
        [<module-decl> ...]
        <compliance-section>
    "}"

<imports-decl> ::=  (same as SMIv2)

<module-identity-decl> ::=  (same as SMIv2)

<nodes-decl> ::=

    "NODES" "{"





Expires May 12, 2002                                           [Page 37]





Internet Draft             SMI Data Structures         November 12, 2001


       [<node-decl> ...]
    "}"

<node-decl> ::= (same as SMIv2 OBJECT IDENTIFIER)

<module-decl> ::=

    (<typedef-decl> | <var-decl> | <notification-decl> )

<typedef-decl> ::=

    ( <scalar-typedef> | <array-typedef> |
       <union-typedef> | <struct-typedef> | <augments-decl> )

<var-decl> ::=

    ( <scalar-var-decl> | <array-var-decl> |
      <union-var-decl>  | <struct-var-decl> )

<scalar-typedef> ::=

    "TYPEDEF" "SCALAR" <type-name> <scalar-core-decl>

<type-name> ::=

    (same rules as for SMIv2 TEXTUAL-CONVENTION descriptors)

<scalar-core-decl> ::=

    "{"
        [<display-part>]
        <syntax-clause>
        [<units-clause>]
        <max-access-clause>
        <status-clause>
        <description-clause>
        [<reference-clause>]
        [<defval-clause>]
     "}"

<display-part> ::=   (same as SMIv2 DIPLAY-HINT)

<syntax-clause> ::=

   (same as SMIv2, except new base and float data types added)





Expires May 12, 2002                                           [Page 38]





Internet Draft             SMI Data Structures         November 12, 2001


<max-access-clause> ::= (same as SMIv2)

<status-clause> ::= (same as SMIv2)

<units-clause> ::= (same as SMIv2)

<description-clause> ::= (same as SMIv2)

<reference-clause> ::= (same as SMIv2)

<defval-clause> ::= (same as SMIv2)

<scalar-type-decl> ::=

    "SCALAR" <object-descriptor> <scalar-core-decl>
        "::=" <N>

<object-descriptor> ::=

    (same rules as for SMIv2 OBJECT-TYPE descriptors)

<N> ::= an INTEGER in the range (1..4294967295)

<scalar-var-decl> ::=

    "SCALAR" <object-descriptor> <scalar-core-decl>
        "::=" <oid-assignment>

<oid-assignment> ::=  (same as SMIv2)

<array-typedef> ::=

    "TYPEDEF" "ARRAY" <type-name> <array-inline-core-decl>

<array-inline-core-decl> ::=
    "{"
       <description-clause>
       [<reference-clause>]
       <index-decl> [<index-decl> ...]
       [<object-decl> ...]
    "}"

<index-decl> ::=

    "INDEX" [<object-descriptor>] "{"





Expires May 12, 2002                                           [Page 39]





Internet Draft             SMI Data Structures         November 12, 2001


        <syntax-clause>
        [<units-clause>]
        <size-clause>
        <description-clause>
        [<reference-clause>]
    "}"

-- size clause is the number of allowed instances, not just max

<size-clause> ::=  "(" ( <fixed-size> | <variable-size> ) ")"

<fixed-size> ::= INTEGER between (1 .. 2147483647)

<variable-size> ::= <size-number> ".." <size-number>

    (where the second <size-number> must be larger than
     the first <size-number>)

<size-number> ::= INTEGER between (0 .. 2147483647)

<object-decl> ::=

    ( <scalar-type-decl> | <array-type-decl> |
      <union-type-decl>  | <struct-type-decl> )

<array-type-decl> ::=

    ( <array-inline-type-decl> | <array-ref-type-decl> )

<array-inline-type-decl> ::=

    "ARRAY" <object-descriptor> <array-inline-core-decl>
         "::=" <N>

<array-ref-type-decl> ::=

    "ARRAY" <object-descriptor> <array-ref-core-decl>
        "::=" <N>

<array-ref-core-decl> ::=

    "{"
       <syntax-clause>
       <status-clause>
       <description-clause>





Expires May 12, 2002                                           [Page 40]





Internet Draft             SMI Data Structures         November 12, 2001


       [<reference-clause>]
    "}"

<array-var-decl> ::=

   ( <array-inline-var-decl> | <array-ref-var-decl> )

<array-inline-var-decl> ::=

    "ARRAY" <object-descriptor> <array-inline-core-decl>
        "::=" <oid-assignment>

<array-ref-var-decl> ::=

    "ARRAY" <object-descriptor> <array-ref-core-decl>
        "::=" <oid-assignment>

<union-typedef> ::=

    "TYPEDEF" "UNION" <type-name> <union-inline-core-decl>

<union-inline-core-decl> ::=

    "{"
        <description-clause>
        [<reference-clause>]
        [<object-decl> ...]
    "}"

<union-type-decl> ::=

    ( <union-inline-type-decl> | <union-ref-type-decl> )

<union-inline-type-decl> ::=

    "UNION" <object-descriptor> <union-inline-core-decl>
        "::=" <N>

<union-ref-type-decl> ::=

    "UNION" <object-descriptor> <union-ref-core-decl>
        "::=" <N>

<union-ref-core-decl> ::=






Expires May 12, 2002                                           [Page 41]





Internet Draft             SMI Data Structures         November 12, 2001


    "{"
        <syntax-clause>
        <status-clause>
        <description-clause>
        [<reference-clause>]
    "}"

<union-var-decl> ::=

    ( <union-inline-var-decl> | <union-ref-var-decl> )

<union-inline-var-decl> ::=

    "UNION" <object-descriptor> <union-inline-core-decl>
        "::=" <oid-assignment>

<union-ref-var-decl> ::=

    "UNION" <object-descriptor> <union-ref-core-decl>
        "::=" <oid-assignment>

<struct-typedef> ::=

    "TYPEDEF" "STRUCT" <type-name> <struct-inline-core-decl>

<struct-inline-core-decl> ::=

    "{"
        <description-clause>
        [<reference-clause>]
        [<object-decl> ...]
    "}"

<struct-type-decl> ::=

    ( <struct-inline-type-decl> | <struct-ref-type-decl> )

<struct-inline-type-decl> ::=

    "STRUCT" <object-descriptor> <struct-inline-core-decl>
        "::=" <N>

<struct-ref-type-decl> ::=

    "STRUCT" <object-descriptor> <struct-ref-core-decl>





Expires May 12, 2002                                           [Page 42]





Internet Draft             SMI Data Structures         November 12, 2001


        "::=" <N>

<struct-ref-core-decl> ::=

    "{"
        <syntax-clause>
        <status-clause>
        <description-clause>
        [<reference-clause>]
    "}"

<struct-var-decl> ::=

    ( <struct-inline-var-decl> | <struct-ref-var-decl> )

<struct-inline-var-decl> ::=

    "STRUCT" <object-descriptor> <struct-inline-core-decl>
        "::=" <oid-assignment>

<struct-ref-var-decl> ::=

    "STRUCT" <object-descriptor> <struct-ref-core-decl>
        "::=" <oid-assignment>

<augments-decl> ::=

    "AUGMENTS" <aug-construct-type> <type-name> "{"
        <description-clause>
        [<object-decl> ...]
    "}" "::=" <augmentNode>

<aug-construct-type> ::= ( "ARRAY" | "UNION" | "STRUCT" )

<augmentNode> ::= (defined in section 5.5)

<notification-decl> ::= (same as SMIv2)

<compliance-section> ::= (same as SMIv2)











Expires May 12, 2002                                           [Page 43]





Internet Draft             SMI Data Structures         November 12, 2001


7.  Intellectual Property

The IETF takes no position regarding the validity or scope of any
intellectual property or other rights that might be claimed to  pertain
to the implementation or use of the technology described in this
document or the extent to which any license under such rights might or
might not be available; neither does it represent that it has made any
effort to identify any such rights.  Information on the IETF's
procedures with respect to rights in standards-track and standards-
related documentation can be found in BCP-11.  Copies of claims of
rights made available for publication and any assurances of licenses to
be made available, or the result of an attempt made to obtain a general
license or permission for the use of such proprietary rights by
implementors or users of this specification can be obtained from the
IETF Secretariat.

The IETF invites any interested party to bring to its attention any
copyrights, patents or patent applications, or other proprietary rights
which may cover technology that may be required to practice this
standard.  Please address the information to the IETF Executive
Director.

8.  Acknowledgements

Portions of the existing SMI RFCs, SMIng drafts, and the ANSI C
Programming Language inspired many of the concepts discussed in this
memo.























Expires May 12, 2002                                           [Page 44]





Internet Draft             SMI Data Structures         November 12, 2001


9.  Appendix A: Discussion of SMIng Objectives

This section lists each accepted design objective described in the SMIng
Objectives document [SMING_OBJ], and explains how SMI-DS addresses the
objective.

4.1.1 The Set of Specification Documents [Yes]

Description
     SMIv2 is defined in three documents, based on an obsolete ITU ASN.1
     specification.  SPPI is defined in one document, based on SMIv2.
     The core of SMIng must be defined in one document and must be
     independent of external specifications.

Fulfillment
     SMI-DS can meet this objective by simply placing as much text as
     desired in a single document.

4.1.2 Textual Representation [Yes]

Description
     SMIng definitions must be represented in a textual format.

Fulfillment
     SMI-DS meets this objective because it is specified using only
     textual characters.

4.1.3 Human Readability [Yes]

Description
     The syntax must make it easy for humans to directly read and write
     SMIng modules.  It must be possible for SMIng module authors to
     produce SMIng modules with text editing tools.

Fulfillment
     The SMI-DS syntax is very close (or identical) to SMIv2 in all
     respects, so it will be easy for MIB authors and readers to use.

4.1.4 Rigorously Defined Syntax [Yes - TBD]

Description
     There must be a rigorously defined syntax for the SMIng language.

Fulfillment
     Once the syntax is finalized, all SMI-DS constructs will be





Expires May 12, 2002                                           [Page 45]





Internet Draft             SMI Data Structures         November 12, 2001


     rigorously defined, including the constructs which do not change
     from SMIv2.

4.1.5 Accessibility [Yes]

Description
     Attribute definitions must indicate whether attributes can be read,
     written, created, deleted, and whether they are accessible for
     notifications, or are not accessible.  Align PIB-ACCESS and MAX-
     ACCESS, and PIB-MIN-ACCESS and MIN-ACCESS.

Fulfillment
     The MAX-ACCESS clause is retained from SMIv2. PIB versions of these
     constructs do not really differ in semantics, just in name.  PIBs
     and MIBs use the same MAX-ACCESS clause.

4.1.6 Language Extensibility [Maybe]

Description
     The language must have characteristics, so that future modules can
     contain information of future syntax without breaking original
     SMIng parsers.

Fulfillment
     Although this objective benefits very few people, it can be
     achieved by rigorously defining the SMI-DS syntax so that a parser
     can always determine where a construct begins and ends.

4.1.7 Special Characters in Text [No]

Description
     Allow an escaping mechanism to encode special characters, e.g.
     double quotes and new-line characters, in text such as DESCRIPTIONs
     or REFERENCEs.

Fulfillment
     Currently there are no mechanisms added to these SMIv2 constructs
     used without modification in SMI-DS. It is not clear why forcing
     the author to use single quotes is unreasonable. Not sure why this
     is a problem.  Adding cryptic character sequences conflicts with
     objective 4.1.3.

4.1.8 Naming [Yes]







Expires May 12, 2002                                           [Page 46]





Internet Draft             SMI Data Structures         November 12, 2001


Description
     SMIng must provide mechanisms to uniquely identify attributes,
     groups of attributes, and events.  It is necessary to specify how
     name collisions are handled.

Fulfillment
     SMI-DS meets all these requirements. Namespaces are handled the
     same as in SMIv2.

4.1.9 Namespace Control [Yes]

Description
     There must be a hierarchical, centrally-controlled namespace for
     standard named items, and a distributed namespace must be supported
     to allow vendor-specific naming and to assure unique module names
     across vendors and organizations.

Fulfillment
     SMI-DS meets this requirement by providing true hierarchical
     naming.  SMI-DS and SMIv2 objects can exist in the same namespace.
     Enterprise-specific definitions and augmentations are supported.

4.1.10 Modules [Yes]

Description
     SMIng must provide a mechanism for uniquely identifying a module,
     and specifying the status, contact person, revision information,
     and the purpose of a module.  SMIng must provide mechanisms to
     group definitions into modules and it must provide rules for
     referencing definitions from other modules.

Fulfillment
     SMI-DS information modules are conceptually identical to SMIv2
     information modules, including the IMPORTS clause.

4.1.11 Module Conformance [Yes]

Description
     SMIng must provide mechanisms to detail the minimum requirements
     implementers must meet to claim conformance to a standard based on
     the module.

Fulfillment
     SMI-DS conformance constructs (such as MAX-ACCESS, MODULE-
     COMPLIANCE, OBJECT-GROUP, NOTIFICATION-GROUP) are unchanged from





Expires May 12, 2002                                           [Page 47]





Internet Draft             SMI Data Structures         November 12, 2001


     SMIv2.

4.1.12 Arbitrary Unambiguous Identities [Yes]

Description
     SMI allows the use of OBJECT-IDENTITIES to define unambiguous
     identities without the need of a central registry.  SMI uses OIDs
     to represent values that represent references to such identities.
     SMIng needs a similar mechanism (a statement to register
     identities, and a base type to represent values).

Fulfillment
     Base type semantics (including OBJECT IDENTIFIER) are unchanged
     from SMIv2.

4.1.13 Protocol Independence [Maybe]

Description
     SMIng must define data definitions in support of the SNMP and COPS-
     PR protocols.  SMIng may define data definitions in support of
     other protocols.

Fulfillment
     SMI-DS is fully compatible with the SNMP protocol, even though
     SMIv2 is table-oriented and SNMP is biased for this data structure.
     COPS-PR may be biased or dependent on a table-based data structure.
     Given the lack of significant deployment of either SMIv2 or SPPI
     based device configuration management, there is little evidence
     that this the 'flat table' data model is working.

4.1.14 Protocol Mapping [Yes]

Description
     The SMIng working group, in accordance with the working group
     charter, will define mappings of protocol independent data
     definitions to protocols based upon installed implementations.  The
     SMIng working group can define mappings to other protocols as long
     as this does not impede the progress on other objectives.

Fulfillment
     As long as the protocol is actually independent of the data
     definition language and its naming scheme (as advertised with
     SNMP), accessible data objects (i.e. SCALARs) can be manipulated in
     the same manner as accessible SMIv2 objects.






Expires May 12, 2002                                           [Page 48]





Internet Draft             SMI Data Structures         November 12, 2001


4.1.15 Translation to Other Data Definition Languages [Maybe - TBD]

Description
     SMIng language constructs must, wherever possible, be translatable
     to SMIv2 and SPPI.  At the time of standardization of a SMIng
     language, existing SMIv2 MIBs and SPPI PIBs on the standards track
     will not be required to be translated to the SMIng language.  New
     MIBs/PIBs will be defined using the SMIng language.

Fulfillment
     Algorithms can be specified to convey each SMI-DS construct to one
     or more SMIv2 constructs. Complex nesting must be unfolded into a
     set of associated SMIv2 tables, each table corresponding to the
     accessible objects at a given nest level of the SMI-DS object.
     Existing SMIv2 tables can easily be converted to SMI-DS using the
     ARRAY construct. There is currently no SMI-DS mechanism for the
     SMIv2 IMPLIED keyword in INDEX clauses.

4.1.16 Base Data Types  [Yes]

Description
     SMIng must support the base data types Integer32, Unsigned32,
     Integer64, Unsigned64, Enumeration, Bits, OctetString, and OID.

Fulfillment
     The SMIv2 base data types are unchanged in SMI-DS.  The Integer64
     and Unsigned64 base data types will also be added.

4.1.17 Enumerations [Yes]

Description
     SMIng must provide support for enumerations.  Enumerated values
     must be a part of the enumeration definition.

Fulfillment
     SMI-DS provides enumerated INTEGERs, unchanged from SMIv2.

4.1.18 Discriminated Unions [Yes]

Description
     SMIng must support discriminated unions.

Fulfillment
     SMI-DS provides the UNION construct to explicitly define (in a
     machine-parseable manner) a group of objects with the





Expires May 12, 2002                                           [Page 49]





Internet Draft             SMI Data Structures         November 12, 2001


     characteristics of a discriminated union. A STRUCT can be defined
     which includes the discriminator SCALAR object and the UNION
     object, to further express these semantics. (See HostInetAddress
     example in section 5.6).

4.1.19 Instance Pointers [Yes]

Description
     SMIng must allow specifying pointers to instances (i.e., a pointer
     to a particular attribute in a row).

Fulfillment
     The concept of a 'row' does not apply to SMI-DS, only to SMIv2,
     however OBJECT IDENTIFIER data objects can point to accessible
     SMIv2 tabular objects.  SMI-DS allows OBJECT IDENTIFIER pointers to
     reference any accessible data object at any nest level.

4.1.20 Row Pointers [Yes]

Description
     SMIng must allow specifying pointers to rows.

Fulfillment
     The concept of a 'row' does not apply to SMI-DS, only to SMIv2,
     however OBJECT IDENTIFIER data objects can point to SMIv2 rows.
     SMI-DS allows OBJECT IDENTIFIER pointers to reference any data
     object at any nest level, including a reference to the container
     and the instance of that container, for each nest level. E.g., if
     foo[1].bar is the accessible object, then OID pointers to 'foo',
     and 'foo[1]' are supported.

4.1.21 Constraints on Pointers [Yes - TBD]

Description
     SMIng must allow specifying the types of objects to which a pointer
     may point.

Fulfillment
     A new variant of the SYNTAX clause could be defined which restricts
     a particular data type that the OID pointer.  E.g., "SYNTAX POINTER
     FooObject" or "SYNTAX POINTER InetAddress", would actually define
     an OBJECT IDENTIFIER.

4.1.22 Base Type Set [Yes]






Expires May 12, 2002                                           [Page 50]





Internet Draft             SMI Data Structures         November 12, 2001


Description
     SMIng must support a fixed set of base types of fixed size and
     precision.  The list of base types must not be extensible unless
     the SMI itself changes.

Fulfillment
     SMI-DS uses a fixed set of base data types.

4.1.23 Extended Data Types [Yes]

Description
     SMIng must support a mechanism to derive new types, which provide
     additional semantics (e.g., Counters, Gauges, Strings, etc.), from
     base types.  It may be desirable to also allow the derivation of
     new types from derived types.  New types must be as restrictive or
     more restrictive than the types that they are specializing.

Fulfillment
     SMI-DS provides the TYPEDEF construct to specify complex or derived
     data types. SCALAR definitions can derive attributes from a base
     type or another derived type.

4.1.24 Units, Formats, and Default Values of Defined Types and
Attributes [Yes]

Description
     In SMIv2 OBJECT-TYPE definitions may contain UNITS and DEFVAL
     clauses and TEXTUAL-CONVENTIONs may contain DISPLAY-HINTs.  In a
     similar fashion units and default values must be applicable to
     defined types and format information must be applicable to
     attributes.

Fulfillment
     SMI-DS retains the UNITS, DEFVAL, and DISPLAY-HINT clauses for all
     SCALAR data type definitions and variable declarations.

4.1.25 Table Existence Relationships [Yes]

Description
     SMIng must support INDEX, AUGMENTS, and EXTENDS in the SNMP/COPS-PR
     protocol mappings.

Fulfillment
     These concepts have been included in SMI-DS, and AUGMENTS has been
     extended to any non-SCALAR TYPEDEF.  The EXTENDS construct is





Expires May 12, 2002                                           [Page 51]





Internet Draft             SMI Data Structures         November 12, 2001


     achieved by simply augmenting an existing ARRAY with a another
     (nested) ARRAY.

4.1.26 Table Existence Relationships (2) [Yes]

Description
     SMIng must support EXPANDS and REORDERS relationships in the
     SNMP/COPS-PR protocol mappings.

Fulfillment
     SMI-DS is not a table-oriented data definition language like SMIv2
     or SPPI. Complex data objects are defined in a nested manner to
     convey a hierarchical relationship. The EXPANDS and REORDERS
     clauses are only meaningful in this table-oriented framework.
     However, the DESCRIPTION clause is provided to express semantics
     such as EXPANDS and REORDERS.

4.1.27 Attribute Groups [Yes]

Description
     An attribute group is a named, reusable set of attributes that are
     meaningful together.  It can be reused as the type of attributes in
     other attribute groups (see also Section 4.1.28).  This is similar
     to `structs' in C.

Fulfillment
     SMI-DS provides the STRUCT macro for this purpose.

4.1.28 Containment [Yes]

Description
     SMIng must provide support for the creation of new attribute groups
     from attributes of more basic types and potentially other attribute
     groups.

Fulfillment
     SMI-DS allows arbitrary nesting of STRUCT, ARRAY, and UNION type
     definitions.

4.1.29 Single Inheritance [Yes]

Description
     SMIng must provide support for mechanisms to extend attribute
     groups through single inheritance.






Expires May 12, 2002                                           [Page 52]





Internet Draft             SMI Data Structures         November 12, 2001


Fulfillment
     SMI-DS allows new complex types to contain other complex types, by
     reference, i.e. the contained data object inherits all attributes
     from the type as defined in another TYPEDEF (and AUGMENTS, if any).

4.1.30 Reusable vs. Final Attribute Groups [Yes]

Description
     SMIng must differentiate between "final" and reusable attribute
     groups, where the reuse of attribute groups covers inheritance and
     containment.

Fulfillment
     SMI-DS provides the TYPEDEF macro to create reusable definitions,
     and variable declarations to identify 'final' attribute groups.

4.1.31 Events [Yes]

Description
     SMIng must provide mechanisms to define events which identify
     significant state changes.

Fulfillment
     The NOTIFICATION-TYPE macro is used (currently unchanged) from
     SMIv2.

4.1.32 Creation/Deletion [Maybe]

Description
     SMIng must support a mechanism to define creation/deletion
     operations for instances.  Specific creation/deletion errors, such
     as INSTALL-ERRORS, must be supported.

Fulfillment
     A new data objected RowStatus could be defined, or the existing
     RowStatus simply used 'as-is' with data objects.  This objective is
     very 'table-oriented' and protocol-specific.  SMI-DS is intended to
     be protocol-independent.

4.1.33 Range and Size Constraints [Yes]

Description
     SMIng must allow specifying range and size constraints where
     applicable.






Expires May 12, 2002                                           [Page 53]





Internet Draft             SMI Data Structures         November 12, 2001


Fulfillment
     The SYNTAX clause is unchanged from SMIv2, which includes a range
     construct. A new SIZE construct has been added for ARRAY data types
     (INDEX clause) to identify array size constraints. The number of
     allowed instances for a particular INDEX is not required to be the
     same as the range of the INDEX variable itself. Fixed and variable
     sized arrays can be specified with this clause.

4.1.34 Uniqueness [Maybe]

Description
     SMIng must allow the specification of uniqueness constraints on
     attributes.  SMIng must allow the specification of multiple
     independent uniqueness constraints.

Fulfillment
     Instance identifiers are of course unique.  The DESCRIPTION clause
     is available to specify uniqueness requirements for any data type
     or object.

4.1.35 Extension Rules [Maybe - TBD]

Description
     SMIng must provide clear rules how one can extend SMIng modules
     without causing interoperability problems "over the wire".

Fulfillment
     The final version of SMI-DS will include a rigorous syntax, but
     there are no plans for an explicit EXTENSION construct, to allow
     SMI-DS to be extended in an distributed and uncontrolled manner.

4.1.36 Deprecate Use of IMPLIED Keyword [Yes]

Description
     The SMIng SNMP mapping must deprecate the use of the IMPLIED
     indexing schema.

Fulfillment
     The IMPLIED construct is removed from the SMI-DS INDEX construct.

4.1.37 No Redundancy [Yes]

Description
     The SMIng language must avoid redundancy.






Expires May 12, 2002                                           [Page 54]





Internet Draft             SMI Data Structures         November 12, 2001


Fulfillment
     SMI-DS remove any clause that is always the same value in all
     situations (e.g. MAX-ACCESS clause for the fooTable and fooEntry
     OBJECT-TYPE macros is always not-accessible, so only SCALAR data
     objects have a MAX-ACCESS clause).  The 'fooEntry' definition is
     removed entirely, and since SMI-DS is data object, not table
     oriented, there is no need for the ASN.1 'FooEntry SEQUENCE'
     construct.  Basic containment relationships are implied by the
     complex data types themselves (nested ARRAY, UNION, STRUCT) rather
     than by using lots of verbose OBJECT-TYPE DESCRIPTION clauses to
     declare the containment relationships between various OBJECT-TYPE
     macros.

4.1.38 Compliance and Conformance [Yes]

Description
     SMIng must provide a mechanism for compliance and conformance
     specifications for protocol-independent definitions as well as for
     protocol mappings.

Fulfillment
     The SMI-DS module compliance section is unchanged from SMIv2.  Just
     like SMIv2, only accessible (SCALAR) objects are listed in this
     section.

4.1.39 Allow Refinement of All Definitions in Conformance Statements
[Yes - TBD]

Description
     SMIv2, RFC 2580, Section 3.1 says: <para removed> The last sentence
     forbids to put a not-accessible INDEX object into an OBJECT-GROUP.
     Hence, you can not refine its syntax in a compliance definition.
     For more details, see http://www.ibr.cs.tu-bs.de/ietf/smi-errata/.

Fulfillment
     The arbitrary rules for SMIv2 can be changed, as they are adapted
     to SMI-DS. It is understood that every SMIv2 construct used in SMI-
     DS is subject to bugfixes.

4.1.40 Categories [No]

Description
     SMIng must provide a mechanism to group definitions into subject
     categories.  Concrete instances may only exist in the scope of a
     given subject category or context.





Expires May 12, 2002                                           [Page 55]





Internet Draft             SMI Data Structures         November 12, 2001


Fulfillment
     SMI-DS currently has no such construct.  This would require
     management and coordination of the set of categories, and therefore
     further thought.  Such a construct could be added if required.

4.1.41 Core Language Keywords vs. Defined Identifiers [No - TBD]

Description
     In SMI and SPPI modules some language keywords (macros and a number
     of basetypes) have to be imported from different SMI language
     defining modules, e.g.  OBJECT-TYPE, MODULE-IDENTITY, Integer32
     must to be imported from SNMPv2-SMI and TEXTUAL- CONVENTION must be
     imported from SNMPv2-TC, if used.  MIB authors are continuously
     confused about these import rules.  In SMIng only defined
     identifiers must be imported.  All SMIng language keywords must be
     implicitly known and there must not be a need to import them from
     any module.

Fulfillment
     Currently, the SMI-DS IMPORTS clause is unchanged from SMIv2.  It
     would be a mistake to forbid IMPORTS of base data types, since this
     is just one more thing for authors to get wrong.  The burden of
     listing all external definitions, including base types, in the
     IMPORTS clause is not a problem worth solving. The SMI-DS rules
     could be changed to make IMPORTS of base types forbidden, optional,
     or mandatory, whatever is required. This issue is not a problem
     worth solving.

4.1.42 Instance Naming  [No]

Description
     Instance naming in SMIv2 and SPPI is different.  SMIng must align
     the instance naming (either in the protocol neutral model or the
     protocol mappings).

Fulfillment
     Both SMIv2 and SPPI use flat naming schemes that cannot be extended
     to complex data structures, which itself is enough reason not to
     merge SMI and SPPI naming.  It would be a critical mistake to
     attempt to name data objects in different ways, in a construct
     independent of the data object definition itself.  This would make
     the data definition language very difficult to read and write.
     There is no reason to name SMI-DS objects differently for SNMP or
     COPS-PR, because SMI-DS uses a nested data object model, not a
     model based an groups of associated tables.





Expires May 12, 2002                                           [Page 56]





Internet Draft             SMI Data Structures         November 12, 2001


4.1.43 Length of Identifiers [Yes - TBD]

Description
     The allowed length of the various kinds of identifiers must be
     extended from the current `should not exceed 32' (maybe even from
     the `must not exceed 64') rule.

Fulfillment
     All the arbitrary SMIv2 rules are subject to removal or repair as
     they are transferred to SMI-DS. The maximum descriptor length an
     agent must accept will be extended to 64.

4.1.44 Assign OIDs in the Protocol Mappings [No]

Description
     SMIng must not assign OIDs to reusable definition of attributes,
     attribute groups, events, etc.  Instead, SNMP and COPS-PR mappings
     must assign OIDs to the mapped items.

Fulfillment
     Although TYPEDEF definitions actually meet this requirement because
     only variable declarations can have complete OID assignments, it
     would be a critical mistake to separate data object naming from the
     data definition itself.  There is no justification whatsoever for
     the management transport protocol to dictate the naming
     characteristics of the data definition language.

4.2.1 Methods [No]

Description
     SMIng should support a mechanism to define method signatures
     (parameters, return values, exception) that are implemented on
     agents.

Fulfillment
     SMI-DS defines a data definition language with sufficient power to
     be used as a platform for object-oriented network management
     definitions in the future (ala C --> C++ transition).

4.2.2 Unions [Yes]

Description
     Allows an attribute to contain one of many types of values.  The
     lack of unions has also lead to relatively complex sparse table
     work-around in some DISMAN mid-level managers.  Despite from





Expires May 12, 2002                                           [Page 57]





Internet Draft             SMI Data Structures         November 12, 2001


     discriminated unions (see Section 4.1.18), this kind of union has
     no accompanied explicit discriminator attribute that selects the
     union's type of value.

Fulfillment
     SMI-DS provides the UNION macro for this purpose.

4.2.3 Float Data Types [Yes]

Description
     SMIng should support the base data types Float32, Float64,
     Float128.

Fulfillment
     SMI-DS will support a Float data type. Is is not clear that 3
     variants are needed though.

4.2.4 Comments [Yes]

Description
     The syntax of comments should be well defined, unambiguous and
     intuitive to most people, e.g., the C++/Java `//' syntax.

Fulfillment
     The ASN.1 comment meets these requirements and is used unchanged
     from SMIv2. There is no community requirement to use Java style
     comments. The use of 2 dashes for a 'start of comment' token is not
     any better or worse than 2 slashes. Not a change worth making.

4.2.5 Referencing Tagged Rows [No]

Description
     PIB and MIB row attributes reference a group of entries in another
     table.  SPPI formalizes this by introducing PIB-TAG and PIB-
     REFERENCES clauses.  This functionality should be retained in
     SMIng.

Fulfillment
     SMI-DS does not use a table-oriented data model, so these
     constructs do not apply.

4.2.6 Arrays [Yes]

Description
     SMIng should allow the definition of a SEQUENCE OF attributes or





Expires May 12, 2002                                           [Page 58]





Internet Draft             SMI Data Structures         November 12, 2001


     attribute groups (Section 4.1.27).

Fulfillment
     SMI-DS provides the ARRAY macro for this purpose.

4.2.7 Internationalization [No - TBD]

Description
     Informational text (DESCRIPTION, REFERENCE, ...) should allow
     i18nized encoding, probably UTF-8.

Fulfillment
     SMI-DS used the DESCRIPTION and REFERENCE clauses unchanged from
     SMIv2. Changes to these clauses could be made if required, but
     unless standard (IETF) information modules are written in a
     language other than English, this only applies to vendor MIBs.

4.2.8 Separate Data Modelling from Management Protocol Mapping [No]

Description
     It should be possible to separate the domain specific data
     modelling work from the network management protocol specific work.

Fulfillment
     It would be a critical mistake to design a data definition language
     based on the quirks of management protocols which transport this
     data. It is be just as bad to partition the data definitions by
     protocol-specific attributes.  (In other words, a management
     protocol which is tightly coupled to a data definition language
     naming scheme is badly designed.)




















Expires May 12, 2002                                           [Page 59]





Internet Draft             SMI Data Structures         November 12, 2001


10.  References

[DSMON-MIB]
     Bierman, A., "Remote Monitoring MIB Extensions for Differentiated
     Services", Work in progress (draft-ietf-rmonmib-dsmon-mib-08.txt),
     Cisco Systems, Inc., October 2001.

[IANA_ENT]
     IANA, "Private Enterprise Numbers", http://www.isi.edu/in-
     notes/iana/assignments/enterprise-numbers, November 2001.

[INET_TC]
     Daniele, M., Haberman, B., Routhier, S., and J. Schoenwaelder,
     "Textual Conventions for Internet Network Addresses", Work in
     progress (draft-ietf-ops-rfc2851-update-05.txt), Consultant, Nortel
     Networks, Wind River Systems, Inc., TU Braunschweig, October 2001.

[RFC1155]
     Rose, M., and K. McCloghrie, "Structure and Identification of
     Management Information for TCP/IP-based Internets", RFC 1155,
     Performance Systems International, Hughes LAN Systems, May 1990.

[RFC1157]
     Case, J., Fedor, M., Schoffstall, M., and J. Davin, "Simple Network
     Management Protocol", RFC 1157, SNMP Research, Performance Systems
     International, Performance Systems International, MIT Laboratory
     for Computer Science, May 1990.

[RFC1212]
     Rose, M., and K. McCloghrie, "Concise MIB Definitions", RFC 1212,
     Performance Systems International, Hughes LAN Systems, March 1991.

[RFC1215]
     M. Rose, "A Convention for Defining Traps for use with the SNMP",
     RFC 1215, Performance Systems International, March 1991.

[RFC1901]
     SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and S.
     Waldbusser, "Introduction to Community-based SNMPv2", RFC 1901,
     SNMP Research, Inc., Cisco Systems, Inc., Dover Beach Consulting,
     Inc., International Network Services, January 1996.

[RFC1905]
     SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and S.
     Waldbusser, "Protocol Operations for Version 2 of the Simple





Expires May 12, 2002                                           [Page 60]





Internet Draft             SMI Data Structures         November 12, 2001


     Network Management Protocol (SNMPv2)", RFC 1905, SNMP Research,
     Inc., Cisco Systems, Inc., Dover Beach Consulting, Inc.,
     International Network Services, January 1996.

[RFC1906]
     SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and S.
     Waldbusser, "Transport Mappings for Version 2 of the Simple Network
     Management Protocol (SNMPv2)", RFC 1906, SNMP Research, Inc., Cisco
     Systems, Inc., Dover Beach Consulting, Inc., International Network
     Services, January 1996.

[RFC2026]
     Bradner, S., "The Internet Standards Process -- Revision 3", RFC
     2026, Harvard University, October, 1996.

[RFC2119]
     S. Bradner, "Key words for use in RFCs to Indicate Requirement
     Levels" RFC 2119, Harvard University, March 1997.

[RFC2570]
     Case, J., Mundy, R., Partain, D., and B. Stewart, "Introduction to
     Version 3 of the Internet-standard Network Management Framework",
     RFC 2570, SNMP Research, Inc., TIS Labs at Network Associates,
     Inc., Ericsson, Cisco Systems, April 1999.

[RFC2571]
     Harrington, D., Presuhn, R., and B. Wijnen, "An Architecture for
     Describing SNMP Management Frameworks", RFC 2571, Cabletron
     Systems, Inc., BMC Software, Inc., IBM T. J. Watson Research, April
     1999.

[RFC2572]
     Case, J., Harrington D., Presuhn R., and B. Wijnen, "Message
     Processing and Dispatching for the Simple Network Management
     Protocol (SNMP)", RFC 2572, SNMP Research, Inc., Cabletron Systems,
     Inc., BMC Software, Inc., IBM T. J. Watson Research, April 1999.

[RFC2573]
     Levi, D., Meyer, P., and B. Stewart, "SNMPv3 Applications", RFC
     2573, SNMP Research, Inc., Secure Computing Corporation, Cisco
     Systems, April 1999.

[RFC2574]
     Blumenthal, U., and B. Wijnen, "User-based Security Model (USM) for
     version 3 of the Simple Network Management Protocol (SNMPv3)", RFC





Expires May 12, 2002                                           [Page 61]





Internet Draft             SMI Data Structures         November 12, 2001


     2574, IBM T. J. Watson Research, April 1999.

[RFC2575]
     Wijnen, B., Presuhn, R., and K. McCloghrie, "View-based Access
     Control Model (VACM) for the Simple Network Management Protocol
     (SNMP)", RFC 2575, IBM T. J. Watson Research, BMC Software, Inc.,
     Cisco Systems, Inc., April 1999.

[RFC2578]
     McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.,
     and S. Waldbusser, "Structure of Management Information Version 2
     (SMIv2)", RFC 2578, STD 58, Cisco Systems, SNMPinfo, TU
     Braunschweig, SNMP Research, First Virtual Holdings, International
     Network Services, April 1999.

[RFC2579]
     McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.,
     and S. Waldbusser, "Textual Conventions for SMIv2", RFC 2579, STD
     58, Cisco Systems, SNMPinfo, TU Braunschweig, SNMP Research, First
     Virtual Holdings, International Network Services, April 1999.

[RFC2580]
     McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.,
     and S. Waldbusser, "Conformance Statements for SMIv2", RFC 2580,
     STD 58, Cisco Systems, SNMPinfo, TU Braunschweig, SNMP Research,
     First Virtual Holdings, International Network Services, April 1999.

[RFC2851]
     Daniele, M., Haberman, B., Routhier, S., and J. Schoenwaelder,
     "Textual Conventions for Internet Network Addresses", RFC 2851,
     Compaq Computer Corporation, Nortel Networks, Wind River Systems,
     Inc., TU Braunschweig, June 2000.

[SMING-OBJ]
     Elliot, C., Harrington, D., Jason, J., Schoenwaelder, J., Strauss,
     F., and W. Weiss, "SMIng Objectives", Work in progress (draft-ietf-
     sming-reqs-06.txt), Cisco Systems, Enterasys Networks, Intel
     Corporation, TU Braunschweig, Ellacoya Networks, October 2001.

11.  Security Considerations

This document defines a structure for management data and therefore does
not expose any management information from a particular device. However,
accessible data objects defined with the mechanisms defined in this
document should be given the same security consideration as objects





Expires May 12, 2002                                           [Page 62]





Internet Draft             SMI Data Structures         November 12, 2001


specified with SMIv2, when being transferred with SNMP.

SNMPv1 by itself is not a secure environment.  Even if the network
itself is secure (for example by using IPSec), even then, there is no
control as to who on the secure network is allowed to access and GET/SET
(read/change/create/delete) the objects in this MIB.

It is recommended that the implementors consider the security features
as provided by the SNMPv3 framework.  Specifically, the use of the User-
based Security Model RFC 2574 [RFC2574] and the View-based Access
Control Model RFC 2575 [RFC2575] is recommended.

It is then a customer/user responsibility to ensure that the SNMP entity
giving access to an instance of this MIB, is properly configured to give
access to the objects only to those principals (users) that have
legitimate rights to indeed GET or SET (change/create/delete) them.

12.  Author's Address

     Andy Bierman
     Cisco Systems, Inc.
     170 West Tasman Drive
     San Jose, CA USA 95134
     Phone: +1 408-527-3711
     Email: abierman@cisco.com

























Expires May 12, 2002                                           [Page 63]





Internet Draft             SMI Data Structures         November 12, 2001


13.  Full Copyright Statement

Copyright (C) The Internet Society (2001).  All Rights Reserved.

This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it or
assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are included
on all such copies and derivative works.  However, this document itself
may not be modified in any way, such as by removing the copyright notice
or references to the Internet Society or other Internet organizations,
except as needed for the purpose of developing Internet standards in
which case the procedures for copyrights defined in the Internet
Standards process must be followed, or as required to translate it into
languages other than English.

The limited permissions granted above are perpetual and will not be
revoked by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an "AS
IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK
FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT
LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT
INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR
FITNESS FOR A PARTICULAR PURPOSE.
























Expires May 12, 2002                                           [Page 64]

