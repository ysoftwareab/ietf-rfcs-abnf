service-type       = generic-uri-scheme / service-scheme
generic-uri-scheme = ALPHA *( alpha / digit / '+' / '-' / '.' )
service-scheme     = "service:" type ['.' na ] [':' type ]
type               = 1*(alpha / digit / '+' / '-' )
na                 = 1*(alpha / digit / '+' / '-' )
                          ; The naming authority field SHOULD have the
                          ; form described in [vendorext]

reserved   = '(' / ')' / ',' / '\' / '!'  / '<' / '=' / '>' /
                  '~' /CTL / ';' / '*' / '+'
escape-val = '\' HEXDIG HEXDIG

attr-list  = attribute / attribute ',' attr-list
attribute  = '(' attr-tag '=' val-list ')' / attr-tag
val-list   = attr-val / attr-val ',' val-list
attr-tag   = 1*( ALPHA / DIGIT / '-')
               ; As per LDAPv3 AttributeTypeDescription [RFC2252]
nonstd-tag = "x-" enum '-' 1*safe-tag
enum       = 1*DIGIT
               ; The <enum> field corresponds to an Enterprise
               ; Number registered with IANA. [IANA] Using this
               ; prefix avoids collisions in interpretation of
               ; nonstandard attribute name.
attr-val   = intval / strval / boolval / opaque
intval     = [-]1*DIGIT
strval     = 1*safe-val
boolval    = "true" / "false"
opaque     = "\FF" 1*escape-val
safe-val   = ; Any character except reserved.
reserved   = '(' / ')' / ',' / '\' / '!'  / '<' / '=' / '>' / '~' / CTL
escape-val = '\' HEXDIG HEXDIG

   An Attribute List MUST be scanned prior to evaluation for all
   occurrences of the escape character '\'.  Reserved characters MUST be
   escaped while other characters MAY be escaped.  All escaped
   characters MUST be restored to their value before attempting string
   matching.  Escaped Opaque values are converted into bytes, not into
   characters.

   The following list contains more detail on the various types of
   Attributes:

      Boolean      A Boolean Attribute MUST have a value list that is
                   one of the Boolean constants "true" or "false". A
                   Boolean value list MUST only have a single value and
                   MUST only be compared with '='.  As with all
                   strings, the Boolean constants are case insensitive.

      Integer      An Integer Attribute MUST have a value list
                   consisting of Integer constants. Integer constants
                   MUST be strings that take the form [-] 1*DIGIT and
                   fall in the range "-2147483648" to "2147483647",
                   that is, the range of 32 bit signed integers.
                   Integer values MUST be compared using integer
                   comparison.

      Opaque       An Opaque Attribute MUST have a value list
                   consisting of opaque values. Opaque values are
                   sequences of bytes.  These MUST be distinguished
                   from strings since they begin with the sequence
                   "\FF".  Unescaping this sequence results in an
                   illegal UTF-8 encoding, indicating that what follows
                   is a sequence of escaped bytes and not a UTF-8
                   string.  For example, a '0' byte is encoded
                   "\FF\00" and "\ff\00\00\30\39" is a
                   bigendian representation of 12345.  Opaque values
                   MUST only be compared with '='.

      String       All other string values are String type. String
                   values MUST be matched using strict lexical
                   ordering.   Example of string values with
                   escaped characters: "Hello\0a" (Hello with
                   a newline) and "\48\65\6c\6c\6f\0a"
                   (the same string, entirely escaped).  To
                   include reserved characters as string data
                   they must be escaped.  Example "a,b" is "a\40b".
                   Illegal UTF-8 characters MUST NOT be included
                   in Strings, ie. "a\ff" is illegal.

      Keyword      A Keyword Attribute has only a tag. A Keyword
                   Attribute MUST be designated by attr-tag in the
                   Attribute List, and it MUST have no values.

   Syntax errors in the Attribute List MUST result in a PARSE ERROR,
   which is returned if the request was unicast.

   When values are advertised by a SA or are registered in a DA, they
   MUST take on implicit typing rules for matching incoming requests,
   according to the types described above. Stored value types in
   Attribute Lists MUST be consistent, i.e., x=4,true,sue,\ff\00\00 is
   in error. Inconsistent stored value types in a SrvReg MUST result in
   a PARSE ERROR returned to the SA.

   A DA MUST consolidate multiple instances of the same Attribute within
   an Attribute List before storing and an SA MUST consolidate multiple
   instances before sending the Attribute in an AttrRply. For example,
   if the Attribute List received by a DA is:

      "(x=5,6,7),(y=a,b,c),(x=6,7,8)"

   one Attribute, "x", is stored having value list "5,6,7,8".

   Embedded blanks in Attribute tags and value lists MUST be elided as
   part of the tags or values in which they appear.  For attribute
   values, blanks internal to the value MUST NOT be ignored. For
   example, in the Attribute List "(attra = -345)", the Attribute tag is
   "attra" and the value is the integer "-345".

simple-query  =  conjoin / term
conjoin       =  "(&" term-list ')'
term-list     =  term term-list / term
term          =  '(' tag querytype item ')' / '(' tag "=*)"
                 ; The "=*" term tests if the Attribute is
                 ; present.
tag           =  1*( ALPHA / DIGIT / "-")
                 ; As per LDAPv3 AttributeTypeDescription [RFC2252]
querytype     =  '='  / "~=" / ">=" / "<="
                 ; These correspond to equal, approx,
                 ; greater than or equal, less than or
                 ; equal.
item          =  value / substring
                 ; Only substring matching is supported.
value         =  1*val-safe
substring     =  [ value ] any [ value ]
any           =  '*' *(value "*")
val-unsafe    =  '(' / ')' / ',' / '' / '!'  / '<' / '=' /
                          '>' / '~' / CTL
val-safe      =  ; All UTF-8 characters are included
                 ; except those in val-unsafe. Val-unsafe
                 ; must be escaped.
escaped       =  '' HEXDIG HEXDIG

   Attribute tags and String values MUST be case-folded before
   performing string matching, as per Section 4.3.1.   Matching rules
   for other types are as described in 4.3.6.

   If a Service Template [RFC2609] is available, the Service Template
   SHOULD be used to guide matching of types. If no Service Template is
   available, for ordered string matching, values MUST be matched using
   an implicit type system.

   If the Attribute in the query has been registered with multiple
   values, the query MUST be compared to each value and the results MUST
   be combined with logical 'OR', i.e., "(x=\ff\00)" matches an
   advertisement of (x=\ff\33,\ff\00); "(Y<=0)" matches (y=0,-1).
   Keywords (i.e., Attributes without values) MUST be matched with a
   "presence" query, as in "(keyword=*)".

   WARNING! SPECIAL CASE:  Ordering comparisons with strings and
   integers is subtle.  Integer comparison is only used if both values
   are integers.  Since implicit type matching is done, this can lead to
   unexpected results.
   Values of ['-']1*DIGIT MUST be treated as integers, so a service
   advertisement with Attribute List "(x=12),(y=-55)" would match the
   query "(&(x>=6)(y<=-44))".  Note that integers MUST NOT match
   strings, for example, the search query "(x=34*)" matches an Attribute
   List "(x=34foo)", but not "(x=3432)" since the first value is a
   String while the second value is an Integer.

   Examples: Given an attribute list "(a=12),(b=10,100),(c=100foo)", the
   query "(a<=16)" is a match.  The query "(a<=100.)" is not a match,
   since "100." is a string, so the value "12" must be treated as a
   string and "100 " is less than "12" by string ordering.  The filter
   "(b<=20)" matches, because y can be 10, but "(b<='1000')" does not
   match: "'1000'" begins with a "'" (0x20), whic is less than the
   character "1", the first character of "10" and "100" values of b.
   The filter "(c<=2)" matches because c is a string, starting with "1".

   A syntax error in a service query results in a PARSE_ERROR.

wild-card = ['*'] attr-tag ['*']

query-only=true" in their Attribute List. A query for this Attribute
