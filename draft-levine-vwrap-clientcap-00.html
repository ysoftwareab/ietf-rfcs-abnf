<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Client Capabilities for VWRAP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Client Capabilities for VWRAP">
<meta name="keywords" content="template">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">VWRAP</td><td class="header">D. Levine, Ed.</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">IBM Thomas J. Watson Research</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">Center</td></tr>
<tr><td class="header">Expires: September 2, 2010</td><td class="header">S. Deffeyes</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">IBM CIO Innovation</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">March 01, 2010</td></tr>
</table></td></tr></table>
<h1><br />Client Capabilities for VWRAP<br />draft-levine-vwrap-clientcap-00</h1>

<h3>Abstract</h3>

<p>client side capabilities for VWRAP.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on September 2, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Requirements Language<br />
<a href="#anchor2">2.</a>&nbsp;
overview<br />
<a href="#anchor3">3.</a>&nbsp;
Motivation<br />
<a href="#anchor4">4.</a>&nbsp;
Requirements<br />
<a href="#anchor5">5.</a>&nbsp;
Rest/Caps style model for client resources<br />
<a href="#anchor6">6.</a>&nbsp;
Overall approach<br />
<a href="#anchor7">7.</a>&nbsp;
A simple example (friendship)<br />
<a href="#anchor8">8.</a>&nbsp;
An eventq URI<br />
<a href="#anchor9">9.</a>&nbsp;
Putting it all together<br />
<a href="#anchor10">10.</a>&nbsp;
From login to a client cap delivered message<br />
<a href="#anchor11">11.</a>&nbsp;
Login/Auth initial cap grants<br />
<a href="#anchor12">12.</a>&nbsp;
Setting up an event queue<br />
<a href="#anchor13">13.</a>&nbsp;
Wiring up the client side resource of a service<br />
<a href="#anchor14">14.</a>&nbsp;
Flowing a message to the handler<br />
<a href="#anchor15">15.</a>&nbsp;
Flowing a response<br />
<a href="#anchor16">16.</a>&nbsp;
Passing back content<br />
<a href="#IANA">17.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">18.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">19.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">19.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">19.2.</a>&nbsp;
Informative References<br />
<a href="#app-additional">Appendix&nbsp;A.</a>&nbsp;
Additional Stuff<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
overview</h3>

<p>
This note defines the use of "Client" side capabilities within the
VWRAP specifications. Client Capabilities are Capabilities, as defined
 by the VWRAP specifications, on the client or virtual worlds viewer.

</p>
<p>
Client side capabilities will often represent resources hosted on devices and
systems behind firewalls, and will thus be accessed via event queues are
similar mechanisms. This note defines patterns for using client side
capabilities, and an URI scheme for adressing such capabilities. A
fairly complete worked example is provided. The exact LLSD, the exact
      URI formats, and the example service are provided to illustrate the
      service pattern, and are extremely provisional. The sequence diagrams
      used to illustrate the flows, as well as the structural diagrams
      represent one possible approach to implementing the service pattern.
      Nothing beyond the interfaces would be normative. This note is an
informatoinal draft.   it is very preliminary and is intended to drive discussion.

</p>
<p>
This draft is likely to be updated in the next few days based on list
feedback.  

</p>
<p>Questions of note:
</p>
<p></p>
<ol class="text">
<li>How much run time / latency cost is associated with this design?
          As we move things from UDP to client side caps, what are the
          performance implications for the client?
</li>
<li>This design is intended to permit the substitution of r-http,
          websockets, or xmpp or similar transports in the architecture. How
          close do we come to that ideal?
</li>
<li>Will this model fit well with the security and trust policy model
          being comtemplated for VWRAP?
</li>
<li>Do we really want to specify that requests to the client should
          be valid on 'any' event queue pipe?? For instance, if I am at Joe's
          Pirate Bay region, maybe I do not want to service a request for
          friendship. Maybe i don't trust joe's pirate bay enuf to take
          friendship requests, maybe i only want to accept them from my nice
          safe trusted agentd.
</li>
<li>Is everything in the eventq uri needed? The viewer wouldnt't be
          servicing requests for other agents
</li>
<li>Why is host_end_cap specified the way it is? why is it not just a
          URI like it is today?
</li>
<li>Are we missing any key requirements here?
</li>
</ol>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Motivation</h3>

<p>
The VWRAP specifications derive much of their initial structure from the design patterns embodied
in Linden Lab(TM)'s Second Life(tm) virtual world service. This service has been
characterized by a fairly straightfoward deployment patttern, where services
are clustered and facaded behind large, unitary interfaces. 

</p>
<p>
In a faceded model it is easy to manage message routing. From the client's perspective, all traffic
terminates in the the facade.  There is an event queue or a two way pipe, and the client accepts
asynchronous traffic from any services within the facade from that message source. The facade
pattern hides any internal routing within the service deployment. There may be internal routing
occuring, but  the client is kept unaware of these issues. 

</p>
<p>
The VRWAP specifications describe a set of services. When those services are decomposed into multiple
deployment patterns, the question of how a given service can delivery asynchronous information to another service or 
client becomes cogent.  

</p>
<p>
The "caps granting" pattern makes it straight forward to return a cap to a seperate service. A client may contact
the seed cap granter at a URI and be handed a URI to a service hosted on a seperate server and indeed a service
which is not even hosted by the cap granter. Services returned by a single caps grant may span trust and administrative domeains.  
When theese services need to deliever asyncrhonous messages the routing problem becomes clear. 

</p>
<p>
The second motivation for this work is managing pairwise addition and evolution of protocols. 
The current design assumes that the "client" is a unitary, process with a deep understanding og the expected
services available on the servers. As the VWRAP specification grow, and we build and explore various ways
of delivering services, we will want to allow new services to be described, and we will almost certainly
find the current client approach limiting. Having an explicit way of saying "For this service, please
route notification to this endpoint" allows people to easily build a range of possible client side structures
including ones which are different than currnet clients.

</p>
<p>
These two sets of motivations drive a desire to explicitly model the service deployment and client deployment
model in a way that allows a dynamic associaton betwen the services. 

</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Requirements</h3>

<p>This note addresses the following requirements for service/client
      modeling in VWRAP:
</p>
<p></p>
<ol class="text">
<li>Support deploying services across arbitrary domain and hosting
          models In particular, permit services to be deployed across multiple
          hosts within a domain, clustering pipes, and securely sharing event
          queues and event delivery.
</li>
<li>Abstract away a specific single bidirectional pipe from the VWRAP
          specs Support event queues, r-http if it becomes a common pattern,
          websockets, if they become common, and full duplex schemes, such as
          xmpp, if they become viable
</li>
<li>Provide a model for architecturally describing resources on the
          client. This, in effect, is "addressing" client side resources,
          providing references to them.
</li>
<li>Permit service side deployers to pass around references to these
          client side resources within the service cloud safely and
          transparently
</li>
<li>
<ul class="text">
<li>Prevent services from spoofing messages to resources others
              than those they have been granted access to
</li>
<li>Provide a endpoint independent path to the client (via any
              eventq available, or any URI representing the client
              resource)
</li>
<li>Preventing guessing of endpoint resource addresses
</li>
</ul>
</li>
<li>Closely model the current event queue implementations
</li>
</ol>

<p>Support deploying services on multiple domains and hosting models
      Virtual worlds have a wide range of deployment patterns, and require a
      broad range of services, with different computational profiles. We want
      to enable people to delegate services to arbitrary servers. This should
      enable clouds to host services, and permit deployers to choose
      deployment models which meet their needs. Abstracting away specific
      pipes This is the single largest driver. We want to divorce the VWRAP
      specifications from the current Linden Lab event queue implementation,
      the UDP pipes, and any single approach to delivering bits to the client.
      VWRAP aspires to support virtual worlds over a period of multiple years.
      We assume that the pipes to clients will evolve over time. Creating a
      web services, URI addressed approach to managing connections to regions,
      is a powerful way to de-couple transport choices from protocol
      handlers.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Rest/Caps style model for client resources</h3>

<p>
       This represents one pattern which could address the requiements. One
open question is whether simply permitting each service to create an event
queue as needed is sufficient. 
     
</p>
<p>Once we want to model the client's resources separate from the
      communications pipes used to access those resources, we are faced with
      the problem of naming, and addressing those resources. The current
      client, mostly assumes that it can parse from message type to determine
      where the message should be routed. The overall justifications for using
      REST approaches are as cogent for the client, as any other portion of
      VWRAP. The REST model affords a consistent approach to modeling
      resources
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Overall approach</h3>

<p>We approach the overall design as describing access to resources
      hosted by clients. As many clients are inaccessible for full http access
      from the services which wish to contact them, we describe the overall
      approach, in a way which permits eventqueues to be used in the current
      implementation, and approaches such as reverse-HTTP (Sometimes refered
      to as rhttp, r-http or ptth) in the future with no changes to the basic
      approach. (and ideally none to the code, beyond supporting r-http
      listeners.) Named client side resources The major addition to the
      current model is that of addressable client side resources. This
      effectively extends the REST/ Capabilities model to interactions
      involving sending data to the client. Instead of sending them to the
      client as a single endpoint, we can route the data to specific endpoints
      managed by the client. By using the basic REST model for manipulating
      these resources, we get a simple, well defined set of interactions
      between services and client side resources.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
A simple example (friendship)</h3>

<p>So, instead of embedding friendship inside a IM message, or even in a
      separate message, and requiring the client to parse the header and then
      route the message, we instead define a resource on the client, which is
      associated with friendship messages. This resource is then passed to the
      service(s) which need to manipulate the resource. The common case will
      be that services will post messages to the client, but we define the
      model generally so that services can invoke normal REST semantic
      operations on the resources.
</p>
<p>Exposing client side resources with an event queue
</p>
<p>Since the client cannot directly expose its resources, the client
      relies on event queues to fetch requests destined for these resources
      from services. This is mediated via a COMET style event queue. The
      client polls the service, and when there are requests destined for it,
      it collects those requests and routes them to the handlers which process
      them.
</p>
<p>The requests contain the resource they are routed to, and the method
      to be invoked on the resource, as well as the payload of the
      request.
</p>
<p></p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;map&gt;
&lt;key&gt;sequence&lt;/key&gt;&lt;int&gt;sequence number&lt;/int&gt;
&lt;key&gt;resource&lt;/key&gt;&lt;string&gt;path of resource&lt;/string&gt;
&lt;key&gt;method&lt;/key&gt;&lt;string&gt;POST&lt;/string&gt;
&lt;key&gt;payload&lt;/key&gt;{LLSD of payload}
&lt;/map&gt;
</pre></div><p>

</p>
<p>Each request can be routed by the client side event queue to the
      desired handler. Note the separate event queues sharing one map of
      resource to handlers, and delivering events to shared handlers. Now, in
      order to complete this story, we need to describe how the services know
      what resources on the client they should post to, and how these
      resources are addressed.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
An eventq URI</h3>

<p>To support addressing client side resource reached event queues, we
      introduce an "eventq:" URI. eventq://client_id@fqdn_of_eventq_host/{path
      to resource} or eventqs://client_id@fqdn_of_eventq_host/{path to
      resource} For details on URI format,
      http://en.wikipedia.org/wiki/URI_scheme and more formally:
      http://tools.ietf.org/html/rfc3986 We are describing a scheme "eventq"
      with hierarchical part broken into the traditional "authority" and
      "path" Our authority is addressed as "client_id@fqdn_of eventq_host"
      What this says is "for the unique client (client_id) you can route via
      an event queue hosted by the host listed as "fqdn_of_eventq_host" which
      will be a hostname. To address the specic resource, on that client, you
      must provide the path. The client_id, is a short term unique string
      representing the client, during this session with the services cloud.
      This is provided to permit several important options. First, it permits
      us to pass a capability with an eventq: URI to a service which already
      has a connection to the client, and allows the transport level software
      to understand it already has a connection to the client. It also allows
      correct behavior in the face of an attempt to re-establish a connection
      to the eventq host, and finally, it allows services to chose *any* event
      queue it knows about which connects to the client for delivering it's
      requests to the client. This allows a number of potential deployment
      patterns which permit scaling of the computational fabric with no
      changes to the client, or necessarily the services. The eventqs scheme,
      is identical to the eventq scheme, with the added requirement that the
      underyling event queue be implemented using https or an equally secure
      transport, so that messages cannot be intercepted, and there is a high
      degree of confidence that the host holding the service end of the eventq
      is the desired host.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Putting it all together</h3>

<p>To actually use this plumbing, we need to associate the client side
      resource with the service which wishes to use it. We incorporate this
      into the setup flow needed to use the resource. The client/viewer
      requests a capability from a seed cap in the services network. (from
      initial login, or transitively from other caps) The service returns with
      a URI of the service side resource. The client then creates a client
      side resource (or resources) for the service to use, and passes them up
      to the service, which then begins to issue requests against these
      resources.
</p>
<p></p>
<ol class="text">
<li>Client/Viewer logs into a service and acquires one or more
          seedcaps
</li>
<li>The client requests a set of capabilities from the seedcaps.
</li>
<li>One or more of these capability requests includes an event
          queue
</li>
<li>The client establishes the event queues, posting its "client_id"
          to the event queue host.
</li>
<li>Zero or more of the capabilities requested use client side
          resources. For these capabilties, the client creates and registers a
          client side resource, in the form of a client capability, composes a
          URI for the resources, and informs the service of the URIs of the
          client side resources.
</li>
<li>The service side service begins posting requests on the
          associated event queues
</li>
<li>The client routes the requests to the registered handlers.
</li>
<li>We flow a response from the handler back to the invoker
</li>
</ol>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
From login to a client cap delivered message</h3>

<p>A small worked example. The actual service involved, and the
      deployment details of the service are purely notional. Do not focus on
      the specific service messages, but the routing and setup flows which
      enable the messages to flow.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Login/Auth initial cap grants</h3>

<p>This is pretty much VWRAP business as usual. The client connects to
      the authentication service, and gets a seedcap, on an Agent Domain
      Service (n, one of many)
</p>
<p></p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+----------------+       +-------------------+  +------------------+
| VWRAP viewer    |       | VWRAP Auth Service |  | Agent  Service |
+----------------+       +-------------------+  +------------------+
        |                          |                     |
        | Login()                  |                     |
        |--------------------- ---&gt;|                     |
        |                          |                     |
        | login_response(seed_cap) |                     |
        |&lt;-------------------------|                     |
        |                          |                     |
        | Request_caps(Caps list)  |                     |
        |-----------------------------------------------&gt;|
        |                          |                     |
        |                          |                     |
        |&lt;-----------------------------------------------|
                caps_granted(array of caps, URIs, of caps)
</pre></div><p>

</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Setting up an event queue</h3>

<p>Pretty straight forward. We create a handler on the client, which
      calls the cap the client got from the login step. 
     There is one additional tidbit that flows at this point,
      which is that we get the Host end of our caps. This fetches from the
      host side of the agent domain event queue, which we will use in our
      URIs. XXX dummy needs explaination here.
</p>
<p></p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;map&gt;a77e875e0f82d975@adhost.test.org/ccaps/e132c4ea-55c8-4be3-a77e-
&lt;key&gt;host_end_cap&lt;/key&gt;
&lt;string&gt;fully.qualified.domain.com&lt;/string&gt;
&lt;/map&gt;
</pre></div><p>

</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Wiring up the client side resource of a service</h3>

<p>The next step is the major addition to the sequence. We take the cap
      for a service we requested earlier, and then create the client side
      handler, associate it with a client side resource, and pass that
      resource to the service side cap.[NOTE:  this seems confusing, i think in
      part because I'm not sure who "we" is. So it is hard to tell who is
      telling whom. I think u know what you mean, but it's not coming across
      in the text. Also, Is there a step where the client 'advertises' what
      services it can provide on a specific event queue? And Does the server
      side 'ask' for a list of client side caps like the viewer asks for caps
      from the AD and region? ]
</p>
<p></p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;map&gt;
&lt;key&gt;org.VWRAP.friendship.client_listener&lt;/key&gt;
&lt;string&gt;eventq://4a0e0e09-d3e1-4ab8-bc3f-
875e0f82d975@adhost.test.org/ccaps/e132c4ea-55c8-4be3-a77e-
3ec91ef63b7a/fslistner&lt;/string&gt;
&lt;/map&gt;
</pre></div><p>

</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
Flowing a message to the handler</h3>

<p>Finally, with all the bits in place, the invoker can send an event,
      and expect it to get picked up at the far end by the handler. XXX is
      this the AD handler, the friendship services handler, or do you mean the
      client eq handler?? This thing just aches for an actual pooperpoint
      diagram. XXX Our hypothetical message is:
</p>
<p></p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;map&gt;
&lt;key&gt;request_type&lt;/key&gt;
&lt;string&gt;friendship request&lt;/string&gt;
&lt;key&gt;user social name&lt;/key&gt;
&lt;string&gt; Hippo The Avatarian&lt;/string&gt;
&lt;key&gt;user uuid&lt;/key&gt;
&lt;string&gt;4509971b-b2f3-43a9-bc71-1736c971a8f7&lt;/string&gt;
&lt;key&gt;message&lt;/key&gt;
&lt;string&gt;Please be my friend, we met at the hippo wallow last week
&lt;/string&gt;
&lt;/map&gt;
</pre></div><p>

</p>
<p>So, the Friendship services takes that payload, and the URI of the
      client's resource. It is out of scope, how it posts the request to the
      service end of the event queue. (being a deployer issue, not part of the
      public spec) It passes the URI, and the payload, and it gets to the
      input hopper of the event queue, along with the method being invoked.
      (in this case "POST") The event queue then packages up the message as
      part of the array of messages it has bound to the client: XXX not quite
      sure why you need to state it is out of scope. plz explainie.
</p>
<p></p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;array&gt;
.
.
&lt;map&gt;
&lt;key&gt;method&lt;/key&gt;&lt;string&gt;POST&lt;/string&gt;
&lt;key&gt;sequence id&lt;/key&gt;&lt;integer&gt;98726&lt;/integer&gt;
&lt;key&gt;resource&lt;/key&gt;
&lt;string&gt;/ccaps/e132c4ea-55c8-4be3-a77e-3ec91ef63b7a/fslistner&lt;/string&gt;
&lt;key&gt;payload&lt;/key&gt;
&lt;map&gt;
&lt;key&gt;request_type&lt;/key&gt;
&lt;string&gt;friendship request&lt;/string&gt;
&lt;key&gt;user social name&lt;/key&gt;
&lt;string&gt; Hippo The Avatarian&lt;/string&gt;
&lt;key&gt;user uuid&lt;/key&gt;
&lt;string&gt;4509971b-b2f3-43a9-bc71-1736c971a8f7&lt;/string&gt;
&lt;key&gt;message&lt;/key&gt;
&lt;string&gt;Please be my friend, we met at the hippo wallow last week
&lt;/string&gt;
&lt;/map&gt;
&lt;/map&gt;
&lt;/array&gt;
</pre></div><p>

</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
Flowing a response</h3>

<p>No such resource: If there is no client side handler at the resource
      listed in the request the event queue handler flows back a 404 responds
      per traditional http; XXX if we arent requiring http, do we need our own
      set of error codes defined?
</p>
<p></p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;array&gt;
..
&lt;map&gt;
&lt;key&gt;sequence number&lt;/key&gt;&lt;integer&gt;98726&lt;/integer&gt;

&lt;key&gt;http_response&lt;/key&gt;
&lt;map&gt;
&lt;key&gt;response code&lt;/key&gt;
&lt;integer&gt;404&lt;/integer&gt;
&lt;key&gt;payload&lt;/key&gt;
&lt;string&gt;
No resource associated with this key
&lt;/string&gt;
&lt;/map&gt;
&lt;/map&gt;
&lt;/array&gt;
</pre></div><p>

</p>
<p>Successful responses When the client's friendship handler has
      accepted the request, it can post a response. This can, of course,
      include simply accepting the request, and then posting an "accept
      friendship" message to the main cap, or accepting it directly, depending
      on the design of the friendship service. We will do both, for
      illustrative purposes
</p>
<p>Simple ok
</p>
<p>For the simple, accepted response, the handler will post back to the
      event queue an OK. (This is an internal flow, not part of the VWRAP
      architecture) and the event queue will then pass on the response to the
      invoker. it Structurally, this is very
      similar to the request. The get() call will pass up responses for
      handling by the service side event queue.
</p>
<p></p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;array&gt;
..
&lt;map&gt;
&lt;key&gt;sequence number&lt;/key&gt;
&lt;integer&gt;98726&lt;/integer&gt;

&lt;key&gt;http_response&lt;/key&gt;
&lt;map&gt;
&lt;key&gt;response code&lt;/key&gt;
&lt;integer&gt;200&lt;/integer&gt;
&lt;key&gt;payload&lt;/key&gt;
&lt;/map&gt;
&lt;/map&gt;
&lt;/array&gt;
</pre></div><p>

</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16"></a><h3>16.&nbsp;
Passing back content</h3>

<p>The final case, is actually passing back content on a reply. This
      merely adds the payload.
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;array&gt;
&lt;map&gt;
&lt;key&gt;sequence number&lt;/key&gt;
&lt;integer&gt;98726&lt;/integer&gt;

&lt;key&gt;http_response&lt;/key&gt;
&lt;map&gt;
&lt;key&gt;response code&lt;/key&gt;
&lt;integer&gt;200&lt;/integer&gt;
&lt;key&gt;payload&lt;/key&gt;
  &lt;map&gt;
  &lt;key&gt;request_type&lt;/key&gt;
  &lt;string&gt;friendship accept&lt;/string&gt;
  &lt;key&gt;user social name&lt;/key&gt;
  &lt;string&gt;Happy Songbird&lt;/string&gt;
  &lt;key&gt;user uuid&lt;/key&gt;
  &lt;string&gt;4509971b-ffa3-43a9-1748-1736c978fa3e&lt;/string&gt;
  &lt;key&gt;message&lt;/key&gt;
  &lt;string&gt;Thank you. I'd love to be friends.
  &lt;/string&gt;
  &lt;/map&gt;
&lt;/map&gt;
&lt;/map&gt;
&lt;/array&gt;
</pre></div><p>

</p>
<p>The overall pattern and other URIs.. The overall pattern is intended
      to provide a framework for handling not just eventq: sceme URIs, but any
      URI which will successfully flow the data between the two services. For
      this to work, the basic pattern, of setting a client side cap needs to
      keep in mind that the "eventq/eventqs" scheme is not the only URI which
      might be passed in the future.
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17"></a><h3>17.&nbsp;
IANA Considerations</h3>

<p>This memo includes no request to IANA.
</p>
<p>If this specification progresses, a request to IANA to register the
      eventq scheme might be contemplated
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18"></a><h3>18.&nbsp;
Security Considerations</h3>

<p>Event queues expose client side resources to messages from servers.
      The URI for eventq provides routing to these resources. This exposes
      these resources to a number of possible attacks. The use of
      capabilities, and the limitation that in order to access a client side
      capability, one has to have access to the host side of an event queue,
      eliminates most of the possible attacks. The current capabilities
      specification uses a 128 bit UUID, generated for each session, for each
      capability, to make the resource portion of the capability essentially
      un-guessable. This requires care in passing around capabilities, as if
      they are passed in plaintext, they would be subject to sniffing, and if
      passed in open sessions, such as http, they would be vulnerable to man
      in the middle attacks. Control of the services side endpoint of event
      queues provides a separate means of limiting the security issues.
      Nothing described here defines how the host end of an event queue is
      exposed to services. Depending on the host implementation, the resource
      could be accessible broadly, or only to programs running in the address
      space of the event queue. If the resource is made available broadly, the
      capability design limits the exposure of the resource to messages aimed
      at the actually resource, but opens up the event queue itself as a
      vehicle for denial of service attacks.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19"></a><h3>19.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>19.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="min_ref">[min_ref]</a></td>
<td class="author-text">authSurName, authInitials., &ldquo;Minimal Reference,&rdquo; 2006.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>19.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="cable">[cable]</a></td>
<td class="author-text">Intel, &ldquo;<a href="http://code.google.com/p/cablebeach/wiki/CableBeachCore1_0">Cable Beach Design Wiki</a>,&rdquo; 2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="caps">[caps]</a></td>
<td class="author-text">Linden Lab, &ldquo;<a href="http://tools.ietf.org/html/draft-lentczner-VWRAP-base-00">Open Grid Protocol: Foundation</a>,&rdquo; 2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="intro">[intro]</a></td>
<td class="author-text">Linden Lab, &ldquo;<a href="http://tools.ietf.org/html/draft-hamrick-VWRAP-intro-00">Open Grid Protocol: Foundation</a>,&rdquo; 2009.</td></tr>
</table>

<a name="app-additional"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Additional Stuff</h3>

<p>This becomes an Appendix.
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">David W. levine (editor)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">IBM Thomas J. Watson Research Center</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">19 Skyline Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Hawthorne, New York  10532</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 914-784-7427</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:dwl@us.ibm.com">dwl@us.ibm.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Suzy Deffeyes</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">IBM CIO Innovation</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">11501 Burnet Road</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Austin, Texas  78758</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 512-286-5904</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:suzyq@us.ibm.com">suzyq@us.ibm.com</a></td></tr>
</table>
</body></html>
