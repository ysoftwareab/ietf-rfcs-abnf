IPv6_Header_co       =       Version
                                    Traffic_Class_co
                                    ECT_Flag_co
                                    CE_Flag
                                    Flow_Label_co
                                    Payload_Length
                                    Next_Header
                                    Hop_Limit_co
                                    Source_Address_co
                                    Destination_Address_co

Version              =       VALUE(4,6,100%)

Traffic_Class        =       STATIC(100%)

ECT_Flag             =       STATIC(100%)

CE_Flag              =       VALUE(1,0,99%) | VALUE(1,1,1%)

Flow_Label           =       STATIC(100%)

Payload_Length       =       INFERRED-SIZE(16,288)

Next_Header          =       LABEL(8,next_header)

Hop_Limit            =       STATIC(100%)

Source_Address       =       STATIC(100%)

Destination_Address  =       STATIC(100%)

eg_1   = case_1 | case_2

case_1 = VALUE(1,0,90%)
                fields_in_between
                dependent_field_flag_is_0

case_2 = VALUE(1,1,10%)
                fields_in_between
                dependent_field_flag_is_1

eg_2   = LABEL(1,flag)
                fields_in_between
                NEXT_FIELD(flag)
                case_1 | case_2

case_1 = VALUE(1,0,90%)
                dependent_field_flag_is_0

case_2 = VALUE(1,1,10%)
                dependent_field_flag_is_1
eg_1 = LABEL(8,a_label)
              some_other_fields
              NEXT_FIELD(a_label)  ; compress the labelled value
              IRREGULAR(8,100%)
              LABEL(16,a_label)    ; re-use the label

eg_2 = LABEL(8,a_label)
              LABEL(16,a_label) ; attempt to re-define a label
                                ; prior to compressing its value


L = 8 * v + p

s  = the scale factor

n = length (context_val)

        # check that the value to be compressed matches each of the r
        # values stored in context for this encoding - if not then
        # STATIC can't be used to compress this encoding

temp = lsb (item, k)
full = 0
full = full + value (temp)
item = str (n, full)
item = str (n, v)
n = length (context_val)
p_item = str (n, p)
new_item = top (uncompressed_data, n)
temp = (new_item - context_val + p_item)
lsb_val = lsb (item, k)
n = length (context_val)
p_item = str (n, p)
twok_item = str (n, 2^k)

interval_start = context_val - p
interval_end = interval_start + twok_item
new_item = concat (msb (interval_start, (n-k)), recd)

start = value (interval_start)
end = value (interval_end)
new = value (new_item)

new_item = concat (msb (interval_end, (n-k)), recd)

scale_len = floor((value(label_value (n)) / d) * m + p)
len_item = label_value (n)
scale_len = floor( (value (len_item) / d) * m + p)
found = 0
i = 0

trans_item = str (n, a(i))
found = 1
i = i + 1
found = 0
i = 0

found = 1
i = i + 1
base = label_value (b)
offset = item - base
base = label_value (b)
item = offset + base
base = label_value (b)
offset = item - base
item = label_value (b)
base = item - offset
init_len = stack-size (uncompressed_data)

final_len = stack-size (uncompressed_data)

decomp_len = final_len - init_len
ip_sum = compute-16-checksum (uncompressed_data, decomp_len)

swapped = byte-swap (original)
original = decomped
original = byte-swap (decomped)
scaled_val = value (original) / scale_f
remainder = value (original) mod scale_f

original = ((scaled_val * scale_f) + remainder) mod 2^n
n = ceiling (log2(k-1))
can_compress = call new_method

n = ceiling (log2(k-1))
j = value (index)

