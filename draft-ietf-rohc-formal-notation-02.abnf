PROPOSED_FORMAT = FORMAT, 
CHECK_FORMAT = 0 -> 
                 ( 
                   format_name(NUM_FORMATS, CURRENT_FORMAT), 
                   updated_context(NAME, CURRENT_FORMAT) 
                   ; 
                   updated_context(NAME, 0), 
                   fail 
                 ) 
DISCRIMINATOR_AND_FORMAT = DISCRIMINATOR 
X = Y, 
VALUE = UNCOMP_VALUE, 
 
 
 
 
 
PROPOSED_VALUE = VALUE, 
PROPOSED_VALUE = VALUE, 
PROPOSED_FIELD_VALUE = FIELD_VALUE, 
PREFIX = co -> 
         true 
PREFIX = replicate 
WHICH = uncompressed_format -> 
         qualify_name('chosen_format', QUALIFIER, CHOSEN_FORMAT), 
         qualify_name('chosen_common', QUALIFIER, CHOSEN_COMMON), 
         comp(CHOSEN_FORMAT, FORMAT_NAME), 
         comp(CHOSEN_COMMON, COMMON_NAME), 
         ( 
           doing(compression) -> 
             uncomp(QUALIFIER, HEADER), 
             uncomp(FORMAT_NAME, HEADER), 
             uncomp(COMMON_NAME, HEADER), 
             uncomp(BACKUP_NAME, HEADER) 
           ; 
           true 
         ), 
         copy_items(FORMAT_NAME, COMMON_NAME, BACKUP_NAME, LIST, 0, 
WHICH = co_common -> 
           true 
WHICH = replicate_common 
WHICH = uncompressed_data -> 
         call_items(QUALIFIER, LIST, 0, FIXED_HEADER, 0), 
         uncomp(NAME, FIXED_HEADER) 
WHICH = compressed_data -> 
         call_items(QUALIFIER, LIST, 0, FIXED_HEADER, 1), 
         comp(NAME, FIXED_HEADER) 
WHICH = list_items -> 
         qualify_name('order', QUALIFIER, LIST_ORDER), 
         qualify_name('order_flag', QUALIFIER, ORDER_FLAG), 
         qualify_name('presence', QUALIFIER, LIST_PRESENCE), 
         qualify_name('presence_flag', QUALIFIER, PRESENCE_FLAG), 
         qualify_name('total', QUALIFIER, LIST_TOTAL), 
         ( 
           doing(decompression) -> 
             length(LIST, LENGTH), 
             LENGTH > 0, 
             INDEX_SIZE is ceiling(log(LENGTH) / log(2)), 
             comp(QUALIFIER, TOTAL_HEADER), 
             ORDER_FLAG, 
             PRESENCE_FLAG, 
             ( 
               uncomp(ORDER_FLAG, O_F), O_F = '0' -> 
                 context(LIST_ORDER, ORDER), 
 
 
 
 
 
                 defined(ORDER), 
                 uncomp(LIST_ORDER, ORDER), 
PARTIAL_HEADER = TOTAL_HEADER, 
SUB_HEADER = PARTIAL_HEADER 
COMP_START = 0 
ORDER = OLD_ORDER -> 
M_ORDER = '', 
PRESENCE = OLD_PRESENCE -> 
M_PRESENCE = '', 
 
 
 
 
 
M_PRESENCE = PRESENCE, 
WHICH = field_list -> 
         call_group_items(LIST, UNCOMP_FIELD), 
         uncomp(QUALIFIER, UNCOMP_FIELD), 
         comp(QUALIFIER, '') 
LIST = [ITEM] -> 
         ITEM 
BITS = '' -> 
       evaluate(16, 0, VALUE) 
N1 =< N -> 
         N2 is N - N1, 
         make_correct_length(N2, V, NEW_V) 
N = 0 -> 
NEW_V = V 
LIST = [] -> 
HEADER = '' 
LIST = [ENTRY | LIST1], 
ENTRY = (ITEM1 : _) -> 
         true 
ITEM1 = ENTRY 
UNCOMP_START = INT_LEN -> 
COMP_HEADER   = '', 
UNCOMP_HEADER = '', 
X = 0 -> 
             true 
X = '' -> 
             true 
TOTAL = 0 
ATOM_OPT = '1', 
ATOM_OPT = '1' -> 
 
 
 
 
 
           make_atom(ENTRY, ITEM), 
           qualify_name(ITEM, NAME, Q_ITEM), 
           uncomp_start(Q_ITEM, UNCOMP_START), 
           comp_start(Q_ITEM, COMP_START), 
           % write(Q_ITEM),nl, 
           Q_ITEM, 
           uncomp(Q_ITEM, UNCOMP_VALUE), 
           comp(Q_ITEM, COMP_VALUE), 
           atom_length(UNCOMP_VALUE, UNCOMP_LENGTH), 
           atom_length(COMP_VALUE, COMP_LENGTH), 
           UNCOMP_START1 is UNCOMP_START + UNCOMP_LENGTH, 
           COMP_START1 is COMP_START + COMP_LENGTH 
UNCOMP_VALUE = '', 
COMP_VALUE = '', 
UNCOMP_START1 = UNCOMP_START, 
COMP_START1 = COMP_START 
LIST = [] -> 
HEADER = '' 
LIST = [ENTRY | LIST1], 
ENTRY = (ITEM1 : _) -> 
         true 
ITEM1 = ENTRY 
CALLED_ITEM = Q_ITEM 
CALLED_ITEM = COMMON_ITEM 
CALLED_ITEM = BACKUP_ITEM 
LIST = [] -> 
UNCOMP_FIELD = '' 
LIST = [ITEM1 | LIST1] -> 
       call_group_items(LIST1, UNCOMP_REMAINDER), 
       make_atom(ITEM1, ITEM), 
       uncomp(ITEM, UNCOMP_VALUE), 
       atom_concat(UNCOMP_VALUE, UNCOMP_REMAINDER, UNCOMP_FIELD). 
    
COMMON_HEADER = '' 
COMMON_HEADER = '' 
NAME = .(LEFT, RIGHT) -> 
       make_atom(RIGHT, ATOMISED_RIGHT), 
       concat_atom([LEFT, ATOMISED_RIGHT], '.', ATOMISED_NAME) 
ATOMISED_NAME = NAME. 
 
 
 
 
 
    
    
EXPRESSION =.. [FUNCTOR | ARG_LIST], 
TERM =.. [FUNCTOR | INT_LIST], 
VALUE1 = TERM, 
LIST = [] -> 
         true 
LIST = [ITEM | LIST1], 
TEXT = (_ ::= _), 
TEXT = '' -> 
RULE_LIST = [] 
TEXT = (HEAD ::= BODY) -> 
       goal_list(BODY, GOALS, REMAINING_TEXT), 
       make_atom(HEAD, HEAD1), 
       reverse([HEAD1 | NAMES], NAMES1), 
       concat_atom(NAMES1, '.', QUALIFIED_HEAD), 
GOALS1 = sequence(GOALS), 
NEW_RULE = 
REMAINING_TEXT = ({TEXT_IN_CURLY_BRACES}, NEW_TEXT) -> 
               parse_text(TEXT_IN_CURLY_BRACES, [HEAD1 | NAMES], 
REMAINING_TEXT = {TEXT_IN_CURLY_BRACES} -> 
               parse_text(TEXT_IN_CURLY_BRACES, [HEAD1 | NAMES], 
NEW_TEXT = '' 
RULE_LIST1 = [], NEW_TEXT = REMAINING_TEXT 
BODY = (GOAL, BODY1) -> 
       GOAL \= {_}, 
       functor(GOAL, F, _), 
       ( 
 
 
 
 
 
         atom_codes(F, [A | _]), between(48, 49, A) -> 
GOAL1 = discriminator(F) 
GOAL1 = GOAL 
GOALS = [GOAL1 | GOALS1] 
GOALS = [GOAL1], 
REMAINING_TEXT = BODY1 
GOALS = [discriminator(F)] 
GOALS = [BODY] 
REMAINING_TEXT = ''. 
    
ARGS = 3 -> 
           ( debug(1) -> write('Updating context: '), write(NAME), nl; 
