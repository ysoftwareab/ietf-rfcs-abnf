
Internet Engineering Task Force                   R. E. Gilligan (Sun)
INTERNET-DRAFT                                   S. Thomson (Bellcore)
                                                    J. Bound (Digital)


                                                    January 9, 1996

                IPv6 Program Interfaces for BSD Systems
                   <draft-ietf-ipngwg-bsd-api-04.txt>

Abstract

In order to implement the version 6 Internet Protocol (IPv6) [1] in an
operating system based on Berkeley Unix (4.x BSD), changes must be made
to the application program interface (API).  TCP/IP applications written
for BSD-based operating systems have in the past enjoyed a high degree
of portability because most of the systems derived from BSD provide the
same API, known informally as "the socket interface".  We would like the
same portability with IPv6.  This memo presents a set of extensions to
the BSD socket API to support IPv6.  The changes include a new data
structure to carry IPv6 addresses, new name-to-address translation
library functions, new address conversion functions, and some new
setsockopt() options.  The extensions are designed to provide access to
IPv6 features, while introducing a minimum of change into the system and
providing complete compatibility for existing IPv4 applications.


Status of this Memo

This document is an Internet Draft.  Internet Drafts are working
documents of the Internet Engineering Task Force (IETF), its Areas,
and its Working Groups.  Note that other groups may also distribute
working documents as Internet Drafts.

Internet Drafts are draft documents valid for a maximum of six months.
This Internet Draft expires on July 6, 1996.  Internet Drafts may be
updated, replaced, or obsoleted by other documents at any time.  It is
not appropriate to use Internet Drafts as reference material or to cite
them other than as a "working draft" or "work in progress."

To learn the current status of any Internet-Draft, please check the
1id-abstracts.txt listing contained in the Internet-Drafts Shadow
Directories on ds.internic.net, nic.nordu.net, ftp.isi.edu, or
munnari.oz.au.

Distribution of this memo is unlimited.





draft-ietf-ipngwg-bsd-api-04.txt                                [Page 1]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


1.  Introduction.

While IPv4 addresses are 32-bits long, IPv6 nodes are identified by
128-bit addresses.  The socket interface make the size of an IP address
quite visible to an application; virtually all TCP/IP applications for
BSD-based systems have knowledge of the size of an IP address.  Those
parts of the API that expose the addresses need to be extended to
accommodate the larger IPv6 address size.  IPv6 also introduces new
features, some of which must be made visible to applications via the
API.  This paper defines a set of extensions to the socket interface to
support the larger address size and new features of IPv6.

This specification is preliminary.  These API extensions are expected to
evolve as we gain more implementation experience.


2.  Design Considerations

There are a number of important considerations in designing changes to
this well-worn API:

   -    The extended API should provide both source and binary
        compatibility for programs written to the original API.  That
        is, existing program binaries should continue to operate when
        run on a system supporting the new API.  In addition, existing
        applications that are re-compiled and run on a system supporting
        the new API should continue to operate.  Simply put, the API
        changes for IPv6 should not break existing programs.

   -    The changes to the API should be as small as possible in order
        to simplify the task of converting existing IPv4 applications to
        IPv6.

   -    Where possible, applications should be able to use the extended
        API to interoperate with both IPv6 and IPv4 hosts.  Applications
        should not need to know which type of host they are
        communicating with.

   -    IPv6 addresses carried in data structures should be 64-bit
        aligned.  This is necessary in order to obtain optimum
        performance on 64-bit machine architectures.

Because of the importance of providing IPv4 compatibility in the API,
these extensions are explicitly designed to operate on machines that
provide complete support for both IPv4 and IPv6.  A subset of this API
could probably be designed for operation on systems that support only
IPv6.  However, this is not addressed in this document.




draft-ietf-ipngwg-bsd-api-04.txt                                [Page 2]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


2.1.  What Needs to be Changed

The socket interface API consists of a few distinct components:

   -    Core socket functions.

   -    Address data structures.

   -    Name-to-address translation functions.

   -    Address conversion functions.

The core socket functions -- those functions that deal with such things
as setting up and tearing down TCP connections, and sending and
receiving UDP packets -- were designed to be transport independent.
Where protocol addresses are passed as function arguments, they are
carried via opaque pointers.  A protocol specific address data structure
is defined for each protocol that the socket functions support.
Applications must cast these protocol specific address structures into
the generic "sockaddr" data type when using the socket functions.  These
functions need not change for IPv6, but a new IPv6 specific address data
structure is needed.

The "sockaddr_in" structure is the protocol specific data structure for
IPv4.  This data structure actually includes 8-octets of unused space,
and it is tempting to try to use this space to adapt the sockaddr_in
structure to IPv6.  Unfortunately, the sockaddr_in structure is not
large enough to hold the 16-octet IPv6 address as well as the other
information (2-octet address family and 2-octet port number) that is
needed.  So a new address data structure must be defined for IPv6.

The name-to-address translation functions in the socket interface are
gethostbyname() and gethostbyaddr().  Gethostbyname() does not provide
enough flexibility to accommodate more than one protocol family.  To
solve this problem, we introduced a new name-to-address translation
function which is analogous to gethostbyname(), but supports addresses
in both the IPv4 and IPv6 address families.  Gethostbyaddr() does not,
strictly speaking, need to be replaced since it carries an address
family argument and can be extended to support both address families
without introducing compatibility problems.  However, we have chosen to
introduce a new function to maintain symmetry with the replacement to
gethostbyname().  The new functions both carry an address family
parameter, so they can be extended to operate with other protocol
families in addition to IPv4 and IPv6.

The address conversion functions -- inet_ntoa() and inet_addr() --
convert IPv4 addresses between binary and printable form.  These
functions are quite specific to 32-bit IPv4 addresses.  We have designed



draft-ietf-ipngwg-bsd-api-04.txt                                [Page 3]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


two analogous functions which convert both IPv4 and IPv6 addresses, and
carry an address type parameter so that they can be extended to other
protocol families as well.

Finally, a few miscellaneous features are needed to support IPv6.  A new
interface is needed in order to support the IPv6 flow label and priority
header fields.  New interfaces are needed in order to receive IPv6
multicast packets and control the sending of multicast packets.  And an
interface is necessary in order to pass IPv6 source route information
between the application and the system.


3.  Socket Interface

This section specifies the socket interface changes for IPv6.

The data types of the structure elements given in the following section
are intended to be examples, not absolute requirements.  System
implementations may use other types if they are appropriate.  In some
cases, such as when a field of a data structure holds a protocol value,
the structure field must be of some minimum size.  These size
requirements are noted in the text.  For example, since the UDP and TCP
port values are 16-bit quantities, the sin6_port field must be at least
a 16-bit data types.  The sin6_port field is specified as a u_int16_t
type, but an implementation may use any data type that is at least
16-bits long.

3.1.  New Address Family

A new address family macro, named AF_INET6, is defined in
<sys/socket.h>.  The AF_INET6 definition is used to distinguish between
the original sockaddr_in address data structure, and the new
sockaddr_in6 data structure.

A new protocol family macro, named PF_INET6, is defined in
<sys/socket.h>.  Like most of the other protocol family macros, this
will usually be defined to have the same value as the corresponding
address family macro:

        #define PF_INET6        AF_INET6

The PF_INET6 is used in the first argument to the socket() function to
indicate that an IPv6 socket is being created.

3.2. IPv6 Address Data Structure

A new data structure to hold a single IPv6 address is defined as
follows:



draft-ietf-ipngwg-bsd-api-04.txt                                [Page 4]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


        struct in6_addr {
                u_char  s6_addr[16];    /* IPv6 address */
        }

This data structure contains an array of sixteen 8-bit elements, which
make up one 128-bit IPv6 address.  The IPv6 address is stored in network
byte order.

Applications obtain the declaration for this structure by including
the system header file <netinet/in.h>.

3.3.  Socket Address Structure for 4.3 BSD-Based Systems

In the socket interface, a different protocol-specific data structure is
defined to carry the addresses for each of the protocol suite.  Each
protocol-specific data structure is designed so it can be cast into a
protocol-independent data structure -- the "sockaddr" structure.  Each
has a "family" field which overlays the "sa_family" of the sockaddr data
structure.  This field can be used to identify the type of the data
structure.

The sockaddr_in structure is the protocol-specific address data
structure for IPv4.  It is used to pass addresses between applications
and the system in the socket functions. The following structure is
defined to carry IPv6 addresses:

        struct sockaddr_in6 {
                u_int16_t       sin6_family;    /* AF_INET6 */
                u_int16_t       sin6_port;      /* Transport layer port # */
                u_int32_t       sin6_flowinfo;  /* IPv6 flow information */
                struct in6_addr sin6_addr;      /* IPv6 address */
        };

This structure is designed to be compatible with the sockaddr data
structure used in the 4.3 BSD release.

The sin6_family field is used to identify this as a sockaddr_in6
structure.  This field is designed to overlay the sa_family field when
the buffer is cast to a sockaddr data structure.  The value of this
field must be AF_INET6.

The sin6_port field is used to store the 16-bit UDP or TCP port
number.  This field is used in the same way as the sin_port field of
the sockaddr_in structure.  The port number is stored in network byte
order.

The sin6_flowinfo field is a 32-bit field that is used to store three
pieces of information: the 24-bit IPv6 flow label, the 4-bit priority



draft-ietf-ipngwg-bsd-api-04.txt                                [Page 5]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


field, and a 1-bit loose/strict source routing flag.  The IPv6 flow
label is represented as the low-order 24-bits of the 32-bit field.  The
priority is represented in the next 4-bits above this, and the
loose/strict flag is the 1 bit above this.  The high-order 3 bits of
this field are reserved.  The sin6_flowinfo field is stored in network
byte order.  The use of the flow label and priority fields are explained
in sec 4.9.  The use of the loose/strict flag is discussed in section
4.10.

The sin6_addr field is a single in6_addr structure (defined in the
previous section).  This field holds one 128-bit IPv6 address.  The
address is stored in network byte order.

The ordering of elements in this structure is specifically designed so
that the sin6_addr field will be aligned on a 64-bit boundary.  This is
done for optimum performance on 64-bit architectures.

Applications obtain the declaration of the sockaddr_in6 structure by
including the system header file <netinet/in.h>.

3.4. Socket Address Structure for 4.4 BSD-Based Systems

The 4.4 BSD release includes a small, but incompatible change to the
socket interface.  The "sa_family" field of the sockaddr data structure
was changed from a 16-bit value to an 8-bit value, and the space saved
used to hold a length field, named "sa_len". The sockaddr_in6 data
structure given in the previous section can not be correctly cast into
the newer sockaddr data structure.  For this reason, following
alternative IPv6 address data structure is provided to be used on
systems based on 4.4 BSD:

        #define SIN6_LEN

        struct sockaddr_in6 {
                u_char          sin6_len;       /* length of this struct */
                u_char          sin6_family;    /* AF_INET6 */
                u_int16_t       sin6_port;      /* Transport layer port # */
                u_int32_t       sin6_flowinfo;  /* IPv6 flow information */
                struct in6_addr sin6_addr;      /* IPv6 address */
        };

The only differences between this data structure and the 4.3 BSD variant
are the inclusion of the length field, and the change of the family
field to a 8-bit data type.  The definitions of all the other fields are
identical to the 4.3 BSD variant defined in the previous section.

Systems that provide this version of the sockaddr_in6 data structure
must also declare the SIN6_LEN as a result of including the



draft-ietf-ipngwg-bsd-api-04.txt                                [Page 6]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


<netinet/in.h> header file.  This macro allows applications to determine
whether they are being built on a system that supports the 4.3 BSD or
4.4 BSD variants of the data structure.  Applications can be written to
run on both systems by simply making their assignments and use of the
sin6_len field conditional on the SIN6_LEN field.  For example, to fill
in an IPv6 address structure in an application, one might write:

        struct sockaddr_in6 sin6;

        bzero((char *) &sin6, sizeof(struct sockaddr_in6));
        #ifdef SIN6_LEN
        sin6.sin6_len = sizeof(struct sockaddr_in6);
        #endif
        sin6.sin6_family = AF_INET6;
        sin6.sin6_port = htons(23);


Note that the size of the sockaddr_in6 structure is larger than the size
of the sockaddr structure.  Applications that use the sockaddr_in6
structure need to be aware that they can not use sizeof(sockaddr) to
allocate a buffer to hold a sockaddr_in6 structure.  They should use
sizeof(sockaddr_in6) instead.

3.5.  The Socket Functions

Applications use the socket() function to create a socket descriptor
that represents a communication endpoint.  The arguments to the socket()
function tell the system which protocol to use, and what format address
structure will be used in subsequent functions.  For example, to create
an IPv4/TCP socket, applications make the call:

        s = socket (PF_INET, SOCK_STREAM, 0);

To create an IPv4/UDP socket, applications make the call:

        s = socket (PF_INET, SOCK_DGRAM, 0);

Applications may create IPv6/TCP and IPv6/UDP sockets by simply using
the constant PF_INET6 instead of PF_INET in the first argument.  For
example, to create an IPv6/TCP socket, applications make the call:

        s = socket (PF_INET6, SOCK_STREAM, 0);

To create an IPv6/UDP socket, applications make the call:

        s = socket (PF_INET6, SOCK_DGRAM, 0);

Once the application has created a PF_INET6 socket, it must use the



draft-ietf-ipngwg-bsd-api-04.txt                                [Page 7]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


sockaddr_in6 address structure when passing addresses in to the system.
The functions which the application uses to pass addresses into the
system are:

           bind()
           connect()
           sendmsg()
           sendto()

The system will use the sockaddr_in6 address structure to return
addresses to applications that are using PF_INET6 sockets.  The
functions that return an address from the system to an application
are:

           accept()
           recvfrom()
           recvmsg()
           getpeername()
           getsockname()

No changes to the syntax of the socket functions are needed to support
IPv6, since the all of the "address carrying" functions use an opaque
address pointer, and carry an address length as a function argument.


3.6.  Compatibility with IPv4 Applications

In order to support the large base of applications using the original
API, system implementations must provide complete source and binary
compatibility with the original API.  This means that systems must
continue to support PF_INET sockets and the sockaddr_in addresses
structure.  Applications must be able to create IPv4/TCP and IPv4/UDP
sockets using the PF_INET constant in the socket() function, as
described in the previous section.  Applications should be able to hold
a combination of IPv4/TCP, IPv4/UDP, IPv6/TCP and IPv6/UDP sockets
simultaneously within the same process.

Applications using the original API should continue to operate as they
did on systems supporting only IPv4.  That is, they should continue to
interoperate with IPv4 nodes.  It is not clear, though, how, or even if,
those IPv4 applications should interoperate with IPv6 nodes.  The open
issues section (section 9) discusses some of the alternatives.


3.7.  Compatibility with IPv4 Nodes

The API also provides a different type of compatibility: the ability for
applications using the extended API to interoperate with IPv4 nodes.



draft-ietf-ipngwg-bsd-api-04.txt                                [Page 8]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


This feature uses the IPv4-mapped IPv6 address format defined in the
IPv6 addressing architecture specification [3].  This address format
allows the IPv4 address of an IPv4 node to be represented as an IPv6
address.  The IPv4 address is encoded into the low-order 32-bits of the
IPv6 address, and the high-order 96-bits hold the fixed prefix
0:0:0:0:0:FFFF.  IPv4-mapped addresses are written as follows:

        ::FFFF:<IPv4-address>

Applications may use PF_INET6 sockets to open TCP connections to IPv4
nodes, or send UDP packets to IPv4 nodes, by simply encoding the
destination's IPv4 address as an IPv4-mapped IPv6 address, and passing
that address, within a sockaddr_in6 structure, in the connect() or
sendto() call.  When applications use PF_INET6 sockets to accept TCP
connections from IPv4 nodes, or receive UDP packets from IPv4 nodes, the
system returns the peer's address to the application in the accept(),
recvfrom(), or getpeername() call using a sockaddr_in6 structure encoded
this way.

Few applications will likely need to know which type of node they are
interoperating with.  However, for those applications that do need to
know, the inet6_isipv4addr() function, defined in section 6.3, is
provided.

3.8.  Flow Information

The IPv6 header has a 24-bit field to hold a "flow label", and a 4-bit
field to hold a "priority" value.  Applications have control over what
values for these fields are used in packets that they originate, and
have access to the field values of packets that they receive.

The sin6_flowinfo field of the sockaddr_in6 structure encodes three
pieces of information: IPv6 flow label, IPv6 priority, and a
strict/loose source routing flag which is discussed in section 4.2.
Applications use this field to set the flow label and priority in IPv6
headers of packets they generate, and to retrieve the flow label and
priority from the packets they receive.  The header fields of an
actively opened TCP connection are set by assigning in the sin6_flowinfo
field of the destination address sockaddr_in6 structure passed in the
connect() function.  The same technique can be used with the
sockaddr_in6 structure passed in to the sendto() or sendmsg() function
to set the flow label and priority fields of UDP packets.  Similarly,
the flow label and priority values of received UDP packets and accepted
TCP connections are reflected in the sin6_flowinfo field of the
sockaddr_in6 structure returned to the application by the recvfrom(),
recvmsg(), and accept() functions.  And an application may specify the
flow label and priority to use in transmitted packets of a passively
accepted TCP connection, by setting the sin6_flowinfo field of the



draft-ietf-ipngwg-bsd-api-04.txt                                [Page 9]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


address passed in the bind() function.

Implementations provide two bitmask constant declarations to help
applications select out the flow label and priority fields.  These
constants are:

        IPV6_FLOWINFO_FLOWLABEL
        IPV6_FLOWINFO_PRIORITY

These constants can be applied to the sin6_flowinfo field of addresses
returned to the application, for example:

        struct sockaddr_in6 sin6;
        . . .
        recvfrom(s, buf, buflen, flags, (struct sockaddr *) &sin6, &fromlen);
        . . .
        received_flowlabel = sin6.sin6_flowinfo & IPV6_FLOWINFO_FLOWLABEL;
        received_priority = sin6.sin6_flowinfo & IPV6_FLOWINFO_PRIORITY;

On the sending side, applications are responsible for selecting the flow
label value.  The system provides constant declarations for the IPv6
priority values defined in the IPv6 specification [1].  These constants
are:

        IPV6_PRIORITY_UNCHARACTERIZED
        IPV6_PRIORITY_FILLER
        IPV6_PRIORITY_UNATTENDED
        IPV6_PRIORITY_RESERVED1
        IPV6_PRIORITY_BULK
        IPV6_PRIORITY_RESERVED2
        IPV6_PRIORITY_INTERACTIVE
        IPV6_PRIORITY_CONTROL
        IPV6_PRIORITY_8
        IPV6_PRIORITY_9
        IPV6_PRIORITY_10
        IPV6_PRIORITY_11
        IPV6_PRIORITY_12
        IPV6_PRIORITY_13
        IPV6_PRIORITY_14
        IPV6_PRIORITY_15

Applications can use these constants along with the flow label they
selected to assign the sin6_flowinfo field, for example:

        struct sockaddr_in6 sin6;
        . . .
        send_flowlabel = . . . ;
        . . .



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 10]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


        sin6.sin6_flowinfo = IPV6_PRIORITY_UNATTENDED |
                             (IPV6_FLOWINFO_FLOWLABEL & send_flowlabel);

The macro declarations for these constants are obtained by including
the header file <netinet/in.h>.


3.9. Binding to System-Selected Address

While the bind() function allows applications to select the source IP
address of UDP packets and TCP connections, applications often wish to
let the system select the source address for them.  In IPv4, this is
done by specifying the IPv4 address represented by the symbolic
constant INADDR_ANY in the bind() call, or by simply by skipping the
bind() entirely.

Since the IPv6 address type is a structure (struct in6_addr), a
symbolic constant can be used to initialize an IPv6 address variable,
but can not be used in an assignment.  Therefore systems provide the
IPv6 address value that can be used to instruct the system to select
the source IPv6 address in two forms.

The first version is a global variable named "ipv6addr_any" which is
an in6_addr type structure.  The extern declaration for this variable
is:

        extern struct in6_addr ipv6addr_any;

Applications use ipv6addr_any similarly to the way they use INADDR_ANY
in IPv4.  For example, to bind a socket to port number 23, but let the
system select the source address, an application could use the
following code:

        struct sockaddr_in6 sin6;
        . . .
        sin6.sin6_family = AF_INET6;
        sin6.sin6_flowinfo = 0;
        sin6.sin6_port = htons(23);
        sin6.sin6_addr = ipv6addr_any;
        . . .
        if (bind(s, (struct sockaddr *) &sin6, sizeof(sin6)) == -1)
                . . .

The other version is a symbolic constant named IPV6ADDR_ANY_INIT.
This constant can be used to initialize an in6_addr structure:

        struct in6_addr anyaddr = IPV6ADDR_ANY_INIT;




draft-ietf-ipngwg-bsd-api-04.txt                               [Page 11]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


Note that this constant can be used ONLY at declaration type.  It can
not be used assign a previously declared in6_addr structure.  For
example, the following code will not work:

        /* This is the WRONG way to assign an unspecified address */
        struct sockaddr_in6 sin6;
        . . .
        sin6.sin6_addr = IPV6ADDR_ANY_INIT; /* Will NOT compile */

3.10. Communicating with Local Services

Applications may need to send UDP packets to, or originate TCP
connections to, services residing on the local node.  In IPv4, they
can do this by using the constant IPv4 address INADDR_LOOPBACK in
their connect(), sendto(), or sendmsg() call.

IPv6 also provides a loopback address which can be used to contact
local TCP and UDP services.  Like the unspecified address, the IPv6
loopback address is provided in two forms -- a global variable and a
symbolic constant.

The global variable is an in6_addr type structure named
"ipv6addr_loopback."  The extern declaration for this variable is:

        extern struct in6_addr ipv6addr_loopback;

Applications use ipv6addr_loopback as they would use INADDR_LOOPBACK
in IPv4 applications.  For example, to open a TCP connection to the
local telnet server, an application could use the following code:

        struct sockaddr_in6 sin6;
        . . .
        sin6.sin6_family = AF_INET6;
        sin6.sin6_flowinfo = 0;
        sin6.sin6_port = htons(23);
        sin6.sin6_addr = ipv6addr_loopback;
        . . .
        if (connect(s, (struct sockaddr *) &sin6, sizeof(sin6)) == -1)
                . . .

The symbolic constant is named IPV6ADDR_LOOPBACK_INIT.  It can be used
at declaration time ONLY; for example:

        struct in6_addr loopbackaddr = IPV6ADDR_LOOPBACK_INIT;

Like IPV6ADDR_ANY_INIT, this constant can not be used in an assignment
to a previously declared IPv6 address variable.




draft-ietf-ipngwg-bsd-api-04.txt                               [Page 12]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


4. Socket Options

A number of new socket options are defined for IPv6.  All of these new
options are at the IPPROTO_IPV6 level.  That is, the "level" parameter
in the getsockopt() and setsockopt() call is IPPROTO_IPV6 when using
these options.  The constant name prefix IPV6_ is used in all of the new
socket options.  This serves to clearly identify these options as
applying to IPv6.

The macro declaration for IPPROTO_IPV6, the new IPv6 socket options, and
related constants defined in this section are obtained by including the
header file <netinet/in.h>

4.1  Changing Socket Type

Unix allows open sockets to be passed between processes via the exec()
call and other means.  It is a relatively common application practice to
pass open sockets across exec() calls.  Thus it is possible for an
application using the original API to pass an open PF_INET socket to an
application that is expecting to receive a PF_INET6 socket.  Similarly,
it is possible for an application using the extended API to pass an open
PF_INET6 socket to an application using the original API, which would be
equipped only to deal with PF_INET sockets.  Either of these cases could
cause problems, because the application which is passed the open socket
might not know how to decode the address structures returned in
subsequent socket functions.

To remedy this problem, a new setsockopt() option is defined that allows
an application to "transform" a PF_INET6 socket into a PF_INET socket
and vice-versa.

An IPv6 application that is passed an open socket from an unknown
process may use the IPV6_ADDRFORM setsockopt() option to "convert" the
socket to PF_INET6.  Once that has been done, the system will return
sockaddr_in6 address structures in subsequent socket functions.
Similarly, an IPv6 application that is about to pass an open PF_INET6
socket to a program that may not be IPv6 capable may "downgrade" the
socket to PF_INET before calling exec().  After that, the system will
return sockaddr_in address structures to the application that was
exec()'ed.

The IPV6_ADDRFORM option is at the IPPROTO_IP level.  The only valid
option values are PF_INET6 and PF_INET.  For example, to convert a
PF_INET6 socket to PF_INET, a program would call:

        int addrform = PF_INET;

        if (setsockopt(s, IPPROTO_IPV6, IPV6_ADDRFORM, (char *) &addrform,



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 13]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


                sizeof(addrform)) == -1)
                perror("setsockopt IPV6_ADDRFORM");

An application may use IPV6_ADDRFORM in the getsockopt() function to
learn whether an open socket is a PF_INET of PF_INET6 socket.  For
example:

        int addrform;
        int len = sizeof(int);

        if (getsockopt(s, IPPROTO_IPV6, IPV6_ADDRFORM, (char *) &addrform,
                &len) == -1)
                perror("getsockopt IPV6_ADDRFORM");
        if (addrform == PF_INET)
                printf("This is an IPv4 socket.\n");
        else if (addrform == PF_INET6)
                printf("This is an IPv6 socket.\n");
        else
                printf("This system is broken.\n");

4.2.  Handling IPv6 Source Routes

IPv6 makes more use of the source routing mechanism than IPv4.  In order
for source routing to operate properly, the node receiving a request
packet that bears a source route must reverse that source route when
sending the reply.  In the case of TCP, the reversal can be done in the
transport protocol implementation transparently to the application.  But
in the case of UDP, the application must perform the reversal itself.
The transport protocol code can not perform the reversal for UDP packets
because a UDP application may receive a number of requests and generate
replies asynchronously.  A "reply" sent by an application may not match
the "request" most recently passed up to the application.

The API for source routing has two components: providing a source route
to be used with originated traffic -- actively opened TCP connections
and UDP packets being sent; and retrieving the source route of received
traffic -- passively accepted TCP connections and received UDP packets.
An application may always provide a source route with TCP connections
being originated and UDP packets being sent.  But to receive source
routes, the application must enable an option.

To provide a source route, an application simply provides an array of
sockaddr_in6 data structures in the msg_name field of the msghdr
structure of a sendmsg() function, or the address argument of the
sendto() function (when sending a UDP packet), or the address argument
of the connect() function (when actively opening a TCP connection).  For
sendto() and connect(), the length argument of the function is the total
length, in octets, of the array.  For sendmsg(), the msg_namelen field



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 14]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


of the msghdr structure specifies the total length of the array.  The
elements of the array represent the full source route, including both
source and destination endpoint address.  The elements of the array are
ordered from destination to source.  That is, the first element of the
array represents the destination endpoint address, and the last element
of the array represents the source endpoint address.  If the application
provides a source route, the source endpoint address can not be omitted.
The sin6_addr field of the source endpoint address may be set to
ipv6addr_any, however, in which case the system will select an
appropriate source address.  The sin6_port field of the destination
endpoint address must be assigned.  The sin6_port field of the source
endpoint address may be set to zero, in which case the system will
select an appropriate source port number.  The sin6_port fields of the
intermediate addresses must be set to zero.

The application also has control over the loose/strict source routing
flag that is defined in the IPv6 specification [1].  It does this by
setting or clearing the loose/strict flag contained in the sin6_flowinfo
field of the destination and intermediate addresses.  On the receive
side, the implementation uses the loose/strict flag in the address array
returned to the application to indicate the loose/strict status of each
hop.

The implementation provides a set of constant definitions to simplify
getting and setting the loose/strict flag for each of the hops of a
source route.  The following constant is used to select the loose/strict
flag from the sin6_flowinfo field:

        IPV6_FLOWINFO_SRFLAG

In addition, two constants are provided which represent the two states
of this flag:

        IPV6_SRFLAG_STRICT
        IPV6_SRFLAG_LOOSE

These constants can be used to inspect the source route flags of
received addresses, for example:

        struct sockaddr_in6 sin6[3];
        . . .
        if ((sin6[0].sin6_flowinfo & IPV6_FLOWINFO_SRFLAG) ==
            IPV6_SRFLAG_STRICT)
            . . .

And they can also be used to set the source route flags:

        struct sockaddr_in6 sin6[3];



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 15]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


        . . .
        sin6[0].sin6_flowinfo =
                (sin6[0].sin6_flowinfo & ~IPV6_FLOWINFO_SRFLAG) |
                IPV6_SRFLAG_STRICT;

The flow label and priority sub-fields of the sin6_flowinfo field of the
destination endpoint address may be set, but the these fields must be
set to zero in the intermediate and source endpoint addresses.

The arrangement of the address structures in the address buffer passed
to sendmsg(), connect() or sendto() is shown in the figure below:

        +--------------------+
        |                    |
        |  sockaddr_in6[0]   |  Destination Endpoint Address
        |                    |
        +--------------------+
        |                    |
        |  sockaddr_in6[1]   |  Last Source-Route Hop Address
        |                    |
        +--------------------+
        .                    .
        .                    .
        .                    .
        +--------------------+
        |                    |
        | sockaddr_in6[N-1]  |  First Source-Route Hop Address
        |                    |
        +--------------------+
        |                    |
        |  sockaddr_in6[N]   |  Source Endpoint Address
        |                    |
        +--------------------+

               Address buffer when sending a source route

The IPV6_RECVSRCRT setsockopt() option controls the reception of source
routes.  The option is disabled by default.  Applications must
explicitly enable the option using the setsockopt() function in order to
receive source routes.

The IPV6_RECVSRCRT option is at the IPPROTO_IPV6 level.  An example of
how an application might use this option is:

        int on = 1;             /* value == 1 means enable the option */

        if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVSRCRT, (char *) &on,
                sizeof(on)) == -1)



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 16]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


                perror("setsockopt IPV6_RECVSRCRT");

When the IPV6_RECVSRCRT option is disabled, only a single sockaddr_in6
address structure is returned to applications in the address argument of
the recvfrom() and accept() functions.  This address represents the
source endpoint address of the UDP packet received or the TCP connection
accepted.

When the IPV6_RECVSRCRT option is enabled, the msg_name field of the
msghdr of the recvmsg() function, or the address argument of the
recvfrom() function (when receiving UDP packets) and the accept()
functions (when passively accepting TCP connections) points to an array
of sockaddr_in6 structures.  When the function returns, the array will
hold two elements -- source and destination address -- when the received
UDP packet or TCP SYN packet does not carry a source route.  The array
will hold more than two elements when the received packet carries a
source route.

The addresses in the array are ordered from source to destination.  That
is, the first element of the array holds source endpoint address of the
received packet.  Following this in the array are the intermediate hops
in the order in which they were visited.  The last element of the array
holds the destination endpoint address.  Note that this is the opposite
of the order specified for sending.  This ordering was chosen so that
the address array returned in a recvmsg() or recvfrom() call can be used
in a subsequent sendmsg() or sendto() call without requiring the
application to re-order the addresses in the array.  Similarly, the
address array received in an accept() call can be used unchanged in a
subsequent connect() call.

The address length argument of the recvfrom() and accept() functions,
and the msg_namelen field of the msghdr field in the recvmsg() function,
indicate the length, in octets, of the full address array.  This
argument is a value-result parameter.  The application sets the maximum
size of the address buffer when it makes the call, and the system
modifies the value to return the actual size of the buffer to the
application.

The sin6_port field of the first and last array elements (source and
destination endpoint address) will hold the source and destination UDP
or TCP port number of the received packet.  The sin6_port field of the
intermediate elements of the array will be zero.

The flow label and priority sub-fields of the sin6_flowinfo field of the
source endpoint address will hold the flow label and priority values of
the received packet.  The flow label and priority sub-fields of the
intermediate addresses and the destination endpoint address will be
zero.  The loose/strict flag of the sin6_flowinfo field of the source



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 17]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


endpoint address and the intermediate addresses will be set according to
the flags in the received packet.  The macros defined above can be used
to inspect the loose/strict flag of each hop.

The address buffer returned to the application in the recvfrom() or
accept() functions when the IPV6_RECVSRCRT option is enabled is shown
below:

        +--------------------+
        |                    |
        |  sockaddr_in6[0]   |  Source Endpoint Address
        |                    |
        +--------------------+
        |                    |
        |  sockaddr_in6[1]   |  First Source-Route Hop Address
        |                    |
        +--------------------+
        .                    .
        .                    .
        .                    .
        +--------------------+
        |                    |
        | sockaddr_in6[N-1]  |  Last Source-Route Hop Address
        |                    |
        +--------------------+
        |                    |
        |  sockaddr_in6[N]   |  Destination Endpoint Address
        |                    |
        +--------------------+

              Address buffer when receiving a source route

IPv6 allows a source route with up to 23 intermediate hops.  Since the
it must also receive the source and destination endpoint addresses, the
application must provide a buffer capable of holding 25 addresses to
receive such a source route.  Implementations provide the following
constant declaration in order to allow applications to simply declare
storage for the largest possible source route:

        IPV6_SR_MAXADDR

Applications can use this constant like this:

        struct sockaddr_in6 sin6[IPV6_SR_MAXADDR];

It may be impractical for some applications to allocate space to hold
the largest possible source route.  Thus a received source route may be
too large to fit into the buffer provided by the application.  In this



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 18]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


circumstance, the system should return only a single address element --
the source endpoint address -- to the application.  This case is clearly
distinguishable to the application because in all other cases, the
system returns at least two address elements -- the source and
destination endpoint addresses.

4.3.  Receiving Interface Determination

Some applications run on multi-homed hosts need to determine which
interface UDP packets were received on or TCP connections are bound to.
While the source routing interface described in the previous section
returns the destination address of the packet, this does not necessarily
identify the receiving interface.  Some cases where it does not are:

   -    When the received packet is multicast.  The destination address
        in this case is an IPv6 multicast address, not the address of an
        interface.

   -    When the node is operating as an IPv6 router.  The node may
        receive packets on interfaces other than the one they are
        addressed to.

   -    When the received packet is sent to the node's link-local
        address which is being used on multiple interfaces.

The address of the receiving interface is returned to the application
similarly to the way that source routes are returned.  A new
setsockopt() option named IPV6_RECVIF is provided at the IPPROTO_IPV6
level.  If this option is enabled, the system returns an additional
sockaddr_in6 structure to the application, holding the IPv6 address of
the receiving interface, in the recvfrom(), recvmsg(), or accept()
functions.

The option is enabled like this:

        int on = 1;             /* value == 1 means enable the option */

        if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVIF, (char *) &on,
                sizeof(on)) == -1)
                perror("setsockopt IPV6_RECVIF");

This option can be used in conjunction with the IP_RECVSRCRT option.
When the IPV6_RECVIF option is enabled, the buffer returned to the
application is structured like this:







draft-ietf-ipngwg-bsd-api-04.txt                               [Page 19]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


        +--------------------+  - - - - - - - - - - - - - - -
        |                    |
        |  sockaddr_in6[0]   |
        |                    |
        +--------------------+
        .                    .  Source Address, or
        .                    .  Full Source Route
        .                    .
        +--------------------+
        |                    |
        | sockaddr_in6[N-1]  |
        |                    |
        +--------------------+  - - - - - - - - - - - - - - -
        |                    |
        |  sockaddr_in6[N]   |  Receiving Interface Address
        |                    |
        +--------------------+  - - - - - - - - - - - - - - -

              Address buffer with receiving interface address

The last address in the array is an IPv6 address of the receiving
interface.  Since interfaces in IPv6 may have more than one address, and
some addresses (e.g. link-local addresses) may be used on more than one
interface, the system should select an address that uniquely identifies
the interface.

As when receiving source routes, the system returns a single
sockaddr_in6 structure holding the source endpoint address if the buffer
supplied by the application is too small to hold the receiving interface
address.

4.4.  Sending Interface Specification

Applications may also need to specify the outgoing interface that
originated UDP or TCP packets should use.  This is accomplished like
source route selection.  The application may provide an additional
sockaddr_in6 structure in its sendto(), sendmsg() or connect() call
specifying the address of the outgoing interface.  Unlike source route
selection, the outgoing interface address can only be included if a new
option is enabled.  The new option is needed so that the system can
differentiate between the application's specification of an outgoing
interface address and a source route.

The new option option is named IPV6_SENDIF and is at the IPPROTO_IPV6
level.  It can be enabled like this:

        int on = 1;             /* value == 1 means enable the option */




draft-ietf-ipngwg-bsd-api-04.txt                               [Page 20]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


        if (setsockopt(s, IPPROTO_IPV6, IPV6_SENDIF, (char *) &on,
                sizeof(on)) == -1)
                perror("setsockopt IPV6_SENDIF");

This option can be used in conjunction with source route specification.
If this option is enabled, the application passes in an address array
structured as follows:

        +--------------------+  - - - - - - - - - - - - - - -
        |                    |
        |  sockaddr_in6[0]   |
        |                    |
        +--------------------+
        .                    .  Destination Address, or
        .                    .  Full Source Route
        .                    .
        +--------------------+
        |                    |
        | sockaddr_in6[N-1]  |
        |                    |
        +--------------------+  - - - - - - - - - - - - - - -
        |                    |
        |  sockaddr_in6[N]   |  Sending Interface Address
        |                    |
        +--------------------+  - - - - - - - - - - - - - - -

              Address buffer with sending interface address

The last address in the array is an IPv6 address of the sending
interface.  Applications should use an address that uniquely identifies
the interface to use.


4.5.  Unicast Hop Limit

A new setsockopt() option is used to control the hop limit used in
outgoing unicast IPv6 packets.  The name of this option is
IPV6_UNICAST_HOPS, and it is used at the IPPROTO_IPV6 layer.  The
following example illustrates how it is used:

        int hoplimit = 10;

        if (setsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS, (char *) &hoplimit,
                sizeof(hoplimit)) == -1)
                perror("setsockopt IPV6_UNICAST_HOPS");

When the IPV6_UNICAST_HOPS option is set with setsockopt(), the option
value given is used as the hop limit for all subsequent unicast packets



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 21]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


sent via that socket.  If the option is not set, the system selects a
default value.

The IPV6_UNICAST_HOPS option may be used in the getsockopt() function to
determine the hop limit value that the system will use for subsequent
unicast packets sent via that socket.  For example:

        int hoplimit;
        int len = sizeof(hoplimit);

        if (getsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS, (char *) &hoplimit,
                &len) == -1)
                perror("getsockopt IPV6_UNICAST_HOPS");
        else
                printf("Using %d for hop limit.\n", hoplimit);


4.6.  Sending and Receiving Multicast Packets

IPv6 applications may send UDP multicast packets by simply specifying an
IPv6 multicast address in the address argument of the sendto() function.

A few setsockopt options at the IPPROTO_IPV6 layer are used to control
some of the parameters of sending multicast packets.  These options are
optional: applications may send multicast packets without using these
options.  The setsockopt() options for controlling the sending of
multicast packets are summarized below:
























draft-ietf-ipngwg-bsd-api-04.txt                               [Page 22]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


        IPV6_MULTICAST_IF

                Set the interface to use for outgoing multicast packets.
                The argument is an IPv6 address of the interface to use.

                Argument type: struct in6_addr


        IPV6_MULTICAST_HOPS

                Set the hop limit to use for outgoing multicast packets.
                (Note a separate option - IPV6_UNICAST_HOPS - is
                provided to set the hop limit to use for outgoing
                unicast packets.)

                Argument type: unsigned int

        IPV6_MULTICAST_LOOP

                Controls whether outgoing multicast packets sent should
                be delivered back to the local application.  A toggle.
                If the option is set to 1, multicast packets are looped
                back.  If it is set to 0, they are not.

                Argument type: unsigned int

The reception of multicast packets is controlled by the two setsockopt()
options summarized below:

        IPV6_ADD_MEMBERSHIP

                Join a multicast group.  Requests that multicast packets
                sent to a particular multicast address be delivered to
                this socket.  The argument is the IPv6 multicast address
                of the group to join.

                Argument type: struct ipv6_mreq

        IPV6_DROP_MEMBERSHIP

                Leave a multicast group.  Requests that multicast
                packets sent to a particular multicast address no longer
                be delivered to this socket.  The argument is the IPv6
                multicast address of the group to join.

                Argument type: struct ipv6_mreq

The argument type of both of these options is the ipv6_mreq structure,



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 23]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


which is defined as follows:

        struct ipv6_mreq {
                /* IPv6 multicast address of group */
                struct in6_addr ipv6mr_multiaddr;

                /* local IPv6 address of interface */
                struct in6_addr ipv6mr_interface;
        };

5. Library Functions

New library functions are needed to lookup IPv6 addresses in the name
service, and to manipulate IPv6 addresses.

5.1.  Name-to-Address Translation Functions

Two new functions analogous to gethostbyname() and gethostbyaddr() have
been defined which support both IPv4 and IPv6 addresses.  The names of
the new functions are hostname2addr() and addr2hostname().  These
functions were designed to have semantics similar to gethostbyname() and
gethostbyaddr(), so that existing IPv4 applications can be easily ported
to IPv6.

The new functions differ from the old in one important way that is not
related to IPv6: The old functions could not safely be used by
multi-threaded applications, while the new ones can.  There are two
multi-threading problems with the old functions.  First, the return
value of the old functions is a pointer to a single static buffer
belonging to the library.  The new functions return a dynamically
allocated buffer, and a third new function, named freehostent(), is
provided to free that storage.  Second, the old functions returned their
error code in a global variable (h_errno).  The new functions carry a
pointer that allows the library to return the error code into storage
provided by the caller.

The hostname2addr() function is similar to gethostbyname(), but enables
applications to specify the type of address to be looked up:

        struct hostent *hostname2addr(
                const char *name,
                int af,
                int *error);

This function looks up the hostname argument name in the name service
and, if the lookup succeeds, returns a completed hostent structure.  If
the lookup fails, the function returns NULL and an error code is
returned in the buffer pointed to by the argument error. The af argument



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 24]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


specifies the type of the address -- IPv4 (AF_INET) or IPv6 (AF_INET6)
-- to return to the caller in the h_addr_list field of the hostent
structure.

If the af argument is AF_INET, hostname2addr() behaves much like
gethostbyname.  It queries the name service for IPv4 addresses and, if
any are found, returns a hostent structure that includes an array of
IPv4 addresses.  Each IPv4 address is encoded in network byte order.

If the af argument is AF_INET6, hostname2addr() queries the name service
for IPv6 addresses.  The function may also query the name service for
IPv4 records.  If this is done, any IPv4 addresses found are returned to
the application encoded as IPv4-compatible IPv6 addresses.  The
determination of whether to query for IPv4 addresses is system specific.
Systems that support querying for IPv4 addresses should provide a
system-wide configuration switch allowing the system administrator to
enable or disable that feature.

IPv6 addresses returned by the hostname2addr() function are encoded in
network byte order.

The second new function, called addr2hostname(), is like the
gethostbyaddr() function, but supports both the IPv4 and IPv6 address
families:

        struct hostent *addr2hostname(
                const void *addr,
                int addrlen,
                int af,
                int *error);

The addr2hostname() function performs an address-to-name lookup on the
address specified by the addr argument, returning a completed hostent
structure if the lookup succeeds.  If the lookup fails, the function
returns NULL and an error code is returned in the buffer pointed to by
the argument error.

The addrlen argument specifies the length of the address (in octets)
pointed to by the addr argument.

The af argument specifies the address family of the addr argument.  This
function supports both the AF_INET and AF_INET6 address families.  If
the af argument is AF_INET, then addr refers to an IPv4 address and
addrlen must have the value 4.  If af is AF_INET6, addr represents an
IPv6 address and addrlen must have the value 16.  In the latter case,
the caller may present an IPv4-mapped IPv6 address in the addr argument.
If this is done, an IPv4 address-to-name lookup is performed on the
embedded IPv4 address.



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 25]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


IPv6 addresses are returned by hostname2addr() and addr2hostname() via
the hostent structure.  This h_addr_list element of this structure
points to an array of ipv6_hostent_addr type structures.  This
structure is declared as follows:

        struct ipv6_hostent_addr {
                /* amount of time in seconds that address is valid for */
                u_int32_t  iha_lifetime;

                /* the IPv6 address being returned */
                struct in6_addr iha_addr;
        };

The hostent and address structures returned by both of these functions
is allocated by the library.  Applications use the freehostent()
function to return this storage to the library after they are done using
it:

        void freehostent(
                struct hostent *hp);

Applications may not access the hostent structure after they have
returned it to the library.

Another new name-to-address translation library function is now under
development at Berkeley.  This new function, named getconninfo(), will
subsume the functionality of gethostbyname(), hostname2addr(), as well
as the getservbyname() and getservbyport() functions.  The new function
is specifically designed to be "transport independent", so it should be
directly usable by IPv6 applications.

System implementations should provide the addr2hostname() and
hostname2addr() functions in order to simplify the porting of existing
IPv4 applications to IPv6.  System implementations may also provide the
getconninfo() function, once it is defined, so that newly written
applications can be transport independent.

The specification of the getconninfo() function is published as a
separate document [2], not included in this spec.

Implementations must retain the BSD gethostbyname() and gethostbyaddr()
functions in order to provide source and binary compatibility for
existing applications.

Applications obtain the function prototype declarations for
hostname2addr() and addr2hostname() by including the header file
<netdb.h>.




draft-ietf-ipngwg-bsd-api-04.txt                               [Page 26]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


5.3.  Address Conversion Functions

BSD Unix provides two functions, inet_addr() and inet_ntoa(), to convert
an IPv4 address between binary and printable form.  IPv6 applications
need similar functions.  The following two functions convert both IPv6
and IPv4 addresses:

        int ascii2addr(
                int af,
                const char *cp,
                void *ap);

and

        char *addr2ascii(
                int af,
                const void *ap,
                int len,
                char *cp);

The first function converts an ascii string to an address in the address
family specified by the af argument.  Currently AF_INET and AF_INET6
address families are supported.  The cp argument points to the ascii
string being passed in.  The ap argument points to a buffer into which
the function stores the address.  Ascii2addr() returns the length of the
address in octets if the conversion succeeds, and -1 otherwise. The
function does not modify the storage pointed to by ap if the conversion
fails. The application must ensure that the buffer referred to by ap is
large enough to hold the converted address.

If the af argument is AF_INET, the function accepts a string in the
standard IPv4 dotted decimal form:

        ddd.ddd.ddd.ddd

where ddd is a one to three digit decimal number between 0 and 255.

If the af argument is AF_INET6, then the function accepts a string in
one of the standard IPv6 printing forms defined in the addressing
architecture specification [3].

The second function converts an address into a printable string.  The af
argument specifies the form of the address.  This can be AF_INET or
AF_INET6.  The ap argument points to a buffer holding an IPv4 address if
the af argument is AF_INET, and an IPv6 address if the af argument is
AF_INET6.  The len field specifies the length in octets of the address
pointed to by ap, and must be 4 if af is AF_INET, or 16 if af is
AF_INET6.  The cp argument points to a buffer that the function can use



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 27]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


to store the ascii string.  If the cp argument is NULL, the function
uses its own private static buffer.  If the application specifies a cp
argument, it must be large enough to hold the ascii conversion of the
address specified as an argument, including the terminating null octet.
For IPv6 addresses, the buffer must be at least 46-octets.  For IPv4
addresses, the buffer must be at least 16-octets.  In order to allow
applications to easily declare buffers of the proper size to store IPv4
and IPv6 addresses in string form, implementations should provide the
following constants, made available to applications that include
<netinet/in.h>:

        #define INET_ADDRSTRLEN         16
        #define INET6_ADDRSTRLEN        46

The addr2ascii() function returns a pointer to the buffer containing the
ascii string if the conversion succeeds, and NULL otherwise.  The
function does not modify the storage pointed to by cp if the conversion
fails.

Applications obtain the prototype declarations for addr2ascii() and
ascii2addr() by including the header file <arpa/inet.h>.

5.3. Embedded IPv4 Addresses

The IPv4-mapped IPv6 address format is used to represent IPv4 addresses
as IPv6 addresses.  Most applications should be able to to manipulate
IPv6 addresses as opaque 16-octet quantities, without needing to know
whether they represent IPv4 addresses.  However, a few applications may
need to determine whether an IPv6 address is an IPv4-mapped address or
not.  The following function is provided for those applications:

        int inet6_isipv4addr (const struct in6_addr *addr);

The "addr" argument to this function points to a buffer holding an IPv6
address in network byte order.  The function returns true (non-zero) if
that address is an IPv4-mapped address, and returns 0 otherwise.

This function could be used by server applications to determine whether
the peer is an IPv4 node or an IPv6 node.  After accepting a TCP
connection via accept(), or receiving a UDP packet via recvfrom(), the
application can apply the inet6_isipv4addr() function to the returned
address.

Applications obtain the prototype for this function by including the
header file <arpa/inet.h>.


6.  Security Considerations



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 28]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


IPv6 provides a number of new security mechanisms, many of which need to
be accessible to applications.  A companion document detailing the
extensions to the socket interfaces to support IPv6 security is being
written [4].  At some point in the future, that document and this one
may be merged into a single API specification.


7. Change History

Changes from the November 1995 Edition

   -    Added the symbolic constants IPV6ADDR_ANY_INIT and
        IPV6ADDR_LOOPBACK_INIT for applications to use for
        initializations.

   -    Eliminated restrictions on the value of ipv6addr_any.  Systems
        may now choose any value, including all-zeros.

   -    Added a mechanism for returning time to live with the address in
        the name-to-address translation functions.

   -    Added a mechanism for applications to specify the interface in
        the setsockopt() options to join and leave a multicast group.

Changes from the July 1995 Edition

   -    Changed u_long and u_short types in structures to u_int32_t and
        u_int16_t for consistency and clarity.

   -    Added implementation-provided constants for IPv4 and IPv6 text
        address buffer length.

   -    Defined a set of constants for subfields of sin6_flowid and for
        priority values.

   -    Defined constants for getting and setting the source route flag.

   -    Define where ansi prototypes for hostname2addr(),
        addr2hostname(), addr2ascii(), ascii2addr(), and
        ipv6_isipv4addr() reside.

   -    Clarified the include file requirements.  Say that the structure
        definitions are defined as a result of including the header file
        <netinet/in.h>, not that the structures are necessarily defined
        there.

   -    Removed underscore chars from is_ipv4_addr() function name for
        BSD compatibility.



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 29]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


   -    Added inet6_ prefix to is_ipv4_addr() function name to avoid
        name space conflicts.

   -    Changes setsockopt option naming convention to use IPV6_ prefix
        instead of IP_ so that there is clearly no ambiguity with IPv4
        options.  Also, use level IPPROTO_IPV6 for these options.

   -    Made hostname2addr() and addr2hostname() functions thread-safe.

   -    Added support for sendmsg() and recvmsg() in source routing
        section.

   -    Changed in_addr6 to in6_addr for consistency.

   -    Re-structured document into sub-sections.

   -    Deleted the implementation experience section.  It was too
        wordy.

   -    Added argument types to multicast socket options.

   -    Added constant for largest source route array buffer.

   -    Added the freehostent() function.

   -    Added receiving interface determination and sending interface
        selection options.

   -    Added definitions of ipv6addr_any and ipv6addr_loopback.

   -    Added text making the lookup of IPv4 addresses by
        hostname2addr() optional.

Changes from the June 1995 Edition

   -    Added capability for application to select loose or strict
        source routing.

Changes from the March 1995 Edition

   -    Changed the definition of the ipv6_addr structure to be an array
        of sixteen chars instead of four longs.  This change is
        necessary to support machines which implement the socket
        interface, but do not have a 32-bit addressable word.  Virtually
        all machines which provide the socket interface do support an
        8-bit addressable data type.

   -    Added a more detailed explanation that the data types defined in



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 30]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


        this documented are not intended to be hard and fast
        requirements.  Systems may use other data types if they wish.

   -    Added a note flagging the fact that the sockaddr_in6 structure
        is not the same size as the sockaddr structure.

   -    Changed the sin6_flowlabel field to sin6_flowinfo to accommodate
        the addition of the priority field to the IPv6 header.

Changes from the October 1994 Edition

   -    Added variant of sockaddr_in6 for 4.4 BSD-based systems (sa_len
        compatibility).

   -    Removed references to SIT transition specification, and added
        reference to addressing architecture document, for definition of
        IPv4-mapped addresses.

   -    Added a solution to the problem of the application not providing
        enough buffer space to hold a received source route.

   -    Moved discussion of IPv4 applications interoperating with IPv6
        nodes to open issues section.

   -    Added length parameter to addr2ascii() function to be consistent
        with addr2hostname().

   -    Changed IP_MULTICAST_TTL to IP_MULTICAST_HOPS to match IPv6
        terminology, and added IP_UNICAST_HOPS option to match
        IP_MULTICAST_HOPS.

   -    Removed specification of numeric values for AF_INET6,
        IP_ADDRFORM, and IP_RCVSRCRT, since they need not be the same on
        different implementations.

   -    Added a definition for the in_addr6 IPv6 address data
        structure.  Added this so that applications could use
        sizeof(struct in_addr6) to get the size of an IPv6 address,
        and so that a structured type could be used in the
        is_ipv4_addr().

8. Open Issues

A few open issues for IPv6 socket interface API specification remain,
including:

   -    Should we add a timeout parameter to hostname2addr() and
        addr2hostname()?  DNS lookups need to be given some finite



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 31]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


        timeout interval, so it might be nice to let the application
        specify that interval.

   -    Can the IPV6_ADDRFORM option really be implemented?

   -    An interface is needed to allocate flow labels.  Should one be
        defined in this spec, or left for another document?

   -    Can existing IPv4 applications interoperate with IPv6 nodes?
        This issue is discussed in more detail in the following section.

8.1. IPv4 Applications Interoperating with IPv6 Nodes

This problem primarily has to do with the how IPv4 applications
represent addresses of IPv6 nodes.  What address should be returned to
the application when an IPv6/UDP packet is received, or an IPv6/TCP
connection is accepted?  The peer's address could be any arbitrary
128-bit IPv6 address.  But the application is only equipped to deal with
32-bit IPv4 addresses encoded in sockaddr_in data structures.

We have not discovered any solution that provides complete transparent
interoperability with IPv6 nodes for applications using the original
IPv4 API.  However, two techniques that partially solve the problem are:

   1)   Prohibit communication between IPv4 applications and IPv6 nodes.
        Only UDP packets received from IPv4 nodes would be passed up to
        the application, and only TCP connections received from IPv4
        nodes would be accepted.  UDP packets from IPv6 nodes would be
        dropped, and TCP connections from IPv6 nodes would be refused.

   2)   The system could generate a local 32-bit cookie to represent the
        full 128-bit IPv6 address, and pass this value to the
        application.  The system would maintain a mapping from cookie
        value into the 128-bit IPv6 address that it represents.  When
        the application passed a cookie back into the system (for
        example, in a sendto() or connect() call) the system would use
        the 128-bit IPv6 address that the cookie represents.

        The cookie would have to be chosen so as to be an invalid IPv4
        address (e.g. an address on net 127.0.0.0), and the system would
        have to make sure that these cookie values did not escape into
        the Internet as the source or destination addresses of IPv4
        packets.

Both of these techniques have drawbacks.  This is an area for further
study.  System implementors may use one of these techniques or implement
another solution.




draft-ietf-ipngwg-bsd-api-04.txt                               [Page 32]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


Acknowledgments

Thanks to the many people who made suggestions and provided feedback to
to the numerous revisions of this document, including: Ran Atkinson,
Fred Baker, Dave Borman, Andrew Cherenson, Alex Conta, Alan Cox, Steve
Deering, Francis Dupont, Robert Elz, Marc Hasson, Tom Herbert, Christian
Huitema, Wan-Yen Hsu, Alan Lloyd, Charles Lynn, Dan McDonald, Craig
Metz, Erik Nordmark, Josh Osborne, Richard Stevens, Matt Thomas, Dean D.
Throop, Glenn Trewitt, David Waitzman, and Carl Williams.  Craig
Partridge suggested the addr2ascii() and ascii2addr() functions.

Ramesh Govindan made a number of contributions and co-authored an
earlier version of this paper.



References

  [1]   R. Hinden. "Internet Protocol, Version 6 (IPv6) Specification".
        Internet Draft.  June 1995.

  [2]   Keith Sklower. "Getconninfo(): An alternative to Gethostbyname()"
        Internet Draft.  June 1995.

  [3]   R. Hinden., S. Deering. "IP Version 6 Addressing Architecture".
        Internet Draft. June 1995.

  [4]   D. McDonald. "IPv6 Security API for BSD Sockets".  Internet
        Draft. January 1995.

Authors' Address

        Jim Bound
        Digital Equipment Corporation
        110 Spitbrook Road ZK3-3/U14
        Nashua, NH 03062-2698
        Phone: +1 603 881 0400
        Email: bound@zk3.dec.com

        Susan Thomson
        Bell Communications Research
        MRE 2P-343, 445 South Street
        Morristown, NJ 07960
        Telephone: +1 201 829 4514
        Email: set@thumper.bellcore.com

        Robert E. Gilligan
        Mailstop MPK 17-202



draft-ietf-ipngwg-bsd-api-04.txt                               [Page 33]

INTERNET-DRAFT             IPv6 BSD API Spec                January 1996


        Sun Microsystems, Inc.
        2550 Garcia Avenue
        Mountain View, CA 94043-1100
        Phone: +1 415 786 5151
        Email: gilligan@eng.sun.com














































draft-ietf-ipngwg-bsd-api-04.txt                               [Page 34]

