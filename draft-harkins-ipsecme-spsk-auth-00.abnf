a = H(b)
       The binary string "b" is given to a function H which produces a
       fixed-length output "a".

Z = scalar-op(x, Y) = x*Y

       the point Y is multiplied x-times to produce another point on the
       curve, Z.

Z = element-op(X, Y) = X + Y

       points X and Y are summed to produce another point on the curve,
       Z.

Z = scalar-op(x, Y) = Y^x mod p

       an element, Y taken to the x-th power modulo the prime returning
       another element in the group, Z.

Z = element-op(X, Y) = (X * Y) mod p

       two elements, X and Y, are multiplied modulo the prime returning
       another element, Z.

ske-seed = H(psk | counter | Ni | Nr)

ske-value = prf+(ske-seed, "IKE SKE Hunting And Pecking")

found = 0
counter = 1
ske-seed = H(psk | counter | Ni | Nr)
ske-value = prf+(swd-seed, "IKE SKE Hunting And Pecking")
x = ske-value
SKE = (x,y)
SKE = (x, p-y)
found = 1
P = f*SKE
found = 1
counter = counter + 1
ske-seed = H(psk | Ni | Nr)

ske-gen = prf+(ske-seed, "IKE Affixing the SKE")

ske-gen = ske-gen mod p

SKE = ske-gen ^ ((p-1)/r) mod p

Scalar = (private + mask) mod r

Element = inverse(scalar-op(mask, SKE))

ss = scalar-op(private, element-op(peer-element, scalar-op(peer-
Tag = H(self-scalar | peer-scalar | F(self-element) | F(peer-
SKEYID = prf(Ni_b | Nr_b, g^xy)

HASH_I = prf(SKEYID, ss | g^xi | g^xr | CKY-I | CKY-R | SA_ib |
HASH_R = prf(SKEYID, ss | g^xr | g^xi | CKY-R | CKY-I | SA_ib |
AUTH = prf(ss, <msg octets>)

