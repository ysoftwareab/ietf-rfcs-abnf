
XML Digital Signatures Working Group               D. Eastlake,
INTERNET-DRAFT                                     Motorola
draft-ietf-xmldsig-core-05.txt                     J. Reagle,
Expires August 28, 2000                            W3C/MIT
                                                   D. Solo,
                                                   Citigroup

                    XML-Signature Syntax and Processing
                                      
Copyright Notice

   Copyright (c) 2000 The Internet Society & W3C (MIT, INRIA, Keio), All
   Rights Reserved.
   
IETF Status of this Memo

   This document is an Internet-Draft and is in full conformance with all
   provisions of Section 10 of RFC2026.
   
   Internet-Drafts are working documents of the Internet Engineering Task
   Force (IETF), its areas, and its working groups. Note that other
   groups may also distribute working documents as Internet-Drafts.
   
   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time. It is inappropriate to use Internet- Drafts as reference
   material or to cite them other than as "work in progress."
   
   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt
   
   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.
   
W3C Status of this document

   This document is a production of the joint IETF/W3C XML Signature
   Working Group.
   
   http://www.w3.org/Signature
   
   The comparable html draft of this version may be found at
   
   http://www.w3.org/TR/2000/WD-xmldsig-core-20000228/
   
   The latest version of this draft series may be found at:
   
   http://www.w3.org/TR/xmldsig/
   
   This specification is a last call Working Draft of the IETF/W3C XML
   Signature Working Group. The Working Group invites review from the
   IETF community, W3C members, and other interested parties. This last
   call serves as a statement that the Working Group believes that the
   specification satisfies the relevant terms of the charter and
   requirements document. The W3C last call ends March 27, 2000; the IETF

Eastlake, Reagle, Solo					[Page 1]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   last call should substantially overlap but may not exactly coincide
   with this period. Subsequently, the Working Group plans to issue a
   specification that addresses any comments resulting from the review
   and propose it as a W3C Candidate Recommendation and IETF Proposed
   Standard.
   
   This document continues to be a draft document and may be updated,
   replaced, or obsoleted by other documents at any time. While the
   Working Group feels the design meets our requirements we especially
   welcome comments on the following topics: security concerns, URI/IDREF
   usage, XPath, DTD/schema specification, and implementation experience.
   Please send comments to the editors and cc: the list
   <w3c-ietf-xmldsig@w3.org>. Publication as a Working Draft does not
   imply endorsement by the W3C membership or IESG. It is inappropriate
   to cite W3C Drafts as other than "work in progress." A list of current
   W3C working drafts can be found at http://www.w3.org/TR. Current IETF
   drafts can be found at http://www.ietf.org/1id-abstracts.html.
   
   Patent disclosures relevant to this specification may be found on the
   Working Group's patent disclosure page.
   
Abstract

   This document specifies XML digital signature processing rules and
   syntax. XML Signatures provide integrity, message authentication,
   and/or signer authentication services for data of any type, whether
   located within the XML that includes the signature or elsewhere.
   
Table of Contents

    1. Introduction
         1. Editorial Conventions
         2. Design Philosophy
         3. Versions, Namespaces and Identifiers
         4. Acknowledgements
    2. Signature Overview and Examples
         1. Simple Example (Signature, SignedInfo, Methods, and
            References)
              1. More on Reference 
         2. Extended Example (Object and SignatureProperty) 
         3. Extended Example (Object and Manifest) 
    3. Processing Rules
         1. Signature Generation
         2. Signature Validation
    4. Core Signature Syntax
         1. The Signature element
         2. The SignatureValue Element
         3. The SignedInfo Element
              1. The CanonicalizationMethod Element
              2. The SignatureMethod Element
              3. The Reference Element
                   1. The Transforms Element 
                   2. The DigestMethod Element 

Eastlake, Reagle, Solo					[Page 2]

Internet Draft		XML-Signature Syntax and Processing	February 2000


                   3. The DigestValue Element 
         4. The KeyInfo Element
         5. The Object Element
    5. Additional Signature Syntax
         1. The Manifest Element
         2. The SignatureProperties Element
         3. Processing Instructions
         4. Comments in dsig Elements
    6. Algorithms
         1. Algorithm Identifiers and Implementation Requirements
         2. Message Digests
         3. Message Authentication Codes
         4. Signature Algorithms
         5. Canonicalization Algorithms
         6. Transform Algorithms
    7. XML Canonicalization and Syntax Constraint Considerations
         1. XML 1.0, Syntax Constraints, and Canonicalization 
         2. DOM/SAX Processing and Canonicalization
    8. Security Considerations
         1. Only What is Signed is Secure
         2. Only What is "Seen" Should be Signed 
         3. Check the Security Model
         4. Algorithms, Key Lengths, Etc. 
    9. Schema, DTD, Data Model,and Valid Example
   10. Definitions
   11. References
   12. Authors' Address
     _________________________________________________________________
   
1.0 Introduction

   This document specifies XML syntax and processing rules for creating
   and representing digital signatures. XML Signatures can be applied to
   any digital content (data object), including XML. An XML Signature may
   be applied to the content of one or more resources. Enveloped or
   enveloping signatures are over data within the same XML document as
   the signature; detached signatures are over data external to the
   signature document.
   
   This specification also defines other useful types including methods
   of referencing collections of resources, algorithms, and keying
   information and management.
   
  1.1 Editorial Conventions
  
   For readability, brevity, and historic reasons this document uses the
   term "signature" to generally refer to to digital authentication
   values of all types.Obviously, the term is also stricly used to refer
   to authentication values that are based on public keys and that
   provide signer authentication. When specifically discussing
   authentication values based on symmetric secret key codes we use the
   terms authenticators or authentication codes. (See section 8.3:Check
   the Security Model.

Eastlake, Reagle, Solo					[Page 3]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   
   This specification uses both XML Schemas [XML-schema] and DTDs [XML].
   (Readers unfamiliar with DTD syntax may wish to refer to Ron Bourret's
   "Declaring Elements and Attributes in an XML DTD" [Bourret].)
   
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   specification are to be interpreted as described in RFC2119
   [KEYWORDS]:
   
     "they MUST only be used where it is actually required for
     interoperation or to limit behavior which has potential for causing
     harm (e.g., limiting retransmissions)"
     
   Consequently, we use these capitalized keywords to unambiguously
   specify requirements over protocol and application features and
   behavior that affect the interoperability and security of
   implementations. These key words are not used (capitalized) to
   describe XML grammar; schema definitions unambiguously describe such
   requirements and we wish to reserve the prominence of these terms for
   the natural language descriptions of protocols and features. For
   instance, an XML attribute might be described as being "optional."
   Compliance with the XML-namespace specification is described as
   "REQUIRED."
   
  1.2 Design Philosophy
  
   The design philosophy and requirements of this specification are
   addressed in the XML-Signature Requirements document
   [XML-Signature-RD].
   
  1.3 Versions, Namespaces and Identifiers
  
   No provision is made for an explicit version number in this syntax. If
   a future version is needed, it will use a different namespace  The XML
   namespace [XML-ns] URI that MUST be used by implementations of this
   (dated) specification is:
       xmlns="http://www.w3.org/2000/02/xmldsig#"

   This namespace is also used as the prefix for algorithm identifiers
   used by this specification. While applications MUST support XML and
   XML-namespaces, the use of internal entities [XML] or our "dsig" XML
   namespace prefix and defaulting/scoping conventions are OPTIONAL; we
   use these facilities to provide compact and readable examples.
   
   This specification uses Uniform  Resource Identifiers [URI] to
   identify resources, algorithms, and semantics. The URI in the
   namespace declaration above is also used as a prefix for URIs under
   the control of this specification. For resources not under the control
   of this specification, we use the designated Uniform Resource Names
   [URN] or Uniform Resource Locators [URL] defined by its normative
   external specification. If an external specification has not allocated
   itself a Uniform Resource Identifier we allocate an identifier under

Eastlake, Reagle, Solo					[Page 4]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   our own namespace. For instance:
   
   SignatureProperties is identified and defined by this specification's
          namespace
          http://www.w3.org/2000/02/xmldsig#SignatureProperties
          
   XSLT is identified and defined by an external namespace
          http://www.w3.org/TR/1999/PR-xslt-19991008
          
   SHA1 is identified via this specification's namespace and defined via
          a normative reference
          http://www.w3.org/2000/02/xmldsig#sha1
          FIPS PUB 180-1. Secure Hash Standard. U.S. Department of
          Commerce/National Institute of Standards and Technology.
          
   Finally, in order to provide for terse namespace declarations we
   sometimes use XML internal entities [XML] as macros within URIs. For
   instance:
<?xml version='1.0'?>
<!DOCTYPE Signature SYSTEM "xmldsig-core-schema.dtd" [
<!ENTITY dsig "http://www.w3.org/2000/02/xmldsig#">
]>
<Signature xmlns="&dsig;">
  <SignedInfo Id="mypage">
  ...

  1.4 Acknowledgements
  
   The contributions of the following working group members to this
   specification are gratefully acknowledged:
     * Milton Anderson, FSTC
     * Mark Bartel, JetForm Corporation (Author)
     * John Boyer, PureEdge (Author)
     * Richard Brown, Globeset
     * Donald Eastlake 3rd, Motorola  (Chair, Author/Editor)
     * Barb Fox, Microsoft (Author)
     * Phillip Hallam-Baker, VeriSign Inc
     * Richard Himes, US Courts
     * Peter Lipp, IAIK TU Graz
     * Joseph Reagle, W3C (Chair, Author/Editor)
     * Ed Simon , Entrust Technologies Inc. (Author)
     * Chris Smithies, PenOp
     * David Solo, Citigroup (Author/Editor)
     * Kent Tamura, IBM
     * Winchel Todd Vincent III, GSU
     * Greg Whitehead, Signio Inc.
     * Gregor Karlinger, IAIK TU Graz
       
2.0 Signature Overview and Examples

   This section provides an overview and examples of XML digital
   signature syntax. The specific processing is given in section
   3:Processing Rules. The formal syntax is found in section 4: Core

Eastlake, Reagle, Solo					[Page 5]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   Signature Syntax and section 5: Additional Signature Syntax.
   
   In this section, an  informal representation and examples are used to
   describe the structure of the XML signature syntax. This
   representation and examples may omit attributes, details and potential
   features that are fully explained later.
   
   XML Signatures are be applied to arbitrary digital content (data
   objects) via an indirection. Data objects are digested, the resulting
   value is placed in an element (with other information) and that
   element is then digested and cryptographically signed. XML digital
   signatures are represented by the Signature element which has the
   following structure (where "?" denotes zero or one occurrence; "+"
   denotes one or more occurrences; and "*" denotes zero or more
   occurrences):
<Signature>
  <SignedInfo>
    (CanonicalizationMethod)?
    (SignatureMethod)
    <Reference URI=? >
      (Transforms)?
      (DigestMethod)
      (DigestValue)
    </Reference>)+
  </SignedInfo>
  (SignatureValue)
  (KeyInfo)?
  (Object)*
</Signature>

   The content that is signed was, at the time of signature creation,
   referred to as an identified resource to which the specified
   transforms were applied. Within an XML document, signatures are
   related to data objects via IDREFs [XML] and the data can be included
   within an enveloping signature or can enclose an enveloped signature.
   Signatures are related to external data objects via URIs [URI] and the
   signature and data object are detached.
   
  2.1 Simple Example (Signature, SignedInfo, Methods, and References)
  
   The following example is a detached signature of the content of the
   HTML4.1 in XML specification.
[s01] <Signature xmlns="http://www.w3.org/2000/02/xmldsig#">
[s02]   <SignedInfo Id="MyFirstSignature">
[s03]    <CanonicalizationMethod
[s04]     Algorithm="http://www.w3.org/1999/07/WD-xml-c14n-19990729">
[s05]    </CanonicalizationMethod>
[s06]    <SignatureMethod Algorithm="http://www.w3.org/2000/02/xmldsig#dsa">
[s07]    </SignatureMethod>
[s08]    <Reference URI="http://www.w3.org/TR/2000/REC-xhtml1-20000126/">
[s09]      <Transforms>
[s10]        <Transform Algorithm="http://www.w3.org/2000/02/xmldsig#c14n"/>
[s11]      </Transforms>

Eastlake, Reagle, Solo					[Page 6]

Internet Draft		XML-Signature Syntax and Processing	February 2000


[s12]      <DigestMethod Algorithm="http://www.w3.org/2000/02/xmldsig#sha1">
[s13]      </DigestMethod>
[s14]      <DigestValue>j6lwx3rvEPO0vKtMup4NbeVu8nk=</DigestValue>
[s15]    </Reference>
[s16]  </SignedInfo>
[s17]  <SignatureValue>MC0CFFrVLtRlk=...</SignatureValue>
[s18]  <KeyInfo>
[s19]    <KeyValue>MIIBtzCCASw...</KeyValue>
[s20]  </KeyInfo>
[s21] </Signature>

   [s02-16] The required SignedInfo element is the information that is
   actually signed. Core validation of SignedInfo consists of two
   mandatory processes: validation of the signature over SignedInfo and
   validation of each Reference digest within SignedInfo. Note that the
   algorithms used in calculating the SignatureValue are also included in
   the signed information while the SignatureValue element is outside
   SignedInfo.
   
   [s03-05] The CanonicalizationMethod is the algorithm that is used to
   canonicalize the SignedInfo element before it is digested as part of
   the signature operation. In the absence of a CanonicalizationMethod
   element, no canonicalization is done.
   
   [s06-07] The SignatureMethod is the algorithm that is used to convert
   the canonicalized SignedInfo into the SignatureValue. It is a
   combination of a digest algorithm and a key dependent algorithm and
   possibly other algorithms such as padding, for example RSA-SHA1. The
   algorithm names are signed to resist attacks based on substituting a
   weaker algorithm. To promote application interoperability we specify
   mandatory to implement signature algorithms. We specify additional
   algorithms as recommended or optional and the signature design does
   permit arbitrary user algorithm specification.
   
   [s08-15] Each Reference element includes the digest method and
   resulting digest value calculated over the identified data object. It
   also may include transformations that produced the input to the digest
   operation. A data object is signed by computing its digest value and a
   signature over that value. The signature is later checked via
   reference and signature validation.
   
   [s18-20] KeyInfo indicates the key to be used to validate the
   signature. Possible forms for identification include certificates, key
   names, and key agreement algorithms and information -- we define only
   a few. KeyInfo is OPTIONAL for two reasons. First, the signer may not
   wish to reveal key information to all signature verifiers. Second, the
   information may be known within the application's context and need not
   be represented explicitly. Since KeyInfo is outside of SignedInfo, if
   the signer wishes to bind the keying information to the signature, a
   Reference can easily identify and include the KeyInfo as part of the
   signature.
   
  2.1.1 More on Reference

Eastlake, Reagle, Solo					[Page 7]

Internet Draft		XML-Signature Syntax and Processing	February 2000


  
[s08] <Reference URI="http://www.w3.org/TR/xml-stylesheet/">
[s09]   <Transforms>
[s10]     <Transform Algorithm="http://www.w3.org/2000/02/xmldsig#c14n>
[s11]   </Transforms>
[s12]   <DigestMethod Algorithm="http://www.w3.org/2000/02/xmldsig#sha1">
[s13]   </DigestMethod>
[s14]   <DigestValue>j6lwx3rvEPO0vKtMup4NbeVu8nk=</DigestValue>
[s15] </Reference>

   [s08] The optional URI attribute of Reference identifies the data
   object to be signed. This attribute may be omitted on at most one
   Reference in a Signature. (This limitation is imposed in order to
   ensure that references and objects may be matched unambiguously.)
   
   [s08-11] This identification, along with the transforms, is a
   description provided by the signer on how they obtained the signed
   data object in the form it was digested (i.e. the digested content).
   The verifier may obtain the digested content in another method so long
   as the digest verifies. In particular, the verifier may obtain the
   content from a different location such as a local store) than that
   specified in the URI.
   
   [s09-11] Transforms is an optional ordered list of processing steps
   that were applied to the resource's content before it was digested.
   Transforms can include operations such as canonicalization,
   encoding/decoding (including compression/inflation), XSLT and XPath.
   XPath transforms permit the signer to derive an XML document that
   omits portions of the source document. Consequently those excluded
   portions can change without affecting signature validity. For example,
   if the resource being signed encloses the signature itself, such a
   transform must be used to exclude the signature value from its own
   computation. If no Transforms element is present, the resource's
   content is digested directly. While we specify mandatory (and
   optional) canonicalization and decoding algorithms, user specified
   transforms are permitted.
   
   [s12-14] DigestMethod is the algorithm applied to the data after
   Transforms is applied (if specified) to yield the DigestValue. The
   signing of the DigestValue is what bind's a resources content to the
   signer's key.
   
  2.2 Extended Example (Object and SignatureProperty)
  
   This specification does not address mechanisms for making statements
   or assertions. Instead, this document defines what it means for
   something to be signed by an XML Signature (message authentication,
   integrity, and/or signer authentication). Applications that wish to
   represent other semantics must rely upon other technologies, such as
   [XML, XML-schema, RDF]. However, we do define a SignatureProperties
   element type for the inclusion of assertions about the signature
   itself (e.g., signature semantics, the time of signing or the serial
   number of hardware used in cryptographic processes). Such assertions

Eastlake, Reagle, Solo					[Page 8]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   may be signed by including a Reference for the SignatureProperties in
   SignedInfo. While the signing application should be very careful about
   what it signs (it should understand what is in the SignatureProperty)
   a receiving application has no obligation to understand that semantic
   (though its parent trust engine may wish to).
   
   Any content about the signature generation may be located within the
   SignatureProperty element. The mandatory Target attribute references
   the Signature element to which the property applies.
   
   Consider the preceding example with an additional reference to a local
   Object that includes a SignatureProperty element. (Such a signature
   would not only be detached [p01] but enveloping [p03].)
[p01] <SignedInfo Id="MySecondSignature">
[   ]  ...
[p02]  <Reference URI="http://www.w3.org/TR/xml-stylesheet/">
[   ]  ...
[p03]  <Reference URI="#AMadeUpTimeStamp"
[p04]         Type="http://www.w3.org/2000/02/xmldsig#SignatureProperty">
[p05]    <DigestMethod Algorithm="http://www.w3.org/2000/02/xmldsig#sha1">
[p06]    </DigestMethod>
[p07]   <DigestValue>k3453rvEPO0vKtMup4NbeVu8nk=</DigestValue>
[p08]  </Reference>
[p09] </SignedInfo>
[p10] ...
[p11] <Object>
[p12]   <SignatureProperties ID="AMadeUpTimeStamp">
[p13]     <SignatureProperty Target="#MySecondSignature">
[p14]       <timestamp xmlns="http://www.ietf.org/rfcXXXX.txt">
[p15]         <date>19990908</date>
[p16]         <time>14:34:34:34</time>
[p17]       </timestamp>
[p18]     </SignatureProperty>
[p19]   </SignatureProperties>
[p20] </Object>

   [p04] The optional Type attribute provides information about the
   resource identified by the URI. In particular, it can indicate that it
   is an Object, SignatureProperties, or Manifest element. This can be
   used by applications to initiate special processing of some Reference
   elements. References to an XML data element within an Object element
   SHOULD identify the actual element pointed to. Where the element
   content is not XML (perhaps it is binary or encoded data) the
   reference should identify the Object and the Reference Type, if given,
   SHOULD indicate Object. Note that Type is advisory and no action based
   on it or checking of its correctness is required by core behavior.
   
   [p11] Object is an optional element for including data objects within
   the signature element or elsewhere. The Object can be optionally typed
   and/or encoded.
   
   [p12] Signature properties, such as time of signing, can be optionally
   signed by identifying them from within a Reference. (These properties

Eastlake, Reagle, Solo					[Page 9]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   are traditionally called signature "attributes" although that term has
   no relationship to the XML term "attribute".)
   
  2.3 Extended Example (Object and Manifest)
  
   The Manifest element is provided to meet additional requirements not
   directly addressed by the mandatory parts of this specification. Two
   requirements and the way the Manifest satisfies them follows.
   
   First, applications frequently need to efficiently sign multiple data
   objects even where the signature operation itself is an expensive
   public key signature. This requirement can be met by including
   multiple Reference elements within SignedInfo since the inclusion of
   each digest secures the data digested. However, some applications may
   not want the core validation behavior associated with this approach
   because it requires every Reference within SignedInfo to undergo
   reference validation -- the DigestValue elements are checked. These
   applications may wish to reserve reference validation decision logic
   to themselves. For example, an application might receive a signature
   valid SignedInfo element that includes three Reference elements. If a
   single Reference fails (the identified data object when digested does
   not yield the specified DigestValue) the signature would fail core
   validation. However, the application may wish to treat the signature
   over the two valid Reference elements as valid or take different
   actions depending on which fails.  To accomplish this, SignedInfo
   would reference a Manifest element that contains one or more Reference
   elements (with the same structure as those in SignedInfo). Then,
   reference validation of the Manifest is under application control.
   
   Second, consider an application where many signatures (using different
   keys) are applied to a large number of documents. An inefficient
   solution is to have a separate signature (per key) repeatedly applied
   to a large SignedInfo element (with many References); this is wasteful
   and redundant. A more efficient solution is to include many references
   in a single Manifest that is then referenced from multiple Signature
   elements.
   
   The example below includes a Reference that signs a Manifest found
   within the Object element.
[   ] ...
[m01]   <Reference URI="#MyFirstManifest"
[m02]     Type="http://www.w3.org/2000/02/xmldsig#Manifest">
[m03]     <DigestMethod Algorithm="http://www.w3.org/2000/02/xmldsig#sha1">
[m04]     </DigestMethod>
[m05]     <DigestValue>345x3rvEPO0vKtMup4NbeVu8nk=</DigestValue>
[m06]   </Reference>
[   ] ...
[m07] <Object>
[m08]   <Manifest Id="MyFirstManifest">
[m09]     <Reference>
[m10]     ...
[m11]     </Reference>
[m12]     <Reference>

Eastlake, Reagle, Solo					[Page 10]

Internet Draft		XML-Signature Syntax and Processing	February 2000


[m13]     ...
[m14]     </Reference>
[m15] </Object>

3.0 Processing Rules

   The sections below describe the operations to be performed as part of
   signature generation and validation.
   
  3.1 Core Generation
  
   The REQUIRED steps include the generation of Reference elements and
   the SignatureValue over SignedInfo.
   
    3.1.1 Reference Generation
    
   For each data object being signed:
    1. Apply the Transforms, as determined by the application, to the
       data object.
    2. Calculate the digest value over the resulting data object.
    3. Create a Reference element, including the (optional)
       identification of the data object, any (optional) transform
       elements, the digest algorithm and the DigestValue.
       
    3.1.2 Signature Generation
    
    1. Create SignedInfo element with SignatureMethod,
       CanonicalizationMethod if required, and Reference(s).
    2. Canonicalize and then calculate the SignatureValue over SignedInfo
       based on algorithms specified in SignedInfo.
    3. Construct the Signature element that includes SignedInfo, Object
       (s) (if desired, encoding may be different than that used for
       signing), KeyInfo (if required), and SignatureValue.
       
  3.2 Core Validation
  
   The REQUIRED steps of core validation include (1) reference
   validation, the verification of the digest contained in each Reference
   in SignedInfo, and (2) the cryptographic signature validation of the
   signature calculated over SignedInfo.
   
   Note, there may be valid signatures that some signature applications
   are unable to validate. Reasons for this include failure to implement
   optional parts of this specification, inability or unwillingness to
   execute specified algorithms, or inability or unwillingness to
   dereference specified URIs (some URI schemes may cause undesireable
   side affects), etc.
   
    3.2.1 Reference Validation
    
   For each Reference in SignedInfo:
    1. Obtain the data object to be digested. (The signature application
       may rely upon the identification (URI) and Transforms provided by

Eastlake, Reagle, Solo					[Page 11]

Internet Draft		XML-Signature Syntax and Processing	February 2000


       the signer in the Reference element, or it may obtain the content
       through other means such as a local cache.)
    2. Digest the resulting data object using the DigestMethod specified
       in its Reference specification.
    3. Compare the generated digest value against DigestValue in
       SignedInfo; if there is any mismatch, validation fails.
       
    3.2.2 Signature Validation
    
    1. Canonicalize the SignedInfo element based on the
       CanonicalizationMethod, if any, in SignedInfo.
    2. Obtain the keying information from KeyInfo or from an external
       source.
    3. Use the specified SignatureMethod to validate the SignatureValue
       over the (optionally canonicalized) SignedInfo element.
       
4.0 Core Signature Syntax

   The general structure of an XML signature is described in section 2:
   Signature Overview. This section provides detailed syntax of the core
   signature features and actual examples. Features described in this
   section are mandatory to implement unless otherwise indicated. The
   syntax is defined via DTDs and [XML-Schema] with the following XML
   preamble, declaration, and internal entity:
Schema Definition:

<?xml version='1.0'?>
<!DOCTYPE schema
   SYSTEM 'http://www.w3.org/TR/1999/WD-xmlschema-1-19991217/structures.dtd'
  [
   <!ENTITY dsig 'http://www.w3.org/2000/02/xmldsig#'>
  ]>

<schema targetNamespace='&dsig;'
   version='0.1'
   xmlns='http://www.w3.org/1999/XMLSchema'
   xmlns:ds='&dsig;'>

  4.1 The Signature element
  
   The Signature element is the root element of a XML Signature. A simple
   example of a complete signature follows:
Schema Definition:

   <element name='Signature'>
     <type content='elementOnly'>
       <group order='seq' minOccurs='1' maxOccurs='1'>
         <element ref='ds:SignedInfo' minOccurs='1' maxOccurs='1'/>
         <element ref='ds:SignatureValue' minOccurs='1' maxOccurs='1'/>
         <element ref='ds:KeyInfo' minOccurs='0' maxOccurs='1'/>
         <element ref='ds:Object' minOccurs='0' maxOccurs='*'/>
       </group>
       <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>

Eastlake, Reagle, Solo					[Page 12]

Internet Draft		XML-Signature Syntax and Processing	February 2000


     </type>
   </element>
DTD:

<!ELEMENT Signature (SignedInfo, SignatureValue, KeyInfo?, Object*)  >
<!ATTLIST Signature
        xmlns   CDATA   #FIXED 'http://www.w3.org/2000/02/xmldsig#'
        Id      ID      #IMPLIED >

  4.2 The SignatureValue Element
  
   The SignatureValue element contains the actual value of the digital
   signature; it is encoded according by the identifier specified in
   SignatureMethod. Base64 [MIME] is the encoding method for all
   SignatureMethods specified within this specification. While we specify
   a mandatory (and optional) SignatureMethod algorithm, user specified
   algorithms (with their own encodings) are permitted.
Schema Definition:

<element name='SignatureValue' type='string'/>
DTD:

<!ELEMENT SignatureValue (#PCDATA)>

  4.3 The SignedInfo Element
  
   The structure of SignedInfo includes the canonicalization algorithm
   (if any), a signature algorithm, and one or more references. The
   SignedInfo element may contain an optional ID attribute that will
   allow it to be referenced by other signatures and objects.
Schema Definition:

<element name='SignedInfo'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
        <element ref='ds:CanonicalizationMethod' minOccurs='0' maxOccurs='1'/>
        <element ref='ds:SignatureMethod' minOccurs='1' maxOccurs='1'/>
        <element ref='ds:Reference' minOccurs='1' maxOccurs='*'/>
    </group>
    <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT SignedInfo (CanonicalizationMethod?,
        SignatureMethod,  Reference+)  >
<!ATTLIST SignedInfo
        Id       ID      #IMPLIED >

   SignedInfo does not include explicit signature or digest properties
   (such as calculation time, cryptographic device serial number, etc.).
   If an application needs to associate properties with the signature or
   digest, it may include such information in a SignatureProperties

Eastlake, Reagle, Solo					[Page 13]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   element within an Object element.
   
    4.3.1 The CanonicalizationMethod Element
    
   CanonicalizationMethod is an optional element that specifies the
   canonicalization algorithm applied to the SignedInfo element prior to
   performing signature calculations. This element uses the general
   structure for algorithms described in section 6.1: Algorithm
   Identifiers. Options include a minimal algorithm (CRLF and charset
   normalization) and more extensive operations such as [XML-C14N]. If
   the CanonicalizationMethod is omitted, no change is made to SignedInfo
   before digesting. (Note this may lead to interoperability failures as
   other applications may not serialize it as the creators application
   did by default. See section 7.)
Schema Definition:

<element name='CanonicalizationMethod'>
  <type content='elementOnly'>
    <attribute name='Algorithm' type='uri' minOccurs='1' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT CanonicalizationMethod (#PCDATA) >
<!ATTLIST CanonicalizationMethod
          Algorithm CDATA #REQUIRED >

    4.3.2 The SignatureMethod Element
    
   SignatureMethod is a required element that specifies the algorithm
   used for signature generation and validation. This algorithm
   identifies all cryptographic functions involved in the signature
   operation (e.g. hashing, public key algorithms, MACs, padding, etc.).
   This element uses the general structure here for algorithms described
   in section 6.1.  While there is a single identifier, that identifier
   may specify a format containing multiple distinct signature values.
Schema Definition:

<element name='SignatureMethod'>
  <type content='elementOnly'>
    <attribute name='Algorithm' type='uri' minOccurs='1' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT SignatureMethod (#PCDATA|HMACOutputLength)*>
<!ATTLIST SignatureMethod
          Algorithm CDATA #REQUIRED >

    4.3.3 The Reference Element
    
   Reference is an element that may occur one or more times. It specifies
   a digest algorithm and digest value, and optionally the object being

Eastlake, Reagle, Solo					[Page 14]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   signed, the type of the object, and/or a list of transforms to be
   applied prior to digesting. The identification and transforms describe
   how the digested content (i.e., the input to the digest method) was
   created. The type attribute facilitates the processing of referenced
   data. For example, while this specification makes no requirements over
   external data, an application may wish to signal that the referent is
   a Manifest. An optional ID attribute permits a Reference to be
   referenced from elsewhere.
Schema Definition:

<element name='Reference'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
          <element ref='ds:Transforms' minOccurs='0' maxOccurs='1'/>
          <element ref='ds:DigestMethod' minOccurs='1' maxOccurs='1'/>
          <element ref='ds:DigestValue' minOccurs='1' maxOccurs='1'/>
    </group>
        <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
        <attribute name='URI' type='uri' minOccurs='0' maxOccurs='1'/>
        <attribute name='Type' type='uri' minOccurs='0' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT Reference (Transforms?, DigestMethod, DigestValue)  >
<!ATTLIST Reference
        Id      ID      #IMPLIED
        URI     CDATA   #IMPLIED
        Type    CDATA   #IMPLIED>

   The URI attribute identifies a data object using a URI-Reference
   [URI], as specified by RFC2396 [URI]. Note that a null URI (URI="") is
   permitted and identifies the XML document that the reference is
   contained within (the root element). XML Signature applications MUST
   be able to parse URI syntax. We RECOMMEND they be able to dereference
   null URIs and URIs in the HTTP scheme. (See the section
   3.2.1:Reference Validation for a further comment on URI
   dereferencing.)
   
   [URI] permits identifiers that specify a fragment identifier via a
   separating pound symbol '#'. (The meaning of the fragment is defined
   by the resource's MIME type). XML Signature applications MUST support
   the the XPointer 'bare name' [Xptr] shortcut after '#' so as to
   identify IDs within XML documents. The results are serialized as
   specified in section 6.6.3:XPath Filtering. For example,
   
   URI="http://foo.com/bar.xml"
          Identifies the external XML resource 'http://foo.com/bar.xml'.
          
   URI="http://foo.com/bar.xml#chapter1"
          Identifies the element with ID attribute value 'chapter1' of
          the external XML resource 'http://foo.com/bar.xml'.
          

Eastlake, Reagle, Solo					[Page 15]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   URI=""
          Identifies the XML resource containing the signature..
          
   URI="#chapter1"
          Identifies the element with ID attribute value 'chapter1' of
          the XML resource containing the signature.
          
   Otherwise, support of other fragment/MIME types (e.g., PDF) or XML
   addressing mechanisms (e.g., [XPath, Xptr]) is OPTIONAL, though we
   RECOMMEND support of [XPath]. Regardless, such fragment identification
   and addressing SHOULD be given under Transforms (not as part of the
   URI) so that they can be fully identified and specified. For instance,
   one could reference a fragment of a document that is encoded by using
   the Reference URI to identify the resource, and one Transform to
   specify decoding, and a second to specify an XPath selection.
   
   If the URI attribute is omitted all-together, the receiving
   application is expected to know the identity of the object. For
   example, a lightweight data protocol might omit this attribute given
   the identity of the object is part of the application context. This
   attribute may be omitted from at most one Reference in any particular
   SignedInfo, or Manifest.
   
   The digest algorithm is applied to the data octets being secured.
   Typically that is done by locating (possibly using the URI if
   provided) the data and transforming it. If the data is an XML
   document, the document is assumed to be unparsed prior to the
   application of Transforms. If there are no Transforms, then the data
   is passed to the digest algorithm unmodified.
   
   The optional Type attribute contains information about the type of
   object being signed. This is represented as a URI. For example:
   
   Type="http://www.w3.org/2000/01/xmldsig#Object"
   Type="http://www.w3.org/2000/01/xmldsig#Manifest"
   Type="http://www.w3.org/2000/01/xmldsig#SignatureProperty"
   
   The Type attribute applies to the item being pointed at, not its
   contents. For example, a reference that identifies an Object element
   containing a SignatureProperties element is still of type #Object. The
   type attribute is advisory. No validation of the type information is
   required by this specification.
   
    4.3.3.1 The Transforms Element
    
   The optional Transforms element contains an ordered list of  Transform
   elements; these describe how the signer obtained the data object that
   was digested. The output of each Transform (octets) serves as input to
   the next Transform. The input to the first Transform is the source
   data. The output from the last Transform is the input for the
   DigestMethod algorithm. When transforms are applied the signer is not
   signing the native (original) document but the resulting (transformed)
   document [section 8.2: Only What is "Seen" Should be Signed].

Eastlake, Reagle, Solo					[Page 16]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   
   Each Transform consists of an Algorithm attribute, optional MimeType
   and Charset attributes, and content parameters, if any, appropriate
   for the given algorithm. The Algorithm attribute value specifies the
   name of the algorithm to be performed, and the Transform content
   provides additional data to govern the algorithm's processing of the
   input resource (see section 6.1: Algorithm Identifiers and
   Implementation Requirements).
   
   The optional MimeType and Charset (IANA registered character set)
   attributes are made available to algorithms which need and are
   otherwise unable to deduce that information about the data they are
   processing.
Schema Definition:

<element name='Transforms' >
  <type content='elementOnly'>
    <element ref='ds:Transform' minOccurs='1' maxOccurs='*'/>
  </type>
</element>

<element name='Transform'>
  <type content='elementOnly'>
    <attribute name='Algorithm' type='string' minOccurs='1' maxOccurs='1'/>
    <attribute name='MimeType' type='string' minOccurs='0' maxOccurs='1'/>
    <attribute name='Charset' type='string' minOccurs='0' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT Transforms (Transform+)>

<!ELEMENT Transform (#PCDATA)>
<!ATTLIST Transform
          Algorithm    CDATA     #REQUIRED
          MimeType     CDATA    #IMPLIED
          Charset      CDATA    #IMPLIED >

   Examples of transforms include but are not limited to base-64 decoding
   [MIME], canonicalization [XML-c14n], XPath filtering [XPath], and XSLT
   [XSLT]. The generic definition of the Transform element also allows
   application-specific transform algorithms. For example, the transform
   could be a decompression routine given by a Java class appearing as a
   base-64 encoded parameter to a Java Transform algorithm. However,
   applications should refrain from using application-specific transforms
   if they wish their signatures to be verifiable outside of their
   application domain. Section 6.6: Transform Algorithms defines the list
   of standard transformations.
   
    4.3.3.2 The DigestMethod Element
    
   DigestMethod is a required element that identifies the digest
   algorithm to be applied to the signed object. This element uses the

Eastlake, Reagle, Solo					[Page 17]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   general structure here for algorithms specified in section 6.1:
   Algorithm Identifiers.
Schema Definition:

<element name='DigestMethod'>
  <type content='elementOnly'>
    <attribute name='Algorithm' type='uri' minOccurs='1' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT DigestMethod (#PCDATA) >
<!ATTLIST DigestMethod
        Algorithm               CDATA   #REQUIRED >

    4.3.3.3 The DigestValue Element
    
   DigestValue is an element that contains the encoded value of the
   digest. The digest is always encoded using Base 64 [MIME].
Schema Definition:

<element name='DigestValue' type='ds:encoded'/>
DTD:

<!ELEMENT DigestValue  (#PCDATA)  >
<!-- base64 encoded signature value -->

  4.4 The KeyInfo Element
  
   KeyInfo may contain keys, names, certificates and other public key
   management information (such as in-band key distribution or agreement
   data or data supporting any other method.) This specification defines
   a few simple types but applications may place their own key
   identification and exchange semantics within this element through the
   XML-namespace facility. [XML-ns]
Schema Definition:

<element name='KeyInfo'>
  <type content='elementOnly'>
    <group order='choice' minOccurs='1' maxOccurs='*'>
        <element name='KeyName' type='string'/>
        <element ref='ds:KeyValue'/>
        <element name='RetrievalMethod' type='uri'/>
        <element ref='ds:X509Data'/>
        <element ref='ds:PGPData'/>
        <element name='MgmtData' type='string' minOccurs='0' maxOccurs='1'/>
    </group>
    <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
  </type>
</element>

<element name='KeyValue'>
  <type content='mixed'>

Eastlake, Reagle, Solo					[Page 18]

Internet Draft		XML-Signature Syntax and Processing	February 2000


    <element ref='ds:DSAKeyValue'/>
    <element ref='ds:RSAKeyValue'/>
  </type>
</element>
DTD:

<!ELEMENT KeyInfo ((KeyName | KeyValue | RetrievalMethod |
          X509Data | PGPData  | MgmtData)*)  >
<!ATTLIST KeyInfo
        Id      ID       #IMPLIED>
<!ELEMENT KeyName  (#PCDATA) >
<!ELEMENT KeyValue  (#PCDATA|DSAKeyValue|RSAKeyValue)*>
<!ELEMENT RetrievalMethod  (#PCDATA)  >

   KeyInfo is an optional element that enables the recipient(s) to obtain
   the key(s) needed to validate the signature. If omitted, the recipient
   is expected to be able to identify the key based on application
   context information. Multiple declarations within KeyInfo refer to the
   same key. Applications may define and use any mechanism they choose
   through inclusion of elements from a different namespace.
   
   Compliant versions implementing KeyInfo MUST implement KeyValue, and
   SHOULD implement RetrievalMethod.
     * KeyName contains an identifier for the key, which may be useful to
       the recipient. It may be a simple string name, index, encoded DN,
       email address, etc.
     * KeyValue contains the actual key(s) used to validate the
       signature. If the key is sent in protected form, the MgmtData
       element should be used. Specific types must be defined for each
       algorithm type (see algorithms).
     * RetrievalMethod is a URI (including optional query parameters)
       that may be used to obtain key and/or certificate information.
     * X509Data contains an identifier of the key/cert used for
       validation (either an IssuerSerial value, a subject name, or a
       subjectkeyID) and an optional collection of certificates and
       revocation/status information which may be used by the recipient.
       IssuerSerial contains the encoded issuer name (RFC 2253) along
       with the serial number.
     * PGPData contains data associated with a PGP key.
     * MgmtData contains in-band key distribution or agreement data.
       Examples may include DH key exchange, RSA key encryption etc.
       
Schema Definition

<element name='X509Data'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
      <group order='choice' minOccurs='1' maxOccurs='1'>
        <element ref='ds:X509IssuerSerial'/>
        <element name='X509SKI' type='string'/>
        <element name='X509SubjectName' type='string'/>
      </group>
      <element name='X509Certificate' type='string' minOccurs='0' maxOccurs='*'

Eastlake, Reagle, Solo					[Page 19]

Internet Draft		XML-Signature Syntax and Processing	February 2000


/>
      <element name='X509CRL' type='string' minOccurs='0' maxOccurs='*'/>
    </group>
  </type>
</element>

<element name='X509IssuerSerial'>
   <type content='elementOnly'>
     <group order='seq' minOccurs='1' maxOccurs='1'>
       <element name='X509IssuerName' type='string' minOccurs='1' maxOccurs='1'
/>
       <element name='X509SerialNumber' type='string' minOccurs='1' maxOccurs='
1'/>
    </group>
  </type>
</element>

<element name='PGPData'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
      <element name='PGPKeyID' type='string' minOccurs='1' maxOccurs='1'/>
      <element name='PGPKeyPacket' type='string' minOccurs='1' maxOccurs='1'/>
    </group>
  </type>
</element>
DTD:

<!ELEMENT X509Data ((X509IssuerSerial | X509SKI | X509SubjectName),
          X509Certificate*, X509CRL*)>
<!ELEMENT X509IssuerSerial (X509IssuerName, X509SerialNumber)  >
<!ELEMENT X509IssuerName (#PCDATA)  >
<!ELEMENT X509SubjectName (#PCDATA) >
<!ELEMENT X509SerialNumber  (#PCDATA)  >
<!ELEMENT X509SKI  (#PCDATA)  >
<!ELEMENT X509Certificate  (#PCDATA)  >
<!ELEMENT X509CRL  (#PCDATA)  >

<!ELEMENT PGPData (PGPKeyID, PGPKeyPacket?)  >
<!ELEMENT PGPKeyPacket  (#PCDATA)  >
<!ELEMENT PGPKeyID  (#PCDATA)  >
<!ELEMENT MgmtData (#PCDATA)>

  4.5 The Object Element
  
   Object is an optional element that may occur one or more times. When
   present, this element may contain any data. The Object element may
   include optional MIME type, ID, and encoding attributes.
   
   The MimeType attribute is an optional attribute which describes the
   data within the Object. This is a string with values defined by
   [MIME]. For example, if the Object contains XML, the MimeType could be
   text/xml. This attribute is purely advisory, no validation of the
   MimeType information is required by this specification.

Eastlake, Reagle, Solo					[Page 20]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   
   The Object's ID is commonly referenced from a Reference in SignedInfo,
   or Manifest. This element is typically used for enveloping signatures
   where the object being signed is to be included in the signature
   document. The digest is calculated over the entire Object element
   including start and end tags.
   
   Note, if the application wishes to exclude the <Object> tags from the
   digest calculation the Reference must identify the actual data object
   (easy for XML documents) or a transform must be used to remove the
   Object tags (likely where the data object is non-XML). Exclusion of
   the object tags may be desired for cases where one wants the signature
   to remain valid if the data object is moved from inside a signature to
   outside the signature (or vice-versa), or where the content of the
   Object is an encoding of an original binary document and it is desired
   to extract and decode so as to sign the original bitwise
   representation.
Schema Definition:

<element name='Object' >
  <type content='mixed'>
     <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
     <attribute name='MimeType' type='string' minOccurs='0' maxOccurs='1'/>
     <attribute name='Encoding' type='uri' minOccurs='0' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT Object (#PCDATA|SignatureProperties|Manifest)*>
<!ATTLIST Object
        Id      ID      #IMPLIED
        MimeType        CDATA   #IMPLIED
        Encoding        CDATA   #IMPLIED >

5.0 Additional Signature Syntax

   This section describes the optional to implement Manifest and
   SignatureProperties elements and describes the handling of XML
   Processing Instructions and Comments. With respect to the elements
   Manifest and SignatureProperties this section specifies syntax and
   little behavior -- it is left to the application. These elements can
   appear anywhere the parent's content model permits; the Signature
   content model only permits them within Object.
   
  5.1 The Manifest Element
  
   The Manifest element provides a list of References. The difference
   from the list in SignedInfo is that it is application defined which,
   if any, of the digests are actually checked against the objects
   referenced and what to do if the object is inaccessible or the digest
   compare fails. If a Manifest is pointed to from SignedInfo, the digest
   over the Manifest itself will be checked by the core signature
   validation behavior. The digests within such a Manifest are checked at

Eastlake, Reagle, Solo					[Page 21]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   application discretion. If a Manifest is referenced from another
   Manifest, even the overall digest of this two level deep Manifest
   might not be checked.
Schema Definition:

<element name='Manifest'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
        <element ref='ds:Reference' minOccurs='0' maxOccurs='*'/>
    </group>
  <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT Manifest (Reference*)  >
<!ATTLIST Manifest
        Id      ID      #IMPLIED >

  5.2 The SignatureProperties Element
  
   Additional information items concerning the generation of the
   signature(s) can be placed in a SignatureProperty element (i.e.,
   date/time stamp or the serial number of cryptographic hardware used in
   signature generation.)
Schema Definition:

<element name='SignatureProperties'>
  <type content='elementOnly'>
    <element ref='ds:SignatureProperty' minOccurs='1' maxOccurs='*'/>
    <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
  </type>
</element>

<element name='SignatureProperty'>
  <type content='mixed'>
    <any namespace='##other'/>
    <attribute name='Target' type='URI' minOccurs='1' maxOccurs='1'/>
  </type>
</element>
DTD:
<!ELEMENT SignatureProperties (SignatureProperty*)  >
<!ATTLIST SignatureProperties
        Id      ID       #IMPLIED  >

<!ELEMENT SignatureProperty (#PCDATA)  >
<!ATTLIST SignatureProperty
        Target  CDATA    #REQUIRED  >

  5.3 Processing Instructions in Signature Elements
  
   No XML processing instructions (PIs) are used by this specification.
   

Eastlake, Reagle, Solo					[Page 22]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   Note that PIs placed inside SignedInfo by an application will be
   signed unless the CanonicalizationMethod algorithm discards them.
   (This is true for any signed XML content.) All of the
   CanonicalizationMethods specified within this specification retain
   PIs. When a PI is part of content that is signed (e.g., within
   SignedInfo or referenced XML documents) any change to the PI will
   obviously result in a signature failure.
   
  5.4 Comments in Signature Elements
  
   XML comments are not used by this specification.
   
   Note that unless CanonicalizationMethod removes comments within
   SignedInfo or any other referenced XML, they will be signed.
   Consequently, a change to the comment will cause a signature failure.
   Similarly, the XML signature over any XML data will be sensitive to
   comment changes unless a comment-ignoring canonicalization/transform
   method, such as the Canonical XML [XML-canonicalization], is
   specified.
   
6.0 Algorithms

   This section identifies algorithms used with the XML digital signature
   standard. Entries contain the identifier to be used in Signature
   elements, a reference to the formal specification, and definitions,
   where applicable, for the representation of keys and the results of
   cryptographic operations.
   
  6.1 Algorithm Identifiers and Implementation Requirements
  
   Algorithms are identified by URIs that appear as an attribute to the
   element that identifies the algorithms' role (DigestMethod, Transform,
   SignatureMethod, or CanonicalizationMethod). All algorithms used
   herein take parameters but in many cases the parameters are implicit.
   For example, a SignatureMethod is implicitly given two parameters: the
   keying info and the output of CanonicalizationMethod (or SignedInfo
   directly if there is no CanonicalizationMethod). Explicit additional
   parameters to an algorithm appear as content elements within the
   algorithm role element. Such parameter elements have a descriptive
   element name, which is frequently algorithm specific, and MUST be in
   the XML Signature namespace or an algorithm specific namespace.
   
   This specification defines a set of algorithms, their URIs, and
   requirements for implementation. Requirements are specified over
   implementation, not over requirements for signature use. Furthermore,
   the mechanism is extensible, alternative algorithms may be used by
   signature applications.
   
   Algorithm Type Algorithm Requirements Algorithm URI
   Digest
     SHA1 REQUIRED http://www.w3.org/2000/02/xmldsig#sha1
   Encoding
     Base64 REQUIRED http://www.w3.org/2000/02/xmldsig#base64

Eastlake, Reagle, Solo					[Page 23]

Internet Draft		XML-Signature Syntax and Processing	February 2000


     QuotedPrintable RECOMMENDED http://www.w3.org/2000/02/xmldsig#qp
   MAC
     HMAC-SHA1 REQUIRED http://www.w3.org/2000/02/xmldsig#hmac-sha1
   Signature
     DSAwithSHA1
   (DSS) REQUIRED http://www.w3.org/2000/02/xmldsig#dsa
     RSAwithSHA1 RECOMMENDED http://www.w3.org/2000/02/xmldsig#rsa-sha1
   Canonicalization
     minimal REQUIRED http://www.w3.org/2000/02/xmldsig#minimal
     XML-
   Canonicalization RECOMMENDED
   http://www.w3.org/TR/1999/WD-xml-c14n-19991115
   Transform
     XSLT RECOMMENDED http://www.w3.org/TR/1999/REC-xslt-19991116
     XPath RECOMMENDED http://www.w3.org/TR/1999/REC-xpath-19991116
   
   Note that the normative identifier is the complete URIs in the table
   though they are frequently abbreviated in XML syntax as "&dsig;base64"
   or the like.
   
  6.2 Message Digests
  
   Only one digest algorithm is defined herein. However, it is expected
   that one or more additional strong digest algorithms will be developed
   in connection with the US Advanced Encryption Standard effort. Use of
   MD5 [MD5] is NOT RECOMMENDED because recent advances in cryptography
   have cast doubt on its strength.
   
    6.2.1 SHA-1
    
   Identifier:
          http://www.w3.org/2000/02/xmldsig#sha1
          
   The SHA-1 algorithm [SHA-1] takes no explicit parameters. An example
   of an SHA-1 DigestAlg element is:
<DigestMethod Algorithm="&dsig;sha1"/>

   A SHA-1 digest is a 160-bit string. The content of the DigestValue
   element shall be the base64 encoding of this bit string viewed as a
   20-octet octet stream. Example, the DigestValue element for the
   message digest:
A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D

   from Appendix A of the SHA-1 standard would be:
<DigestValue>qZk+NkcGgWq6PiVxeFDCbJzQ2J0=</DigestValue>

  6.3 Message Authentication Codes
  
   MAC algorithms take two implicit parameters, their keying material
   determined from KeyInfo and the byte stream output by
   CanonicalizationMethod or SignedInfo directly if there is no
   CanonicalizationMethod. MACs and signature algorithms are
   syntactically identical but a MAC implies a shared secret key.

Eastlake, Reagle, Solo					[Page 24]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   
    6.3.1 HMAC
    
   Identifier:
          http://www.w3.org/2000/02/xmldsig#hmac-sha1
          
   The HMAC algorithm (RFC2104 [HMAC]) takes the truncation length in
   bits as a parameter. An example of an HMAC SignatureMethod element:
<SignatureMethod Algorithm="&dsig;hmac-sha1">
   <HMACOutputLength>128</HMACOutputLength>
</SignatureMethod>

   The output of the HMAC algorithm is ultimately the output (possibly
   truncated) of the chosen digest algorithm. This value shall be base64
   encoded in the same straightforward fashion as the output of the
   digest algorithms. Example: the SignatureValue element for the
   HMAC-SHA1 digest
9294727A 3638BB1C 13F48EF8 158BFC9D

   from the test vectors in [HMAC] would be
<SignatureValue>kpRyejY4uxwT9I74FYv8nQ==</SignatureValue>
Schema Definition:

<element name='HMACOutputLength' type='integer' minOccurs='0' maxOccurs='1'/>
DTD:

<!ELEMENT HMACOutputLength (#PCDATA)>

  6.4 Signature Algorithms
  
   Signature algorithms take two implicit parameters, their keying
   material determined from KeyInfo and the byte stream output by
   CanonicalizationMethod or SignedInfo directly if there is no
   CanonicalizationMethod. Signature and MAC algorithms are syntactically
   identical but a signature implies public key cryptography.
   
   Note: the schema and DTD declarations within this section are not yet
   part of section 9: schemas.
   
    6.4.1 DSA
    
   Identifier:
          http://www.w3.org/2000/02/xmldsig#dsa
          
   The DSA algorithm [DSS] takes no explicit parameters. An example of a
   DSA SignatureMethod element is:
<SignatureMethod Algorithm="&dsig;dsa"/>

   The output of the DSA algorithm consists of a pair of integers usually
   referred by the pair (r, s). The signature value consists of the
   base64 encoding of the concatenation of two octet-streams that
   respectively result from the octet-encoding of the values r and s.
   Integer to octet-stream conversion must be done according to the I2OSP

Eastlake, Reagle, Solo					[Page 25]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   operation defined in the RFC 2437 [PKCS1] specification with a k
   parameter equal to 20. For example, the SignatureValue element for a
   DSA signature (r, s) with values specified in hexadecimal:
r = 8BAC1AB6 6410435C B7181F95 B16AB97C 92B341C0
s = 41E2345F 1F56DF24 58F426D1 55B4BA2D B6DCD8C8

   from the example in Appendix 5 of the DSS standard would be
<SignatureValue>
i6watmQQQ1y3GB+VsWq5fJKzQcBB4jRfH1bfJFj0JtFVtLotttzYyA==</SignatureValue>

   DSA key values have the following set of fields: P, Q, G and Y are
   mandatory when appearing as a key value, J, seed and pgenCounter are
   optional but SHOULD be present. (The seed and pgenCounter fields MUST
   appear together or be absent). All parameters are encoded as base64
   values.
Schema:

<element name='DSAKeyValue'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
      <element name='P' type='string' minOccurs='1' maxOccurs='1'/>
      <element name='Q' type='string' minOccurs='1' maxOccurs='1'/>
      <element name='G' type='string' minOccurs='1' maxOccurs='1'/>
      <element name='Y' type='string' minOccurs='1' maxOccurs='1'/>
      <element name='J' type='string' minOccurs='0' maxOccurs='1'/>
    </group>
    <group order='seq' minOccurs='0' maxOccurs='1'>
      <element name='Seed' type='string' minOccurs='1' maxOccurs='1'/>
      <element name='PgenCounterQ' type='string'   minOccurs='1' maxOccurs='1'/
>
    </group>
  </type>
</element>
DTD:

<!ELEMENT DSAKeyValue (P, Q, G, Y, J?, (Seed, PgenCounter)?) >
<!ELEMENT P (#PCDATA) >
<!ELEMENT Q (#PCDATA) >
<!ELEMENT G (#PCDATA) >
<!ELEMENT Y (#PCDATA) >
<!ELEMENT J (#PCDATA) >
<!ELEMENT Seed (#PCDATA) >
<!ELEMENT PgenCounter (#PCDATA) >
<!-- Each of these fields consists a PCDATA
     where the data is base64 encoded -->

    6.4.2 PKCS1
    
   Identifier:
          http://www.w3.org/2000/02/xmldsig#rsa-sha1
          
   The expression "RSA algorithm" as used in this specification refers to
   the RSASSA-PKCS1-v1_5 algorithm described in  RFC 2437 [PKCS1]. The

Eastlake, Reagle, Solo					[Page 26]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   RSA algorithm takes no explicit parameters. An example of an RSA
   SignatureMethod element is:
<SignatureMethod Algorithm="&dsig;rsa-sha1"/>

   The output of the RSA algorithm is an octet string. The SignatureValue
   content for an RSA signature shall be the base64 encoding of this
   octet string. Example: TBD
   
   RSA key values have two fields: Modulus and Exponent.
Schema:

<element name='RSAKeyValue'>
  <type content='elementOnly'>
    <element name='Modulus' type='string' minOccurs='1' maxOccurs='1'/>
    <element name='Exponent' type='string' minOccurs='1' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT RSAKeyValue (Modulus, Exponent) >
<!ELEMENT Modulus (#PCDATA) >
<!ELEMENT Exponent (#PCDATA) >
<!-- Each field contains a CDATA which is the
     value for that item base64 encoded -->

  6.5 Canonicalization Algorithms
  
   Canonicalization algorithms take one implicit parameter when they
   appear as a CanonicalizationMethod within the SignedInfo element.
   
    6.5.1 Minimal Canonicalization
    
   Identifier:
          http://www.w3.org/2000/02/xmldsig#minimal 
          
   An example of a minimal canonicalization element is:
<CanonicalizationMethod Algorithm="&dsig;minimal"/>

   The minimal canonicalization algorithm:
     * converts the character encoding to UTF-8, removing the encoding
       pseudo-attribute
     * normalizes line endings as provided by [XML]. (See section 7: XML
       and Canonicalization and Syntactical Considerations.)
       
    6.5.2 Canonical XML
    
   Identifier:
          http://www.w3.org/TR/1999/WD-xml-c14n-19991115
          
   An example of an XML canonicalization element is:
<CanonicalizationMethod Algorithm="http://www.w3.org/TR/1999/WD-xml-c14n-199911
15"/>


Eastlake, Reagle, Solo					[Page 27]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   The normative specification of Canonical XML is [XML-c14n].
   
  6.6 Transform Algorithms
  
   A Transform algorithm has three implicit parameters. The first is a
   byte stream from the Reference or as the output of an earlier
   Transform. The second and third are the optional MimeType and Charset
   attributes that can be specified on the Transform element.
   
   Application developers are strongly encouraged to support all
   transforms listed in this section as RECOMMENDED unless the
   application environment has resource constraints that would make such
   support impractical. The Working Group goal is to maximize application
   interoperability on XML signatures, and the working group expects
   ubiquitous availability of software to support these transforms that
   can be incorporated into applications without extensive development.
   
    6.6.1 Canonicalization
    
   Any canonicalization algorithm that can be used for
   CanonicalizationMethod can be used as a Transform.
   
    6.6.2 Base-64 and Quoted-Printable Decoding
    
   Identifiers:
          http://www.w3.org/2000/02/xmldsig#base-64
          http://www.w3.org/2000/02/xmldsig#qp
          
   The normative specification for base 64 and quoted-printable decoding
   transforms is [MIME]. Neither the base-64 nor the quoted-printable
   Transform element has content. The input is decoded by the algorithms.
   This transform is useful if an application needs to sign the raw data
   associated with the encoded content of an element. Quoted-printable is
   provided, in addition to base-64, in keeping with the XML support of a
   roughly human readable final format.
   
    6.6.3 XPath Filtering
    
   Identifier:
          http://www.w3.org/TR/1999/REC-xpath-19991116
          
   The XPath transform output is the result of applying an XPath
   expression to an input string. The XPath expression appears in a
   parameter element named XPath. The input string is equivalent to the
   result of dereferencing the URI attribute of the Reference element
   containing the XPath transform, then, in sequence, applying all
   transforms that appear before the XPath transform in the Reference
   element's Transforms.
   
   The primary purpose of this transform is to omit information from the
   input document that must be allowed to vary after the signature is
   affixed to the input document. It is the responsibility of the XPath
   expression author to ensure that all information the authentication of

Eastlake, Reagle, Solo					[Page 28]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   which is necessary has been included in the output such that
   modification of the excluded information does not affect the secure
   interpretation of the data in the application context. One simple
   example of this is the omission of an enveloped signature's
   SignatureValue element.
   
    6.6.3.1 Evaluation Context Initialization
    
   The XPath transform establishes the following evaluation context for
   the XPath expression given in the XPath parameter element:
     * A context node, initialized to null.
     * A context position, initialized to 0.
     * A context size, initialized to 0.
     * A library of functions equal to the function set defined in XPath
       plus the functions parse() and serialize() defined in this
       specification.
     * A set of variable bindings containing the variables $exprEncoding,
       $exprBOM, and $input.
          + $exprEncoding: a string containing the character encoding of
            the XPath expression
          + $exprBOM: a string containing the byte order mark for the
            XPath expression; set to the empty string if the document
            containing the XPath expression has no byte order mark.
          + $input: the string containing the input XML document,
            including the byte order mark, if one exists. (Typically,
            $input is passed directly to parse(), but if $input does not
            contain a well-formed XML document, XPath functions such as
            concat() can be used before passing the result to parse()).
     * An empty set of namespace declarations. (Note: It is possible to
       address a node by its qualified name, even though the evaluation
       context has not been initialized with a declaration of the
       namespace. The XPath language provides the functions
       namespace-uri() and local-name() for this purpose).
       
   The XPath implementation is expected to convert all strings appearing
   in the XPath expression to the same encoding used by the input string
   prior to making any comparisons.
   
    6.6.3.2 Document Order
    
   The XPath specification defines a node-set to be unordered. However,
   the specification also defines the notion of document order, and it is
   clear that implementations must maintain knowledge of the document
   order in order to correctly process the proximity position of a node.
   In XPath, a node's position in the document order is given by the
   location of the first character of the node's representative text in
   the document, except that an element's namespace nodes are defined to
   be before its attribute nodes and the relative order of namespace
   nodes and attribute nodes is application dependent. Within the
   XML-Signature application of XPath, two namespace/attribute orderings
   are defined:
     * Lexicographic Order: the namespace and attribute axes are
       lexicographically sorted on input, with namespace URI as primary

Eastlake, Reagle, Solo					[Page 29]

Internet Draft		XML-Signature Syntax and Processing	February 2000


       key and local name as secondary key. On serialization, the
       namespace nodes are placed before the attribute nodes.
     * Exact Order: as with all other types of nodes, each namespace and
       attribute node is associated with an integer P indicating the
       location of the first character of its representative text, and
       the namespace and attribute axes are sorted by P. On
       serialization, the namespace and attribute axes are merged using P
       as the key.
       
    6.6.3.3 Function Library Additions
    
   Function: node-set parse (stringInput, boolean LexOrder)
   
   This function converts the Input string into a node-set. The function
   throws an exception if it cannot provide the functionality
   corresponding to the LexOrder setting or if the string does not
   contain a well-formed XML document (including byte order mark if the
   document has one).
   
   Because parse() uses an XML processor to read the input, linefeeds are
   normalized, attribute values are normalized, CDATA sections are
   replaced by their content, and entity references are recursively
   replaced by substitution text. In addition, any consecutive characters
   are grouped into a single text node.
   
   Although an XML processor reads the input XML document, validating and
   non-validating XML processors only behave in the same way (e.g. with
   respect to attribute value normalization and entity reference
   definition) until an external reference is encountered. If the
   implementation uses a non-validating processor, and it encounters an
   external reference in the input document, then the function should
   throw an exception to indicate that the necessary algorithm is
   unavailable (The XPath transform cannot simply generate incorrect
   output since many applications distinguish between an unverifiable
   signature versus an invalid signature).
   
   The node-set returned by this function has a context node of the root
   of the input XML document, and the context position and context size
   are equal to 1. The function also associates a document order position
   P with each node. For attribute and namespace nodes, the value of P is
   dependent upon the LexOrder parameter. If the LexOrder is false, then
   P is assigned using exact order as defined in the previous section. If
   LexOrder is true, then the value of P for namespace and attribute
   nodes is assigned based on a lexicographic ordering of the namespace
   and attributes (as defined in the previous section). For a given
   element E with document order position P, N namespace nodes and A
   attribute nodes, the successive namespace nodes are assigned document
   order positions P+1 to P+N, and the successive attribute nodes are
   assigned document order positions P+N+1 to P+N+A.
   
   The function associates two strings with the root node: BOM and
   XMLDecl. The BOM string contains the byte order mark or the empty
   string if there was no byte order mark. The XMLDecl strings contain

Eastlake, Reagle, Solo					[Page 30]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   the complete, unaltered input text that the XML processor absorbs
   while recognizing the 'XMLDecl' production rule.
   
   The function associates a namespace-prefix string with each element,
   attribute and namespace node to store the namespace prefix of
   namespace qualified nodes. The string is empty unless the name of the
   node is namespace qualified.
   
   Function:string serialize(node-set)
   
   This function converts a node-set into a string by generating the
   representative text for each node in the node-set. The nodes of a
   node-set are processed in ascending order of the nodes' P values
   (document order positions) as assigned by the parse() function. The
   method of text generation is dependent on the node type and given in
   the following list:
     * Root Node- The BOM (byte order mark) string then the XMLDecl
       string. (Note that parse() does not preserve the document type
       declaration (the text that was absorbed while matching the
       'doctypedecl' production rule). This is because XPath provides no
       access to the DTD or even node type for storing the DTD, so there
       is nothing with which to associate a document order position.)
     * Element Nodes- An open angle bracket (<), the element name, any
       namespace and attribute nodes in document order given by P, then a
       close angle bracket (>), the descendant nodes of the element that
       are in the node-set in document order, an open angle bracket, a
       forward slash (/), the element name, and a close angle bracket.
       The element name is either (1) the local name if the namespace
       prefix string is empty or (2) the namespace prefix and a colon
       followed by the local name of the element.
     * Namespace and Attribute Nodes- a space, the namespace prefix and a
       colon if the namespace prefix string for the node is non-empty,
       the local name, an equals sign, an open double quote, the modified
       string value, the attribute value, and a close double quote. The
       string value of the node is modified by replacing all ampersands
       (&) with &amp;, all double quote characters with &quot;, and all
       illegal characters for the output character encoding with
       hexadecimal character references (e.g. &#x0D;).
     * Text Nodes- the string value, except all ampersands are replaced
       by &amp;, all open angle brackets (<) are replaced by &lt;, and
       all illegal characters for the output character encoding with
       hexadecimal character references (e.g. &#x0D;).
     * Processing Instruction Nodes- an open angle bracket, a question
       mark, the expanded name of the node, a space, the string value,
       the question mark, and a close angle bracket.
     * Comment Nodes- the open comment sequence (<!--), the string value
       of the node, and the close comment sequence (-->).
       
    6.6.3.4 XPath Transform Output
    
   The result of the XPath expression is a string, boolean, number, or
   node-set. If the result of the XPath expression is a string, then the
   string is the output of the XPath transform. If the result is a

Eastlake, Reagle, Solo					[Page 31]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   boolean or number, then the XPath transform output is computed by
   calling the XPath string() function on the boolean or number. If the
   result of the XPath expression is a node-set, then the XPath transform
   output is the string result of calling serialize() on the node-set.
   
   For example, consider creating an enveloped signature S1 (a Signature
   element with an id attribute equal to "S1"). The signature S1 is
   enveloped because its Reference URI indicates some ancestor element of
   S1. Since the DigestValue in the Reference is calculated before S1's
   SignatureValue, the SignatureValue must be omitted from the
   DigestValue calculation. This can be done with an XPath transform
   containing the following XPath expression in its XPath parameter
   element:
   
   serialize(parse($input, "true")/descendant-or-self::node()[
        not(self::SignatureValue and parent::Signature[@id="S1"]) and
        not(self::KeyInfo and parent::Signature[@id="S1"]) and
        not(self::DigestValue and ancestor::*[3 and @id="S1"])]
   
   The parse() call creates a node-set from the $input using
   lexicographic order for the namespace and attribute order. The
   '/descendant-or-self::node()' means that all nodes in the entire parse
   tree starting at the root node are candidates for the result node-set.
   For each node candidate, the node is included in the resultant
   node-set if and only if the node test (the boolean expression in the
   square brackets) evaluates to "true" for that node. The node test
   returns true for all nodes except the SignatureValue and KeyInfo child
   elements and the DigestValue descendants of Signature S1. Thus,
   serialize() returns a string containing the entire $input except for
   omitting the parts of S1 that must change during core processing, so
   these changes will not invalidate a DigestValue computed over the
   serialize() result.
   
   Note that this expression works even if the XPath transform is
   implemented with a non-validating processor because S1 is identified
   by comparison to the value of an attribute named 'id' rather than by
   using the XPath id() function. Although the id() function is useful
   when the 'id' attribute is not named 'id', the XPath expression author
   will know the 'id' attribute's name when writing the expression.
   
   It is RECOMMENDED that the XPath be constructed such that the result
   of this operation is a well-formed XML document. This should be the
   case if root element of the input resource is included by the XPath
   (even if a number of its descendant nodes are omitted by the XPath
   expression). It is also RECOMMENDED that nodes should not be omitted
   from the input if they affect the interpretation of the output nodes
   in the application context. The XPath expression author is responsible
   for this since the XPath expression author knows the application
   context.
   
    6.6.4 XSLT Transform
    
   Identifier:

Eastlake, Reagle, Solo					[Page 32]

Internet Draft		XML-Signature Syntax and Processing	February 2000


          http://www.w3.org/TR/1999/REC-xslt-19991116
          
   The Transform element contains a single parameter child element called
   XSLT, whose content MUST conform to the XSL Transforms [XSLT] language
   syntax. The processing rules for the XSLT transform are stated in the
   XSLT specification [XSLT].
   
7.0 XML Canonicalization and Syntax Constraint Considerations

   Digital signatures only work if the verification calculations are
   performed on exactly the same bits as the signing calculations. If the
   surface representation of the signed data can change between signing
   and verification, then some way to standardize the changeable aspect
   must be used before signing and verification. For example, even for
   simple ASCII text there are at least three widely used line ending
   sequences. If it is possible for signed text to be modified from one
   line ending convention to another between the time of signing and
   signature verification, then the line endings need to be canonicalized
   to a standard form before signing and verification or the signatures
   will break.
   
   XML is subject to surface representation changes and to processing
   which discards some surface information. For this reason, XML digital
   signatures have a provision for indicating canonicalization methods in
   the signature so that a verifier can use the same canonicalization as
   the signer.
   
   Throughout this specification we distinguish between the
   canonicalization of a Signature data object and other signed XML data
   objects. It is possible for an isolated XML document to be treated as
   if it were binary data so that no changes can occur. In that case, the
   digest of the document will not change and it need not be
   canonicalized if it is signed and verified as such. However, XML that
   is read and processed using standard XML parsing and processing
   techniques is frequently changed such that some of its surface
   representation information is lost or modified. In particular, this
   will occur in many cases for the Signature and enclosed SignedInfo
   elements since they, and possibly an encompassing XML document, will
   be processed as XML.
   
   Similarly, these considerations apply to Manifest, Object, and
   SignatureProperties elements if those elements have been digested,
   their DigestValue is to be checked, and they are being processed as
   XML.
   
   The kinds of changes in XML that may need to be canonicalized can be
   divided into three categories. There are those related to the basic
   [XML], as described in 7.1 below. There are those related to [DOM],
   [SAX], or similar processing as described in 7.2 below. And, third,
   there is the possibility of character set conversion, such as between
   UTF-8 and UTF-16, both of which all XML standards compliant processors
   are required to support. Any canonicalization algorithm should yield
   output in a specific fixed character set. For both the minimal

Eastlake, Reagle, Solo					[Page 33]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   canonicalization defined in this specification and the W3C Canonical
   XML [XML-c14n], that character set is UTF-8.
   
  7.1 XML 1.0, Syntax Constraints, and Canonicalization
  
   XML 1.0 [XML] defines an interface where a conformant application
   reading XML is given certain information from that XML and not other
   information. In particular,
    1. line endings are normalized to the single character #xA by
       dropping #xD characters if they are immediately followed by a #xA
       and replacing them with #xA in all other cases,
    2. missing attributes declared to have default values are provided to
       the application as if present with the default value,
    3. character references are replaced with the corresponding
       character,
    4. entity references are replaced with the corresponding declared
       entity,
    5. attribute values are normalized by
         A. replacing character and entity references as above,
         B. replacing occurrences of #x9, #xA, and #xD with #x20 (space)
            except that the sequence #xD#xA is replaced by a single
            space, and
         C. if the attribute is not declared to be CDATA, stripping all
            leading and trailing spaces and replacing all interior runs
            of spaces with a single space, and
    6. for elements declared to have element content, eliminate white
       space that appears within their content but not within the content
       of any enclosed element.
       
   Note that items (2), (4), (5C), and (6) depend on specific schema,
   DTD, or similar declarations. In the general case, such declarations
   will not be available to or used by the signature verifier. Thus, to
   interoperate between different XML implementations, the following
   syntax contraints MUST be observed when generating any signed material
   to be processed as XML, including the SignedInfo element:
    1. attributes having default values be explicitly present,
    2. all entity references (except "amp", "lt", "gt", "apos", and
       "quot" which are pre-defined) be expanded,
    3. attribute value white space be normalized, and
    4. insignificant white space not be generated within elements having
       element content.
       
  7.2 DOM/SAX Processing and Canonicalization
  
   In addition to the canonicalization and syntax constraints discussed
   above, many XML applications use the Document Object Model [DOM] or
   The Simple API for XML  [SAX]. DOM maps XML into a tree structure of
   nodes and typically assumes it will be used on an entire document with
   subsequent processing being done on this tree. SAX converts XML into a
   series of events such as a start tag, content, etc. In either case,
   many surface characteristics such as the ordering of attributes and
   insignificant white space within start/end tags is lost. In addition,
   namespace declarations are mapped over the nodes to which they apply,

Eastlake, Reagle, Solo					[Page 34]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   losing the namespace prefixes in the source text and, in most cases,
   losing where namespace declarations appeared in the original instance.
   
   If an XML Signature is to be produced or verified on a system using
   the DOM or SAX processing, a canonical method is needed to serialize
   the relevant part of a DOM tree or sequence of SAX events. XML
   canonicalization specifications, such as [XML-c14n], are based only on
   information which is preserved by DOM and SAX. For an XML Signature to
   be verifiable by an implementation using DOM or SAX, not only must the
   syntax constraints given in section 7.1 be followed but an appropriate
   XML canonicalization MUST be specified so that the verifier can
   re-serialize DOM/SAX mediated input into the same byte sequence that
   was signed.
   
8.0 Security Considerations

   The XML Signature specification provides a very flexible digital
   signature mechanism. Implementors must give consideration to their
   application threat models and to the following factors.
   
  8.1 Only What is Signed is Secure
  
   A requirement of this specification is to permit signatures to "apply
   to a part or totality of a XML document." (See section 3.1.3 of
   [XML-Signature-RD]) The Transforms mechanism meets this requirement by
   permitting one to sign data derived from processing the content of the
   identified resource. For instance, applications that wish to sign a
   form, but permit users to enter limited field data without
   invalidating a previous signature on the form might use XPath [XPath]
   to exclude those portions the user needs to change. Transforms may be
   arbitrarily specified and may include canonicalization instructions or
   even XSLT transformations. Of course, signatures over such a derived
   document do not secure any information discarded by the Transforms.
   
   Furthermore, core validation behavior does not confirm that the signed
   data was obtained by applying each step of the indicated transforms.
   (Though it does check that the digest of the resulting content matches
   that specified in the signature.)  For example, some application may
   be satisfied with verifying an XML signature over a cached copy of
   already transformed data. Other application might require that content
   be freshly dereferenced and transformed.
   
  8.2 Only What is "Seen" Should be Signed
  
   If signing is intended to convey the judgment or consent of an
   automated mechanism or person, then it is normally necessary to secure
   as exactly as practical the information that was presented to that
   mechanism or person. Note that this can be accomplished by literally
   signing what was presented, such as the screen images shown a user.
   However, this may result in data which is difficult for subsequent
   software to manipulate. Instead, one can sign the data along with
   whatever filters, style sheets, client profile or other information
   that affects its presentation.

Eastlake, Reagle, Solo					[Page 35]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   
   Also note that the use of Canonical  XML [XML-C14N] ensures that all
   internal entities and XML namespaces are expanded within the content
   being signed. All entities are replaced with their definitions and the
   canonical form explicitly represents the namespace that an element
   would otherwise inherit. Those application that do not canonicalize
   XML content (especially the SignedInfo element) SHOULD NOT use
   internal entities and SHOULD represent the name space explicitly
   within the content being signed since they can not rely upon
   canonicalization to do this for them.
   
  8.3 Check the Security Model
  
   This standard specifies public key signatures and keyed hash
   authentication codes. These have substantially different security
   models. Furthermore, it permits user specified algorithms which may
   have other models.
   
   With public key signatures, any number of parties can hold the public
   key and verify signatures while only the parties with the private key
   can create signatures. The number of holders of the private key should
   be minimized and preferably be one. Confidence by verifiers in the
   public key they are using and its binding to the entity or
   capabilities represented by the corresponding private key is an
   important issue, usually addressed by certificate or online authority
   systems.
   
   Keyed hash authentication codes, based on secret keys, are typically
   much more efficient in terms of the computational effort required but
   have the characteristic that all verifiers need to have possession of
   the same key as the signer. Thus any verifier can forge signatures.
   
   This standard permits user provided signature algorithms and keying
   information designators. Such user provided algorithms may have
   different security models. For example, methods involving biometrics
   usually depend on a physical characteristic of the authorized user
   that can not be changed the way public or secret keys can be and may
   have other security model differences.
   
  8.4 Algorithms, Key Lengths, Certificates, Etc.
  
   The strength of a particular signature depends on all links in the
   security chain. This includes the signature and digest algorithms
   used, the strength of the key generation [RANDOM] and the size of the
   key, the security of key and certificate authentication and
   distribution mechanisms, certificate chain validation policy,
   protection of cryptographic processing from hostile observation and
   tampering, etc.
   
   Care must be exercised by validaters in executing the various
   algorithms that may be specified in an XML signature and in the
   processing of any "executable content" that might be provided to such
   algorithms as parameters, such as XSLT transforms. The algorithms

Eastlake, Reagle, Solo					[Page 36]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   specified in this document will usually be implemented via a trusted
   library but even there perverse parameters might cause unacceptable
   processing or memory demand. Even more care may be warranted with
   application defined algorithms.
   
   The security of an overall system will also depend on the security and
   integrity of its operating procedures, its personnel, and on the
   administrative enforcement of those procedures. All the factors listed
   in this section are important to the overall security of a system;
   however, most are beyond the scope of this specification.
   
9.0 Schema, DTD, Data Model, and Valid Example

   XML Signature Schema Instance
          xmldsig-core-schema.xsd
          XML schema instance based on 19991207 Schema DTD [XML-Schema].
          
   XML Signature DTD
          xmldsig-core-schema.dtd
          
   RDF Data Model
          xmldsig-datamodel-20000112.gif
          
   XML Signature Example
          signature-example.xml
          Well formed XML that validates under the schema and DTD.
          
10.0 Definitions

   Authentication Code
          A value generated from the application of a shared key to a
          message via a cryptographic algorithm such that it has the
          properties of message authentication (integrity) but not signer
          authentication
          
   Authentication, Message
          "A signature should identify what is signed, making it
          impracticable to falsify or alter either the signed matter or
          the signature without detection." [Digital Signature
          Guidelines, ABA]
          
   Authentication, Signer
          "A signature should indicate who signed a document, message or
          record, and should be difficult for another person to produce
          without authorization." [Digital Signature Guidelines, ABA]
          
   Core
          The syntax and processing defined by this specification,
          including core validation. We use this term to distinguish
          other markup, processing, and applications semantics from our
          own.
          
   Data Object (Content/Document)

Eastlake, Reagle, Solo					[Page 37]

Internet Draft		XML-Signature Syntax and Processing	February 2000


          The actual binary/octet data being operated on (transformed,
          digested, or signed) by an application -- frequently an HTTP
          entity [HTTP]. Note that the proper noun Object designates a
          specific XML element. Occasionally we refer to a data object as
          a document or as a resource's content. The term element content
          is used to describe the data between XML start and end tags
          [XML]. The term XML document is used to describe data objects
          which conform to the XML specification [XML].
          
   Integrity
          The inability to change a message without also changing the
          signature value. See message authentication.
          
   Object
          An XML Signature element wherein arbitrary (non-core) data may
          be placed. An Object element is merely one type of digital data
          (or document) that can be signed via a Reference.
          
   Resource
          "A resource can be anything that has identity. Familiar
          examples include an electronic document, an image, a service
          (e.g., 'today's weather report for Los Angeles'), and a
          collection of other resources.... The resource is the
          conceptual mapping to an entity or set of entities, not
          necessarily the entity which corresponds to that mapping at any
          particular instance in time. Thus, a resource can remain
          constant even when its content---the entities to which it
          currently corresponds---changes over time, provided that the
          conceptual mapping is not changed in the process." [URI] In
          order to avoid a collision of the term entity within the URI
          and XML specifications, we use the term data object, content or
          document to refer to the actual bits being operated upon.
          
   Signature
          Formally speaking, a value generated from the application of a
          private key to a message via a cryptographic algorithm such
          that it has the properties of signer authentication and
          message authentication (integrity). (However, we sometimes use
          the term signature generically such that it encompasses
          Authentication Code values as well, but we are careful to make
          the distinction when the property of signer authentication is
          relevant to the exposition.) A signature may be
          (non-exclusively) described as detached, enveloping, or
          enveloped.
          
   Signature, Detached
          The signature is over content external to the Signature
          element, and can be identified via a URI, IDREF, or transform.
          Consequently, the signature is "detached" from the content it
          signs. This definition typically applies to separate data
          objects, but it also includes the instance where the Signature
          and data object reside within the same XML document but are
          sibling elements.

Eastlake, Reagle, Solo					[Page 38]

Internet Draft		XML-Signature Syntax and Processing	February 2000


          
   Signature, Enveloping
          The signature is over content found within an Object element of
          the signature itself. The Object(or its content) is identified
          via a Reference (via IDREF or transform).
          
   Signature, Enveloped
          The signature is over the XML content that contains the
          signature as an element. The content provides the root XML
          document element. Obviously, enveloped signatures must take
          care not to include their own value in the calculation of the
          SignatureValue.
          
   Transform
          The processing of a byte stream from source content to derived
          content. Typical transforms include XML Canonicalization,
          XPath, and XSLT.
          
   Validation, Core
          The core processing requirements of this specification
          requiring signature validation and SignedInfo reference
          validation.
          
   Validation, Reference
          The hash value of the identified and transformed content,
          specified by Reference, matches its specified DigestValue.
          
   Validation, Signature
          The SignatureValue matches the result of processing SignedInfo
          with  CanonicalizationMethod and SignatureMethod as specified
          in section 3.2.
          
   Validation, Trust/Application
          The application determines that the semantics associated with a
          signature are valid. For example, an application may validate
          the time stamps or the integrity of the signer key -- though
          this behavior is external to this core specification.
          
11.0 References

   ABA
          Digital Signature Guidelines.
          http://www.abanet.org/scitech/ec/isc/dsgfree.html
          
   Bourret
          Ron Bourret. Declaring Elements and Attributes in an XML DTD.
          http://www.informatik.tu-darmstadt.de/DVS1/staff/bourret/xml/xm
          ldtd.html
          
   DOM
          Document Object Model (DOM) Level 1 Specification.
          http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/
          

Eastlake, Reagle, Solo					[Page 39]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   DOMHASH
          Internet Draft. Digest Values for DOM (DOMHASH)
          http://www.ietf.org/internet-drafts/draft-ietf-trade-hiroshi-do
          m-hash-03.txt
          
   DSS
          FIPS PUB 186-1. Digital Signature Standard (DSS). U.S.
          Department of Commerce/National Institute of Standards and
          Technology.
          
   HMAC
          RFC 2104. HMAC: Keyed-Hashing for Message Authentication. H.
          Krawczyk, M. Bellare, R. Canetti.
          
   HTTP
          RFC 2616.Hypertext Transfer Protocol -- HTTP/1.1. J. Gettys, J.
          Mogul, H. Frystyk, L. Masinter, P. Leach, T. Berners-Lee.
          http://www.ietf.org/rfc/rfc2616.txt
          
   KEYWORDS
          RFC2119 -- Key words for use in RFCs to Indicate Requirement
          Levels.
          http://www.ietf.org/rfc/rfc2119.txt
          
   MD5
          RFC 1321. The MD5 Message-Digest Algorithm. R. Rivest..
          http://www.ietf.org/rfc/rfc1321.txt
          
   MIME
          RFC 2045. Multipurpose Internet Mail Extensions (MIME) Part
          One: Format of Internet Message Bodies. N. Freed & N.
          Borenstein..
          http://www.ietf.org/rfc/rfc2045.txt
          
   RANDOM
          RFC1750 -- Randomness Recommendations for Security.
          http://www.ietf.org/rfc/rfc1750.txt
          
   RDF
          RDF Schema W3C Proposed Recommendation
          http://www.w3.org/TR/1999/PR-rdf-schema-19990303/
          RDF Model and Syntax W3C Recommendation
          http://www.w3.org/TR/1999/REC-rdf-syntax-19990222
          
   PKCS1
          RFC 2437. PKCS #1: RSA Cryptography Specifications Version 2.0.
          B. Kaliski, J. Staddon.
          http://www.ietf.org/rfc/rfc2432.txt
          
   SAX
          David Megginson et. al. SAX: The Simple API for XML May 1998.
          http://www.megginson.com/SAX/index.html
          

Eastlake, Reagle, Solo					[Page 40]

Internet Draft		XML-Signature Syntax and Processing	February 2000


   SHA-1
          FIPS PUB 180-1. Secure Hash Standard. U.S. Department of
          Commerce/National Institute of Standards and Technology.
          http://csrc.nist.gov/fips/fip180-1.pdf
          
   URI
          RFC2396 - Uniform Resource Identifiers (URI): Generic Syntax
          http://www.ietf.org/rfc/rfc2396.txt
          
   URL
          RFC1738. Uniform Resource Locators (URL). Berners-Lee, T.,
          Masinter, L., and M. McCahill . December 1994.
          http://www.ietf.org/rfc/rfc1738.txt
          
   URN
          RFC 2141. URN Syntax. R. Moats..
          ftp://ftp.isi.edu/in-notes/rfc2141.txt
          RFC 2611. URN Namespace Definition Mechanisms. L. Daigle, D.
          van Gulik, R. Iannella, P. Falstrom..
          ftp://ftp.isi.edu/in-notes/rfc2611.txt
          
   XLink
          XML Linking Language
          http://www.w3.org/1999/07/WD-xlink-19990726
          
   XML
          Extensible Markup Language (XML) Recommendation.
          http://www.w3.org/TR/1998/REC-xml-19980210
          
   XML-c14n
          Canonical XML. W3C Working Draft
          http://www.w3.org/TR/1999/WD-xml-c14n-19991115
          
   XML-ns
          Namespaces in XML W3C Recommendation
          http://www.w3.org/TR/1999/REC-xml-names-19990114
          
   XPath
          XML Path Language (XPath)Version 1.0. W3C Proposed
          Recommendation
          http://www.w3.org/TR/1999/PR-xpath-19991008
          
   XPointer
          XML Pointer Language (XPointer). W3C Working Draft.
          http://www.w3.org/1999/07/WD-xptr-19990709
          
   XML-schema
          XML Schema Part 1: Structures W3C Working Draft
          http://www.w3.org/TR/1999/WD-xmlschema-1-19991217/
          XML Schema Part 2: Datatypes W3C Working Draft
          http://www.w3.org/TR/1999/WD-xmlschema-2-19991217/
          
   XML-Signature-RD

Eastlake, Reagle, Solo					[Page 41]

Internet Draft		XML-Signature Syntax and Processing	February 2000


          XML-Signature Requirements W3C Working Draft
          http://www.w3.org/1999/08/WD-xmldsig-requirements-990820
          
   XSL
          Extensible Stylesheet Language (XSL) W3C Working Draft
          http://www.w3.org/TR/2000/WD-xsl-20000112/
          
   XSLT
          XSL Transforms (XSLT) Version 1.0. W3C Proposed Recommendation
          http://www.w3.org/TR/1999/PR-xslt-19991008
          
   WebData
          Web Architecture: Describing and Exchanging Data.
          http://www.w3.org/1999/04/WebData
          
12. Authors' Address

   Donald E. Eastlake 3rd
   Motorola
   65 Shindegan Hill Road
   Carmel, NY 10512 USA
   Phone: 1-508-261-5434
   Email: dee3@torque.pothole.com
   
   Joseph M. Reagle Jr., W3C
   Massachusetts Institute of Technology
   Laboratory for Computer Science
   NE43-350, 545 Technology Square
   Cambridge, MA 02139
   Phone: 1.617.258.7621
   Email: reagle@w3.org
   
   David Solo
   Citigroup
   666 Fifth Ave, 3rd Floor
   NY, NY 10103 USA
   Phone: +1-212-830-8118
   Email: dsolo@alum.mit.edu















Eastlake, Reagle, Solo					[Page 42]

