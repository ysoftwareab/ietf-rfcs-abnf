<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Session Peering Provisioning Protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Session Peering Provisioning Protocol">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">DRINKS</td><td class="header">J-F. Mule</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">CableLabs</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">K. Cartwright</td></tr>
<tr><td class="header">Expires: January 13, 2011</td><td class="header">TNS</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">S. Ali</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">NeuStar</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">A. Mayrhofer</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">enum.at GmbH</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">July 12, 2010</td></tr>
</table></td></tr></table>
<h1><br />Session Peering Provisioning Protocol<br />draft-ietf-drinks-spprov-01</h1>

<h3>Abstract</h3>

<p>
				This document defines a protocol for provisioning session establishment data into Session Data Registries and SIP Service Provider data stores.  The provisioned data is typically used by various network elements for session peering. 
				
</p>
<p>
				This document describes the Session Peering Provisioning Protocol used by clients to provision registries.  The document provides a set of guiding principles for the design of this protocol including extensibility and independent transport definitions, a basic data model and an XML Schema Document.
				
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on January 13, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#introduction">1.</a>&nbsp;
Introduction<br />
<a href="#Terminology">2.</a>&nbsp;
Terminology<br />
<a href="#protocoldefinition">3.</a>&nbsp;
Protocol Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#protocoloverview">3.1.</a>&nbsp;
Protocol Overview and Layering<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#datamodel">3.2.</a>&nbsp;
Data Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#datamodelstructure">3.2.1.</a>&nbsp;
Structure of the SPPP Data Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DataModelObj">3.2.2.</a>&nbsp;
Data Model Objects and Attributes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DataModelLUF">3.2.3.</a>&nbsp;
Applicability for LUF-only Data Provisioning<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DataModelLRF">3.2.4.</a>&nbsp;
Applicability for LUF+LRF data Provisioning<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#commonparams">3.3.</a>&nbsp;
Common Attributes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#openisssues">3.4.</a>&nbsp;
Known Issues and Current Limitations of the Data Model<br />
<a href="#transportreq">4.</a>&nbsp;
Transport Protocol Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#transpconnreq">4.1.</a>&nbsp;
Connection Oriented<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#requestresponse">4.2.</a>&nbsp;
Request & Response Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#connectionlength">4.3.</a>&nbsp;
Connection Lifetime<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#authentication">4.4.</a>&nbsp;
Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#confidentiality">4.5.</a>&nbsp;
Confidentiality & Integrity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#timing">4.6.</a>&nbsp;
Near Real Time<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#respsizes">4.7.</a>&nbsp;
Request & Response Sizes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#reqorder">4.8.</a>&nbsp;
Request and Response Correlation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ack">4.9.</a>&nbsp;
Request Acknowledgement<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mandatorytransport">4.10.</a>&nbsp;
Mandatory
        Transport<br />
<a href="#xmlconsiderations">5.</a>&nbsp;
XML Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#namespaces">5.1.</a>&nbsp;
Namespaces<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#versioning">5.2.</a>&nbsp;
Versioning<br />
<a href="#Request and Reply Model">6.</a>&nbsp;
Request and Reply Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#request">6.1.</a>&nbsp;
Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#reply">6.2.</a>&nbsp;
Reply<br />
<a href="#resultcodes">7.</a>&nbsp;
Response Codes and Messages<br />
<a href="#protocolcommands">8.</a>&nbsp;
Protocol Commands<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#commanddetail">8.1.</a>&nbsp;
Add Route Group Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#getroutegrps">8.2.</a>&nbsp;
Get Route Groups Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#addrtegrp">8.3.</a>&nbsp;
Add Route Group Offers Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#accrtegrpoff">8.4.</a>&nbsp;
Accept Route Group Offers Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rejrtegrpoff">8.5.</a>&nbsp;
Reject Route Group Offers Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#getrtegrpoff">8.6.</a>&nbsp;
Get Route Group Offers Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PubIdsOper">8.7.</a>&nbsp;
Public Identifier Operations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#addPubIds">8.7.1.</a>&nbsp;
Add Public Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#getPubIds">8.7.2.</a>&nbsp;
Get Public Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#delPubIds">8.7.3.</a>&nbsp;
Delete Public Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#egressRteOper">8.8.</a>&nbsp;
Egress Route Operations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#addEgressRte">8.8.1.</a>&nbsp;
Add Egress Route<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#getEgressRte">8.8.2.</a>&nbsp;
Get Egress Route<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#delEgressRte">8.8.3.</a>&nbsp;
Delete Egress Route<br />
<a href="#securityconsiderations">9.</a>&nbsp;
Security Considerations<br />
<a href="#IANA">10.</a>&nbsp;
IANA Considerations<br />
<a href="#formalspecification">11.</a>&nbsp;
Formal Specification<br />
<a href="#specificationextensibility">12.</a>&nbsp;
Specification Extensibility<br />
<a href="#anchor1">13.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">14.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">14.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">14.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="introduction"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
		   Service providers and enterprises use registries to make call or session routing decisions for Voice over IP, SMS and MMS traffic exchanges. This document is narrowly focused on the provisioning protocol for these registries.  This protocol prescribes a way for an entity to provision session-related data into a registry. The data being provisioned can be optionally shared with other participating peering entities. The requirements and use cases driving this protocol have been documented in <a class='info' href='#I-D.ietf-drinks-usecases-requirements'>[I&#8209;D.ietf&#8209;drinks&#8209;usecases&#8209;requirements]<span> (</span><span class='info'>Channabasappa, S., &ldquo;DRINKS Use cases and Protocol Requirements,&rdquo; May&nbsp;2010.</span><span>)</span></a>.  The reader is expected to be familiar with the terminology defined in the previously mentioned document.
		   <br />
<br />

		   Three types of provisioning flows have been described in the use case document: client to registry provisioning, registry to local data repository and registry-to-registry. This document addresses a subset (client-to-registry provisioning) by defining a Session Peering Provisioning Protocol (SPPP) for provisioning Session Establishment Data (SED) into a Registry (arrow numbered one in the figure below).  While the other "provisioning flows" are shown below as separate message flows, no determination has been made for whether one common baseline protocol could be used for all three, or whether distinct protocols are required.
	   
</p>
<p>
		                <br /><hr class="insert" />
<a name="RegFlows"></a>
</p>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

                         *------------*               *------------*
(1). Provisioning SED    |            | (3).Registry  |            |
-----------------------&gt; |  Registry  |&lt;-------------&gt;|  Registry  |
     data into Registries|            |  to Registry  |            |
                         *------------*  exchanges    *------------*
                              /  \                          \
                             /    \                          \
                            /      \                          \
                           /        \                          v
                          /          \                         ...
                         /            \
                        / (2).         \
                       / Distributing   \
                      /      SED         \
                     V                    V
                    +----------+       +----------+
                    |Local Data|       |Local Data|
                    |Repository|       |Repository|
                    +----------+       +----------+

</pre></div><p>

<p style='text-align: center'>
							Three Registry Provisioning Flows 
						
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

		

<p>
			The data provisioned for session establishment is typically used by various downstream SIP signaling systems to route a call to the next hop associated with the called domain.  These systems typically use a  local data store ("Local Data Repository") as their source of session routing information. More specifically, the SED data is the set of parameters that the outgoing signaling path border elements (SBEs) need to initiate the session.  See <a class='info' href='#RFC5486'>[RFC5486]<span> (</span><span class='info'>Malas, D. and D. Meyer, &ldquo;Session Peering for Multimedia Interconnect (SPEERMINT) Terminology,&rdquo; March&nbsp;2009.</span><span>)</span></a> for more details. 
			<br />
<br />

			A "terminating" SIP Service Provider (SSP) provisions SED into the registry to be selectively shared with other peer SSPs. Subsequently, a Registry may distribute the provisioned data into local Data Repositories used for look-up queries (identifier -> URI) or for lookup and location resolution (identifier -> URI -> ingress SBE of terminating SSP).  In some cases, the Registry may additionally offer a central query resolution service (not shown in the above figure).
		
</p>
<p>
			A key requirement for the SPPP protocol is to be able to accommodate two basic deployment scenarios:
            </p>
<ol class="text">
<li>
				   A Look-Up Function (LUF) to determine the target domain to assist in call routing (as described in <a class='info' href='#RFC5486'>[RFC5486]<span> (</span><span class='info'>Malas, D. and D. Meyer, &ldquo;Session Peering for Multimedia Interconnect (SPEERMINT) Terminology,&rdquo; March&nbsp;2009.</span><span>)</span></a>).  In this case, the querying entity may use other means to perform the Location Routing Function (LRF) which in turn helps determine the actual location of the Signaling Function in that domain.
				
</li>
<li>
				   Both Look-Up function (LUF) and Location Routing Function (LRF) to locate the SED data fully.
				
</li>
</ol><p>
		
</p>
<p>
			In terms of protocol design, SPPP protocol is agnostic to the transport.  This document includes the description of the data model and the means to enable protocol operations within a request and response structure. To encourage interoperability, the protocol supports extensibility aspects.
		
</p>
<p>
		   Transport requirements are provided in this document to help with the selection of the optimum transport mechanism. (<a class='info' href='#I-D.ietf-drinks-sppp-over-soap'>[I&#8209;D.ietf&#8209;drinks&#8209;sppp&#8209;over&#8209;soap]<span> (</span><span class='info'>Cartwright, K., &ldquo;SPPP Over SOAP and HTTP,&rdquo; June&nbsp;2010.</span><span>)</span></a>) identifies a SOAP transport mechanism for SPPP.
		
</p>
<p>
   This document is organized as follows:
		</p>
<ul class="text">
<li>
				<a class='info' href='#protocoldefinition'>Section&nbsp;3<span> (</span><span class='info'>Protocol Definition</span><span>)</span></a> provides an overview of the SPPP protocol, including the layering approach, functional entities and data model;
			
</li>
<li>        
				<a class='info' href='#transportreq'>Section&nbsp;4<span> (</span><span class='info'>Transport Protocol Requirements</span><span>)</span></a> defines requirements for SPPP transport protocols;
			
</li>
<li>        
				<a class='info' href='#xmlconsiderations'>Section&nbsp;5<span> (</span><span class='info'>XML Considerations</span><span>)</span></a> defines XML considerations that XML parsers must meet to conform to this specification.
			
</li>
<li>
				 <a class='info' href='#Request and Reply Model'>Section&nbsp;6<span> (</span><span class='info'>Request and Reply Model</span><span>)</span></a> describes the protocol request-reply model;
			
</li>
<li> 
				<a class='info' href='#protocolcommands'>Section&nbsp;8<span> (</span><span class='info'>Protocol Commands</span><span>)</span></a> defines the protocol commands for this version of SPPP, and how to extend them;
			
</li>
</ul><p>

		
</p>
<a name="Terminology"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>
                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in  <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.  
                
</p>
<p>
					This document reuses terms from <a class='info' href='#RFC3261'>[RFC3261]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;SIP: Session Initiation Protocol,&rdquo; June&nbsp;2002.</span><span>)</span></a>,  <a class='info' href='#RFC5486'>[RFC5486]<span> (</span><span class='info'>Malas, D. and D. Meyer, &ldquo;Session Peering for Multimedia Interconnect (SPEERMINT) Terminology,&rdquo; March&nbsp;2009.</span><span>)</span></a>, use cases and requirements documented in <a class='info' href='#I-D.ietf-drinks-usecases-requirements'>[I&#8209;D.ietf&#8209;drinks&#8209;usecases&#8209;requirements]<span> (</span><span class='info'>Channabasappa, S., &ldquo;DRINKS Use cases and Protocol Requirements,&rdquo; May&nbsp;2010.</span><span>)</span></a> and the ENUM Validation Architecture <a class='info' href='#RFC4725'>[RFC4725]<span> (</span><span class='info'>Mayrhofer, A. and B. Hoeneisen, &ldquo;ENUM Validation Architecture,&rdquo; November&nbsp;2006.</span><span>)</span></a>.
				
</p>
<p>
					 In addition, this document specifies the following additional terms:
                <br />
<br />

                
                </p>
<blockquote class="text"><dl>
<dt>SPPP: </dt>
<dd>
							Session Peering Provisioning Protocol, the protocol used to provision data into a Registry (see arrow labeled "1." in Figure 1 of <a class='info' href='#I-D.ietf-drinks-usecases-requirements'>[I&#8209;D.ietf&#8209;drinks&#8209;usecases&#8209;requirements]<span> (</span><span class='info'>Channabasappa, S., &ldquo;DRINKS Use cases and Protocol Requirements,&rdquo; May&nbsp;2010.</span><span>)</span></a>).  It is the primary scope of this document.
							<br />

                        
</dd>
<dt>SPDP: </dt>
<dd>
							Session Peering Distribution Protocol, the protocol used to distribute data to Local Data Repository (see arrow labeled "2." in Figure 1 of <a class='info' href='#I-D.ietf-drinks-usecases-requirements'>[I&#8209;D.ietf&#8209;drinks&#8209;usecases&#8209;requirements]<span> (</span><span class='info'>Channabasappa, S., &ldquo;DRINKS Use cases and Protocol Requirements,&rdquo; May&nbsp;2010.</span><span>)</span></a>).
							<br />

                        
</dd>
<dt>Client: </dt>
<dd>
							An application that supports an SPPP Client; it is sometimes referred to as a "Registry Client".
							<br />

                        
</dd>
<dt>Registry: </dt>
<dd>
							The Registry operates a master database of Session Establishment Data for one or more Registrants.
							<br />

							A Registry acts as an SPPP Server. 
							<br />
<br />

                        
</dd>
<dt>Registrant: </dt>
<dd>
							In this document, we extend the definition of a Registrant based on <a class='info' href='#RFC4725'>[RFC4725]<span> (</span><span class='info'>Mayrhofer, A. and B. Hoeneisen, &ldquo;ENUM Validation Architecture,&rdquo; November&nbsp;2006.</span><span>)</span></a>.  The Registrant is the end-user, the person or organization who is the "holder" of the Session Establishment Data being provisioned into the Registry.  For example, in <a class='info' href='#I-D.ietf-drinks-usecases-requirements'>[I&#8209;D.ietf&#8209;drinks&#8209;usecases&#8209;requirements]<span> (</span><span class='info'>Channabasappa, S., &ldquo;DRINKS Use cases and Protocol Requirements,&rdquo; May&nbsp;2010.</span><span>)</span></a>, a Registrant is pictured as a SIP Service Provider in Figure 2.
							<br />

							A Registrant is identified by its name in the data model.
							<br />
<br />

                        
</dd>
<dt>Registrar: </dt>
<dd>
							In this document, we also extend the definition of a Registrar from <a class='info' href='#RFC4725'>[RFC4725]<span> (</span><span class='info'>Mayrhofer, A. and B. Hoeneisen, &ldquo;ENUM Validation Architecture,&rdquo; November&nbsp;2006.</span><span>)</span></a>.  A Registrar performs provisioning operations on behalf of a Registrant by interacting with the Registry, in our case via the SPPP protocol defined in this document.
							<br />

							A Registrar is identified by its name in the data model.
                        
</dd>
</dl></blockquote><p>

                 
</p>
<a name="protocoldefinition"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Protocol Definition</h3>

<p>
                        This section introduces the structure of the data model and provides the information framework for the SPPP protocol.  An overview of the protocol operations is first provided with a typical deployment scenario.  The data model is then defined along with all the objects manipulated by the protocol and their relationships.
                
</p>
<a name="protocoloverview"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Protocol Overview and Layering</h3>

<p>
                   SPPP is a simple request/reply protocol that allows a client application to submit provisioning data and query requests to a server.  The SPPP data structures are designed to be protocol agnostic. Concerns regarding encryption, non-repudiation, and authentication are beyond the scope of this document. For more details, please refer to the Transport Protocol Requirements section.
                
</p><br /><hr class="insert" />
<a name="SPPP_layering"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

          Layer                      Example
     +-------------+      +-----------------------------+
 (5) |Data Objects |      |      RteGrpType, etc.       |
     +-------------+      +-----------------------------+
           |                           |
     +-------------+      +-----------------------------+
 (4) | Operations  |      |    addRteGrpsRqst, etc.     |
     +-------------+      +-----------------------------+
           |                           |
     +-------------+      +-----------------------------+
 (3) |   Message   |      | spppRequest, spppResponse   |
     +-------------+      +-----------------------------+
           |                           |
     +-------------+      +-----------------------------+
 (2) |   Message   |      |   HTTP, SOAP, None, etc.    |
     |   Envelope  |      |                             |
     +-------------+      +-----------------------------+
           |                           |
     +-------------+      +-----------------------------+
 (1) |  Transport  |      |    TCP, TLS, BEEP, etc.     |
     |   Protocol  |      |                             |
     +-------------+      +-----------------------------+

</pre></div>
<p style='text-align: center'>
							SPPP Layering
						
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
                        SPPP can be viewed as a set of layers that collectively define the structure of an SPPP request and response.  Layers 1 and 2, as detailed below, are left to separate specifications to allow for potentially multiple SPPP transport, envelope, and authentication technologies. This document defines layers 3, 4, and 5 below.
                
</p>
<p>
                         </p>
<ol class="text">
<li>
                                   The transport protocol layer provides a communication mechanism between the client and server.  SPPP can be layered over any transport protocol that provides a set of basic requirements defined in the Transport Protocol Requirements section.
                                
</li>
<li>
                                        The message envelope layer is optional, but can provide features that are above the transport technology layer but below the application messaging layer.  Technologies such as HTTP and SOAP are examples of messaging envelope technologies.
                                
</li>
<li>
                                        The message layer provides a simple, envelope-independent and transport-independent, SPPP wrapper for SPPP request and response messages.
                                
</li>
<li>
                                        The operation layer defines the set of base SPPP actions that can be invoked using an SPPP message. Operations are encoded using XML encoded actions and objects.
                                
</li>
<li>
                                        The data object layer defines the base set of SPPP data objects that can be included in update operations or returned in operation responses.
                                
</li>
</ol><p>
                
</p>
<a name="datamodel"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Data Model</h3>

<p>
					The data model illustrated and described in <a class='info' href='#SPPP_datamodel'>Figure&nbsp;3</a> defines the logical objects and the relationships between these objects that the SPPP protocol supports.  SPPP defines the protocol operations through which an SPPP Client populates a Registry with these logical objects.  Various clients belonging to different Registrants and distinct Registrars may use the protocol for populating the Registry's data.  
                
</p>
<a name="datamodelstructure"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
Structure of the SPPP Data Model</h3>

<p>
					The logical structure presented below is consistent with the terminology and requirements defined in <a class='info' href='#I-D.ietf-drinks-usecases-requirements'>[I&#8209;D.ietf&#8209;drinks&#8209;usecases&#8209;requirements]<span> (</span><span class='info'>Channabasappa, S., &ldquo;DRINKS Use cases and Protocol Requirements,&rdquo; May&nbsp;2010.</span><span>)</span></a>.  Note that the current version of this data model does not yet address the notion of Data Recipient Groups (left for a future revision of this document).
				
</p><br /><hr class="insert" />
<a name="SPPP_datamodel"></a>

<p style='text-align: center'>

        
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+-------------+      +------------------+
| all object  |      |Organization:     |
| types       |      |orgId,            |
+------+------+      |orgName,          |
       +------------&gt;|                  |
                     |extension         |
 All objects are     |                  |
 associated with 2   |                  |
 Organizations to    +------------------+
 identify the            ^
 registrant and          |A Route Group is
 the registrar           |associated with
                         |zero or more
                         |Organizations
                         |
                +--------+--------------+
                |Route Group:           |        +-----[abstract]-+
                |  rantId*,             |        |                |
                |  rarId,               |        |                |
                |  rteGrpName*,         |        | Route Record:  |
                |  dgName*,             +-------&gt;|  priority,     |
                |  isInSvc,             |        |  extension     |
                |  rteRec*,             |        |                |
                |  peeringOrg,          |        +----------------+
                |  sourceIdent,         |            ^
                |  extension            |            |Various types
                +-----------------------+            |of Route
                      ^                              |Records...
                      |                       +------+------------...
                      |                       |        |         |
                      |                     +----+  +-------+ +----+
                      |                     | URI|  | NAPTR | | NS |
     +----------------+-----+               +----+  +-------+ +----+
     |Destination           |
     |Group:                |     +----------[abstract]-+
     |  rantId*,            |     |Public               |
     |  rarId,              |     |Identifier:          |
     |  dgName*,            |     |  rantId*,           |
     |  extension           |&lt;----+  rarId,             |
     +----------------------+     |  publicIdentifier*, |
                                  |  dgName*,           |
                                  |  extension          |
                                  +---------------------+
                                             ^
                                             |Various types
                                             |of Public
                                             |Identifiers...
                                  +------+------------...
                                  |        |      |
                               +-----+  +----+ +-----+
                               |Email|  | TN | | TNR |
                               +-----+  +----+ +-----+ ...





</pre></div>
<p style='text-align: center'>
                SPPP Data Model
        
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
					Note that the attributes whose names end with the character * are mandatory attributes.
                
</p>
<a name="DataModelObj"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
Data Model Objects and Attributes</h3>

<p>
            The objects and attributes that comprise the data model can be described as follows (objects listed from the bottom up):

            </p>
<ul class="text">
<li> Public Identifier (publicIdentifier):
					<br />

					A public identifier is a well known attribute that is often used to perform lookup functions. For the purposes of this document, a Public Identifier can be an email address, a telephone number, a range of telephone numbers or a PSTN Routing Number (RN). 
					<br />
<br />

					A Destination Group may be associated with a Public Identifier to create a logical grouping and share a common set of Routes. 
					<br />
<br />

					A Public Identifier may optionally be associated with zero or more individual route records. This ability for a Public Identifier to be directly associated with a set of routes (e.g. target URI), as opposed to being associated with a Destination Group, supports the use cases where the target URI contains data specifically tailored to an individual Public Identifier.
                
</li>
<li> Telephone Number Range (TNRType, tn, endTn):
					<br />

					A public identifier may represent an inclusive range of telephone numbers. The TN range is defined by the first and last telephone number of the inclusive range. For example, a TN range of (tn=12125550000, endTn=12125560000) means all the TNs from 12125550000 to 12125560000 are included.
                
</li>
<li> Destination Group (dgName):
					<br />

					A collection of zero or more Public Identifiers that are related to one or more Route Group relationships. 
                
</li>
<li> Route Group (rteGrpName):
                	<br />

					A Route Group contains a set of route records (RteRecs) that are associated with Public Identifiers. To support the use cases defined in <a class='info' href='#I-D.ietf-drinks-usecases-requirements'>[I&#8209;D.ietf&#8209;drinks&#8209;usecases&#8209;requirements]<span> (</span><span class='info'>Channabasappa, S., &ldquo;DRINKS Use cases and Protocol Requirements,&rdquo; May&nbsp;2010.</span><span>)</span></a>, this document defines the following types of RteRecs: NAPTRType, NSType, and URIType. To support the Look-Up Function resolution, it is assumed that the administrative domain will be defined as a URI and it can be expressed as a URIType or a NAPTRType.
					<br />

					A Route Group can be either in or out of service (as indicated by 'isInService' attribute).  It also contains a list of organizations that can query the object (peeringOrg) and have access to its content (sourceIdent).
                
</li>
<li> Source Identity (SourceIdentType, sourceIdentLabels, sourceIdentScheme):
                	<br />

					In some scenarios, it is important to identify the source of a query.  The source identity label is a character string that identifies the source of a resolution lookup and can be used for source-based routing.  We define several ways of identifying the source: by IP address, by the source URI or a domain name. 
                
</li>
<li> Route Record (RteRecType):
					<br />

					A Route Record is the data that the resolution systems return in response to a successful query with the Public Identifier as the query string. It is associated with a Route Group for routes that are not specific to a Public Identifier.
					<br />

					To support the use cases defined in <a class='info' href='#I-D.ietf-drinks-usecases-requirements'>[I&#8209;D.ietf&#8209;drinks&#8209;usecases&#8209;requirements]<span> (</span><span class='info'>Channabasappa, S., &ldquo;DRINKS Use cases and Protocol Requirements,&rdquo; May&nbsp;2010.</span><span>)</span></a>, SPPP protocol defines three type of Route Records: URIType, NAPTRType, and NSType. These Route Records extend the abstract type RteRecType and inherit the common attribute 'priority' that is meant for setting precedence across the route records defined within a Route Group in a protocol agnostic fashion.
                
</li>
<li>
					Organization (OrgIdType):
					<br />

					An Organization represents an entity that is authorized to access given data elements. All objects are associated with two organizations to identify the registrant and the registrar.  An entity authorized to view a Route Group (typically a SSP peering partner) is identified a peering Organization (peeringOrg). 
                
</li>
</ul><p>

                
</p>
<a name="DataModelLUF"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.3"></a><h3>3.2.3.&nbsp;
Applicability for LUF-only Data Provisioning</h3>

<p>
                		This section describes the data model for SPPP clients that only provision data for LUF resolution.                		
                	
</p>
<p>
                		The purpose of LUF data provisioning is to provide the administrative domain given a destination group.  As such, a client provisioning LUF-only data only needs to provide one or more route groups that contain a route group name and a URI for the target domain.
                	
</p>
<p>
                		Note that source-based routing is supported: depending on what entity requests the look-up resolution (sourceIdent), a different URI may be returned by using different Route Groups.
                	
</p>
<p>
                	Certain protocol operations could be added in future revisions of this document as "short-cuts" for LUF related data provisioning.
                	
</p><br /><hr class="insert" />
<a name="SPPP_datamodelLUF"></a>

<p style='text-align: center'>

        
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
              +-----------------------+
              |Route Group:           |
              |  rteGrpName*,         |
              |  isInService,         |
              |  URI    ,             |
              |  extension            |
              |                       |
              +-----------------------+
                         ^
                         |
               +---------+------------+
               |Destination           |
               |Group:                |
               |  dgName*,            |&lt;----+
               |  extension           |     |
               +----------------------+     |
                                            |
                              +-------------+---------+
                              |Public                 |
                              |Identifier:            |
                              |  publicIdentifier*,   |
                              |  dgName*,             |
                              |  extension            |
                              +-----------------------+
</pre></div>
<p style='text-align: center'>
                LUF-only Data Model Example for SPPP
        
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
			As an example, a request to add a route group where public identifiers resolve into the URI sip:ssp1.example.com during look-up resolution would be:
			
</p><br /><hr class="insert" />
<a name="SPPP_datamodelexamLUF"></a>

<p style='text-align: center'>

        
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;addRteGrpsRqst
       xmlns="urn:ietf:params:xml:ns:sppp:base:1"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
        &lt;clientTransId&gt;id-12317123&lt;/clientTransId&gt;
        &lt;minorVer&gt;20&lt;/minorVer&gt;
        &lt;rteGrp&gt;
            &lt;base&gt;
                &lt;rantId&gt;registrantID123&lt;/rantId&gt;
                &lt;rarId&gt;registrarId0&lt;/rarId&gt;
            &lt;/base&gt;
            &lt;rteGrpName&gt;route_grp_1&lt;/rteGrpName&gt;
            &lt;rteRec xsi:type="URIType"&gt;
                &lt;ere&gt;^(.*)$&lt;/ere&gt;
                &lt;uri&gt;urn:ssp1.example.com&lt;/uri&gt;
            &lt;/rteRec&gt;
            &lt;isInSvc&gt;true&lt;/isInSvc&gt;
        &lt;/rteGrp&gt;
&lt;/addRteGrpsRqst&gt;

</pre></div>
<p style='text-align: center'>
                
        
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="DataModelLRF"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.4"></a><h3>3.2.4.&nbsp;
Applicability for LUF+LRF data Provisioning</h3>

<p>
                		This section provides a read-out of the data model for SPPP clients that provision data for both LUF and LRF resolution.                		
                	
</p>
<p>
                		The purpose of LUF+LRF data provisioning is to provide a URI given a destination group as well as the location routing for that target domain.  As such, a client provisioning LUF+LRF data provides one or more route groups that contain a route group name and a URI for the target domain and each route group is associated with a Route Record which can be in the form of a URI, NAPTR or NS resource record.
                	
</p><br /><hr class="insert" />
<a name="SPPP_datamodelLUFLRF"></a>

<p style='text-align: center'>

        
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
              +-----------------------+
              |Route Group:           |        +-----[abstract]-+
              |  rteGrpName*,         |        |                |
              |  isInSvc,             |        | Route Record:  |
              |  rteRec,              +-------&gt;|  NAPTR         |
              |  extension            |        |  priority,     |
              |                       |        |  extension     |
              +-----------------------+        |                |
                         ^                     +----------------+
                         |
               +---------+------------+
               |Destination           |
               |Group:                |
               |  dgName*,            |&lt;----+
               |  extension           |     |
               +----------------------+     |
                                            |
                              +-------------+-[abstract]-+
                              |Public                    |
                              |Identifier:               |
                              |  publicIdentifier*,      |
                              |  dgName*,                |
                              |  extension               |
                              +--------------------------+

</pre></div>
<p style='text-align: center'>
                LUF+LRF Data Model Example for SPPP
        
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
			As an example, a request to add a route group where public identifiers resolve into the URI ssp1.example.com and NAPTR associated with that domain based on the source Organization would be:
			
</p><br /><hr class="insert" />
<a name="SPPP_datamodelexamLUFLRF"></a>

<p style='text-align: center'>

        
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;addRteGrpsRqst xmlns="urn:ietf:params:xml:ns:sppp:base:1"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
        &lt;clientTransId&gt;id-12317123&lt;/clientTransId&gt;
        &lt;minorVer&gt;20&lt;/minorVer&gt;
        &lt;rteGrp&gt;
            &lt;base&gt;
                &lt;rantId&gt;registrantID123&lt;/rantId&gt;
                &lt;rarId&gt;registrarId0&lt;/rarId&gt;
            &lt;/base&gt;
            &lt;rteGrpName&gt;route_grp_1&lt;/rteGrpName&gt;
            &lt;isInSvc&gt;true&lt;/isInSvc&gt;
            &lt;rteRec xsi:type="URIType"&gt;
                &lt;ere&gt;^(.*)$&lt;/ere&gt;
                &lt;uri&gt;urn:ssp1.example.com&lt;/uri&gt;
            &lt;/rteRec&gt;
            &lt;isInSvc&gt;true&lt;/isInSvc&gt;
        &lt;/rteGrp&gt;
&lt;/addRteGrpsRqst&gt;

</pre></div>
<p style='text-align: center'>
                
        
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="commonparams"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Common Attributes</h3>

<p>
					This section defines common object attributes.  The protocol exchanges and operations in SPPP take various parameters.  Some of these are common to several objects.  
					
</p>
<p>
					Two organization roles have been identified in the use cases and in this protocol.  A registrant is the organization or business entity that "owns" the object while a registrar is an entity that can provision an object.
					
</p>
<a name="openisssues"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Known Issues and Current Limitations of the Data Model</h3>

<p>
						The data model described in <a class='info' href='#SPPP_datamodel'>Figure&nbsp;3</a>  does not yet address all of the requirements and use cases defined in <a class='info' href='#I-D.ietf-drinks-usecases-requirements'>[I&#8209;D.ietf&#8209;drinks&#8209;usecases&#8209;requirements]<span> (</span><span class='info'>Channabasappa, S., &ldquo;DRINKS Use cases and Protocol Requirements,&rdquo; May&nbsp;2010.</span><span>)</span></a>.
						
</p>
<p>
						This section will list known protocol issues to be addressed in future revisions.
                        
</p>
<a name="transportreq"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Transport Protocol Requirements</h3>

<p>
                          This section provides requirements for transport protocols
        suitable for SPPP. More specifically, this section specifies the
        services, features, and assumptions that SPPP delegates to the chosen
        transport and envelope technologies.
          
</p>
<p>
                Two different groups of use cases are specified in <a class='info' href='#I-D.ietf-drinks-usecases-requirements'>[I&#8209;D.ietf&#8209;drinks&#8209;usecases&#8209;requirements]<span> (</span><span class='info'>Channabasappa, S., &ldquo;DRINKS Use cases and Protocol Requirements,&rdquo; May&nbsp;2010.</span><span>)</span></a>. One group of use cases
        describes the provisioning of data by a client into a Registry (Section
        3.1 of the above referenced document), while the other group describes
        the distribution of data into local data repositories (Section 3.2).
        The current version of this document focuses on the first set of use
        cases (client to registry provisioning).
                                        <br />
<br />

                                        These use cases may involve the provisioning of very
        small data sets like the modification or update of a single public
        identifier.  Other provisioning operations may deal with huge datasets
        like the "download" of a whole local number portability database to a
        Registry.
                                        <br />
<br />

		As a result, a transport protocol for SPPP must be very
        flexible and accommodate various sizes of data set sizes.
          
</p>
<p>
			 For the reasons outlined above, it is conceivable that        provisioning and distributing may use different transport protocols. This document focuses on the provisioning protocol.
          
</p>
<p>A few topics remain open for discussion:
                </p>
<ul class="text">
<li>The ability to establish multiple connections between a client and server may be desirable.  If so, we may want to specify the relation of transactions between the various connections.
</li>
<li>Pipelining of requests is required at the SPPP protocol layer.  It may have impacts at the transport level that need to be outlined.
</li>
<li>Scope: the current scope of this effort is based upon having a connection oriented transport.  Is there any need to support a transport protocol with asynchronous operation?

</li>
<li>If it is required that responses arrive in the order of the
        requests, this must be specified clearly.
</li>
</ul><p>
          
</p>
<a name="transpconnreq"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Connection Oriented</h3>

<p>
                                        The SPPP protocol follows a model where a Client
        establishes a connection to a Server in order to further exchange
        provisioning transactions over such point-to-point connection. A
        transport protocol for SPPP MUST therefore be connection oriented.
                
</p>
<p>
                                        Note that the role of the "Client" and the "Server" only
        applies to     the connection, and those roles are not related in any
        way to the     type of entity that participates in a protocol exchange.
        For     example, a Registry might also include a "Client" when     such
        a Registry initiates a connection (for example, for data distribution to
        SSP).
                
</p>
<a name="requestresponse"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Request & Response Model</h3>

<p>
					Provisioning operations in SPPP follow the request -
					response model, where a transaction is initiated by a Client using a	Request command, and the Server responds to the Client by means of a Response.
					<br />
<br />

					Multiple subsequent request-response exchanges MAY be        performed over a single connection.
				
</p>
<p>
					Therefore, a transport protocol for SPPP MUST follow the        request-response model by allowing a response to be sent to the request initiator.
</p>
<a name="connectionlength"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Connection Lifetime</h3>

<p>
                        Some use cases involve provisioning a single request
        to a network element - connections supporting such provisioning requests
        might be short-lived, and only established on demand.
                
</p>
<p>
                        Other use cases involve either provisioning a huge set
        of data, or a constant stream of small updates, which would require
        long-lived connections.
                
</p>
<p>
                        Therefore, a protocol suitable for SPPP SHOULD support short lived as well
        as long lived connections.
                
</p>
<a name="authentication"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Authentication</h3>

<p>
        Many use cases require the Server to
        authenticate the Client, and potentially also the Client to authenticate
        the Server. While authentication of the Server by the Client is expected
        to be used only to prevent impersonation of the Server, authentication
        of the Client by the Server is expected to be used to identify and
        further authorize the Client to certain resources on the Server.
                
</p>
<p>
                Therefore, an SPPP transport protocol MUST provide means for a Server to authenticate and authorize a Client, and MAY provide means for Clients to authenticate a Server.
                
</p>
<p>
				However, SPPP transport SHOULD also allow for
				unauthenticated     connections.
				
</p>
<a name="confidentiality"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Confidentiality & Integrity</h3>

<p>
					Data that is transported over the protocol is deemed confidential. Therefore, a transport protocol suitable for SPPP MUST ensure confidentiality and integrity protection by providing encryption capabilities.
				
</p>
<p>
					Additionally, a DRINKS protocol MUST NOT use an unreliable        lower-layer transport protocol that does not provide confidentiality and integrity protection.
                        
</p>
<a name="timing"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Near Real Time</h3>

<p>
					Many use cases require near real-time responses from the Server. Therefore, a DRINKS transport protocol MUST support near-real-time response to requests submitted by the Client.
                
</p>
<a name="respsizes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.7"></a><h3>4.7.&nbsp;
Request & Response Sizes</h3>

<p>
					SPPP covers a range of use cases - from cases where        provisioning a single public identifier will create very small request and response sizes to cases where millions of data records are submitted or retrieved in one transaction. Therefore, a transport protocol suitable for SPPP MUST support a great variety of request and response sizes.
				
</p>
<p>
					A transport protocol MAY allow splitting large chunks of data into several smaller chunks.
                
</p>
<a name="reqorder"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.8"></a><h3>4.8.&nbsp;
Request and Response Correlation</h3>

<p>
					A transport protocol suitable for SPPP MUST allow responses to be correlated with requests.
                
</p>
<a name="ack"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.9"></a><h3>4.9.&nbsp;
Request Acknowledgement</h3>

<p>
					Data transported in the SPPP protocol is likely crucial for the operation of the communication network that is being provisioned.
					<br />
<br />

					Failed transactions can lead to situations where a subset of public identifiers (or even SSPs) might not be reachable, or situations where the provisioning state of the network is inconsistent.
                
</p>
<p>
                	Therefore, a transport protocol for SPPP MUST provide a Response for each Request, so that a Client can identify whether a Request succeeded or failed.
                
</p>
<a name="mandatorytransport"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.10"></a><h3>4.10.&nbsp;
Mandatory
        Transport</h3>

<p>
							As of this writing of this revision, one transport protocol proposal has been provided in <a class='info' href='#I-D.ietf-drinks-sppp-over-soap'>[I&#8209;D.ietf&#8209;drinks&#8209;sppp&#8209;over&#8209;soap]<span> (</span><span class='info'>Cartwright, K., &ldquo;SPPP Over SOAP and HTTP,&rdquo; June&nbsp;2010.</span><span>)</span></a>. 
							<br />
<br />

							This section will define a mandatory transport protocol to be compliant with this RFC.
							
</p>
<a name="xmlconsiderations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
XML Considerations</h3>

<p>
                        XML serves as the encoding format for SPPP, allowing complex hierarchical data to be expressed in a text format that can be read, saved, and manipulated with both traditional text tools and tools specific to XML. 
                        <br />
<br />

                        XML is case sensitive. Unless stated otherwise, XML specifications and examples provided in this document MUST be interpreted in the character case presented to develop a conforming implementation.
                        <br />
<br />
                        
                        This section discusses a small number of XML-related considerations pertaining to SPPP.
                
</p>
<a name="namespaces"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Namespaces</h3>

<p>
                                        All SPPP protocol elements are defined in the following namespace: 
                                        <br />

                                        urn:ietf:params:xml:ns:sppp:base:1
                                
</p>
<p>
                                        Namespace and schema definitions are used to identify both the base protocol schema and the schemas for managed objects.
                                
</p>
<a name="versioning"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Versioning</h3>

<p>
                                        All XML instances SHOULD begin with an  &lt;?xml?&gt;  declaration to identify the version of XML that is being used, optionally identify use of the character encoding used, and optionally provide a hint to an XML parser that an external schema file is needed to validate the XML instance.
                                        <br />
<br />

                                        Conformant XML parsers recognize both UTF-8 (defined in <a class='info' href='#RFC3629'>[RFC3629]<span> (</span><span class='info'>Yergeau, F., &ldquo;UTF-8, a transformation format of ISO 10646,&rdquo; November&nbsp;2003.</span><span>)</span></a>) and UTF-16 (defined in <a class='info' href='#RFC2781'>[RFC2781]<span> (</span><span class='info'>Hoffman, P. and F. Yergeau, &ldquo;UTF-16, an encoding of ISO 10646,&rdquo; February&nbsp;2000.</span><span>)</span></a>); per <a class='info' href='#RFC2277'>[RFC2277]<span> (</span><span class='info'>Alvestrand, H., &ldquo;IETF Policy on Character Sets and Languages,&rdquo; January&nbsp;1998.</span><span>)</span></a> UTF-8 is the RECOMMENDED character encoding for use with SPPP.
                                
</p>
<p>
                                        Character encodings other than UTF-8 and UTF-16 are allowed by XML. UTF-8 is the default encoding assumed by XML in the absence of an "encoding" attribute or a byte order mark (BOM); thus, the "encoding" attribute in the XML declaration is OPTIONAL if UTF-8 encoding is used.  SPPP clients and servers MUST accept a UTF-8 BOM if present, though emitting a UTF-8 BOM is NOT RECOMMENDED.
                                
</p>
<p>
                                        Example XML declarations:
                                        <br />
<br />

                                         &lt;?xml?&gt; version="1.0" encoding="UTF-8" standalone="no"?&gt;
                                
</p>
<a name="Request and Reply Model"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Request and Reply Model</h3>

<p>
                        An SPPP client interacts with an SPPP server by using one of the supported transport mechanisms to send one or more requests to the server and receive corresponding replies from the server.  An SPPP request is wrapped within the &lt;spppRequest&gt; element while an SPPP reply is wrapped within an &lt;spppReply&gt; element.  Furthermore, fully formed SPPP requests and replies are comprised of constructs required by the chosen transport technology, and the chosen envelope technology.  The supported transport technology and envelope technology specifications will be defined in separate documents, and are not discussed here.
                
</p>
<a name="request"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Request</h3>

<p>
                                An SPPP request object, common to any transport and envelope technology, is contained within the generic &lt;spppRequest&gt; element.
                        
</p>
<p>
                        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

        &lt;element name="spppRequest"&gt;
                 &lt;complexType&gt;
                          &lt;sequence&gt;
                                   &lt;any/&gt;
                          &lt;/sequence&gt;
                 &lt;/complexType&gt;
        &lt;/element&gt;

</pre></div><p>

                        
</p>
<p>
                                Within any &lt;spppRequest&gt; element is the request object specific to the type of object(s) being operated on and the action(s) being performed on that object.  For example, the addRteGroupRqst object, used to create Route Groups, that would be passed within an &lt;spppRequest&gt; is defined as follows:
                        
</p>
<p>
                        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

        &lt;element name="addRteGrpsRqst"&gt;
                                   &lt;complexType&gt;
            &lt;sequence&gt;
              &lt;element name="basicRqst"
                type="spppb:BasicRqstType"/&gt;
              &lt;element name="rteGrp"
                type="spppb:RteGrpType"
                maxOccurs="unbounded"/&gt;
            &lt;/sequence&gt;
           &lt;/complexType&gt;
        &lt;/element&gt;

</pre></div><p>

                        
</p>
<p>
                                All update requests contain a BasicRqstType object.  This object is defined as follows:
                        
</p>
<p>
                        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

        &lt;complexType name="BasicRqstType"&gt;
         &lt;sequence&gt;
          &lt;element name="clientTransId "
                   type="spppb:TransIdType"/&gt;
          &lt;element name="minorVer"
                   type="spppb:MinorVerType"/&gt;
          &lt;element name="ext"
                   type="spppb:ExtAnyType"
                   minOccurs="0"/&gt;
         &lt;/sequence&gt;
        &lt;/complexType&gt;

</pre></div><p>

                        
</p>
<p>
                        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

        &lt;simpleType name="TransIdType"&gt;
            &lt;restriction base="string"/&gt;
        &lt;/simpleType&gt;

</pre></div><p>

                        
</p>
<p>
                        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

        &lt;simpleType name="MinorVerType"&gt;
            &lt;restriction base="unsignedLong"/&gt;
        &lt;/simpleType&gt;

</pre></div><p>

                        
</p>
<p>
							The data elements within the BasicRqstType object are primarily “house keeping” data elements.  They are described as follows:

							</p>
<ul class="text">
<li>
											clientTransId:  The client generated transaction ID that identifies this request for tracking purposes.  This value is also echoed back to the client in the response.  This value will not be checked for uniqueness.
									
</li>
<li>
											minorVer:  This identifies the minor version of the SPPP API that the client is attempting to use.  This is used in conjunction with the major version identifier in the XML namespace.  Refer to the Versioning section of this document for more detail.
									
</li>
<li>
											ext:  This is the standard extension element for this object.  Refer to the Extensibility section of this document for more details.
									
</li>
</ul><p>
                        
</p>
<a name="reply"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Reply</h3>

<p>
                                An SPPP reply object, common to any transport and envelope technology, is contained within the generic &lt;spppReply&gt; element.
                        
</p>
<p>
                        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

        &lt;element name="spppReply"&gt;
                 &lt;complexType&gt;
                          &lt;sequence&gt;
                                   &lt;any/&gt;
                          &lt;/sequence&gt;
                 &lt;/complexType&gt;
        &lt;/element&gt;

</pre></div><p>

                        
</p>
<p>
                                Within any &lt;spppReply&gt; element is the reply object containing the result of the request.  All create, update, and delete operations result in a common response object structure, defined as follows:
                        
</p>
<p>
                        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

       &lt;element name="cmnRspns"&gt;
          &lt;complexType&gt;
             &lt;sequence&gt;
                &lt;element name="rspns" type="spppb:BasicRspnsType"/&gt;
             &lt;/sequence&gt;
          &lt;/complexType&gt;
       &lt;/element&gt;

</pre></div><p>

                        
</p>
<p>
                        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

        &lt;complexType name="BasicRspnsType"&gt;
          &lt;sequence&gt;
           &lt;element name="clientTransId"
                        type="TransIdType"/&gt;
           &lt;element name="serverTransId"
                        type="TransIdType"/&gt;
           &lt;element name="resCode"
                        type="int"/&gt;
           &lt;element name="resMsg"
                        type="string"/&gt;
           &lt;element name="ext"
                        type="spppb:ExtAnyType"
                        minOccurs="0"/&gt;
          &lt;/sequence&gt;
                                &lt;/complexType&gt;

</pre></div><p>

                        
</p>
<p>
                                The data elements within the BasicRspnseType object are described as follows:

                                </p>
<ul class="text">
<li>
                                                clientTransId:  The echoed back client transaction ID that explicitly identifies this request for tracking purposes.  This value is not guaranteed to be unique.
                                        
</li>
<li>
                                                serverTransId:  The server transaction ID that identifies this request for tracking purposes.  This value is guaranteed to be unique.
                                        
</li>
<li>
                                                resCode:  The response code that explicitly identifies the result of the request.  See the Response Code section  for further details.
                                        
</li>
<li>
                                                resMsg:  The human readable response message that accompanies the response code.  See the Response Code section for further details.
                                        
</li>
<li>
                                                ext:  This is the standard extension element for this object.  Refer to the Extensibility section for more details.
                                        
</li>
</ul><p>
                        
</p>
<a name="resultcodes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Response Codes and Messages</h3>

<p>
                                This section contains an initial listing of response codes and their corresponding human readable text.
                        
</p>
<p>
                                The response code numbering scheme generally adheres to the theory formalized in section 4.2.1 of <a class='info' href='#RFC2821'>[RFC2821]<span> (</span><span class='info'>Klensin, J., &ldquo;Simple Mail Transfer Protocol,&rdquo; April&nbsp;2001.</span><span>)</span></a>:

                        </p>
<ul class="text">
<li>
                                        The first digit of the response code can only be 1 or 2: 1 = a positive result, 2 = a negative result.
                                
</li>
<li>
                                        The second digit of the response code indicates the category: 0 = Protocol Syntax, 1 = Implementation Specific Business Rule, 2 = Security, 3 = Server System.
                                
</li>
<li>
                                        The third and fourth digits of the response code indicate the individual message event within the category defines by the first two digits.
                                
</li>
</ul><p>
                        
</p><br /><hr class="insert" />
<a name="Table1"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left" width="10%"><col align="left" width="90%">
<tr><th align="left">Result Code</th><th align="left">Text</th></tr>
<tr>
<td align="left"> 1000   </td>
<td align="left"> Request Succeeded.</td>
</tr>
<tr>
<td align="left"> 2001   </td>
<td align="left"> Request syntax invalid.</td>
</tr>
<tr>
<td align="left"> 2002   </td>
<td align="left"> Request too large.</td>
</tr>
<tr>
<td align="left"> 2003   </td>
<td align="left"> Version not supported.</td>
</tr>
<tr>
<td align="left"> 2103   </td>
<td align="left"> Command invalid.</td>
</tr>
<tr>
<td align="left"> 2104   </td>
<td align="left"> Attribute value invalid: [ObjecTypeName]:[Object's rantId]:[Object's name]:{[Embedded ObjecTypeName]}:[attribute name]:[attribute value].</td>
</tr>
<tr>
<td align="left"> 2105   </td>
<td align="left"> Object does not exist: [ObjecTypeName]:[Object's rantId]:[Object's name].</td>
</tr>
<tr>
<td align="left"> 2106   </td>
<td align="left"> Object status or ownership does not allow for operation: [OperationName]:[ObjecTypeName]:[Object's rantId]:[Object's name].</td>
</tr>
<tr>
<td align="left"> 2301   </td>
<td align="left"> System temporarily unavailable.</td>
</tr>
<tr>
<td align="left"> 2302   </td>
<td align="left"> Unexpected internal system or server error.</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1: Response Codes Numbering Scheme and Messages&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
                        Some response messages are "parameterized" with one or more of the following parameters: "attribute name", "attribute value", "objectType-objectId", and "operation name".
                
</p>
<p>
                        The use of these parameters MUST adhere to the following rules:
                
                </p>
<ul class="text">
<li>
                                All parameters within a response message are mandatory and MUST be present.  Parameters within a response message MUST NOT be left empty.
                        
</li>
<li>
                                Any value provided for the "attribute name" parameter MUST be an exact element name of the protocol data element that the response message is referring to.  For example, valid values for "attribute name" are "destGrpName", "rteGrpName", etc.
                        
</li>
<li>
A value provided for the "command/request type" parameter MUST be 
an exact request object name that the response message is 
referring to.  For example, a valid value for "request 
object name" is "delRteGrpsRqst".
                        
</li>
<li>
The value for "attribute value" MUST be the value of the data
element to which the preceding "attribute name" refers.
                        
</li>
<li>
Result code 2104 SHOULD be used whenever an element value does
        not adhere to data validation rules.
                        
</li>
<li>
Result codes 2104 and 2105 MUST NOT be used interchangeably.
Response code 2105 SHOULD be returned when the data element(s)
used to uniquely identify a pre-existing object do not exist.
If the data elements used to uniquely identify an object are
malformed, then response code 2104 SHOULD be returned.
                        
</li>
</ul><p>
        
</p>
<a name="protocolcommands"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Protocol Commands</h3>

<p>
                This section provides a preliminary list of SPPP protocol commands.
                <br />

                At this early stage of the protocol development, the commands are only listed with a brief description.
        
</p>
<a name="commanddetail"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Add Route Group Operation</h3>

<p>
                As described in the introductory sections, a Route Group represents a combined grouping of Route Records that define route information, Destination Groups that contain a set of Public Identifiers with common routing information, and the list of peer organizations that have access to these public identifiers using this route information. It is this indirect linking of public identities to route information that significantly improves the scalability and manageability of the peering data. Additions and changes to routing information are reduced to a single operation on a Route Group, rather than millions of data updates to individual public identity records that individually contain their peering point data.
                
</p>
<p>
                 The addRteGrpsRqst operation creates or overwrites one or more Route Group objects. If a Route Group with the given name and registrant ID does not exist, then the server MUST create the Route Group. If a Route Group with the given name and registrant does exist, then the server MUST replace the current properties of the Route Group with the properties passed into the addRteGrpsRqst operation.  The XSD declarations of the operation request object are as follows:
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="addRteGrpsRqst" type="spppb:AddRteGrpsRqstType"/&gt;
	  &lt;complexType name="AddRteGrpsRqstType"&gt;
        &lt;complexContent&gt;
          &lt;extension base="spppb:BasicRqstType"&gt;
            &lt;sequence&gt;
              &lt;element name="rteGrp" type="spppb:RteGrpType"
                                            maxOccurs="unbounded"/&gt;
            &lt;/sequence&gt;
          &lt;/extension&gt;
        &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>
                  The element passed into the spppRequest element for this operation is the addRteGrpsRqst element.  This element is of type AddRteGrpsRqstType, which extends BasicRqstType and contains one or more RteGrpType objects.  Any limitation on the maximum number of RteGrpType objects that may be passed into this operation is a policy decision and is not limited by the protocol. The RteGrpType object structure is defined as follows:
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;complexType name="RteGrpType"&gt;
      &lt;sequence&gt;
        &lt;element name="base" type="spppb:BasicObjType"/&gt;
        &lt;element name="rteGrpName" type="spppb:ObjNameType"/&gt;
        &lt;element name="rteRec" type="spppb:RteRecType"
                        minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;element name="dgName" type="spppb:ObjNameType"
                        minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;element name="peeringOrg" type="spppb:OrgIdType"
                        minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;element name="sourceIdent" type="spppb:SourceIdentType"
                        minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;element name="isInSvc" type="boolean"/&gt;
                &lt;element name="ext" type="spppb:ExtAnyType"
s="0"/&gt;
      &lt;/sequence&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>The RteGrpType object is composed of the following elements:
                    </p>
<ul class="text">
<li>
                            base:  As described in previous sections, most objects contain exactly one instance of BasicObjType which contains the ID of the registrant organization that owns this object and the ID of the registrar organization that provisioned this object.
                        
</li>
<li>
                            rteGrpName:  The character string that contains the name of the Route Group.  It uniquely identifies this object within the context of the registrant ID (a child element of the base element as described above).
                        
</li>
<li>
                            rteRec:  Set of zero or more objects of type RteRecType that house the routing information, sometimes referred to as SED, that the RteGrpType object contains.
                        
</li>
<li>
                            dgName:  Set of zero or more names of DestGrpType object instances.  Each dgName name, in association with this Route Group's registrant ID, uniquely identifies a DestGrpType object instance whose public identities are reachable using the routing information housed in this Route Group.
                        
</li>
<li>
                            peeringOrg:  Set of zero or more peering organization IDs that have accepted an offer to receive this Route Group's information.  The set of peering organizations in this list is not directly settable or modifiable using the addRteGrpsRqst operation. This set is instead controlled using the route offer and accept operations.
                        
</li>
<li>
                            sourceIdent:  Set of zero or more SourceIdentType object instances.  These objects, described further below, house the source identification schemes and identifiers that are applied at resolution time as part of source based routing algorithms for the Route Group.
                        
</li>
<li>
                            isInSvc:  A boolean element that defines whether this Route Group is in service.  The routing information contained in a Route Group that is in service is a candidate for inclusion in resolution responses for public identities residing in the Destination Group associated with this Route Group.  The routing information contained in a Route Group that is not in service is not a candidate for inclusion is resolution responses.
                        
</li>
<li>
                            ext:  Point of extensibility described in a previous section of this document.
                        
</li>
</ul><p>
                
</p>
<p>
                  As described above, the Route Group contains a set of route record objects. A route record object is based on an abstract type: RteRecType. The concrete types that use RteRecType as an extension base are NAPTRType, NSType, and URIType.  The definitions of these types are included below.  The NAPTRType object is comprised of the data elements necessary for a NAPTR that contains routing information the Route Group.  The NSType object is comprised of the data elements necessary for a Name Server that points to another DNS server that contains the desired routing information.  The URIType object is comprised of the data elements necessary to house a URI.
                
</p>
<p>
					The data provisioned in a Registry can be leveraged for many purposes and queried using various protocols including SIP, ENUM and others.  It is for this reason that a route record type offers a choice of URI, and DNS resource record types.  The URIType is commonly used to provision data related to the SIP route in registries.  The use of DNS resource record types is also relevant to the scenario where the data provisioned in the registry is used to answer ENUM queries but the provisioning protocol should be agnostic to a particular resolution protocol.
				
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;complexType name="RteRecType" abstract="true"&gt;
      &lt;sequence&gt;
        &lt;element name="priority" type="positiveInteger"
                                            default="100"/&gt;
      &lt;/sequence&gt;
    &lt;/complexType&gt;

    &lt;complexType name="NAPTRType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:RteRecType"&gt;
          &lt;sequence&gt;
            &lt;element name="order" type="unsignedShort"/&gt;
            &lt;element name="pref" type="unsignedShort"/&gt;
            &lt;element name="flags" type="string" minOccurs="0"/&gt;
            &lt;element name="svcs" type="string"/&gt;
            &lt;element name="regx" type="spppb:RegexParamType"
                                            minOccurs="0"/&gt;
            &lt;element name="repl" type="string" minOccurs="0"/&gt;
            &lt;element name="ttl" type="positiveInteger"
                                            minOccurs="0"/&gt;
            &lt;element name="ext" type="spppb:ExtAnyType"
                                            minOccurs="0"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

    &lt;complexType name="NSType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:RteRecType"&gt;
          &lt;sequence&gt;
            &lt;element name="hostName" type="string"/&gt;
            &lt;element name="ipAddr" type="spppb:IPAddrType"
                    minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;element name="ttl" type="positiveInteger"
                                            minOccurs="0"/&gt;
            &lt;element name="ext" type="spppb:ExtAnyType"
                                            minOccurs="0"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

    &lt;complexType name="IPAddrType"&gt;
      &lt;sequence&gt;
        &lt;element name="addr" type="string"/&gt;
        &lt;element name="type" type="spppb:IPType"/&gt;
        &lt;element name="ext" type="spppb:ExtAnyType"
                                            minOccurs="0"/&gt;
      &lt;/sequence&gt;
    &lt;/complexType&gt;

    &lt;simpleType name="IPType"&gt;
      &lt;restriction base="token"&gt;
        &lt;enumeration value="IPv4"/&gt;
        &lt;enumeration value="IPv6"/&gt;
      &lt;/restriction&gt;
    &lt;/simpleType&gt;

    &lt;complexType name="URIType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:RteRecType"&gt;
          &lt;sequence&gt;
            &lt;element name="ere" type="string" default="^(.*)$"/&gt;
            &lt;element name="uri" type="string"/&gt;
            &lt;element name="ext" type="spppb:ExtAnyType"
minOccurs="0"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>The NAPTRType object is composed of the following elements:
                    </p>
<ul class="text">
<li>
                            order:  Order value in an ENUM NAPTR, relative to other NAPTRType objects in the same Route Group.
                        
</li>
<li>
                            pref:  Preference value in an ENUM NAPTR.
                        
</li>
<li>
                            svcs:  ENUM service(s) that are served by the SBE. This field's value must be of the form specified in RFC 3761 (e.g., E2U+pstn:sip+sip). The allowable values are a matter of policy and not limited by this protocol.
                        
</li>
<li>
                            regx:  NAPTR’s regular expression field. If this is not included then the Repl field must be included.
                        
</li>
<li>
                            repl:  NAPTR replacement field, should only be provided if the Regex field is not provided, otherwise it will be ignored by the server.
                        
</li>
<li>
                            ttl:  Number of seconds that an addressing server may cache this NAPTR.
                        
</li>
<li>
                            ext:  Point of extensibility described in a previous section of this document.
                        
</li>
</ul><p>
                
</p>
<p>The NSType object is composed of the following elements:
                    </p>
<ul class="text">
<li>
                            hostName:  Fully qualified host name of the name server.
                        
</li>
<li>
                            ipAddr:  Zero or more objects of type IpAddrType. Each object holds an IP Address and the IP Address type, IPv4 or IP v6.
                        
</li>
<li>
                            ttl:  Number of seconds that an addressing server may cache this Name Server.
                        
</li>
<li>
                            ext:  Point of extensibility described in a previous section of this document.
                        
</li>
</ul><p>
                
</p>
<p>The URIType object is composed of the following elements:
                    </p>
<ul class="text">
<li>
                            ere:  The POSIX Extended Regular Expression (ere) as defined in <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a>
                        
</li>
<li>
                            uri:  the URI as defined in <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a>
                        
</li>
</ul><p>
                
</p>
<p>
                The RteGrpType object provides support for source-based routing via the source identity element.  The source-based routing criteria provides the ability to specify zero or more of the following in association with a given Route Group:  a regular expression that is matched against the resolution client IP address, a regular expression that is matched against the root domain name(s), and/or a regular expression that is matched against the calling party URI(s).  The result will be that, after identifying the visible Route Groups whose associated Destination Group(s) contain the lookup key being queried, the resolution server will evaluate the characteristics of the Source URI, and Source IP address, and root domain of the lookup key being queried.  The resolution server compares these criteria against source based routing criteria associated with the Route Groups.  The routing information contained in Route Groups that have source based routing criteria will only be included in the resolution response if one or more of the criteria matches the source criteria from the resolution request.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;complexType name="SourceIdentType"&gt;
      &lt;sequence&gt;
        &lt;element name="sourceIdentRegex" type="string"/&gt;
        &lt;element name="sourceIdentScheme"
                                  type="spppb:SourceIdentSchemeType"/&gt;
        &lt;element name="ext" type="spppb:ExtAnyType"
                                            minOccurs="0"/&gt;
      &lt;/sequence&gt;
    &lt;/complexType&gt;

    &lt;simpleType name="SourceIdentSchemeType"&gt;
      &lt;restriction base="token"&gt;
        &lt;enumeration value="uri"/&gt;
        &lt;enumeration value="ip"/&gt;
        &lt;enumeration value="rootDomain"/&gt;
      &lt;/restriction&gt;
    &lt;/simpleType&gt;

</pre></div><p>

                
</p>
<p>The SourceIdentType object is composed of the following data elements:
                    </p>
<ul class="text">
<li>
                            sourceIdentScheme:  The source identification scheme that this source identification criteria applies to and that the associated sourceIdentRegex should be matched against.
                        
</li>
<li>
                            sourceIdentRegex:  The regular expression that should be used to test for a match against the portion of the resolution request that is dictated by the associated sourceIdentScheme.
                        
</li>
<li>
                            ext:  Point of extensibility described in a previous section of this document.
                        
</li>
</ul><p>
                
</p>
<p>
                The result of the addRteGrpsRqst operation is the addRteGrpsRspns element defined below.  As with all SPPP requests, the result is all-or-nothing.  If more than one RteRecType is passed into this request, then they will either all succeed or all fail.  In the case of failure, the failure response code(s) and message(s) will indicate the reason for the failure and the object(s) that caused the failure.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

&lt;element name="addRteGrpsRspns" type="spppb:BasicRspnsType"/&gt;

</pre></div><p>

                
</p>
<p>The response codes that the addRteGrpsRqst operation can return are as follows:
                    </p>
<ul class="text">
<li>1000:   Request Succeeded.
</li>
<li>2001:   Request syntax invalid.
</li>
<li>2002:   Request too large.
</li>
<li>2003:   Version not supported.
</li>
<li>2103:   Command invalid.
</li>
<li>2104:   Attribute value invalid.
</li>
<li>2105:   Object does not exist.
</li>
<li>2106:   Object status or ownership does not
                                   allow for request.
</li>
<li>2301:   System temporarily unavailable.
</li>
<li>2302:   Unexpected internal system or server error.
</li>
</ul><p>
                
</p>
<a name="getroutegrps"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Get Route Groups Operation</h3>

<p>
                 The getRteGrpsRqst operation allows a client to get the properties of Route Group objects that a registrar organization is authorized to view. The server will attempt to find a Route Group object that has the registrant ID and route group name pair contained in each ObjKeyType object instance.  If the set of ObjKeyType objects is empty then the server will return the list of Route Group objects that the querying client has the authority to view.  If there are no matching Route Groups found then an empty result set will be returned.
                
</p>
<p>
                 The element passed into the spppRequest element for this operation is the getRteGrpsRqst element.  This element is of type GetRteGrpsRqstType, which extends BasicRqstType and contains zero or more ObjKeyType objects. Any  limitation on the maximum number of objects that may be passed into or returned by this operation is a policy decision and not limited by the protocol.  The XSD declaration of the operation is as follows:
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

     &lt;element name="getRteGrpsRqst" type="spppb:GetRteGrpsRqstType"/&gt;

    &lt;complexType name="GetRteGrpsRqstType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:BasicRqstType"&gt;
          &lt;sequence&gt;
            &lt;element name="objectKey" type="spppb:ObjKeyType"
                            minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>
                The result of the getRteGrpsRqst operation returned in the spppResponse element is the getRteGrpsRspns element defined below.  This object contains the resulting set of RteGrpType objects, or an empty set if there were no matches.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="getRteGrpsRspns"
type="spppb:GetRteGrpsRspnsType"/&gt;

    &lt;complexType name="GetRteGrpsRspnsType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:BasicRspnsType"&gt;
          &lt;sequence&gt;
            &lt;element name="rteGrp" type="spppb:RteGrpType"
                 minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>The response codes that the getRteGrpsRqst operation can return are as follows:
                    </p>
<ul class="text">
<li>1000:   Request Succeeded.
</li>
<li>2001:   Request syntax invalid.
</li>
<li>2002:   Request too large.
</li>
<li>2003:   Version not supported.
</li>
<li>2103:   Command invalid.
</li>
<li>2104:   Attribute value invalid.
</li>
<li>2301:   System temporarily unavailable.
</li>
<li>2302:   Unexpected internal system or server error.
</li>
</ul><p>
                
</p>
<a name="addrtegrp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
Add Route Group Offers Operation</h3>

<p>
                The list of peer organizations whose resolution responses can include the routing information contained in a given Route Group is controlled by the organization to which a Route Group object belongs, its registrant, and the peer organization that submits resolution requests, a data recipient or peering organization.  The registrant offers access to a Route Group by submitting a Route Group Offer and the data recipient can then accept or reject that offer.  Not until access to a Route Group has been offered and accepted will the data recipient's organization ID be included in the peeringOrg list in a Route Group object, and that Route Group's peering information become a candidate for inclusion in the responses to the resolution requests submitted by that data recipient. The addRteGrpOffersRqst operation creates or overwrites one or more Route Group Offer objects. If a Route Group Offer for the given Route key (route name and registrant ID) and offeredToOrg ID does not exist, then the server creates the Route Group Offer object.  If a such a Route Group Offer does exist, then the server replaces the current object with the new object.  The XSD declarations of the operation request object are as follows:
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="addRteGrpOffersRqst"
                                type="spppb:AddRteGrpOffersRqstType"/&gt;

    &lt;complexType name="AddRteGrpOffersRqstType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:BasicRqstType"&gt;
          &lt;sequence&gt;
            &lt;element name="rteGrpOffer" type="spppb:RteGrpOfferType"
                                               maxOccurs="unbounded"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>
                 The element passed into the spppRequest element for this operation is the addRteGrpOffersRqst element.  This element is of type AddRteGrpOffersRqstType, which extends BasicRqstType and contains one or more RteGrpOfferType objects. Any  limitation on the maximum number of objects that may be passed into or returned by this operation is a policy decision and not limited by the protocol.  The XSD declaration of the operation is as follows:
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;complexType name="RteGrpOfferType"&gt;
      &lt;sequence&gt;
        &lt;element name="base" type="spppb:BasicObjType"/&gt;
        &lt;element name="rteGrpOfferKey" type="spppb:RteGrpOfferKeyType"/&gt;
        &lt;element name="status" type="spppb:RteGrpOfferStatusType"/&gt;
        &lt;element name="offerDateTime" type="dateTime"/&gt;
        &lt;element name="acceptDateTime" type="dateTime" minOccurs="0"/&gt;
        &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
      &lt;/sequence&gt;
    &lt;/complexType&gt;
       &lt;complexType name="RteGrpOfferKeyType"&gt;
      &lt;sequence&gt;
        &lt;element name="rteGrpKey" type="spppb:ObjKeyType"/&gt;
        &lt;element name="offeredTo" type="spppb:OrgIdType"/&gt;
      &lt;/sequence&gt;
    &lt;/complexType&gt;

    &lt;simpleType name="RteGrpOfferStatusType"&gt;
      &lt;restriction base="token"&gt;
        &lt;enumeration value="offered"/&gt;
        &lt;enumeration value="accepted"/&gt;
      &lt;/restriction&gt;
    &lt;/simpleType&gt;

</pre></div><p>

                
</p>
<p>The RteGrpOfferType object is composed of the following elements:
                    </p>
<ul class="text">
<li>
                            base:  As described in previous sections, most objects contain exactly one instance of BasicObjType which contains the ID of the registrant organization that owns this object and the ID of the registrar organization that provisioned this object.
                        
</li>
<li>
                            rteGrpOfferKey:  The object that identifies the route that is or has been offered and the organization that it is or has been offered to.  The combination of these three data elements uniquely identify a Route Group Offer.
                        
</li>
<li>
                            status:  The status of the offer, offered or accepted.  This status is controlled by the server.  It is automatically set to "offered" when ever a new Route Group Offer is added, and is automatically set to "accepted" if and when that offer is accepted.  The value of the element is ignored when passed in by the client.
                        
</li>
<li>
                            offerDateTime:  Date and time in GMT when the Route Group Offer was added.
                        
</li>
<li>
                            acceptDateTime:  Date and time in GMT when the Route Group Offer was accepted.
                        
</li>
</ul><p>
                
</p>
<p>
                The result of addRteGrpOffersRqst is the addRteGrpOffersRspns element defined below.  As with all SPPP requests, the result is all-or-nothing.  If more than one RteGrpOfferType is passed into this request, then they will either all succeed or all fail.  In the case of failure, the failure response code(s) and message(s) will indicate the reason for the failure and the object(s) that caused the failure.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  &lt;element name="addRteGrpOffersRspns" type="spppb:BasicRspnsType"/&gt;

</pre></div><p>

                
</p>
<p>The response codes that the addRteGrpOffersRqst operation can return are as follows:
                    </p>
<ul class="text">
<li>1000:   Request Succeeded.
</li>
<li>2001:   Request syntax invalid.
</li>
<li>2002:   Request too large.
</li>
<li>2003:   Version not supported.
</li>
<li>2103:   Command invalid.
</li>
<li>2104:   Attribute value invalid.
</li>
<li>2105:   Object does not exist.
</li>
<li>2106:   Object status or ownership does not allow for request.
</li>
<li>2301:   System temporarily unavailable.
</li>
<li>2302:   Unexpected internal system or server error.
</li>
</ul><p>
                
</p>
<a name="accrtegrpoff"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.4"></a><h3>8.4.&nbsp;
Accept Route Group Offers Operation</h3>

<p>
                Not until access to a Route Group has been offered and accepted will the data recipient's organization ID be included in the peeringOrg list in that Route Group object, and that Route Group's peering information become a candidate for inclusion in the responses to the resolution requests submitted by that data recipient.The acceptRteGrpOffersRqst operation is called by, or on behalf of, the data recipient to accept one or more Route Group Offers that are pending in the "offered" status for the data recipient's organization ID.  If a Route Group Offer for the given Route Group Offer key (route name, route registrant ID, data recipient's organization ID) exists, then the server moves the Route Group Offer to the "accepted" status and adds that data recipient's organization ID into the list of peerOrgIds for that Route Group.  If a such a Route Group Offer does not exist, then the server returns the appropriate error code 2105.  The XSD declarations for the operation request object are as follows:
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="acceptRteGrpOffersRqst"
                             type="spppb:AcceptRteGrpOffersRqstType"/&gt;

    &lt;complexType name="AcceptRteGrpOffersRqstType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:BasicRqstType"&gt;
          &lt;sequence&gt;
            &lt;element name="rteGrpOfferKey"
               type="spppb:RteGrpOfferKeyType" maxOccurs="unbounded"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>
                 The element passed into the spppRequest element for this operation is the acceptRteGrpOffersRqst element.  This element is of type AcceptRteGrpOffersRqstType, which extends BasicRqstType and contains one or more RteGrpOfferKeyType objects. Any limitation on the maximum number of objects that may be passed into or returned by this operation is a policy decision and not limited by the protocol.
                
</p>
<p>
                The result of acceptRteGrpOffersRqst is the acceptRteGrpOffersRspns element defined below.  As with all SPPP requests, the result is all-or-nothing.  If more than one RteGrpOfferKeyType is passed into this request, then they will either all succeed or all fail.  In the case of failure, the failure response code(s) and message(s) will indicate the reason for the failure and the object(s) that caused the failure.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="acceptRteGrpOffersRspns"
                                         type="spppb:BasicRspnsType"/&gt;

</pre></div><p>

                
</p>
<p>The response codes that the acceptRteGrpOffersRspns operation can return are as follows:
                    </p>
<ul class="text">
<li>1000:   Request Succeeded.
</li>
<li>2001:   Request syntax invalid.
</li>
<li>2002:   Request too large.
</li>
<li>2003:   Version not supported.
</li>
<li>2103:   Command invalid.
</li>
<li>2104:   Attribute value invalid.
</li>
<li>2105:   Object does not exist.
</li>
<li>2106:   Object status or ownership does not allow for request.
</li>
<li>2301:   System temporarily unavailable.
</li>
<li>2302:   Unexpected internal system or server error.
</li>
</ul><p>
                
</p>
<a name="rejrtegrpoff"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.5"></a><h3>8.5.&nbsp;
Reject Route Group Offers Operation</h3>

<p>
                Not until access to a Route Group has been offered and accepted will the data recipient's organization ID be included in the peeringOrg list in that Route Group object, and that Route Group's peering information become a candidate for inclusion in the responses to the resolution requests submitted by that data recipient.  However, the data recipient that the Route Group has been offered to has the option of rejecting a Route Group Offer that has been offered but not accepted or that has been offered and accepted.  The rejectRteGrpOffersRqst operation is used for these purposes and is called by, or on behalf of, the data recipient to accept one or more Route Group Offers that are pending in the "offered" status or the "accepted" status for the data recipient's organization ID.  If a Route Group Offer for the given Route Group Offer key (route name, route registrant ID, data recipient's organization ID) exists in either the offered or accepted status, then the server deletes that Route Group Offer object , and, if appropriate, removes the data recipients organization ID from the list of peerOrgIds for that Route Group.  If the Route Group Offer does not exist, then the server returns the appropriate error code 2105.  The XSD declarations for the operation request object are as follows:
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="rejectRteGrpOffersRqst"
                             type="spppb:RejectRteGrpOffersRqstType"/&gt;

    &lt;complexType name="RejectRteGrpOffersRqstType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:BasicRqstType"&gt;
          &lt;sequence&gt;
            &lt;element name="rteGrpOfferKey"
               type="spppb:RteGrpOfferKeyType" maxOccurs="unbounded"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>
                 The element passed into the spppRequest element for this operation is the rejectRteGrpOffersRqst element.  This element is of type RejectRteGrpOffersRqstType, which extends BasicRqstType and contains one or more RteGrpOfferKeyType objects. Any limitation on the maximum number of objects that may be passed into or returned by this operation is a policy decision and not limited by the protocol.
                
</p>
<p>
                The result of rejectRteGrpOffersRqst is the rejectRteGrpOffersRspns element defined below.  As with all SPPP requests, the result is all-or-nothing.  If more than one RteGrpOfferKeyType is passed into this request, then they will either all succeed or all fail.  In the case of failure, the failure response code(s) and message(s) will indicate the reason for the failure and the object(s) that caused the failure.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="rejectRteGrpOffersRspns"
                                type="spppb:BasicRspnsType"/&gt;

</pre></div><p>

                
</p>
<p>The response codes that the rejectRteGrpOffersRspns operation can return are as follows:
                    </p>
<ul class="text">
<li>1000:   Request Succeeded.
</li>
<li>2001:   Request syntax invalid.
</li>
<li>2002:   Request too large.
</li>
<li>2003:   Version not supported.
</li>
<li>2103:   Command invalid.
</li>
<li>2104:   Attribute value invalid.
</li>
<li>2105:   Object does not exist.
</li>
<li>2106:   Object status or ownership does not allow for request.
</li>
<li>2301:   System temporarily unavailable.
</li>
<li>2302:   Unexpected internal system or server error.
</li>
</ul><p>
                
</p>
<a name="getrtegrpoff"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.6"></a><h3>8.6.&nbsp;
Get Route Group Offers Operation</h3>

<p>
                 The getRteGrpOffersRqst operation allows a client to get the properties of zero or more Route Group Offer objects that that  registrar is authorized to view. The server will attempt to find Route Group Offer objects that has all the properties specified in the criteria passed into the operation.  If no criteria is passed in then the server will return  the list of Route Group Offer objects that the querying client has the authority to view.  If there are no matching Route Group Offers found then an empty result set will be returned.
                
</p>
<p>
                 The element passed into the spppRequest element for this operation is the getRteGrpOffersRqst element.  This element is of type GetRteGrpOffersRqstType, which extends BasicRqstType and contains the criteria that the returnedRoute Group Offer objects must match.  Any  limitation on the maximum number of objects that may be passed into or returned by this operation is a policy decision and not limited by the protocol.  The XSD declaration of the operation is as follows:
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="getRteGrpOffersRqst"
                                type="spppb:GetRteGrpOffersRqstType"/&gt;

    &lt;complexType name="GetRteGrpOffersRqstType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:BasicRqstType"&gt;
          &lt;sequence&gt;
            &lt;element name="offeredByPeers" type="boolean"
                                                       minOccurs="0"/&gt;
            &lt;element name="offeredToPeers" type="boolean"
                                                       minOccurs="0"/&gt;
            &lt;element name="status" type="spppb:RteGrpOfferStatusType"
                                                       minOccurs="0"/&gt;
            &lt;element name="peeringOrg" type="spppb:OrgIdType"
                                 minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;element name="rteGrpOfferKey"
type="spppb:RteGrpOfferKeyType" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>The GetRteGrpOffersRqstType object is composed of the following elements:
                    </p>
<ul class="text">
<li>
                            offeredByPeers:  Zero or one boolean value that, if true, indicates that only offers that are offered by peering organizations to the querying registrant should be included in the result set.  If this value is false, the offers by peering organizations to the querying registrant should not be included in the result set.  The result set is also subject to other query criteria in the request.
                        
</li>
<li>
                            offeredToPeers:  Zero or one boolean value that, if true, indicates that only offers that are offered to peering organizations by the querying registrant should be included in the result set.  If this value is false, the offers to peering organizations by the querying registrant should not be included in the result set.  The result set is also subject to other query criteria in the request.
                        
</li>
<li>
                            status:  The status of the offer, offered or accepted.  Only offers in the specified status should be included in the result set.  If this element is not present then the status of the offer should not be considered in the query.  The result set is also subject to other query criteria in the request.
                        
</li>
<li>
                            peeringOrg:  Zero or more organization IDs.  Only offers that are offered to or offered by the organization IDs in this list should be included in the result set.  The result set is also subject to other query criteria in the request.
                        
</li>
<li>
                            rteGrpOfferKey:  Zero or more Route Group Offer Keys.  Only offers having one of these keys should be included in the result set.  The result set is also subject to other query criteria in the request.
                        
</li>
</ul><p>
                
</p>
<p>
                The result of the getRteGrpOffersRqst operation returned in the spppResponse element is the getRteGrpOffersRspns element defined below.  This object contains the resulting set of RteGrpOfferType objects, or an empty set if there were no matches.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="getRteGrpOffersRspns"
                               type="spppb:GetRteGrpOffersRspnsType"/&gt;

    &lt;complexType name="GetRteGrpOffersRspnsType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:BasicRspnsType"&gt;
          &lt;sequence&gt;
            &lt;element name="rteGrpOffer" type="spppb:RteGrpOfferType"
                                 minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>The response codes that the getRteGrpOffersRqst operation can return are as follows:
                    </p>
<ul class="text">
<li>1000:   Request Succeeded.
</li>
<li>2001:   Request syntax invalid.
</li>
<li>2002:   Request too large.
</li>
<li>2003:   Version not supported.
</li>
<li>2103:   Command invalid.
</li>
<li>2104:   Attribute value invalid.
</li>
<li>2301:   System temporarily unavailable.
</li>
<li>2302:   Unexpected internal system or server error.
</li>
</ul><p>
                
</p>
<a name="PubIdsOper"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.7"></a><h3>8.7.&nbsp;
Public Identifier Operations</h3>

<p>
                Public Identifier is a well-known attribute that is used as the search key to find the routes associated with it. There are three types of public identifiers defined in this document: TNType for the telephone number, EmailType for the email address, and RNType for PSTN routing number. Further, TNRangeType is used to add a range of telephone numbers.
                
</p>
<a name="addPubIds"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.7.1"></a><h3>8.7.1.&nbsp;
Add Public Identifier</h3>

<p>
                addPubIdsRqst operation is used to create or overwrite one or more public identifier(s). When activating a new public identifier that can be reached using a common set of routes, it is often associated with a well-known destination group. In some cases, such as the email public identifier, the routing information is unique, and therefore, addPubIdsRqst allows the public identifier to be directly associated with a route record.
                
</p>
<p>
                PubIdType in the schema represents the public identifier and it is defined as an abstract type. TNType, EmailType, and RNType, the concrete types of PubIdType, are inputs to 'addPubIdRqst' operation. The declaration of 'addPubIdsRqst' is as follows:
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="addPubIdsRqst" type="spppb:AddPubIdsRqstType"/&gt;
    &lt;complexType name="AddPubIdsRqstType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:BasicRqstType"&gt;
          &lt;sequence&gt;
            &lt;element name="pi" type="spppb:PubIdType"
              maxOccurs="unbounded"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>
                For the 'addPubIdsRqst' operation to succeed, each public identifier should be associated with at least a valid destination group or a valid route type as defined within the PubIdType definition. If not, the provisioning server will deem the request a failure and return an appropriate failure code in the response.
                
</p>
<p>
                TNType is a concrete public identifier that extends PubIdType definition. If the entity provisioning the telephone number is the carrier of record [see RFC 5067], then it SHOULD include the 'corClaim' element with a value 'true'. If the SPPP server records disagree with the COR claim of the provisioning entity, an appropriate failure response MUST be returned.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  &lt;complexType name="PubIdType" abstract="true"&gt;
    &lt;sequence&gt;
      &lt;element name="base" type="spppb:BasicObjType"/&gt;
      &lt;element name="dgName" type="spppb:ObjNameType" minOccurs="0"/&gt;
      &lt;element name="rteRec" type="spppb:RteRecType" minOccurs="0"
        maxOccurs="unbounded"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;complexType name="TNType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:PubIdType"&gt;
        &lt;sequence&gt;
          &lt;element name="tn" type="string"/&gt;
          &lt;element name="corClaim" type="spppb:CORInfoType"
            minOccurs="0"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>
                For added flexibility, there is support to add a range of telephone numbers and associate them with a destination group. TNRType extends TNType and adds the 'endTn' attribute to mark the end of the range. In the TNRType context, the extended 'tn' attribute is used for the starting TN of a given telephone number range.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;complexType name="TNRType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:TNType"&gt;
          &lt;sequence&gt;
            &lt;element name="endTn" type="string"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>
                The element passed into the spppRequest element for this operation is the addPubIdsRqst element. This element is of type AddPubIdsRqstType, which extends BasicRqstType and contians one or more PubIdType objects. Any limitation on the maximum number of PubIdType objects that may be passed into this operatoin is a policy decision and is not limited by the protocol.
                
</p>
<p>
                The response from the server is returned in addPubIdsRspns element. If more than one public identifiers are passed in the addPubIdsRqst, then a failure to add one will result in the failure of addPubIdsRqst operation. If the 'transactional' attribute is set to 'true' in the root element spppRequest and more than one operation request elements are included, then a failure of any one operation will result in the overall failure of spppRequest.  In the case of a failure, the response code(s) and message(s) will indicate the reason of failure.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

&lt;element name="addRteGrpsRspns" type="spppb:BasicRspnsType"/&gt;

</pre></div><p>

                
</p>
<p>The response codes that the addRteGrpsRqst operation can return are as follows:
                    </p>
<ul class="text">
<li>1000:   Request Succeeded.
</li>
<li>2001:   Request syntax invalid.
</li>
<li>2002:   Request too large.
</li>
<li>2003:   Version not supported.
</li>
<li>2103:   Command invalid.
</li>
<li>2104:   Attribute value invalid.
</li>
<li>2105:   Object does not exist.
</li>
<li>2106:   Object status or ownership does not allow for request.
</li>
<li>2301:   System temporarily unavailable.
</li>
<li>2302:   Unexpected internal system or server error.
</li>
</ul><p>
                
</p>
<a name="getPubIds"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.7.2"></a><h3>8.7.2.&nbsp;
Get Public Identifier</h3>

<p>
            The getPubIdsRqst can be used by an authorized entity to obtain the properties of one or more public identifiers. In case of an authorization failure or if no matching public identifiers are found, an appropriate failure code will be returned.
          
</p>
<p>
            To make a successful query, getPubIdsRqst element is set within the spppRequest root element. getPubIdsRqst is of type GetPubIdsRqstType, which extends from the common BasicRqstType. 
          
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      &lt;element name="getPubIdsRqst" type="spppb:GetPubIdsRqstType"/&gt;
      &lt;complexType name="AddPubIdsRqstType"&gt;
        &lt;complexContent&gt;
          &lt;extension base="spppb:BasicRqstType"&gt;
            &lt;sequence&gt;
              &lt;element name="pi" type="spppb:PubIdType"
                maxOccurs="unbounded"/&gt;
            &lt;/sequence&gt;
          &lt;/extension&gt;
        &lt;/complexContent&gt;
      &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>
                  The result of the getPubIdsRqst operation returned in the spppResponse element is the getPubIdsRspns element of type GetPubIdsRspnsType. If the matching record is found, getPubIdsRspns element will include one or more pi elements with destination group name and/or the route record associations.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="getPubIdsRspns" type="spppb:GetPubIdsRspnsType"/&gt;
    &lt;complexType name="GetPubIdsRspnsType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:BasicRspnsType"&gt;
          &lt;sequence&gt;
            &lt;element name="pi" type="spppb:PubIdType" minOccurs="0"
              maxOccurs="unbounded"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>The response codes that the addRteGrpsRqst operation can return are as follows:
                    </p>
<ul class="text">
<li>1000:   Request Succeeded.
</li>
<li>2001:   Request syntax invalid.
</li>
<li>2002:   Request too large.
</li>
<li>2003:   Version not supported.
</li>
<li>2103:   Command invalid.
</li>
<li>2104:   Attribute value invalid.
</li>
<li>2105:   Object does not exist.
</li>
<li>2106:   Object status or ownership does not allow for request.
</li>
<li>2301:   System temporarily unavailable.
</li>
<li>2302:   Unexpected internal system or server error.
</li>
</ul><p>
                
</p>
<a name="delPubIds"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.7.3"></a><h3>8.7.3.&nbsp;
Delete Public Identifier</h3>

<p>
            In order to remove the public identifier, an authorized entity can use the delPubIdsRqst operation. If the entity that issued the command is not authorized to perform this operation or if the public identifier doesn't exist, an appropriate error code will be returned in the response.
          
</p>
<p>
            delPubIdsRqst element is set in the root spppRequest element. delPubIdsRqst element is of type DelPubIdsRqstType as shown below:
          
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="getPubIdsRqst" type="spppb:GetPubIdsRqstType"/&gt;
    &lt;complexType name="DelPubIdsRqstType"&gt;
      &lt;complexContent&gt;
        &lt;extension base="spppb:BasicRqstType"&gt;
          &lt;sequence&gt;
            &lt;element name="pi" type="spppb:PubIdType"
              maxOccurs="unbounded"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>
                  The result of the delPubIdsRqst operation returned in the spppResponse element is the getPubIdsRspns element of type GetPubIdsRspnsType.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    &lt;element name="delPubIdsRspns" type="spppb:BasicRspnsType"/&gt;

</pre></div><p>

                
</p>
<a name="egressRteOper"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.8"></a><h3>8.8.&nbsp;
Egress Route Operations</h3>

<p>
            This section describes the operations related to egress routes. In this version, egress routes are only defined for route records of NAPTR type (future versions may expand this notion to URI types).
           
</p>
<p>
            The egress route functionality allows a call originating SSP to define its egress route in an attempt to reach the ingress SBE of the target SSP. In some cases, the call originating SSP has more than one choice of egress SBEs and intends to selectively use one of these route elements for call termination to the target SSP.
           
</p>
<p>
            An egress route simply allows an organization to re-write the route records provided by a peer in a given Route Group.  If a terminating SSP has provided a route group with at least one route record in the form of an ingress DNS NAPTR record, then the egress route allows the originating SSP to re-write the regular expression of the matching ingress NAPTR.  The SPPP protocol allows a client to add, get and delete egress route objects based on a given peer's ingress route group.
           
</p>
<p>
            An egress route is of type EgrRteType as shown below:
          
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  &lt;complexType name="EgrRteType"&gt;
    &lt;sequence&gt;
      &lt;element name="base" type="spppb:BasicObjType"/&gt;
      &lt;element name="egrRteName" type="spppb:ObjNameType"/&gt;
      &lt;element name="pref" type="unsignedShort"/&gt;
      &lt;element name="svcs" type="string"/&gt;
      &lt;element name="regxRewriteRule" type="spppb:RegexParamType"/&gt;
      &lt;element name="ingressRte" type="spppb:ObjKeyType" minOccurs="0"/&gt;
      &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>The EgrRteType object is composed of the following elements:
                    </p>
<ul class="text">
<li>
                            base:  As described in previous sections, most objects contain exactly one instance of BasicObjType which contains the ID of the registrant organization that owns this object and the ID of the registrar organization that provisioned this object.
                        
</li>
<li>
                            egrRteName:  The name of the egress route.
                        
</li>
<li>
                            pref:  
                        
</li>
<li>
                            svcs:  The ENUM services that the egress route should be used for if the route record is a NAPTR.
                        
</li>
<li>
                            regxRewriteRule:  The regular expression re-write rule that should be applied to the regular expression of the ingress NAPTR(s) that belong to the ingress route and that have the given ENUM service (ere + repl).
                        
</li>
<li>
                            ingressRte:  The ingress route  group name that the egress route should be used for.
                        
</li>
<li>
                            ext:  Point of extensibility described in a previous section of this document.
                        
</li>
</ul><p>
            
           
          
</p>
<a name="addEgressRte"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.8.1"></a><h3>8.8.1.&nbsp;
Add Egress Route</h3>

<p>
            addEgrRtesRqst operation is used to create or overwrite one or more egress routes.
          
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  &lt;element name="addEgrRtesRqst" type="spppb:AddEgrRtesRqstType"/&gt;
  &lt;complexType name="AddEgrRtesRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="egrRte" type="spppb:EgrRteType"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="EgrRteType"&gt;
    &lt;sequence&gt;
      &lt;element name="base" type="spppb:BasicObjType"/&gt;
      &lt;element name="egrRteName" type="spppb:ObjNameType"/&gt;
      &lt;element name="pref" type="unsignedShort"/&gt;
      &lt;element name="svcs" type="string"/&gt;
      &lt;element name="regxRewriteRule" type="spppb:RegexParamType"/&gt;
      &lt;element name="ingressRte" type="spppb:ObjKeyType" minOccurs="0"/&gt;
      &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

</pre></div><p>

                
</p>
<p>
        addEgrRtesRqst is added in the spppRequest root element in order to send a valid request to the server. A limitation on the maximum number of EgrRteType is enforced by the registry and will vary from one implementation to the next.
        
</p>
<p>
          The response from the server is returned in addEgrRtesRspns element, which is defined as the element of type BasicRspnsType.
        
</p>
<a name="getEgressRte"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.8.2"></a><h3>8.8.2.&nbsp;
Get Egress Route</h3>

<p>
            The getEgrRtesRqst is used by an authorized entity to fetch the well-known egress route data.
          
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  &lt;element name="getEgrRtesRqst" type="spppb:GetEgrRtesRqstType"/&gt;
  &lt;complexType name="GetEgrRtesRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="objectKey" type="spppb:ObjKeyType"
            minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;

</pre></div><p>

                
</p>
<a name="delEgressRte"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.8.3"></a><h3>8.8.3.&nbsp;
Delete Egress Route</h3>

<p>
            delEgressRte is used by authorized entities to remove a well-know route.
          
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  &lt;element name="delEgrRtesRqst" type="spppb:DelEgrRtesRqstType"/&gt;
  &lt;complexType name="DelEgrRtesRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="objectKey" type="spppb:ObjKeyType"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;

</pre></div><p>

                
</p>
<a name="securityconsiderations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Considerations</h3>

<p>
                        The transport protocol section contains some security properties that the transport protocol must provide so that authenticated endpoints can exchange data confidentially and with integrity protection.
                
</p>
<p>
                        More details will be provided in a future revision of this document.
                
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
IANA Considerations</h3>

<p> 
				This document uses URNs to describe XML namespaces and XML schemas conforming to a registry mechanism described in <a class='info' href='#RFC3688'>[RFC3688]<span> (</span><span class='info'>Mealling, M., &ldquo;The IETF XML Registry,&rdquo; January&nbsp;2004.</span><span>)</span></a>.  
			
</p>
<p>
				Two URI assignments are requested.
				<br />
<br />

				Registration request for the SPPP XML namespace:
				<br />

				urn:ietf:params:xml:ns:sppp:base:1
				<br />

				Registrant Contact: IESG
				<br />

				XML: None.  Namespace URIs do not represent an XML specification.
			
</p>
<p>
                        Registration request for the XML schema:
                        <br />

                        URI: urn:ietf:params:xml:schema:sppp:1
                        <br />

                        Registrant Contact: IESG
                        <br />

                        XML: See the "Formal Specification" section of this document (<a class='info' href='#formalspecification'>Section&nbsp;11<span> (</span><span class='info'>Formal Specification</span><span>)</span></a>).
                
</p>
<a name="formalspecification"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Formal Specification</h3>

<p>
                        This section provides the draft XML Schema Definition for the SPPP protocol.  Please read <a class='info' href='#openisssues'>Section&nbsp;3.4<span> (</span><span class='info'>Known Issues and Current Limitations of the Data Model</span><span>)</span></a> for known issues.
                
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>


&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;schema xmlns:spppb="urn:ietf:params:xml:ns:sppp:base:1"
  xmlns="http://www.w3.org/2001/XMLSchema"
  targetNamespace="urn:ietf:params:xml:ns:sppp:base:1"
  elementFormDefault="qualified" xml:lang="EN"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt; ------------------ Object Type Definitions
      -------------- &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;complexType name="RteGrpType"&gt;
    &lt;sequence&gt;
      &lt;element name="base" type="spppb:BasicObjType"/&gt;
      &lt;element name="rteGrpName" type="spppb:ObjNameType"/&gt;
      &lt;element name="rteRec" type="spppb:RteRecType" minOccurs="0"
        maxOccurs="unbounded"/&gt;
      &lt;element name="dgName" type="spppb:ObjNameType" minOccurs="0"
        maxOccurs="unbounded"/&gt;
      &lt;element name="peeringOrg" type="spppb:OrgIdType" minOccurs="0"
        maxOccurs="unbounded"/&gt;
      &lt;element name="sourceIdent" type="spppb:SourceIdentType"
        minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;element name="isInSvc" type="boolean"/&gt;
      &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;complexType name="DestGrpType"&gt;
    &lt;sequence&gt;
      &lt;element name="base" type="spppb:BasicObjType"/&gt;
      &lt;element name="dgName" type="spppb:ObjNameType"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;complexType name="PubIdType" abstract="true"&gt;
    &lt;sequence&gt;
      &lt;element name="base" type="spppb:BasicObjType"/&gt;
      &lt;element name="dgName" type="spppb:ObjNameType" minOccurs="0"/&gt;
      &lt;element name="rteRec" type="spppb:RteRecType" minOccurs="0"
        maxOccurs="unbounded"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;complexType name="EmailType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:PubIdType"&gt;
        &lt;sequence&gt;
          &lt;element name="email" type="string"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="TNType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:PubIdType"&gt;
        &lt;sequence&gt;
          &lt;element name="tn" type="string"/&gt;
          &lt;element name="corClaim" type="spppb:CORInfoType"
            minOccurs="0"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="TNRType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:TNType"&gt;
        &lt;sequence&gt;
          &lt;element name="endTn" type="string"/&gt;
          &lt;element name="corClaim" type="spppb:CORInfoType"
            minOccurs="0"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="RNType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:PubIdType"&gt;
        &lt;sequence&gt;
          &lt;element name="rn" type="string" default="true"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="NAPTRType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:RteRecType"&gt;
        &lt;sequence&gt;
          &lt;element name="order" type="unsignedShort"/&gt;
          &lt;element name="pref" type="unsignedShort"/&gt;
          &lt;element name="flags" type="string" minOccurs="0"/&gt;
          &lt;element name="svcs" type="string"/&gt;
          &lt;element name="regx" type="spppb:RegexParamType"
            minOccurs="0"/&gt;
          &lt;element name="repl" type="string" minOccurs="0"/&gt;
          &lt;element name="ttl" type="positiveInteger" minOccurs="0"/&gt;
          &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="NSType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:RteRecType"&gt;
        &lt;sequence&gt;
          &lt;element name="hostName" type="string"/&gt;
          &lt;element name="ipAddr" type="spppb:IPAddrType" minOccurs="0"
            maxOccurs="unbounded"/&gt;
          &lt;element name="ttl" type="positiveInteger" minOccurs="0"/&gt;
          &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="URIType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:RteRecType"&gt;
        &lt;sequence&gt;
          &lt;element name="ere" type="string" default="^(.*)$"/&gt;
          &lt;element name="uri" type="string"/&gt;
          &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="RteGrpOfferType"&gt;
    &lt;sequence&gt;
      &lt;element name="base" type="spppb:BasicObjType"/&gt;
      &lt;element name="rteGrpOfferKey" type="spppb:RteGrpOfferKeyType"/&gt;
      &lt;element name="status" type="spppb:RteGrpOfferStatusType"/&gt;
      &lt;element name="offerDateTime" type="dateTime"/&gt;
      &lt;element name="acceptDateTime" type="dateTime" minOccurs="0"/&gt;
      &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;complexType name="EgrRteType"&gt;
    &lt;sequence&gt;
      &lt;element name="base" type="spppb:BasicObjType"/&gt;
      &lt;element name="egrRteName" type="spppb:ObjNameType"/&gt;
      &lt;element name="pref" type="unsignedShort"/&gt;
      &lt;element name="svcs" type="string"/&gt;
      &lt;element name="regxRewriteRule" type="spppb:RegexParamType"/&gt;
      &lt;element name="ingressRte" type="spppb:ObjKeyType" minOccurs="0"/&gt;
      &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;annotation&gt;
    &lt;documentation&gt; ------------------ Abstract Object and Element
      Type Definitions -------------- &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;complexType name="BasicObjType"&gt;
    &lt;sequence&gt;
      &lt;element name="rantId" type="spppb:OrgIdType"/&gt;
      &lt;element name="rarId" type="spppb:OrgIdType"/&gt;
      &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;complexType name="RteRecType" abstract="true"&gt;
    &lt;sequence&gt;
      &lt;element name="priority" type="positiveInteger" default="100"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;complexType name="RegexParamType"&gt;
    &lt;sequence&gt;
      &lt;element name="ere" type="string" default="^(.*)$"/&gt;
      &lt;element name="repl" type="string"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;simpleType name="OrgIdType"&gt;
    &lt;restriction base="string"/&gt;
  &lt;/simpleType&gt;
  &lt;simpleType name="ObjNameType"&gt;
    &lt;restriction base="string"/&gt;
  &lt;/simpleType&gt;
  &lt;simpleType name="TransIdType"&gt;
    &lt;restriction base="string"/&gt;
  &lt;/simpleType&gt;
  &lt;simpleType name="MinorVerType"&gt;
    &lt;restriction base="unsignedLong"/&gt;
  &lt;/simpleType&gt;
  &lt;complexType name="ObjKeyType"&gt;
    &lt;sequence&gt;
      &lt;element name="rantId" type="spppb:OrgIdType"/&gt;
      &lt;element name="name" type="spppb:ObjNameType"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;complexType name="RteGrpOfferKeyType"&gt;
    &lt;sequence&gt;
      &lt;element name="rteGrpKey" type="spppb:ObjKeyType"/&gt;
      &lt;element name="offeredTo" type="spppb:OrgIdType"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;complexType name="BasicRqstType"&gt;
    &lt;sequence&gt;
      &lt;element name="clientTransId" type="spppb:TransIdType"
        minOccurs="0"/&gt;
      &lt;element name="minorVer" type="spppb:MinorVerType" minOccurs="0"/&gt;
      &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;complexType name="BasicRspnsType"&gt;
    &lt;sequence&gt;
      &lt;element name="clientTransId" type="spppb:TransIdType"
        minOccurs="0"/&gt;
      &lt;element name="serverTransId" type="spppb:TransIdType"/&gt;
      &lt;element name="resCode" type="int"/&gt;
      &lt;element name="resMsg" type="string"/&gt;
      &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
    &lt;/sequence&gt;
    &lt;attribute name="clientTransId" type="spppb:TransIdType"/&gt;
    &lt;attribute name="serverTransId" type="spppb:TransIdType"/&gt;
  &lt;/complexType&gt;
  &lt;complexType name="IPAddrType"&gt;
    &lt;sequence&gt;
      &lt;element name="addr" type="string"/&gt;
      &lt;element name="type" type="spppb:IPType"/&gt;
      &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;simpleType name="IPType"&gt;
    &lt;restriction base="token"&gt;
      &lt;enumeration value="IPv4"/&gt;
      &lt;enumeration value="IPv6"/&gt;
    &lt;/restriction&gt;
  &lt;/simpleType&gt;
  &lt;complexType name="SourceIdentType"&gt;
    &lt;sequence&gt;
      &lt;element name="sourceIdentLabel" type="string"/&gt;
      &lt;element name="sourceIdentScheme"
        type="spppb:SourceIdentSchemeType"/&gt;
      &lt;element name="ext" type="spppb:ExtAnyType" minOccurs="0"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;simpleType name="SourceIdentSchemeType"&gt;
    &lt;restriction base="token"&gt;
      &lt;enumeration value="uri"/&gt;
      &lt;enumeration value="ip"/&gt;
      &lt;enumeration value="rootDomain"/&gt;
    &lt;/restriction&gt;
  &lt;/simpleType&gt;
  &lt;complexType name="CORInfoType"&gt;
    &lt;sequence&gt;
      &lt;element name="corClaim" type="boolean" default="true"/&gt;
      &lt;element name="corClaimApproved" type="boolean" default="false"
      /&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;complexType name="SvcMenuType"&gt;
    &lt;sequence&gt;
      &lt;element name="serverStatus" type="spppb:ServerStatusType"/&gt;
      &lt;element name="majMinVersion" type="string"
        maxOccurs="unbounded"/&gt;
      &lt;element name="objURI" type="anyURI" maxOccurs="unbounded"/&gt;
      &lt;element name="extURI" type="anyURI" minOccurs="0"
        maxOccurs="unbounded"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;simpleType name="ServerStatusType"&gt;
    &lt;restriction base="token"&gt;
      &lt;enumeration value="inService"/&gt;
      &lt;enumeration value="outOfService"/&gt;
    &lt;/restriction&gt;
  &lt;/simpleType&gt;
  &lt;simpleType name="RteGrpOfferStatusType"&gt;
    &lt;restriction base="token"&gt;
      &lt;enumeration value="offered"/&gt;
      &lt;enumeration value="accepted"/&gt;
    &lt;/restriction&gt;
  &lt;/simpleType&gt;
  &lt;complexType name="ExtAnyType"&gt;
    &lt;sequence&gt;
      &lt;any namespace="##other" maxOccurs="unbounded"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;annotation&gt;
    &lt;documentation&gt; -------------- Operation Request and Response
      Object Type Definitions ------------ &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;complexType name="AddRteGrpsRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="rteGrp" type="spppb:RteGrpType"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="DelRteGrpsRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="objectKey" type="spppb:ObjKeyType"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetRteGrpsRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="objectKey" type="spppb:ObjKeyType"
            minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetRteGrpsRspnsType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRspnsType"&gt;
        &lt;sequence&gt;
          &lt;element name="rteGrp" type="spppb:RteGrpType" minOccurs="0"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="AddDestGroupsRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="destGrp" type="spppb:DestGrpType"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="DelDestGroupsRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="objectKey" type="spppb:ObjKeyType"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetDestGroupsRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="objectKey" type="spppb:ObjKeyType"
            minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetDestGroupsRspnsType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRspnsType"&gt;
        &lt;sequence&gt;
          &lt;element name="destGrp" type="spppb:DestGrpType"
            minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="AddPubIdsRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="pi" type="spppb:PubIdType"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="DelPubIdsRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="pi" type="spppb:PubIdType"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetPubIdsRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="pi" type="spppb:PubIdType" minOccurs="0"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetPubIdsRspnsType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRspnsType"&gt;
        &lt;sequence&gt;
          &lt;element name="pi" type="spppb:PubIdType" minOccurs="0"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="AddRteGrpOffersRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="rteGrpOffer" type="spppb:RteGrpOfferType"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="DelRteGrpOffersRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="rteGrpOfferKey"
            type="spppb:RteGrpOfferKeyType" maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="AcceptRteGrpOffersRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="rteGrpOfferKey"
            type="spppb:RteGrpOfferKeyType" maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="RejectRteGrpOffersRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="rteGrpOfferKey"
            type="spppb:RteGrpOfferKeyType" maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetRteGrpOffersRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="offeredByPeers" type="boolean" minOccurs="0"/&gt;
          &lt;element name="offeredToPeers" type="boolean" minOccurs="0"/&gt;
          &lt;element name="status" type="spppb:RteGrpOfferStatusType"
            minOccurs="0"/&gt;
          &lt;element name="peeringOrg" type="spppb:OrgIdType"
            minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;element name="rteGrpOfferKey"
            type="spppb:RteGrpOfferKeyType" minOccurs="0"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetRteGrpOffersRspnsType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRspnsType"&gt;
        &lt;sequence&gt;
          &lt;element name="rteGrpOffer" type="spppb:RteGrpOfferType"
            minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="AddEgrRtesRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="egrRte" type="spppb:EgrRteType"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="DelEgrRtesRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="objectKey" type="spppb:ObjKeyType"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetEgrRtesRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"&gt;
        &lt;sequence&gt;
          &lt;element name="objectKey" type="spppb:ObjKeyType"
            minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetEgrRtesRspnsType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRspnsType"&gt;
        &lt;sequence&gt;
          &lt;element name="rteGrp" type="spppb:RteGrpType" minOccurs="0"
            maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetSvcMenuRqstType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRqstType"/&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="GetSvcMenuRspnsType"&gt;
    &lt;complexContent&gt;
      &lt;extension base="spppb:BasicRspnsType"&gt;
        &lt;sequence&gt;
          &lt;element name="svcMenu" type="spppb:SvcMenuType"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;annotation&gt;
    &lt;documentation&gt; -------------- Operation Request and Response
      Element Definitions ------------ &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;annotation&gt;
    &lt;documentation&gt; -------------- Manage Route Groups
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;element name="addRteGrpsRqst" type="spppb:AddRteGrpsRqstType"/&gt;
  &lt;element name="delRteGrpsRqst" type="spppb:DelRteGrpsRqstType"/&gt;
  &lt;element name="getRteGrpsRqst" type="spppb:GetRteGrpsRqstType"/&gt;
  &lt;element name="addRteGrpsRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="delRteGrpsRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="getRteGrpsRspns" type="spppb:GetRteGrpsRspnsType"/&gt;
  &lt;annotation&gt;
    &lt;documentation&gt; -------------- Manage Destination Groups
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;element name="addDestGroupsRqst" type="spppb:AddDestGroupsRqstType"/&gt;
  &lt;element name="delDestGroupsRqst" type="spppb:DelDestGroupsRqstType"/&gt;
  &lt;element name="getDestGroupsRqst" type="spppb:GetDestGroupsRqstType"/&gt;
  &lt;element name="addDestGroupsRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="delDestGroupsRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="getDestGroupsRspns"
    type="spppb:GetDestGroupsRspnsType"/&gt;
  &lt;annotation&gt;
    &lt;documentation&gt; -------------- Manage Public Identifiers
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;element name="addPubIdsRqst" type="spppb:AddPubIdsRqstType"/&gt;
  &lt;element name="delPubIdsRqst" type="spppb:DelPubIdsRqstType"/&gt;
  &lt;element name="getPubIdsRqst" type="spppb:GetPubIdsRqstType"/&gt;
  &lt;element name="addPubIdsRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="delPubIdsRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="getPubIdsRspns" type="spppb:GetPubIdsRspnsType"/&gt;
  &lt;annotation&gt;
    &lt;documentation&gt; -------------- Manage Route Group Offers
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;element name="addRteGrpOffersRqst"
    type="spppb:AddRteGrpOffersRqstType"/&gt;
  &lt;element name="delRteGrpOffersRqst"
    type="spppb:DelRteGrpOffersRqstType"/&gt;
  &lt;element name="acceptRteGrpOffersRqst"
    type="spppb:AcceptRteGrpOffersRqstType"/&gt;
  &lt;element name="rejectRteGrpOffersRqst"
    type="spppb:RejectRteGrpOffersRqstType"/&gt;
  &lt;element name="getRteGrpOffersRqst"
    type="spppb:GetRteGrpOffersRqstType"/&gt;
  &lt;element name="addRteGrpOffersRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="delRteGrpOffersRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="acceptRteGrpOffersRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="rejectRteGrpOffersRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="getRteGrpOffersRspns"
    type="spppb:GetRteGrpOffersRspnsType"/&gt;
  &lt;annotation&gt;
    &lt;documentation&gt; -------------- Manage Egress Routes
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;element name="addEgrRtesRqst" type="spppb:AddEgrRtesRqstType"/&gt;
  &lt;element name="delEgrRtesRqst" type="spppb:DelEgrRtesRqstType"/&gt;
  &lt;element name="getEgrRtesRqst" type="spppb:GetEgrRtesRqstType"/&gt;
  &lt;element name="addEgrRtesRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="delEgrRtesRspns" type="spppb:BasicRspnsType"/&gt;
  &lt;element name="getEgrRtesRspns" type="spppb:GetEgrRtesRspnsType"/&gt;
  &lt;annotation&gt;
    &lt;documentation&gt; -------------- Misc Operations &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;element name="getSvcMenuRqst" type="spppb:GetSvcMenuRqstType"/&gt;
  &lt;element name="getSvcMenuRspns" type="spppb:GetSvcMenuRspnsType"/&gt;
  &lt;annotation&gt;
    &lt;documentation&gt; -------- Generic Request and Response Definitions
      --------------- &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;element name="spppRequest"&gt;
    &lt;complexType&gt;
      &lt;sequence&gt;
        &lt;any maxOccurs="unbounded"/&gt;
      &lt;/sequence&gt;
      &lt;attribute name="transactional" type="boolean" use="optional"/&gt;
    &lt;/complexType&gt;
  &lt;/element&gt;
  &lt;element name="spppResponse"&gt;
    &lt;complexType&gt;
      &lt;sequence&gt;
        &lt;any maxOccurs="unbounded"/&gt;
      &lt;/sequence&gt;
    &lt;/complexType&gt;
  &lt;/element&gt;
&lt;/schema&gt;

</pre></div><p>


                
</p>
<a name="specificationextensibility"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Specification Extensibility</h3>

<p>
                        The protocol defined in this specification is extensible.  This section explains how to extend the protocol and what procedures are necessary to follow in order to ensure proper extensions.
                
</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Acknowledgments</h3>

<p>
                This document is a result of various discussions held in the DRINKS working group and within the DRINKS protocol design team, which is comprised of the following individuals, in alphabetical order: Deborah A Guyton (Telcordia), Sumanth Channabasappa (CableLabs), Jean-Francois Mule (CableLabs), Kenneth Cartwright (TNSI), Manjul Maharishi (TNSI), David Schwartz (XConnect), and the co-chairs Richard Shockey and Alexander Mayrhofer (enum.at GmbH).
                
</p>
<p>
                The authors of this document thank the following individuals for their advice, reviews and comments during the development of this protocol: Lisa Dusseault, "YOUR NAME HERE" -- send comments to drinks list.
                
                
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>14.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-drinks-sppp-over-soap">[I-D.ietf-drinks-sppp-over-soap]</a></td>
<td class="author-text">Cartwright, K., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-drinks-sppp-over-soap-00.txt">SPPP Over SOAP and HTTP</a>,&rdquo; draft-ietf-drinks-sppp-over-soap-00 (work in progress), June&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-drinks-sppp-over-soap-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2277">[RFC2277]</a></td>
<td class="author-text"><a href="mailto:Harald.T.Alvestrand@uninett.no">Alvestrand, H.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2277">IETF Policy on Character Sets and Languages</a>,&rdquo; BCP&nbsp;18, RFC&nbsp;2277, January&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2277.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2277.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2277.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2781">[RFC2781]</a></td>
<td class="author-text"><a href="mailto:phoffman@imc.org">Hoffman, P.</a> and <a href="mailto:fyergeau@alis.com">F. Yergeau</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2781">UTF-16, an encoding of ISO 10646</a>,&rdquo; RFC&nbsp;2781, February&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2781.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3629">[RFC3629]</a></td>
<td class="author-text">Yergeau, F., &ldquo;<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>,&rdquo; STD&nbsp;63, RFC&nbsp;3629, November&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3629.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3688">[RFC3688]</a></td>
<td class="author-text">Mealling, M., &ldquo;<a href="http://tools.ietf.org/html/rfc3688">The IETF XML Registry</a>,&rdquo; BCP&nbsp;81, RFC&nbsp;3688, January&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3688.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3986">[RFC3986]</a></td>
<td class="author-text"><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com">Fielding, R.</a>, and <a href="mailto:LMM@acm.org">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>,&rdquo; STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3986.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3986.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3986.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>14.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-drinks-usecases-requirements">[I-D.ietf-drinks-usecases-requirements]</a></td>
<td class="author-text">Channabasappa, S., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-drinks-usecases-requirements-03.txt">DRINKS Use cases and Protocol Requirements</a>,&rdquo; draft-ietf-drinks-usecases-requirements-03 (work in progress), May&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-drinks-usecases-requirements-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2821">[RFC2821]</a></td>
<td class="author-text">Klensin, J., &ldquo;<a href="http://tools.ietf.org/html/rfc2821">Simple Mail Transfer Protocol</a>,&rdquo; RFC&nbsp;2821, April&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc2821.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3261">[RFC3261]</a></td>
<td class="author-text">Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>,&rdquo; RFC&nbsp;3261, June&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3261.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3761">[RFC3761]</a></td>
<td class="author-text">Faltstrom, P. and M. Mealling, &ldquo;<a href="http://tools.ietf.org/html/rfc3761">The E.164 to Uniform Resource Identifiers (URI) Dynamic Delegation Discovery System (DDDS) Application (ENUM)</a>,&rdquo; RFC&nbsp;3761, April&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3761.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4725">[RFC4725]</a></td>
<td class="author-text">Mayrhofer, A. and B. Hoeneisen, &ldquo;<a href="http://tools.ietf.org/html/rfc4725">ENUM Validation Architecture</a>,&rdquo; RFC&nbsp;4725, November&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4725.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5486">[RFC5486]</a></td>
<td class="author-text">Malas, D. and D. Meyer, &ldquo;<a href="http://tools.ietf.org/html/rfc5486">Session Peering for Multimedia Interconnect (SPEERMINT) Terminology</a>,&rdquo; RFC&nbsp;5486, March&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5486.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jean-Francois Mule</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">CableLabs</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">858 Coal Creek Circle</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Louisville, CO  80027</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jfm@cablelabs.com">jfm@cablelabs.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Kenneth Cartwright</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">TNS</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1939 Roland Clarke Place</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Reston, VA  20191</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:kcartwright@tnsi.com">kcartwright@tnsi.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Syed Wasim Ali</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NeuStar</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">46000 Center Oak Plaza</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sterling, VA  20166</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:syed.ali@neustar.biz">syed.ali@neustar.biz</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Alexander Mayrhofer</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">enum.at GmbH</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Karlsplatz 1/9</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Wien,   A-1010</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Austria</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:alexander.mayrhofer@enum.at">alexander.mayrhofer@enum.at</a></td></tr>
</table>
</body></html>
