Network Working Group                                         Lou Berger
Internet Draft                                      LabN Consulting, LLC
Expiration Date: March 2000
                                                             Der-Hwa Gan
                                                  Juniper Networks, Inc.

                                                          George Swallow
                                                     Cisco Systems, Inc.

                                                                Ping Pan
                                                       Bell Labs, Lucent

                                                          September 1999


                   RSVP Refresh Reduction Extensions


                 draft-ietf-rsvp-refresh-reduct-00.txt

Status of this Memo

   This document is an Internet-Draft and is in full conformance with
   all provisions of Section 10 of RFC2026.  Internet-Drafts are working
   documents of the Internet Engineering Task Force (IETF), its areas,
   and its working groups.  Note that other groups may also distribute
   working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.ht

Abstract

   This document describes a number of mechanisms that reduce the
   refresh overhead of RSVP.  The extensions can be used to reduce
   processing requirements of refresh messages, eliminate the state
   synchronization latency incurred when an RSVP message is lost and,
   when desired, refreshing state without the transmission of whole
   refresh messages.  These extension present no backwards compatibility
   issues.





Berger, et al.                                                  [Page 1]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


Contents

 1      Introduction and Background  ...............................   3
 1.1    Trigger and Refresh Messages  ..............................   4
 2      RSVP Bundle Message  .......................................   4
 2.1    Bundle Header  .............................................   5
 2.2    Message Formats  ...........................................   6
 2.3    Sending RSVP Bundle Messages  ..............................   6
 2.4    Receiving RSVP Bundle Messages  ............................   7
 2.5    Forwarding RSVP Bundle Messages  ...........................   8
 2.6    Bundle-Capable Bit  ........................................   8
 3      MESSAGE_ID Extension  ......................................   9
 3.1    MESSAGE_ID and MESSAGE_ID ACK Objects  .....................  10
 3.2    Ack Message Format  ........................................  11
 3.3    MESSAGE_ID Object Usage  ...................................  12
 3.4    MESSAGE_ID ACK Object Usage  ...............................  14
 3.5    Multicast Considerations  ..................................  14
 3.5.1  Reference RSVP/Routing Interface  ..........................  16
 3.6    Compatibility  .............................................  16
 4      Summary Refresh Extension  .................................  17
 4.1    MESSAGE_ID LIST, SRC_LIST and MCAST_LIST Objects  ..........  18
 4.2    Srefresh Message Format  ...................................  22
 4.3    Srefresh Message Usage  ....................................  23
 4.4    Srefresh NACK  .............................................  25
 4.5    Compatibility  .............................................  26
 5      Reference Exponential Back-Off Procedures  .................  26
 5.1    Outline of Operation  ......................................  26
 5.2    Time Parameters  ...........................................  27
 5.3    Example Retransmission Algorithm  ..........................  28
 6      Acknowledgments  ...........................................  29
 7      Security Considerations  ...................................  29
 8      References  ................................................  29
 9      Authors' Addresses  ........................................  30





Berger, et al.                                                  [Page 2]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


1. Introduction and Background

   The resource requirements (in terms of CPU processing and memory) for
   running RSVP on a router increases proportionally with the number of
   sessions.  Supporting a large number of sessions can present scaling
   problems.

   This document describes mechanisms to help alleviate one set of scal-
   ing issues.  RSVP Path and Resv messages must be periodically
   refreshed to maintain state.  The approach described effectively
   reduces the volume of messages which must be periodically sent and
   received, as well as the resources required to process refresh mes-
   sages.

   The described mechanisms also address issues of latency and reliabil-
   ity of RSVP Signaling.  The latency and reliability problem occurs
   when a non-refresh RSVP message is lost in transmission.  Standard
   RSVP [RFC2205] maintains state via the generation of RSVP refresh
   messages.  In the face of transmission loss of RSVP messages, the
   end-to-end latency of RSVP signaling is tied to the refresh interval
   of the node(s) experiencing the loss.  When end-to-end signaling is
   limited by the refresh interval, the establishment or change of a
   reservation may be beyond the range of what is acceptable for some
   applications.

   One way to address the refresh volume problem is to increase the
   refresh period, "R" as defined in Section 3.7 of [RFC2205].  Increas-
   ing the value of R provides linear improvement on transmission over-
   head, but at the cost of increasing the time it takes to synchronize
   state.

   One way to address the latency and reliability of RSVP Signaling is
   to decrease the refresh period R.  Decreasing the value of R provides
   increased probability that state will be installed in the face of
   message loss, but at the cost of increasing refresh message rate and
   associated processing requirements.

   An additional issue is the time to deallocate resources after a tear
   message is lost.  RSVP does not retransmit ResvTear or PathTear mes-
   sages.  If the sole tear message transmitted is lost, then resources
   will only be deallocated once the "cleanup timer" interval has
   passed.  This may result in resources being allocated for an unneces-
   sary period of time.  Note that adjusting the refresh period has no
   impact on this issues since tear messages are not retransmitted.

   The extensions defined in this document address both the refresh vol-
   ume and the reliability issues with mechanisms other than adjusting
   refresh rate.  A Bundle message is defined to reduce overall message



Berger, et al.                                                  [Page 3]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   handling load.  A MESSAGE_ID object is defined to reduce refresh mes-
   sage processing by allowing the receiver to more readily identify an
   unchanged message.  A MESSAGE_ACK object is defined which can be used
   to detect message loss and, when used in combination with the MES-
   SAGE_ID object, can be used to suppress refresh messages altogether.
   A summary refresh message is defined to enable  refreshing  state
   without the transmission of whole refresh messages, while maintaining
   RSVP's ability to indicate when state is lost or when next hops
   change.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].


1.1. Trigger and Refresh Messages

   This document categorizes RSVP messages into two types: trigger and
   refresh messages.  Trigger messages are those RSVP messages that
   advertise state or any other information not previously transmitted.
   Trigger messages include messages advertising new state, a route
   change that altered the reservation paths, or a reservation modifica-
   tion by a downstream router.  Trigger messages also include those
   messages that include changes in non-RSVP processed objects, such as
   changes  in the Policy or ADSPEC objects.

   Refresh messages represent previously advertised state and contain
   exactly the same objects and same information as a previously trans-
   mitted message.  Only Path and Resv messages can be refresh messages.
   Refresh messages are typically bit for bit identical to the corre-
   sponding previously transmitted message, with the exception of the
   the INTEGRITY object and the flags in the MESSAGE_ID object.  These
   flags and the INTEGRITY object are allowed to differ in refresh mes-
   sages.


2. RSVP Bundle Message

   An RSVP Bundle message consists of a bundle header followed by a body
   consisting of a variable number of standard RSVP messages.  A Bundle
   message is used to aggregated multiple RSVP messages within a single
   PDU.  The term "bundling" is used to avoid confusion with RSVP reser-
   vation aggregation.  The following subsections define the formats of
   the bundle header and the rules for including standard RSVP messages
   as part of the message.






Berger, et al.                                                  [Page 4]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


2.1. Bundle Header


       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Vers  | Flags |   Msg type    |         RSVP checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The format of the bundle header is identical to the format of the
   RSVP common header [RFC2205].  The fields in the header are as fol-
   lows:

      Vers: 4 bits

         Protocol version number.  This is version 1.

      Flags: 4 bits

         0x01: Bundle capable

           If set, indicates to RSVP neighbors that this node is willing
           and capable of receiving bundle messages.  This bit is mean-
           ingful only between adjacent RSVP neighbors.

         0x02-0x08: Reserved

      Msg type: 8 bits

         12 = Bundle

      RSVP checksum: 16 bits

         The one's complement of the one's complement sum of the entire
         message, with the checksum field replaced by zero for the pur-
         pose of computing the checksum.  An all-zero value means that
         no checksum was transmitted.  Because individual sub-messages
         carry their own checksum as well as the INTEGRITY object for
         authentication, this field MAY be set to zero.

      Send_TTL: 8 bits

         The IP TTL value with which the message was sent.  This is used
         by RSVP to detect a non-RSVP hop by comparing the IP TTL that a
         Bundle message sent to the TTL in the received message.




Berger, et al.                                                  [Page 5]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


      RSVP length: 16 bits

         The total length of this RSVP Bundle message in bytes, includ-
         ing the bundle header and the sub-messages that follow.


2.2. Message Formats

   An RSVP Bundle message must contain at least one sub-message.  A sub-
   message MAY be any message type except for another Bundle message.
   Current valid sub-messages are RSVP Path, PathTear, PathErr, Resv,
   ResvTear, ResvErr, ResvConf or Ack

   Empty RSVP Bundle messages SHOULD NOT be sent.  A Bundle message MUST
   NOT include another RSVP Bundle message as a sub-message.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Vers  | Flags |    12         |         RSVP checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                   First sub-message                         //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                   More sub-messages..                       //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


2.3. Sending RSVP Bundle Messages

   RSVP Bundle messages are sent hop by hop between RSVP-capable neigh-
   bors as "raw" IP datagrams with protocol number 46.  Raw IP datagrams
   are also intended to be used between an end system and the first/last
   hop router, although it is also possible to encapsulate RSVP messages
   as UDP datagrams for end-system communication that cannot perform raw
   network I/O.

   RSVP Bundle messages MUST not be used if the next hop RSVP neighbor
   does not support RSVP Bundle messages.  Methods for discovering such
   information include: (1) manual configuration and (2) observing the
   Bundle-capable bit (see the description that follows) in the received
   RSVP messages.  If the next hop RSVP neighbor is not known or changes
   in next hops cannot be identified via routing, Bundle messages MUST



Berger, et al.                                                  [Page 6]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   NOT be sent.  Note that when the routing next hop is not RSVP capable
   it will typically not be possible to identify changes in next hop.

   Support for RSVP Bundle messages is optional.  While message bundling
   helps in scaling RSVP, and in reducing processing overhead and band-
   width consumption, a node is not required to transmit every standard
   RSVP message in a Bundle message.  A node MUST always be ready to
   receive standard RSVP messages.

   The IP source address is local to the system that originated the Bun-
   dle message.  The IP destination address is the next hop node for
   which the sub-messages are intended.  These addresses need not be
   identical to those used if the sub-messages were sent as standard
   RSVP messages.

   For example, the IP source address of Path and PathTear messages is
   the address of the sender it describes, while the IP destination
   address is the DestAddress for the session.  These end-to-end
   addresses are overridden by hop-by-hop addresses while encapsulated
   in a Bundle message.  These addresses can easily be restored from the
   SENDER_TEMPLATE and SESSION objects within Path and PathTear mes-
   sages.  For Path and PathTear messages, the next hop node can be
   identified either via a received ACK or from a received corresponding
   Resv message.  Path and PathTear messages for multicast sessions MUST
   NOT be sent in Bundle messages except when the outgoing link is a
   point-to-point link and it is known that the next hop is RSVP capa-
   ble.

   RSVP Bundle messages SHOULD NOT be sent with the Router Alert IP
   option in their IP headers.  This is because Bundle messages are
   addressed directly to RSVP neighbors.

   Each RSVP Bundle message MUST occupy exactly one IP datagram.  If it
   exceeds the MTU, the datagram is fragmented by IP and reassembled at
   the recipient node.  A single RSVP Bundle message MUST NOT exceed the
   maximum IP datagram size, which is approximately 64K bytes.


2.4. Receiving RSVP Bundle Messages

   If the local system does not recognize or does not wish to accept an
   Bundle message, the received messages shall be discarded without fur-
   ther analysis.

   The receiver next compares the IP TTL with which a Bundle message is
   sent to the TTL with which it is received.  If a non-RSVP hop is
   detected, the number of non-RSVP hops is recorded.  It is used later
   in processing of sub-messages.



Berger, et al.                                                  [Page 7]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   Next, the receiver verifies the version number and checksum of the
   RSVP Bundle message and discards the message if any mismatch is
   found.

   The receiver then starts decapsulating individual sub-messages.  Each
   sub-message has its own complete message length and authentication
   information.  Each sub-message is processed as if it was received
   individually.


2.5. Forwarding RSVP Bundle Messages

   When an RSVP router receives a Bundle messages which is not addressed
   to one of it's IP addresses, it SHALL forward the message.  Non-RSVP
   routers will treat RSVP Bundle messages as any other IP datagram.


2.6. Bundle-Capable Bit


   To support message bundling, an additional capability bit is added to
   the common RSVP header, which is defined in [RFC2205].

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Vers | Flags |   Msg Type    |         RSVP Checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP Length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Flags: 4 bits

         0x01: Bundle capable

           If set, indicates to RSVP neighbors that this node is willing
           and capable of receiving Bundle messages.  This bit is mean-
           ingful only between adjacent RSVP neighbors.













Berger, et al.                                                  [Page 8]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


3. MESSAGE_ID Extension

   Two new objects are defined as part of the MESSAGE_ID extension.  The
   two object types are the MESSAGE_ID object and the MESSAGE_ID ACK
   object.  The objects are used to support acknowledgments.  When
   refreshes are normally generated, the MESSAGE_ID object can also be
   used to simply provide a shorthand indication of when a message rep-
   resents new state.  Such information can be used on the receiving
   node to reduce refresh processing requirements.

   Message identification and acknowledgment is done on a hop-by-hop
   basis.  Acknowledgment is handled independent of SESSION or message
   type.  Both types of MESSAGE_ID objects contain a message identifier.
   The identifier MUST be unique on a per source IP address basis across
   messages sent by an RSVP node and received by a particular node.  No
   more than one MESSAGE_ID object may be included in an RSVP message.
   Each message containing an MESSAGE_ID object may be acknowledged via
   a MESSAGE_ID ACK object.  MESSAGE_ID ACK objects may be sent piggy-
   backed in unrelated RSVP messages or in RSVP Ack messages.

   Either type of MESSAGE_ID object may be included in a bundle sub-mes-
   sage.  When included, the object is treated as if it were contained
   in a standard, unbundled, RSVP message.  Only one MESSAGE_ID object
   MAY be included in a (sub)message and it MUST follow any present MES-
   SAGE_ID ACK objects.  When no MESSAGE_ID ACK objects are present, the
   MESSAGE_ID object MUST immediately follow the INTEGRITY object.  When
   no INTEGRITY object is present, the MESSAGE_ID object MUST immedi-
   ately follow the (sub)message header.

   When present, one or more MESSAGE_ID ACK objects MUST immediately
   follow the INTEGRITY object.  When no INTEGRITY object is present,
   the MESSAGE_ID ACK objects MUST immediately follow the the (sub)mes-
   sage header.  An MESSAGE_ID ACK object may only be included in a mes-
   sage when the message's IP destination address matches the unicast
   address of the node that generated the message(s) being acknowledged.
















Berger, et al.                                                  [Page 9]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


3.1. MESSAGE_ID and MESSAGE_ID ACK Objects


   MESSAGE_ID Class = 166 (Value to be assigned by IANA of form
   10bbbbbb)

   MESSAGE_ID object

      Class = MESSAGE_ID Class, C_Type = 1

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Flags     |                      Epoch                    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Message_ID                         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

         Flags: 8 bits

            0x80 = Summary_Capable flag

             Indicates that the sender supports the summary refresh
             extension.  This flag MUST be set if the node supports the
             summary refresh extension.  See Section 4.4 for description
             of handling by receiver.

            0x40 = ACK_Desired flag

             Indicates that the sender is willing to accept a message
             acknowledgment.  Acknowledgments MUST be silently ignored
             when they are sent in response to messages whose
             ACK_Desired flag is not set.

         Epoch: 24 bits

         A value that indicates when the Message_ID sequence has reset.
         SHOULD be randomly generated each time a node reboots.  This
         value MUST NOT be changed during normal operation.

         Message_ID: 32 bits

         When combined with the message generator's IP address, the Mes-
         sage_ID field uniquely identifies a message.  This field is
         ordered and only decreases in value when the Epoch changes or
         the value wraps.





Berger, et al.                                                 [Page 10]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   MESSAGE_ID ACK object

      Class = MESSAGE_ID Class, C_Type = 2

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Flags     |                      Epoch                    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Message_ID                         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

         Flags: 8 bits

            0x80 = Summary_Capable flag

             Indicates that the sender supports the summary refresh
             extension.  This flag MUST be set if the node supports the
             summary refresh extension.  See Section 4.4 for description
             of handling by receiver.

            0x40 = Refresh_NACK flag

             Indicates that no state was found corresponding to the
             indicated message identifier.  This flag SHALL ONLY be set
             when the matching Epoch and Message_ID field values were
             received in a Summary Refresh message, and MUST NOT be set
             in response to a MESSAGE_ID object received in any other
             message.  See Section 4 for details.

         Epoch: 24 bits

         The Epoch field copied from the message being acknowledged.

         Message_ID: 32 bits

         The Message_ID field copied from the message being acknowl-
         edged.


3.2. Ack Message Format

   Ack messages carry one or more MESSAGE_ID ACK objects.  They MUST NOT
   contain any MESSAGE_ID objects.  Ack messages are sent hop-by-hop
   between RSVP nodes.  The IP destination address of an Ack message is
   the unicast address of the node that generated the message(s) being
   acknowledged.  For Path, PathTear, Resv, and RervErr messages this is
   taken from the RSVP_HOP Object.  For PathErr and ResvErr messages



Berger, et al.                                                 [Page 11]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   this is taken from the message's source address.  The IP source
   address is an address of the node that sends the Ack message.

   The Ack message format is as follows:

     <ACK Message> ::= <Common Header> [ <INTEGRITY> ]
                           <MESSAGE_ID ACK>
                           [ <MESSAGE_ID ACK> ... ]

   For Ack messages, the Msg Type field of the Common Header MUST be set
   to 13 (Value to be assigned by IANA).


3.3. MESSAGE_ID Object Usage

   The MESSAGE_ID object may be included in any RSVP message other than
   the Ack message.  The MESSAGE_ID object is always generated and pro-
   cessed hop-by-hop.  The IP address of the object generator is repre-
   sented in a per RSVP message type specific fashion.  For Path and
   PathTear messages the generator's IP address is contained in the
   RSVP_HOP.  For Resv, ResvTear, PathErr, ResvErr, ResvConf and Bundle
   messages the generator's IP address is the source address in the IP
   header.  Note that MESSAGE_ID objects can be used in both a Bundle
   message and its sub-messages.  As is always the case with the Bundle
   message, each sub-message is processed as if it was received individ-
   ually.  This includes processing of MESSAGE_ID objects.

   The Epoch field contains a generator selected value.  The value is
   used to indicate when the sender resets the values used in the Mes-
   sage_ID field.  This information is used by the receiver to detect
   out of order messages.  On startup, a node SHOULD randomly select a
   value to be used in the Epoch field.  The node SHOULD ensure that the
   selected value is not the same as was used when the node was last
   operational.  The value MUST NOT be changed unless the node or the
   RSVP agent is restarted.

   The Message_ID field contains a generator selected value.  This
   value, when combined with the generator's IP address, identifies a
   particular RSVP message and the specific state information it repre-
   sents.  When a node is sending a refresh message with a MESSAGE_ID
   object, it SHOULD use the same Message_ID value that was used in the
   RSVP message that first advertised the state being refreshed.  When a
   node is sending a trigger message, the Message_ID value MUST have a
   value that is greater than any other previously used value.  A value
   is considered to have been used when it has been sent in any message
   using the associated IP address.  Note that this 32-bit value MAY
   wrap.




Berger, et al.                                                 [Page 12]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   The ACK_Desired flag is set when the MESSAGE_ID object generator is
   capable of accepting MESSAGE_ID ACK objects.  Such information can be
   used to ensure reliable delivery of error and confirm messages and to
   support fast refreshes in the face of network loss.  Nodes setting
   the ACK_Desired flag SHOULD retransmit unacknowledged messages at a
   more rapid interval than the standard refresh period until the mes-
   sage is acknowledged or until a "rapid" retry limit is reached.
   Rapid retransmission rate SHOULD be based on well known exponential
   back-off procedures.  See Section 5 for  details on one exponential
   back-off retransmission approach.  Note that nodes setting the
   ACK_Desired flag for unicast sessions, do not need to track the iden-
   tify of the next hop since all that is expected is an ACK, not an ACK
   from a specific next hop.  Issues relate to multicast sessions are
   covered in a later section.  The ACK_Desired flag will typically be
   set only in trigger messages.  The ACK_Desired flag MAY be set in
   refresh messages.

   Nodes processing incoming MESSAGE_ID objects SHOULD check to see if a
   newly received message is out of order and can be ignored.  Out of
   order messages can be identified by examining the values in the Epoch
   and Message_ID fields.  If the Epoch value differs from the value
   previously received from the message sender, the receiver MUST fully
   processes the message.  If the Epoch values match and the Message_ID
   value is greater than the largest value previously received from the
   sender, the receiver MUST fully processes the message.  If the value
   is less than the largest value previously received from the sender,
   then the receiver SHOULD check the value previously received for the
   state associated with the message.  This check should be performed
   for the currently defined messages: Path, Resv, PathTear, ResvTear,
   PathErr and ResvErr. If no local state information can be associated
   with the message, the receiver MUST fully processes the message.  If
   local state can be associated with the message and the received Mes-
   sage_ID value is less than the most recently received value associ-
   ated with the state, the message SHOULD be ignored, i.e., silently
   dropped.

   Nodes receiving messages containing MESSAGE_ID objects SHOULD use the
   information in the objects to aid in determining if a message repre-
   sents new state or a state refresh.  Note that state is only
   refreshed in Path and Resv messages.  If the received Epoch values
   differs from the value previously received from the message sender,
   the message is a trigger message and the receiver MUST fully pro-
   cesses the message.  If a Path or Resv message contains the same Mes-
   sage_ID value that was used in the most recently received message for
   the same session and, for Path messages, SENDER_TEMPLATE then the
   receiver SHOULD treat the message as a state refresh.  If the Mes-
   sage_ID value is grater than the most recently received value, the
   receiver MUST fully processes the message.  If the Message_ID value



Berger, et al.                                                 [Page 13]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   is less than the most recently received value, the receiver SHOULD
   ignore the message.

   Nodes receiving a non-out of order message containing a MESSAGE_ID
   object with the ACK_Desired flag set, SHOULD respond with a MES-
   SAGE_ID ACK object.  Note that MESSAGE_ID objects received in mes-
   sages containing errors, i.e., are not syntactically valid,  MUST NOT
   be acknowledged.  PathErr and ResvErr messages SHOULD be treated as
   implicit acknowledgments.


3.4. MESSAGE_ID ACK Object Usage

   The MESSAGE_ID ACK object is used to acknowledge receipt of messages
   containing MESSAGE_ID objects that were sent with the ACK_Desired
   flag set.  The Epoch and Message_ID fields of a MESSAGE_ID ACK object
   MUST have the same value as was received.  A MESSAGE_ID ACK object
   MUST NOT be generated in response to a received MESSAGE_ID object
   when the ACK_Desired flag is not set, except as noted in Section 4.3.

   A MESSAGE_ID ACK object MAY be sent in any RSVP message that has an
   IP destination address matching the generator of the associated MES-
   SAGE_ID object.  The MESSAGE_ID ACK object will not typically be
   included in the non hop-by-hop Path, PathTear and ResvConf messages.
   When no appropriate message is available, one or more MESSAGE_ID ACK
   objects SHOULD be sent in an Ack message.  Implementations SHOULD
   include MESSAGE_ID ACK objects in standard RSVP messages when possi-
   ble.

   MESSAGE_ID ACK objects received with the Refresh_NACK flag set MUST
   process the object as described in Section 4.3.  Upon receiving a
   MESSAGE_ID ACK object with the Refresh_NACK flag not set, a node
   SHOULD stop retransmitting the message at the "rapid" retry rate.


3.5. Multicast Considerations

   Path and PathTear messages may be sent to IP multicast destination
   addresses.  When the destination is a multicast address, it is possi-
   ble that a single message containing a single MESSAGE_ID object will
   be received by multiple RSVP next hops.  When the ACK_Desired flag is
   set in this case, acknowledgment processing is more complex.  There
   are a number of issues to be addressed including ACK implosion, num-
   ber acknowledgments to be expected and handling of new receivers.

   ACK implosion occurs when each receiver responds to the MESSAGE_ID
   object at approximately the same time.  This can lead to a poten-
   tially large number of MESSAGE_ID ACK objects being simultaneously



Berger, et al.                                                 [Page 14]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   delivered to the message generator.  To address this case, the
   receiver MUST wait a random interval prior to acknowledging a MES-
   SAGE_ID object received in a message destined to a multicast address.
   The random interval SHOULD be between zero (0) and a configured maxi-
   mum time.  The configured maximum SHOULD be set in proportion to the
   refresh and "rapid" retransmission interval, i.e, such that the maxi-
   mum back-off time does not result in retransmission.

   A more fundamental issue is the number of acknowledgments that the
   upstream node, i.e., the message generator, should expect.  The num-
   ber of acknowledgments that should be expected is the same as the
   number of RSVP next hops.  In the router-to-router case, the number
   of next hops can usually be obtained from routing.  When hosts are
   either the upstream node or the next hops, the number of next hops
   will typically not be readily available.  Another case where the num-
   ber of RSVP next hops will typically not be known is when there are
   non-RSVP routers between the message generator and the RSVP next
   hops.

   When the number of next hops is not known, the message generator
   SHOULD only expect a single response.  The result of this behavior
   will be special retransmission handling until the message is deliv-
   ered to at least one next hop, then followed by standard RSVP
   refreshes.  Refresh messages will synchronize state with any next
   hops that don't receive the original message.

   Another issue is handling new receivers.  It is possible that after
   sending a Path message and handling of expected number of acknowledg-
   ments that a new receiver joins the group.  In this case a new Path
   message must be sent to the new receiver.  When normal refresh pro-
   cessing is occurring, there is no issue.  When normal refresh pro-
   cessing is suppressed, a Path message must still be generated.  In
   the router-to-router case, the identification of new next hops can
   usually be obtained from routing.  When hosts are either the upstream
   node or the next hops, the identification of new next hops will typi-
   cally not be possible.  Another case where the identification of new
   RSVP next hops will typically not be possible is when there are non-
   RSVP routers between the message generator and the RSVP next hops.

   When identification of new next hops is not possible, the message
   generator SHOULD only expect a single response.  The result of this
   behavior will be special retransmission handling until the message is
   delivered to at least one next hop, then followed by standard RSVP
   refreshes.  Refresh messages will synchronize state with any next
   hops that don't receive the original message either due to loss or
   not yet being a group member.





Berger, et al.                                                 [Page 15]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


3.5.1. Reference RSVP/Routing Interface

   When using the MESSAGE_ID extension with multicast sessions it is
   preferable for RSVP to obtain the number of next hops from routing
   and to be notified when that number changes.  The interface between
   routing and RSVP is purely an implementation issue.  Since RSVP
   [RFC2205] describes a reference routing interface, we present a ver-
   sion of the RSVP/routing interface updated to provide number of next
   hop information.  See [RFC2205] for previously defined parameters and
   function description.

       o    Route Query
            Mcast_Route_Query( [ SrcAddress, ] DestAddress,
                                Notify_flag )
                                -> [ IncInterface, ] OutInterface_list,
                                   NHops_list

       o    Route Change Notification
            Mcast_Route_Change( ) -> [ SrcAddress, ] DestAddress,
                              [ IncInterface, ] OutInterface_list,
                              NHops_list

       NHops_list provides the number of multicast group members
       reachable via each OutInterface_list entry.


3.6. Compatibility

   There are no backward compatibility issues raised by the MESSAGE_ID
   Class.  The MESSAGE_ID Class has an assigned value whose form is
   10bbbbbb.  Per RSVP [RFC2205], classes with values of this form must
   be ignored and not forwarded by nodes not supporting the class.  When
   the receiver of a MESSAGE_ID object does not support the class, the
   object will be silently ignored.  The generator of the MESSAGE_ID
   object will not see any acknowledgments and therefore refresh mes-
   sages per standard RSVP.  Lastly, since the MESSAGE_ID ACK object can
   only be issued in response to the MESSAGE_ID object, there are no
   possible issues with this object or Ack messages.













Berger, et al.                                                 [Page 16]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


4. Summary Refresh Extension

   The Summary Refresh extension enables the refreshing of RSVP state
   without the transmission of standard Path or Resv messages.  The ben-
   efits of the described extension are that it reduces the amount of
   information that must be transmitted and processed in order to main-
   tain RSVP state synchronization.  Importantly, the described exten-
   sion preserves RSVP's ability to handle non-RSVP next hops and to
   adjust to changes in routing.  This extension cannot be used with
   Path or Resv messages that contain any change from previously trans-
   mitted messages, i.e, are not refresh messages.

   The summary refresh extension uses the previously defined MESSAGE_ID
   object class, the ACK message, and a new Srefresh message.  The new
   message carries a list of Message_ID fields corresponding to the Path
   and Resv states that are to be refreshed.  The Message_ID fields are
   carried in one of three Srefresh related MESSAGE_ID class objects.
   The three Srefresh related MESSAGE_ID class objects are the MES-
   SAGE_ID LIST object, the MESSAGE_ID SRC_LIST object, and the MES-
   SAGE_ID MCAST_LIST object.  The MESSAGE_ID LIST object is made up of
   a list of Message_ID fields that were originally advertised in MES-
   SAGE_ID objects that shared a common Epoch value.  The MESSAGE_ID
   SRC_LIST object is used for multicast sessions over multi-access net-
   works and adds the sender's IP address.  The MESSAGE_ID MCAST_LIST
   object is used for multicast sessions over point-to-point links and
   adds the sender's IP address and the Session IP address.

   An RSVP node receiving an Srefresh message, matches each received
   listed Message_ID field with installed Path or Resv state.  All
   matching state is updated as if a normal RSVP refresh message has
   been received.  If matching state cannot be found, then the Srefresh
   message sender is notified via a refresh NACK.

   A refresh NACK is indicated by setting the Refresh_NACK flag in the
   MESSAGE_ID ACK object.  The rules for sending a MESSAGE_ID ACK object
   with the Refresh_NACK flag set are the same as was described in the
   previous section.  This includes sending MESSAGE_ID ACK object both
   piggy-backed in unrelated RSVP messages or in RSVP ACK messages.

   Nodes supporting the described extension can advertise their support
   and detect if an RSVP neighbor also supports the extension.  This is
   accomplished via a flag in the MESSAGE_ID and MESSAGE_ID ACK objects.









Berger, et al.                                                 [Page 17]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


4.1. MESSAGE_ID LIST, SRC_LIST and MCAST_LIST Objects


   The MESSAGE_ID LIST, MESSAGE_ID SRC_LIST and MESSAGE_ID MCAST_LIST
   objects are part of the MESSAGE_ID class.  See Section 3.1 for class
   value.

   MESSAGE_ID LIST object

      Class = MESSAGE_ID Class, C_Type = 3

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Flags     |                      Epoch                    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Message_ID                         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                 :                             |
      //                                :                            //
      |                                 :                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Message_ID                         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Flags: 8 bits

         No flags are currently defined.  This field MUST be zero on
         transmission and ignored on receipt.

      Epoch: 24 bits

         The Epoch field from the MESSAGE_ID object corresponding to the
         state being refreshed.

      Message_ID: 32 bits

         The Message_ID field from the MESSAGE_ID object corresponding
         to the state being refreshed.  A variable number of Message_IDs
         may be included.  The number may range from one up to as many
         as can be carried without the Srefresh Message exceeding the
         MTU.









Berger, et al.                                                 [Page 18]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   MESSAGE_ID SRC_LIST object

      Class = MESSAGE_ID Class, C_Type = 4

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Flags     |                      Epoch                    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                              Source_                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          Message_ID_Tuple                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                 :                             |
      //                                :                            //
      |                                 :                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                              Source_                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          Message_ID_Tuple                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Where a Source_Message_ID_Tuple consists of:

      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Message_ID                         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Source_IP_Address                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Flags: 8 bits

         No flags are currently defined.  This field MUST be zero on
         transmission and ignored on receipt.

      Epoch: 24 bits

         The Epoch field from the MESSAGE_ID object corresponding to the
         state being refreshed.












Berger, et al.                                                 [Page 19]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


      Message_ID: 32 bits

         The Message_ID field from the MESSAGE_ID object corresponding
         to the Path state being refreshed.  A variable number of Mes-
         sage_IDs may be included.  The number may range from one up to
         as many as can be carried without the Srefresh Message exceed-
         ing the MTU.  Each Message_ID MUST be followed by the source IP
         address corresponding to the sender of the Path state being
         refreshed.

      Source_IP_Address: 32 bits

         The source IP address corresponding to the sender of the Path
         state being refreshed.

   MESSAGE_ID MCAST_LIST object

      Class = MESSAGE_ID Class, C_Type = 5

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Flags     |                      Epoch                    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             Multicast_                        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Message_ID_                        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               Tuple                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                 :                             |
      //                                :                            //
      |                                 :                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             Multicast_                        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Message_ID_                        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               Tuple                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+











Berger, et al.                                                 [Page 20]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   Where a Multicast_Message_ID_Tuple consists of:

      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Message_ID                         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Source_IP_Address                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                      Destination_IP_Address                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Flags: 8 bits

         No flags are currently defined.  This field MUST be zero on
         transmission and ignored on receipt.

      Epoch: 24 bits

         The Epoch field from the MESSAGE_ID object corresponding to the
         state being refreshed.

      Message_ID: 32 bits

         The Message_ID field from the MESSAGE_ID object corresponding
         to the Path state being refreshed.  A variable number of Mes-
         sage_IDs may be included.  The number may range from one up to
         as many as can be carried without the Srefresh Message exceed-
         ing the MTU.  Each Message_ID MUST be followed by the source IP
         address corresponding to the sender of the Path state being
         refreshed, and the destination IP address of the session.

      Source_IP_Address: 32 bits

         The source IP address corresponding to the sender of the Path
         state being refreshed.

      Destination_IP_Address: 32 bits

         The destination IP address corresponding to the session of the
         Path state being refreshed.












Berger, et al.                                                 [Page 21]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


4.2. Srefresh Message Format

   Srefresh messages carry one or more MESSAGE_ID LIST, MESSAGE_ID
   SRC_LIST, and MESSAGE_ID MCAST_LIST objects.  MESSAGE_ID LIST and
   MESSAGE_ID MCAST_LIST objects MAY be carried in the same Srefresh
   message.  MESSAGE_ID SRC_LIST can not be combined in Srefresh mes-
   sages with the other objects.  A single Srefresh message MAY refresh
   both Path or Resv state.

   Srefresh messages carrying Message_ID fields corresponding to Path
   state SHOULD be sent with a destination IP address equal to the
   address carried in the corresponding SESSION objects.  The destina-
   tion IP address MAY be set to the RSVP next hop when the next hop is
   known to be RSVP capable and either (a) the session is unicast or (b)
   the outgoing interface is a point-to-point link.  Srefresh messages
   carrying Message_ID fields corresponding to Resv state MUST be sent
   with an destination IP address set to the Resv state's previous hop.

   Srefresh messages sent to a multicast destination, MUST contain MES-
   SAGE_ID SRC_LIST objects and MUST NOT include any MESSAGE_ID LIST or
   MESSAGE_ID MCAST_LIST objects.  Srefresh messages sent to the RSVP
   next hop MAY contain either or both MESSAGE_ID LIST and MESSAGE_ID
   MCAST_LIST objects, but MUST NOT include any MESSAGE_ID SRC_LIST
   objects.

   The source IP address of an Srefresh message is an address of the
   node that generates the message.  The source IP address MUST match
   the addressed associate with the MESSAGE_ID objects when they were
   included in a standard RSVP message.  As previously mentioned, the
   address associate with a MESSAGE_ID object is represented in a per
   RSVP message type specific fashion.  For Path and PathTear messages
   the associated IP address is contained in the RSVP_HOP.  For Resv,
   ResvTear, PathErr, ResvErr, ResvConf and Bundle messages the associ-
   ated IP address is the source address in the IP header.

   Srefresh messages that are sent destined to a session's destination
   IP address MUST be sent the Router Alert IP option in their IP head-
   ers.  Srefresh messages addressed directly to RSVP neighbors SHOULD
   NOT be sent with the Router Alert IP option in their IP headers.

   Each Srefresh message MUST occupy exactly one IP datagram.  If it
   exceeds the MTU, the datagram is fragmented by IP and reassembled at
   the recipient node.  A single RSVP Srefresh message MUST NOT exceed
   the maximum IP datagram size, which is approximately 64K bytes.  Sre-
   fresh messages MAY be sent within an RSVP aggregate messages.
   Although this is not expected since Srefresh messages can carry a
   list of Message_ID fields within a single object.




Berger, et al.                                                 [Page 22]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   The Srefresh message format is as follows:

   <Srefresh Message> ::= <Common Header> [ <INTEGRITY> ]
                    <unicast message_id list> <multicast message_id list> |
                    <source message_id list>

   <unicast message_id list>   ::= [ <MESSAGE_ID LIST> ... ]

   <multicast message_id list> ::= [ <MESSAGE_ID MCAST_LIST> ... ]

   <source message_id list>    ::= <MESSAGE_ID SRC_LIST>
                                   [ <MESSAGE_ID SRC_LIST> ... ]

   For Srefresh messages, the Msg Type field of the Common Header MUST
   be set to 14 (Value to be assigned by IANA).


4.3. Srefresh Message Usage

   An Srefresh message MAY be generated to refresh Resv or Path state.
   If an Srefresh message is used to refresh some particular state, then
   the generation of a standard refresh message SHOULD be suppressed.  A
   state's refresh interval is not affected by the use of Srefresh mes-
   sage based refreshes.  An Srefresh message MUST NOT be used in place
   of a trigger Path or Resv message, i.e., one that would advertise a
   state change.

   When generating an Srefresh message, a node SHOULD refresh as much
   Path and Resv state as is possible by including the information from
   as many MESSAGE_ID objects in the same Srefresh message.  Only the
   information from MESSAGE_ID objects that meet the previously
   described source and destination IP address restrictions may be
   included in the same Srefresh message.  Identifying Resv state that
   can refreshed using the same Srefresh message is fairly straightfor-
   ward.  Identifying which Path state may be included is a little more
   complex.

   Independent of the state being refreshed, only state that was previ-
   ously advertised in Path and Resv messages containing MESSAGE_ID
   objects can be refreshed via an Srefresh message.  Srefresh message
   based refreshes must preserve the state synchronization properties of
   Path or Resv message based refreshes.  Specifically, the use of Sre-
   fresh messages MUST NOT result in state being timed-out at the RSVP
   next hop.  The period at which state is refreshed when using Srefresh
   messages MAY be shorter than the period that would be used when using
   Path or Resv message based refreshes, but it MUST NOT be longer.  The
   particular approach used to trigger Srefresh message based refreshes
   is implementation specific.  Some possibilities are triggering



Berger, et al.                                                 [Page 23]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   Srefresh message generation based on each state's refresh period or,
   on a per interface basis, periodically generating Srefresh messages
   to refresh all state that has not been refreshed within the state's
   refresh interval.  Other approaches are also possible.

   When generating an Srefresh message, there are two methods for iden-
   tifying which Path state may be refreshed in a specific message.  In
   both cases, the previously mentioned refresh interval and source IP
   address restrictions must be followed.  The primary method is to
   include only those sessions that share the same destination IP
   address in the same Srefresh message.  When using this method, the
   destination address of each session MUST be the same as the destina-
   tion address in the IP header of the Srefresh message.

   The secondary method for identifying which Path state may be
   refreshed within a single Srefresh message is an optimization.  This
   method MAY be used when the next hop is known to support RSVP and
   when either (a) the session is unicast or (b) the outgoing interface
   is a point-to-point link.  This method MUST NOT be used when the next
   hop is not known to support RSVP or when the outgoing interface is to
   a multi-access network and the session is to a multicast address.
   When using this method, the destination address in the IP header of
   the Srefresh message is always the next hop's address.  When the out-
   going interface is a point-to-point link, all Path state associated
   with sessions advertised out the interface SHOULD be included in the
   same Srefresh message.  When the outgoing interface is not a point-
   to-point link, all unicast session Path state SHOULD be included in
   the same Srefresh message.

   Identifying which Resv state may be refreshed within a single Sre-
   fresh message is based simply on the source and destination IP
   addresses.  Any state that was previously advertised in Resv messages
   with the same IP addresses as an Srefresh message MAY be included.

   After identifying the Path and Resv state that can be included in a
   particular Srefresh message, the message generator adds to the mes-
   sage MESSAGE_ID information matching each identified state's previ-
   ously used object.  For all Resv state and for Path state of unicast
   sessions, the information is added to the message in an MESSAGE_ID
   LIST object that has a matching Epoch value.  If no matching object
   exists, then a new MESSAGE_ID LIST object is created.  Path state of
   multicast sessions may be added to the same message when the destina-
   tion address of the Srefresh message is the RSVP next hop.  In this
   case the information is added to the message in an MESSAGE_ID
   MCAST_LIST object that has a matching Epoch value.  If no matching
   object exists, then a new MESSAGE_ID MCAST_LIST object is created.
   When the destination address of the message is a multicast address,
   then identified information is added to the message in an MESSAGE_ID



Berger, et al.                                                 [Page 24]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   SRC_LIST object that has a matching Epoch value.  If no matching
   object exists, then a new MESSAGE_ID SRC_LIST object is created.
   Once the Srefresh message is composed, the message generator trans-
   mits the message out the proper interface.

   Upon receiving an Srefresh message, a receiver MUST attempt to iden-
   tify matching Path or Resv state.  Matching is done based on the
   source address in the IP header of the Srefresh message and each MES-
   SAGE_ID class object contained in the message.  For each received
   Message_ID field, the receiver performs an installed state lookup
   based on the received value and the received object type.  If match-
   ing state can be found, then the receiver MUST update the matching
   state information as if a standard refresh had been received.  If the
   receiver cannot identify any installed state matching a Message_ID
   field associated with Resv state or Path state of unicast session,
   i.e. carried in a MESSAGE_ID LIST Object, then an Srefresh NACK MUST
   be generated corresponding to each unmatched Message_ID field in a
   MESSAGE_ID LIST object.  For unmatched Message_ID fields associated
   with Path state of multicast sessions, an RPF check must be performed
   in order to determine if a NACK should be generated.  The RPF check
   is performed based on the source and group information carried in the
   MESSAGE_ID SRC_LIST and MCAST_LIST objects.  The receiver only gener-
   ates an Srefresh NACK when the receiver would forward packets to the
   identified group from the listed sender.  If the receiver would for-
   ward multicast data packets from a listed sender and there is a cor-
   responding unmatched Message_ID field, then an appropriate Srefresh
   NACK MUST be generated.  If the receiver is not forwarding packets to
   the identified group from a listed sender, a corresponding unmatched
   Message_ID field is silently ignored.


4.4. Srefresh NACK

   Srefresh NACKs are used to indicated that a received MESSAGE_ID LIST,
   SRC_LIST, or MCAST_LIST object does not match any installed state.
   An Srefresh NACK is encoded in a MESSAGE_ID ACK object with the
   Refresh_NACK flag set.  When generating an Srefresh NACK, The epoch
   and Message_ID fields of a MESSAGE_ID ACK object MUST have the same
   value as was received.  Objects with the Refresh_NACK flag set are
   transmitted as previously described, see Section 3.4.

   MESSAGE_ID ACK objects received with the Refresh_NACK flag set indi-
   cate that the object generator does not have any installed state
   matching the object.  Upon receiving a MESSAGE_ID ACK object with the
   Refresh_NACK flag set, the receiver performs an installed Path or
   Resv state lookup based on the values contained in the object.  If
   matching state is found, then the receiver MUST transmit the matching
   state via a standard Path or Resv message.  If the receiver cannot



Berger, et al.                                                 [Page 25]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   identify any installed state, then no action is required.


4.5. Compatibility

   Nodes supporting the Summary Refresh extension advertise their sup-
   port via the Summary_Capable flag in all MESSAGE_ID and MESSAGE_ID
   ACK objects transmitted by the node.  Support is also implied when a
   node transmits an Srefresh Message.  This enables supporting nodes to
   detect each other.  When it is not known if a next hop supports the
   extension, standard Path and Resv message based refreshes MUST be
   used.  Note that when the routing next hop does not support RSVP, it
   will not always be possible to detect if the RSVP next hop supports
   the Summary Refresh extension.  Therefore, when the routing next hop
   is not RSVP capable the Srefresh message based refresh SHOULD NOT be
   used.  A node MAY be administratively configured to use Srefresh mes-
   sages in all cases when all RSVP nodes in a network are known to sup-
   port the Summary Refresh extension.

   Nodes supporting the Summary Refresh extension must also take care to
   recognize when a next hop stops sending MESSAGE_ID and MESSAGE_ID ACK
   objects with the Summary_Capable flag set.  To cover this case, nodes
   supporting the Summary Refresh extension MUST examine each received
   Summary_Capable flag.  If the flag changes from indicating support to
   indicating non-support then Srefresh messages MUST NOT be used for
   subsequent state refreshes to that neighbor.


5. Reference Exponential Back-Off Procedures

   This section is based on [Pan] and provides an example of how to
   implement exponential back-off.  Implementations MAY choose to use
   the described procedures.


5.1. Outline of Operation

   We propose the following feedback mechanism for exponential back-off
   retransmission of an RSVP message: When sending such a message, a
   node inserts a MESSAGE_ID object with the the ACK_Desired flag set.
   Upon reception, a receiving node acknowledges the arrival of the mes-
   sage by sending back an message acknowledgment (that is, a corre-
   sponding MESSAGE_ID ACK object.)  When the sending node receives this
   message acknowledgment for a Path or Resv message, it will automati-
   cally scale back the retransmission rate for these messages for the
   flow.  If the trigger message was for a different message type, no
   other further action is required.




Berger, et al.                                                 [Page 26]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   Until the message acknowledgment is received, the sending node will
   retransmit the message.  The interval between retransmissions is gov-
   erned by a rapid retransmission timer.  The rapid retransmission
   timer starts at a small interval which increases exponentially until
   it reaches a threshold.  From that point on, the sending node will
   use a fixed timer to refresh Path and Resv messages and stop re-
   transmitting other messages.  This mechanism is designed so that the
   message load is only slightly larger than in the current specifica-
   tion even when the receiving node does not support message acknowl-
   edgment.


5.2. Time Parameters

   The described procedures make use of the following time parameters.
   All parameters are per interface.

      Rapid retransmission interval Rf:

           Rf is the initial retransmission interval for unacknowledged
           messages.  After sending the message for the first time, the
           sending node will schedule a retransmission after Rf seconds.
           The value of Rf could be as small as the round trip time (RTT)
           between a sending and a receiving node, if known.  Unless a node
           knows that all receiving nodes support echo-replies, a slightly
           larger configurable value is suggested.


      Slow refresh interval Rs:

           The sending node retransmits Path and Resv messages with this
           interval after it has determined that the receiving node will
           generate MESSAGE_ID ACK objects.  To reduce the number of
           unnecessary retransmissions in a stable network, Rs can be set
           to a large value.  The value of Rs should be configurable per
           each egress interface.

      Fixed retransmission interval R:

           A node retransmits the trigger message with the interval Rf*(1 +
           Delta)**i until the retransmission interval reaches the fixed
           retransmission interval R or a message acknowledgment has been
           received.  If no acknowledgment has been received, the node
           continues to retransmit Resv and Path messages every R seconds.
           By default R should be the same value as the retransmission
           interval in the current RSVP specification.





Berger, et al.                                                 [Page 27]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


      Increment value Delta:

           Delta governs the speed with which the sender increases the
           retransmission interval.  The ratio of two successive
           retransmission intervals is (1 + Delta).


5.3. Example Retransmission Algorithm

   After a sending node transmits a message containing a MESSAGE_ID
   object with the ACK_Desired flag set, it should immediately schedule
   a retransmission after Rf seconds.  If a corresponding MESSAGE_ID ACK
   object is received earlier than Rf seconds, then retransmission
   SHOULD be canceled.  Otherwise, it will retransmit the message after
   (1 + Delta)*Rf seconds.  The staged retransmission will continue
   until either an appropriate MESSAGE_ID ACK object is received, or the
   retransmission interval has been increased to R.  Once the retrans-
   mission interval has been increased to R, Path and Resv messages will
   be refreshed within the interval R.  Other messages will not be
   retransmitted.

   The implementation of exponential back-off retransmission is simple.
   A sending node can use the following algorithm after transmitting a
   message containing a MESSAGE_ID object with the ACK_Desired flag set:

       On initial transmission initialize: Rk = Rf

       if (Rk < R)  {
           retransmit the message;
           wake up after Rk seconds;
           Rk = Rk * (1 + Delta);
           exit;
       }
       else  {    /* no reply from receivers for too long: */
           Rk = R;
           if (message is a Path or Resv Message) {
               send out a refresh message;
               wake up after Rk seconds;
               exit;
           }
           else  {
               clean up any associated state and resources;
               exit;
           }
       }

   Asynchronously, when a sending node receives a corresponding MES-
   SAGE_ID ACK object, it will change the retransmission interval Rk to



Berger, et al.                                                 [Page 28]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


   Rs and, for non Path or Resv messages, clean up any associated state
   and resources.  Note that the transmitting node does not advertise
   the use of the described exponential back-off procedures via the
   TIME_VALUE object.


6. Acknowledgments

   This document represents ideas and comments from the MPLS-TE design
   team and participants in the RSVP Working Group's interim meeting.
   Thanks to Yoram Bernet, Fred Baker, Roch Guerin, Henning Schulzrinne,
   Andreas Terzis, David Mankins and Masanobu Yuhara for specific feed-
   back on the document.

   Portions of this work are based on work done by Masanobu Yuhara and
   Mayumi Tomikawa [Yuhara].


7. Security Considerations

   No new security issues are raised in this document.  See [RFC2205]
   for a general discussion on RSVP security issues.

8. References

[Pan]     Pan, P., Schulzrinne, H., "Staged Refresh Timers for RSVP,"
          Global Internet'97, Phoenix, AZ, Nov. 1997.
          http://www.ctr.columbia.edu/~pan/papers/timergi.ps

[RFC2119] Bradner, S., "Key words for use in RFCs to Indicate
          Requirement Levels," RFC 2119.

[RFC2205] Braden, R. Ed. et al, "Resource ReserVation Protocol
           -- Version 1 Functional Specification", RFC 2205,
           September 1997.

[Yuhara]  Yuhara, M., Tomikawa, M. "RSVP Extensions for ID-based
          Refreshes,"  Internet Draft,
          draft-yuhara-rsvp-refresh-00.txt, April 1999.












Berger, et al.                                                 [Page 29]


Internet Draft    draft-ietf-rsvp-refresh-reduct-00.txt   September 1999


9. Authors' Addresses

   Lou Berger
   LabN Consulting, LLC
   Voice:  +1 301 468 9228
   Email:  lberger@labn.net

   Der-Hwa Gan
   Juniper Networks, Inc.
   385 Ravendale Drive
   Mountain View, CA 94043
   Voice:  +1 650 526 8074
   Email:  dhg@juniper.net

   George Swallow
   Cisco Systems, Inc.
   250 Apollo Drive
   Chelmsford, MA 01824
   Voice:  +1 978 244 8143
   Email:  swallow@cisco.com

   Ping Pan
   Bell Labs, Lucent
   101 Crawfords Corner Road, Room 4C-508
   Holmdel, NJ 07733
   USA
   Phone:  +1 732 332 6744
   Email:  pingpan@dnrc.bell-labs.com























Berger, et al.                                                 [Page 30]

