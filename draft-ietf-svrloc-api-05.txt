
Service Location Working Group                               James Kempf
INTERNET DRAFT                                              Erik Guttman
30 May 1998                                             Sun Microsystems

                      An API for Service Location
                      draft-ietf-svrloc-api-05.txt


Status of This Memo

   This document is a submission by the Service Location Working Group
   of the Internet Engineering Task Force (IETF).  Comments should be
   submitted to the srvloc@srvloc.org mailing list.

   Distribution of this memo is unlimited.

   This document is an Internet-Draft.  Internet-Drafts are working
   documents of the Internet Engineering Task Force (IETF), its areas,
   and its working groups.  Note that other groups may also distribute
   working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at
   any time.  It is inappropriate to use Internet- Drafts as reference
   material or to cite them other than as ``work in progress.''

   To view the entire list of current Internet-Drafts, please check
   the ``1id-abstracts.txt'' listing contained in the Internet-Drafts
   Shadow Directories on ftp.is.co.za (Africa), ftp.nordu.net (Northern
   Europe), ftp.nis.garr.it (Southern Europe), munnari.oz.au (Pacific
   Rim), ftp.ietf.org (US East Coast), or ftp.isi.edu (US West Coast).

   Distribution of this memo is unlimited.


Abstract

   The Service Location Protocol (SLP) provides a new way for clients to
   dynamically discovery network services.  With SLP, it is simple to
   offer highly available services that require no user configuration or
   assistance from network administrators prior to use.  This document
   describes standardized API's for SLP in C and Java.  The API's are
   modular and are designed to allow implementions to offer just the
   feature set needed.  In addition, standardized file formats for
   configuration and serialized registrations are defined, allowing SLP
   agents to set network and other parameters in a portable way.  The
   serialized file format allows legacy services to be registered with
   SLP directory agents in cases where modifying the legacy service







Kempf, Guttman             Expires 30 October 1998              [Page i]

Internet Draft             Service Location API              30 May 1998


   program code is difficult or impossible, and to portably exchange a
   registration database.


















































Kempf, Guttman             Expires 30 October 1998             [Page ii]

Internet Draft             Service Location API              30 May 1998




                                Contents


Status of This Memo                                                    i

Abstract                                                               i

 1. Introduction                                                       1
     1.1. Goals . . . . . . . . . . . . . . . . . . . . . . . . . .    1
     1.2. Terminology . . . . . . . . . . . . . . . . . . . . . . .    2

 2. File Formats                                                       4
     2.1. Configuration File Format . . . . . . . . . . . . . . . .    5
           2.1.1. DA configuration  . . . . . . . . . . . . . . . .    6
           2.1.2. Static Scope Configuration  . . . . . . . . . . .    6
           2.1.3. Tracing and Logging . . . . . . . . . . . . . . .    7
           2.1.4. Serialized Proxy Registrations  . . . . . . . . .    8
           2.1.5. Networking Configuration Parameters . . . . . . .    8
           2.1.6. UA Configuration  . . . . . . . . . . . . . . . .   10
           2.1.7. Security  . . . . . . . . . . . . . . . . . . . .   10
     2.2. Serialized Registration File  . . . . . . . . . . . . . .   11
     2.3. Proccessing Serialized Registration and Configuration
             Files  . . . . . . . . . . . . . . . . . . . . . . . .   12

 3. Binding Independent Implementation Considerations                 13
     3.1. Multithreading  . . . . . . . . . . . . . . . . . . . . .   13
     3.2. Asynchronous and Incremental  . . . . . . . . . . . . . .   13
     3.3. Type Checking for Service Types . . . . . . . . . . . . .   13
     3.4. Refreshing Registrations  . . . . . . . . . . . . . . . .   13
     3.5. Configuration File Processing . . . . . . . . . . . . . .   14
     3.6. Attribute Types . . . . . . . . . . . . . . . . . . . . .   14
     3.7. Removal of Duplicates . . . . . . . . . . . . . . . . . .   14
     3.8. Character Set Encoding  . . . . . . . . . . . . . . . . .   14
     3.9. Error Semantics . . . . . . . . . . . . . . . . . . . . .   15
    3.10. Modular Implementations . . . . . . . . . . . . . . . . .   18
    3.11. Scope Discovery and Handling  . . . . . . . . . . . . . .   18

 4. C Language Binding                                                19
     4.1. Constant Types  . . . . . . . . . . . . . . . . . . . . .   19
           4.1.1. URL Lifetimes . . . . . . . . . . . . . . . . . .   19
           4.1.2. Error Codes . . . . . . . . . . . . . . . . . . .   20
           4.1.3. SLPBoolean  . . . . . . . . . . . . . . . . . . .   21
     4.2. Struct Types  . . . . . . . . . . . . . . . . . . . . . .   21
           4.2.1. SLPSrvURL . . . . . . . . . . . . . . . . . . . .   21
           4.2.2. SLPHandle . . . . . . . . . . . . . . . . . . . .   22
     4.3. Callbacks . . . . . . . . . . . . . . . . . . . . . . . .   22
           4.3.1. SLPRegReport  . . . . . . . . . . . . . . . . . .   23



Kempf, Guttman            Expires 30 October 1998             [Page iii]

Internet Draft             Service Location API              30 May 1998


           4.3.2. SLPSrvTypeCallback  . . . . . . . . . . . . . . .   24
           4.3.3. SLPSrvURLCallback . . . . . . . . . . . . . . . .   25
           4.3.4. SLPAttrCallback . . . . . . . . . . . . . . . . .   26
     4.4. Opening and Closing the SLP Library . . . . . . . . . . .   27
           4.4.1. SLPOpen . . . . . . . . . . . . . . . . . . . . .   27
           4.4.2. SLPClose  . . . . . . . . . . . . . . . . . . . .   28
     4.5. Protocol API  . . . . . . . . . . . . . . . . . . . . . .   29
           4.5.1. SLPReg  . . . . . . . . . . . . . . . . . . . . .   29
           4.5.2. SLPDereg  . . . . . . . . . . . . . . . . . . . .   31
           4.5.3. SLPDelAttrs . . . . . . . . . . . . . . . . . . .   32
           4.5.4. SLPFindSrvTypes . . . . . . . . . . . . . . . . .   33
           4.5.5. SLPFindSrvs . . . . . . . . . . . . . . . . . . .   34
           4.5.6. SLPFindAttrs  . . . . . . . . . . . . . . . . . .   36
     4.6. Miscellaneous Functions . . . . . . . . . . . . . . . . .   37
     4.7. SLPFindScopes . . . . . . . . . . . . . . . . . . . . . .   37
     4.8. SLPParseSrvURL  . . . . . . . . . . . . . . . . . . . . .   38
     4.9. SLPFree . . . . . . . . . . . . . . . . . . . . . . . . .   39
    4.10. SLPEscape . . . . . . . . . . . . . . . . . . . . . . . .   40
    4.11. SLPUnescape . . . . . . . . . . . . . . . . . . . . . . .   41
    4.12. SLPGetProperty  . . . . . . . . . . . . . . . . . . . . .   42
    4.13. SLPSetProperty  . . . . . . . . . . . . . . . . . . . . .   42
    4.14. Implementation Notes  . . . . . . . . . . . . . . . . . .   43
          4.14.1. Refreshing Registrations  . . . . . . . . . . . .   43
          4.14.2. Syntax for String Parameters  . . . . . . . . . .   43
          4.14.3. Client Side Syntax Checking . . . . . . . . . . .   44
          4.14.4. System Properties . . . . . . . . . . . . . . . .   44
          4.14.5. Memory Management . . . . . . . . . . . . . . . .   44
          4.14.6. Asychronous and Incremental Return Semantics  . .   45
    4.15. Examples  . . . . . . . . . . . . . . . . . . . . . . . .   45
          4.15.1. Discovering one's mailbox . . . . . . . . . . . .   45

 5. Java Language Binding                                             49
     5.1. Introduction  . . . . . . . . . . . . . . . . . . . . . .   49
     5.2. Exceptions and Errors . . . . . . . . . . . . . . . . . .   49
           5.2.1. Class ServiceLocationException  . . . . . . . . .   50
     5.3. Basic Data Structures . . . . . . . . . . . . . . . . . .   51
           5.3.1. Interface ServiceLocationEnumeration  . . . . . .   51
           5.3.2. Class ServiceLocationAttribute  . . . . . . . . .   51
           5.3.3. Class ServiceType . . . . . . . . . . . . . . . .   54
           5.3.4. Class ServiceURL  . . . . . . . . . . . . . . . .   56
     5.4. SLP Access Interfaces . . . . . . . . . . . . . . . . . .   59
           5.4.1. Interface Advertiser  . . . . . . . . . . . . . .   59
           5.4.2. Interface Locator . . . . . . . . . . . . . . . .   62
     5.5. The Service Location Manager  . . . . . . . . . . . . . .   65
           5.5.1. Class ServiceLocationManager  . . . . . . . . . .   65
     5.6. Service Template Introspection  . . . . . . . . . . . . .   67
           5.6.1. Abstract Class TemplateRegistry . . . . . . . . .   67
           5.6.2. Interface ServiceLocationAttributeVerifier  . . .   69
           5.6.3. Interface ServiceLocationAttributeDescriptor  . .   72



Kempf, Guttman             Expires 30 October 1998             [Page iv]

Internet Draft             Service Location API              30 May 1998


     5.7. Implementation Notes  . . . . . . . . . . . . . . . . . .   75
           5.7.1. Refreshing Registrations  . . . . . . . . . . . .   75
           5.7.2. Parsing Alternate Transports in ServiceURL  . . .   75
           5.7.3. Client Side Syntax Checking . . . . . . . . . . .   75
           5.7.4. Language Locale Handling  . . . . . . . . . . . .   75
           5.7.5. Setting SLP System Properties . . . . . . . . . .   76
           5.7.6. Multithreading  . . . . . . . . . . . . . . . . .   76
           5.7.7. Modular Implementations . . . . . . . . . . . . .   76
           5.7.8. Asynchronous and Incremental Return Semantics . .   77
     5.8. Examples  . . . . . . . . . . . . . . . . . . . . . . . .   77

 6. Internationalization Considerations                               80
     6.1. service URL . . . . . . . . . . . . . . . . . . . . . . .   80
     6.2. Character Set Encoding  . . . . . . . . . . . . . . . . .   80
     6.3. Language Tagging  . . . . . . . . . . . . . . . . . . . .   80

 7. Security Considerations                                           81

 8. Acknowledgements                                                  81


1. Introduction

   The Service Location API is designed for standardized access the
   Service Location Protocol (SLP). The APIs allow client and service
   programs to be be written or modified in a very simple manner to
   provide dynamic service discovery and selection.  Bindings in the
   C and Java languages are defined in this document.  In addition,
   standardized formats for configuration files and for serialized
   registration files are presented.  These files allow SLP agents
   to configure network parameters, to register legacy services that
   have not been SLP enabled, and to portably exchange registration
   databases.


1.1. Goals

   The overall goal of the API is to enable source portability of
   applications that use the API between different implementations of
   SLP. The result should facilitate the adoption of SLP, and conversion
   of clients and service programs to SLP.

   The goals of the C binding are to create a minimal but complete
   access to the functionality of the SLP protocol, allowing for simple
   memory management and limited code size.

   The Java API provides for modular implementations (where unneeded
   features can be omitted) and an object oriented interface to the
   complete set of SLP data and functionality.



Kempf, Guttman             Expires 30 October 1998              [Page 1]

Internet Draft             Service Location API              30 May 1998


   The standardized configuration file and serialized file formats
   provide a simple syntax with complete functional coverage of the
   protocol, but without including secure information such as private
   keys.


1.2. Terminology

      Service Location Protocol (SLP)

         The underlying protocol allowing dynamic and scalable service
         discovery.  This protocol is specified in the Service Location
         Protocol Version 2 [11].

      SLP framework

         When a 'Service Location framework' is mentioned, it refers to
         both the SLP implementation and interface implementation; ie.
         whatever provides the SLP functionality to user level programs.
         This includes remote agents.

      Directory Agent (DA)

         A service that automatically gathers service advertisements
         from SAs in order to provide them to UAs.

      User Agent (UA)

         This is the Service Location process or library that allows
         SLP requests to be made on behalf of a client process.  UAs
         automatically direct requests to DAs when they exist.  In their
         absence, UAs make requests to SAs.

      Service Agent (SA)

         This is the Service Location process or library that allows
         service software to register and deregister itself with the SLP
         framework.  SAs MUST respond to UA service requests, detect DAs
         and register service advertisements with them.

      SA Server

         Many operating system platforms only allow a single process to
         listen on a particular port number.  Since SAs are required
         to listen on a multicast address for SLP service requests,
         implementaions of the SLP framework on such platforms that want
         to support multiple SAs on one machine need to arrange for a
         single process to do the listening while the advertising SAs
         communicate with that process through another mechanism.  The



Kempf, Guttman             Expires 30 October 1998              [Page 2]

Internet Draft             Service Location API              30 May 1998


         single listening process is called an SA server.  SA servers
         share many characteristics with DAs, but they are not the same.

      Service Advertisement

         A URL possibly combined with service attributes.  These are
         made available to UAs by SAs, either directly or via a DA.

      Locale

         The language localization that applies to strings passed into
         or returned from the SLP API. The Locale is expressed using a
         Language Tag [10].  All attribute strings are associated with a
         particular locale.  The locale is completely orthogonal to the
         ANSI C locale.  The SLP locale is mapped into the Java locale
         in the Java API.

      Service Template

         A document that describes the syntax of the URL for a given
         service type and a definition of all service attributes
         including the meaning, defaults, and constraints on values the
         attributes may take.  See [12] for more information on service
         templates.

      The service:  URL

         A service of a particular type announces its availability
         with a service:  URL that includes its service access point
         (domain name or ip address, and possibly its port number) and
         optionally basic configuration parameters.  The syntax of the
         service:  URL is defined in the service template.  Other URL's
         can be used in service advertisements if desired.

      Service Attributes

         The attributes associated with a given service.  The values
         that can be assigned to service attributes are defined by the
         service template.

      Scope

         A string used to control the availability of service
         advertisements.  Every SLP Agent is configured with one or more
         scope strings.  Scopes are assigned by site administrators to
         group services for many purposes, but chiefly as a means of
         scalability.  DAs store only services advertised having a scope
         string matching the scopes with which they are configured.




Kempf, Guttman             Expires 30 October 1998              [Page 3]

Internet Draft             Service Location API              30 May 1998


      Naming Authority (NA)

         This is a 'suffix' to the service type string.  It completely
         changes the meaning of the service type.  NAs are used
         for private definitions of well known Service Types and
         experimental Service Type extensions.  The default NA is
         "IANA", which MUST NOT be explicitely included.  Service types
         with the IANA naming authority are registered with the Internet
         Assigned Numbers Authority (see [12] for more information on
         the registration procedure).


2. File Formats

   This section describes the configuration and serialized registration
   file formats.  Both files are defined in the UTF8 character set [7].

   String values in the configuration file require SLP reserved
   characters to be escaped.  The SLP reserved characters are `(', `)',
   `,', `\', `!', `<', `=', `>', `~' and control characters such as
   newline.  The escapes are formed exactly as for the wire protocol,
   i.e.  a backslash followed by two hex digits representing the
   character.  For example, the escape for ',' is '\2c'.

   Escaped strings beginning with `\ff`, an encoding for a nonUTF8
   character, are treated as opaques.  Exactly as in the wire protocol,
   syntactically correct opaque encodings consist of a string beginning
   with `\ff` and containing *only* escaped characters that are
   transformed to bytes.  Such strings are only syntactically correct
   in the serialized registration file as attribute values.  In other
   cases, whenever an escape is encountered and the character is not an
   SLP reserved character, an error is signalled.

   On platforms that only support the ASCII subset of UTF8, the upper
   bit of bytes incoming from the configuration and registration files
   determines whether the character is ASCII or nonASCII. According to
   the standard UTF8 encoding, the upper bit is zero if the character
   is ASCII and one if the character is multibyte and thus nonASCII.
   Platforms without intrinsic UTF8 support are required to parse the
   multibyte character and store it in an appropriate internal format.
   Support for UTF8 is required to implement the SLP protocol (see [11])
   and can be reused during configuration file parsing.

   The location and name of the configuration file is system-dependent,
   but implementations of the API are encouraged to locate it together
   with other configuration files and name it consistently.






Kempf, Guttman             Expires 30 October 1998              [Page 4]

Internet Draft             Service Location API              30 May 1998


2.1. Configuration File Format

   The configuration file format consists of a newline delimited list
   of zero or more property definitions.  Each property definition
   corresponds to a particular configurable SLP, network, or other
   parameter in one or more of the three SLP agents.  The file format
   grammer in ABNF [9] syntax is:


      config-file   =  line-list
      line-list     =  line / line line-list
      line          =  property-line / comment-line
      comment-line  =  ( "#" / ";" ) 1*allchar newline
      property-line =  property newline
      property      =  tag "=" value-list
      tag           =  prop / prop "." property
      prop          =  1*char
      value-list    =  value / value "," value-list
      value         =  int / bool / value-list / string
      int           =  1*DIGIT
      bool          =  "true" / "false" / "TRUE" / "FALSE"
      newline       =  CR / ( CRLF )
      string        =  1*allchar
      char          =  DIGIT / ALPHA / other
      other         =  %x21-%x2f / %x3a-%x40 /
                       %x5b-%x60 / %7b-%7e
      allchar       =  char / HT / SP / escape
      escape        =  "\" HEXDIG HEXDIG
                       ; Used for SLP reserved characters


   With the exception of the net.slp.useScopes and the
   net.slp.DAAddresses properties, all other properties can be
   changed through property accessors in the C and Java APIs.  The
   property accessors only change the property values in the running
   agent program and do not affect the values in the configuration
   file.  The net.slp.useScopes and net.slp.DAAddresses properties are
   read-only because they control the agent's view of the scopes and DAs
   and are therefore critical to the function of the API scope discovery
   algorithm.  Attempts to modify them are unlikely to yield productive
   results, and could harm the ability of the agent to find scopes and
   use DAs.

   The properties break down into seven general areas.  Each of the
   following subsections describes an area and its properties.







Kempf, Guttman             Expires 30 October 1998              [Page 5]

Internet Draft             Service Location API              30 May 1998


2.1.1. DA configuration

   Important configuration parameters for DAs are included in this
   section.  These are:

      net.slp.isDA

         A boolean indicating if the SLP server is to act as a DA. If
         false, not run as a DA. Default is false.

      net.slp.DAHeartBeat

         A 32 bit integer giving the number of seconds for the
         DA heartbeat.  Default is 3 hours (10800 seconds).  This
         property corresponds to the protocol specification parameter
         CONFIG_DA_BEAT [11].  Ignored if isDA is false.


2.1.2. Static Scope Configuration

   These parameters allow various aspects of scope handling to be
   configured.

      net.slp.useScopes

         A value-list of strings indicating the only scopes a UA or
         SA is allowed to use when making requests or registring,
         or the scopes a DA must support.  If not present, then in
         the absence of scope information from other sources (DHCP,
         active and passive discovery), the default is "DEFAULT".
         If another scope is used by a UA, a SCOPE_NOT_SUPPORTED
         error SHOULD be returned.  If another scope is used by a
         SA, a SCOPE_NOT_SUPPORTED error MUST be returned, since
         SAs are required to register in all scopes with which they
         are configured.  Unlike other parameters, this parameter is
         ``read-only'', so attempts to change it after the configuration
         file has been read are ignored.  See Section 3.11 for the
         algorithm the API uses in determining what scope information to
         present.

      net.slp.DAAddresses

         A value-list of IP addresses or DNS-resolvable names giving
         the DAs to use for statically configured UAs and SAs, along
         with their scopes.  If isDA is true, registrations and
         deregistrations in the appropriate scopes are forwarded these
         DAs.  Default is none.  Scopes from the net.slp.useScopes
         parameter and addresses and scopes obtained via DHCP take
         precedence over these.  Unlike other parameters, this



Kempf, Guttman             Expires 30 October 1998              [Page 6]

Internet Draft             Service Location API              30 May 1998


         parameter is ``read-only'', so attempts to change it after the
         configuration file has been read are ignored.  If scope and DA
         information is available from other sources, the information
         from this list is used as a supplement.

         The following grammer describes the property:


               addr-list     =  addr / addr "," addr-list
               addr          =  addrrep "(" scope-list ")"
               addrrep       =  ipv4-addr / ipv6-addr / fqdn
               ipv4-addr     =  1*3DIGIT 3( "." 1*3DIGIT )
               ipv6-addr     =  64HEXDIGIT
               fqdn          =  ALPHA / ALPHA *[ anum / "-" ] anum
               anum          =  ALPHA / DIGIT
               scope-list    =  scope / scope "," scope-list
               scope         =  string
                                ; See grammar of Section 2.1
                                ; and [11].

         Scoped DAs are listed with a comma delimited list inside
         brackets following the DA address.  For example:


            (da1.fr.org(default),da2.fr.org(scope1,scope2),da3.fr.org(default,scope3))


         Here da1 has scope default, da2 has scope1 and scope2, da3 has
         default and scope3.


2.1.3. Tracing and Logging

   This section allows tracing and logging information to be printed by
   the various agents.

      net.slp.traceDATraffic

         A boolean controlling printing of messges about traffic with
         DAs.  Default is false.

      net.slp.traceMsg

         A boolean controlling printing of details on SLP messages.
         The fields in all incoming messages and outgoing replies are
         printed.  Default is false.






Kempf, Guttman             Expires 30 October 1998              [Page 7]

Internet Draft             Service Location API              30 May 1998


      net.slp.traceDrop

         A boolean controlling printing details when a SLP message is
         dropped for any reason.  Default is false.

      net.slp.traceReg

         A boolean controlling dumps of all registered services upon
         registration and deregistration.  If true, the contents
         of the DA or SA server are dumped after a registration or
         deregistration occurs.  Default is false.


2.1.4. Serialized Proxy Registrations

   These properties control the reading and writing of serialized
   registrations.

      net.slp.serializedRegURL

         A string containing a URL pointing to a document containing
         serialized registrations that should be processed when the DA
         or SA server starts up.  Default is none.


2.1.5. Networking Configuration Parameters

   The properties in this section allow various network configuration
   parameters to be set.

      net.slp.isBroadcastOnly

         A boolean indicating if broadcast should be used instead of
         multicast.  Default is false.

      net.slp.passiveDADetection

         A boolean indicating whether passive DA detection should be
         used.  Default is true.

      net.slp.multicastTTL

         A positive integer less than or equal to 32, giving the
         multicast TTL. Default is 32.

      net.slp.DAActiveDiscoveryInterval

         A 32 bit integer giving the number of seconds between DA active
         discovery queries.  Default is 900 seconds (15 minutes).  This



Kempf, Guttman             Expires 30 October 1998              [Page 8]

Internet Draft             Service Location API              30 May 1998


         property corresponds to the protocol specification parameter
         CONFIG_DA_FIND [11].

      net.slp.multicastMaximumWait

         A 32 bit integer giving the maximum amount of time to perform
         multicast, in milliseconds.  Default is 15000 ms (15 sec.).
         This property corresponds to the CONFIG_MC_MAX parameter in the
         protocol specification [11].

      net.slp.multicastTimeouts

         A value-list of 32 bit integers used as timeouts, in
         milliseconds, to implement the multicast convergence algorithm.
         Each value specifies the time to wait before sending the
         next request, or until nothing new has been learned from
         two successive requests.  Ignored if isDA is true.  Default
         is:  3000,3000,3000,3000,3000.  In a fast network the
         agressive values of 1000,1250,1500,2000,4000 allow better
         performance.  This property corresponds to the CONFIG_MC_RETRY
         parameter in the protocol specification [11].  Note that the
         net.slp.DADiscoveryTimeouts property MUST be used for active DA
         discovery.

      net.slp.DADiscoveryTimeouts

         A value-list of 32 bit integers used as timeouts, in
         milliseconds, to implement the multicast convergence
         algorithm during active DA discovery.  Each value specifies
         the time to wait before sending the next request, or
         until nothing new has been learned from two successive
         requests.  This property corresponds to the protocol
         specification parameter CONFIG_DA_RETRY [11].  Default is:
         2000,2000,2000,2000,3000,4000.

      net.slp.datagramTimeouts

         A value-list of 32 bit integers used as timeouts, in
         milliseconds, to implement unicast datagram transmission to
         DAs.  The nth value gives the time to block waiting for a reply
         on the nth try to contact the DA. The sum of these values is
         the protocol specification property CONFIG_DA_MAX [11].

      net.slp.randomWaitBound

         A 32 bit integer giving the maximum value for all random
         wait parameters, in milliseconds.  Default is 1000 (1
         sec.).  This value corresponds to the protocol specification




Kempf, Guttman             Expires 30 October 1998              [Page 9]

Internet Draft             Service Location API              30 May 1998


         parameters CONFIG_START_WAIT, CONFIG_REG_PASSIVE, and
         CONFIG_REG_ACTIVE [11].

      net.slp.MTU

         A 16 bit integer giving the network packet MTU, in bytes.
         This is the maximum size of any datagram to send, but the
         implementation might receive a larger datagram.  Default is
         1400.

      net.slp.multicastInterfaces

         Value-list of strings giving the names of network interfaces
         on which a DA or SA should listen for multicast.  Default is
         empty, i.e.  just listen on the default network interface.


2.1.6. UA Configuration

   This section contains configuration parameters for the UA.

      net.slp.locale

         A RFC 1766 Language Tag [10] for the language locale.  Setting
         this property causes the property value to become the default
         locale for SLP messages.  Default is "en".

      net.slp.maxResults

         A 32 bit integer giving the maximum number of results to
         accumulate and return for a synchronous request before the
         timeout, or the maximum number of results to return through a
         callback if the request results are reported asychronously.
         Positive integers and -1 are legal values.  If -1, indicates
         that all results should be returned.  Default value is -1.

         DAs and SAs always return all results that match the
         request.  This configuration value applies only to UAs, that
         filter incoming results and only return as many values as
         net.slp.maxResults indicates.


2.1.7. Security

   The properties in this section allow security parameters to be
   configured.  Key management is implementation dependent.






Kempf, Guttman             Expires 30 October 1998             [Page 10]

Internet Draft             Service Location API              30 May 1998


      net.slp.URLSignature

         A boolean indicating whether the SA should sign URLs.  URLs are
         signed if true.  Default is false.  Applies to SAAdverts as
         well.

      net.slp.attributeSignature

         A boolean indicating whether the SA should sign attributes.
         Attributes are signed if true.  Default is false.

      net.slp.DAAdvertSignature

         A boolean indicating whether the DA should sign DAAdverts.
         DAAdverts are signed if true.  Default is false.


2.2. Serialized Registration File

   The serialized registration file contains a group of registrations
   that a DA or SA server (if one exists) registers when it starts up.
   These registrations are primarily for older service programs that do
   not internally support SLP and cannot be converted, and for portably
   exchanging registrations between SLP implementations.  The character
   format of the registrations is required to be UTF8.

   The syntax of the serialized registration file, in ABNF format [9],
   is as follows:


      ser-file      =  reg-list
      reg-list      =  reg / reg reg-list
      reg           =  creg / ser-reg
      creg          =  comment-line ser-reg
      comment-line  =  ( "#" / ";" ) 1*allchar newline
      ser-reg       =  url-props [slist] attr-list newline
      url-props     =  surl sep lang sep ltime sep [ type ]
      sep           =  *WSP "," *WSP
      surl          =  ;The registration's URL. See
                       ; [12] for syntax.
      lang          =  2*3ALPHA [ "-" 1*ALPHA ]
                       ;RFC 1766 Language Tag see [10].
      ltime         =  1*DIGIT
                       ; A positive 16-bit integer
                       ; giving the lifetime
                       ; of the registration.
      type          =  string
                       ; The service type name, see [11]
                       ; and [12] for syntax.



Kempf, Guttman             Expires 30 October 1998             [Page 11]

Internet Draft             Service Location API              30 May 1998


      slist         =  attr
                       ; Attribute definition with id "scopes"
                       ; and value list containing scope names.
                       ; See grammar of Section 2.1
                       ; and [11].
      attr-list     =  attr-def / attr-def attr-list
      attr-def      =  attr / keyword
      keyword       =  attr-id
      attr          =  attr-id assgn-op attr-val-list newline
      assgn-op      =  *WSP "=" *WSP
      attr-id       =  ;Attribute id, see [11] for syntax.
      attr-val-list =  attr-val / attr-val sep attr-val-list
      attr-val      =  ;Attribute value, see [11] for syntax.
      char          =  DIGIT / ALPHA / other
                       ;'other' defined in section 2.1.
      allchar       =  char / WSP


   The syntax for attributes and attribute values requires escapes for
   special characters as specified in [11], in addition to nonASCII
   characters.  DAs and SA servers that process serialized registrations
   MUST handle them exactly as if they were registered by an SA. In the
   urlprops production, the type token is optional.  If the type token
   is present for a service:  URL, a warning is signalled and type name
   is ignored.  Scopes can be included in a registration by including
   an attribute definition with tag "scopes" followed by a comma
   separated list of scope names immediately after the URL registration.
   If the optional scope list is present, the registations are made
   in the indicated scopes; otherwise, they are registered in the
   scopes with which the DA or SA server was configured through the
   net.slp.useScopes property.

   If the scope list contains scopes that are not in the
   net.slp.useScopes property (provided that property is set) or
   are not specified by DHCP, the API library is required to abort the
   program.


2.3. Proccessing Serialized Registration and Configuration Files

   Implementations are encouraged to make processing of configuration
   and serialized files as transparent as possible to clients of
   the API. At the latest, errors MUST be caught when the relevent
   configuration item is used.  At the earliest, errors MAY be caught
   when the relevent file is loaded into the executing agent.  Errors
   SHOULD be reported by logging to the appropriate platform logging
   file, error output, or log device, and the default value substituted.
   Serialized registration file entries SHOULD be caught and reported
   when the file is loaded.



Kempf, Guttman             Expires 30 October 1998             [Page 12]

Internet Draft             Service Location API              30 May 1998


   Configuration file loading MUST be complete prior to the initiation
   of the first networking connection.  Serialized registration MUST be
   complete before the DA accepts the first network request.


3. Binding Independent Implementation Considerations

   This section discusses a number of implementation considerations
   independent of language binding, with language specific notes where
   applicable.


3.1. Multithreading

   Implementations of both the C and Java APIs are required to make API
   calls thread-safe.  Access to data structures shared between threads
   must be co-ordinated to avoid corruption or invalid access.  One way
   to achieve this goal is to allow only one thread at a time in the
   implementing library.  Performance in such an implementation suffers,
   however.  Therefore, where possible, implementations are encouraged
   to allow multiple threads within the SLP API library.


3.2. Asynchronous and Incremental

   The APIs are designed to encourage implementations supporting
   asychronous and incremental client interaction.  The goal is to allow
   large numbers of returned service URLs, service types, and attributes
   without requiring the allocation of huge chunks of memory.  The
   particular design features to support this goal differ in the two
   language bindings.


3.3. Type Checking for Service Types

   Service templates [12] allow SLP registrations to be type checked
   for correctness.  Implementations of the API are free to make use of
   service type information for type checking, but are not required to
   do so.  If a type error occurs, the registration should terminate
   with TYPE_ERROR.


3.4. Refreshing Registrations

   SLP advertisements carry an explicit lifetime with them.  After the
   lifetime expires, the DA flushes the registration from its cache.
   Implementations of the SA API are encouraged to provide an automatic
   refreshing capability, so that service advertiser applications can
   simply register their services for as long as they continue running.



Kempf, Guttman             Expires 30 October 1998             [Page 13]

Internet Draft             Service Location API              30 May 1998


   The SA API is required to deregister any such advertisements as soon
   as the calling application exits.


3.5. Configuration File Processing

   DAs, SAs and UAs processing the configuration file, and DAs and SA
   servers processing the serialized registration file are required
   to log any errors using whatever underlying error mechanism is
   appropriate for the platform.  Examples include include writing error
   messages to the standard output, writing to a system logging device,
   or displaying the errors to a logging window.  After the error is
   reported, the offending parameter must be set to the default and
   program execution continued.  An agent MUST NOT fail if a file format
   error occurs.


3.6. Attribute Types

   String encoded attribute values do not include explicit type
   information.  All UA implementations and those SA and DA
   implementations that choose to support type checking should use the
   type rules described in [12] in order to convert from the string
   representation on the wire to an object typed appropriately.


3.7. Removal of Duplicates

   The UA implementation SHOULD always collate results to remove
   duplicates during synchronous operations and for the Java API. During
   asychronous operation in C, the UA implementation SHOULD forgo
   duplicate elimination to reduce memory requirements in the library.
   This allows the API library to simply take the returned attribute
   value list strings, URL strings, or service type list strings
   and call the callback function with it, without any additional
   processing.  Naturally, the burden of duplicate elimination is thrown
   onto the client in this case.


3.8. Character Set Encoding

   Character string parameters in the Java API are all represented in
   Unicode internally because that is the Java-supported character set.
   Characters buffer parameters in the C API are represented in UTF8 to
   maintain maximum compatibility on platforms that only support the
   ASCII subset of UTF8.  API functions are still required to handle the
   full range of UTF8 characters because the SLP protocol requires it,
   but the API implementation can represent the characters internally
   in any convenient way.  On the wire, all characters are converted to



Kempf, Guttman             Expires 30 October 1998             [Page 14]

Internet Draft             Service Location API              30 May 1998


   UTF8.  Inside URLs, characters that are not allowed by URL syntax [2]
   must be escaped according to the URL escape character convention.
   Strings that are included in SLP messages may include SLP reserved
   characters and are escaped by convenience functions by the API. The
   character code used to encode the escaped characters is UTF8.

   The maximum length of any string parameter in C or Java is 64K bytes.


3.9. Error Semantics

   All errors encountered processing SLP messages SHOULD be logged.
   For synchronous calls, an error is only reported on a call if no
   successful replies were received from any SLP framework entity.  If
   an error occured among one or several successful replies, then the
   error should be logged and the successful replies returned.  For
   asychronous calls, an error occuring during correspondence with a
   particular remote SLP agent is reported through the first callback
   (in the C API) or enumeration method invocation (in the Java API)
   after the error occurs, which would normally report the results of
   the correspondence.  This allows the callback or client code to
   determine whether the operation should be terminated or continue.  In
   some cases, the error returned from the SLP framework may be fatal
   (SLP_PARSE_ERROR, etc.).  In these cases, the API library terminates
   the operation.

   Both the Java and C APIs contain language specific error code
   mechanisms for returning error information.  The names of the error
   codes are consistent between the two implementations, however.

   The following error codes are returned from a remote agent (DA or SA
   server):

      LANGUAGE_NOT_SUPPORTED

         No DA or SA has service advertisement information in the
         language requested, but at least one DA or SA indicated, via
         the LANGUAGE_NOT_SUPPORTED error code, that it might have
         information for that service in another language.

      PARSE_ERROR

         The SLP message was rejected by a remote SLP agent.  The API
         returns this error only when no information was retrieved, and
         at least one SA or DA indicated a protocol error.  The data
         supplied through the API may be malformed or a may have been
         damaged in transit.





Kempf, Guttman             Expires 30 October 1998             [Page 15]

Internet Draft             Service Location API              30 May 1998


      INVALID_REGISTRATION

         The API may return this error if an attempt to register a
         service was rejected by all DAs because of a malformed URL or
         attributes.  SLP does not return the error if at least one DA
         accepted the registration.

      AUTHENTICATION_ABSENT

         If the SLP framework supports authentication, this error arises
         when the UA or SA failed to send an authenticator for requests
         or registrations in a protected scope.

      INVALID_UPDATE

         An update for a nonexisting registration was issued.

   The following errors result from interactions with remote agents or
   can occur locally:

      AUTHENTICATION_FAILED

         If the SLP framework supports authentication, this error arises
         when a authentication on an SLP message received from a remote
         SLP agent failed.

      SCOPE_NOT_SUPPORTED

         The API returns this error if the UA or SA has been configured
         with net.slp.useScopes value-list of scopes and the UA or SA
         request did not specify one or more of these allowable scopes,
         and no others.  It may also be returned by a DA if the scope
         included in a request is not supported by a DA.

   The following errors are generated through a program interacting with
   the API implementation.  They do not involve a remote SLP agent.

      NOT_IMPLEMENTED

         If an unimplemented feature is used, this error is returned.

      NETWORK_INIT_FAILED

         If the network cannot initialize properly, this error is
         returned.







Kempf, Guttman             Expires 30 October 1998             [Page 16]

Internet Draft             Service Location API              30 May 1998


      NETWORK_TIMED_OUT

         When no reply can be obtained in the time specified by the
         configured timeout interval, this error is returned.

      NETWORK_ERROR

         The failure of networking during normal operations causes this
         error to be returned.

      BUFFER_OVERFLOW

         An outgoing request overflowed the maximum network MTU size.
         The request should be reduced in size or broken into pieces and
         tried again.

      MEMORY_ALLOC_FAILED

         If the API fails to allocate memory, the operation is aborted
         and returns this.

      PARAMETER_BAD

         If a parameter passed into an interface is bad, this error is
         returned.

      INTERNAL_SYSTEM_ERROR

         A basic failure of the API causes this error to be returned.
         This occurs when a system call or library fails.  The operation
         could not recover.

      HANDLE_IN_USE

         In the C API, callback functions are not permitted to
         recursively call into the API on the same SLPHandle, either
         directly or indirectly.  If an attempt is made to do so, this
         error is returned from the called API function.

      TYPE_ERROR

         If the API supports type checking of registrations against
         service type templates, this error can arise if the attributes
         in a registration do not match the service type template for
         the service.

   Some error codes are handled differently in the Java API. These
   differences are discussed in Section 5.




Kempf, Guttman             Expires 30 October 1998             [Page 17]

Internet Draft             Service Location API              30 May 1998


   The errors OPTION_NOT_UNDERSTOOD, VER_NOT_SUPPORTED, INTERNAL_ERROR,
   RQST_NOT_SUPPORTED, AUTHENTICATON_ALGO_UNKNOWN, and DA_BUSY_NOW
   should be handled internally and not surfaced to clients through the
   API.


3.10. Modular Implementations

   Subset implementations that do not support the full range of
   functionality are required to nevertheless support every interface
   in order to maintain link compatiblity between compliant API
   implementations and applications.  If a particular operation is not
   supported, a NOT_IMPLEMENTED error should be returned.  The Java API
   has some additional conventions for handling subsets.  Applications
   that are expected to run on a wide variety of platforms should be
   prepared for subset API implementations by checking returned error
   codes.


3.11. Scope Discovery and Handling

   Both APIs contain an operation to obtain a list of currently known
   scope names.  This scope information comes from a variety of places:
   DHCP, the net.slp.useScopes and net.slp.DAAddresses properties, and
   active and passive discovery.

   API implementations are required to process presented scope
   information in the following way.  Scopes returned by DHCP have
   first priority and MUST be returned if they are available.  The
   net.slp.useScopes property has second priority, and scopes discovered
   through the net.slp.useScopes property MUST be returned if this
   property is set and there are no scopes available from DHCP. If
   neither of these sources provide information on scopes, then scopes
   obtained from the net.slp.DAAddresses property, from active DA
   discovery, and from passive DA discovery all MUST be returned.  If
   no information is available from any of these sources, then the
   API library MAY perform SA discovery, using the service type hint
   passed in through the API to limit the search to SAs supporting a
   particular service type.  In the absence of any of the above sources
   of information, the API MUST return the default scope, ``DEFAULT''.
   Note that the API MUST always return some scope information.

   SLP requires that SAs MUST perform their operations in all scopes
   currently known to them. [11].  The API enforces this constraint
   by checking the list of scopes presented in the call to SA
   operations, and signals a SCOPE_NOT_SUPPORTED error if any scopes
   are missing.  UAs SHOULD use a scope obtained through one of the API
   operations for finding scopes.  Any other scope name MAY result in a
   SCOPE_NOT_SUPPORTED error from a remote agent.



Kempf, Guttman             Expires 30 October 1998             [Page 18]

Internet Draft             Service Location API              30 May 1998


   Scopes are used in larger networks for administrators to control
   service access.  Care must be taken by programmers using the API not
   to expose the ability to create or view arbitrary scopes in cases
   where the host has been preconfigured with a scope list.


4. C Language Binding

   The C language binding presents a minimal overhead implemention
   that maps directly into the protocol.  There is one C language
   function per protocol request, with the exception of the SLPDereg()
   and SLPDelAttrs() functions, which map into different uses of the
   SLP deregister request.  Parameters are for the most part character
   buffers.  Memory management is kept simple by having the API library
   allocate memory and requiring that client callback functions copy
   incoming parameters into memory allocated by the client code.  Memory
   returned directly from the API functions is deallocted using the
   SLPFree() function.

   To conform with standard C practice, all character strings passed to
   and returned through the API are null terminated, even though the
   SLP protocol does not use null terminated strings.  Strings passed
   as parameters are UTF8 but they may still be passed as a C string
   (a null terminated sequence of bytes.)  Escaped characters must be
   encoded as UTF8.  In the common case of the ASCII subset of UTF8, the
   usual one byte per character C strings work.  API functions assist in
   escaping and unescaping strings.


4.1. Constant Types

4.1.1. URL Lifetimes

4.1.1.1. Synopsis


   typedef enum {
     SLP_LIFETIME_DEFAULT = 10800,
     SLP_LIFETIME_MAXIMUM = 65535
   } SLPURLLifetime;



4.1.1.2. Description

   The SLPURLLifetime enum type contains URL lifetime values, in
   seconds, that are frequently used.  SLP_LIFETIME_DEFAULT is 3 hours,
   while SLP_LIFETIME_MAXIMUM is about 18 hours and corresponds to the
   maximum size of the lifetime field in SLP messages.



Kempf, Guttman             Expires 30 October 1998             [Page 19]

Internet Draft             Service Location API              30 May 1998


4.1.2. Error Codes

4.1.2.1. Synopsis


   typedef enum {
     SLP_LAST_CALL                    = 1,
     SLP_OK                           = 0,
     SLP_LANGUAGE_NOT_SUPPORTED       = -1,
     SLP_PARSE_ERROR                  = -2,
     SLP_INVALID_REGISTRATION         = -3,
     SLP_SCOPE_NOT_SUPPORTED          = -4,
     SLP_AUTHENTICATION_ABSENT        = -6,
     SLP_AUTHENTICATION_FAILED        = -7,
     SLP_INVALID_UPDATE               = -9;
     SLP_NOT_IMPLEMENTED              = -17,
     SLP_BUFFER_OVERFLOW              = -18,
     SLP_NETWORK_TIMED_OUT            = -19,
     SLP_NETWORK_INIT_FAILED          = -20,
     SLP_MEMORY_ALLOC_FAILED          = -21,
     SLP_PARAMETER_BAD                = -22,
     SLP_NETWORK_ERROR                = -23,
     SLP_INTERNAL_SYSTEM_ERROR        = -24,
     SLP_HANDLE_IN_USE                = -25,
     SLP_TYPE_ERROR                   = -26

   } SLPError ;



4.1.2.2. Description

   The SLPError enum contains error codes that are returned from API
   functions.

   The SLP_OK code indicates that the no error occured during the
   operation.  The SLP_LAST_CALL code is passed to callback functions
   when the API library has no more data for them and threfore
   no further calls will be made to the callback on the currently
   outstanding operation.  The callback can use this to signal the main
   body of the client code that no more data will be forthcoming on the
   operation, so that the main body of the client code can break out of
   data collection loops.  On the last call of a callback during both
   a synchronous and asynchronous call, the error code parameter has
   value SLP_LAST_CALL, and the other parameters are all null.  If no
   results are returned by an API operation, then only call with the
   error parameter set to SLP_LAST_CALL is made.





Kempf, Guttman             Expires 30 October 1998             [Page 20]

Internet Draft             Service Location API              30 May 1998


4.1.3. SLPBoolean

4.1.3.1. Synopsys


   typedef enum {
      SLP_FALSE = 0,
      SLP_TRUE = 1

   } SLPBoolean;



4.1.3.2. Description

   The SLPBoolean enum is used as a boolean flag.


4.2. Struct Types

4.2.1. SLPSrvURL

4.2.1.1. Synopsis


   typedef struct srvurl {
     char *s_pcSrvType;
     char *s_pcHost;
     int   s_iPort;
     char *s_pcNetFamily;
     char *s_pcSrvPart;
   } SLPSrvURL;



4.2.1.2. Description

   The SLPSrvURL structure is filled in by the SLPParseSrvURL() function
   with information parsed from a character buffer containing URL.
   The fields correspond to different parts of the URL. Note that
   the structure is conformant with the standard Berkeley sockets
   struct servent, with the exception that the pointer to an array of
   characters for aliases (s_aliases field) is replaced by the pointer
   to host name (s_pcHost field).

      s_pcSrvType

         A pointer to a character string containing the service type
         name, including naming authority.



Kempf, Guttman             Expires 30 October 1998             [Page 21]

Internet Draft             Service Location API              30 May 1998


      s_pcHost

         A pointer to a character string containing the host
         identification information.

      s_iPort

         The port number, or zero if none.  The port is only available
         if the transport is IP.

      s_pcNetFamily

         A pointer to a character string containing the network address
         family identifier.  Possible values are ``ipx'' for the IPX
         family, ``at'' for the Appletalk family, and ``'' (i.e.  the
         empty string) for the IP address family.

      s_pcSrvPart

         The remainder of the URL, after the host identification.

   The host and port should be sufficient to open a socket to the
   machine hosting the service, and the remainder of the URL should
   allow further differentiation of the service.


4.2.2. SLPHandle

4.2.2.1. Synopsis


   typedef void* SLPHandle;


   The SLPHandle type is returned by SLPOpen() and is a parameter to all
   SLP functions.  It serves as a handle for all resources allocated on
   behalf of the process by the SLP library.  The type is opaque, since
   the exact nature differs depending on the implementation.


4.3. Callbacks

   A function pointer to a callback function specific to a particular
   API operation is included in the parameter list when the API function
   function is invoked.  The callback function is called with the
   results of the operation in both the synchronous and asychronous
   cases.  The memory included in the callback parameters is owned by
   the API library, and the client code in the callback MUST copy out




Kempf, Guttman             Expires 30 October 1998             [Page 22]

Internet Draft             Service Location API              30 May 1998


   the contents if it wants to maintain the information longer than the
   duration of the current callback call.

   In addition to parameters for reporting the results of the operation,
   each callback parameter list contains an error code parameter and a
   cookie parameter.  The error code parameter reports the error status
   of the ongoing (for asychronous) or completed (for synchronous)
   operation.  The cookie parameter allows the client code that starts
   the operation by invoking the API function to pass information down
   to the callback without using global variables.  The callback returns
   an SLPBoolean to indicate whether the API library should continue
   processing the operation.  Asychronous operations are terminated,
   synchronous operations ignore the return (since the operation is
   already complete).


4.3.1. SLPRegReport

4.3.1.1. Synopsis


   typedef void SLPRegReport(SLPHandle hSLP,
                             SLPError errCode,
                             void *pvCookie);



4.3.1.2. Description

   The SLPRegReport callback type is the type of the callback function
   to the SLPReg(), SLPDereg(), and SLPDelAttrs() functions.


4.3.1.3. Parameters

      hSLP

         The SLPHandle used to initiate the operation.

      errCode

         An error code indicating if an error occured during the
         operation.

      pvCookie

         Memory passed down from the client code that called the
         original API function, starting the operation.  May be NULL.




Kempf, Guttman             Expires 30 October 1998             [Page 23]

Internet Draft             Service Location API              30 May 1998


4.3.2. SLPSrvTypeCallback

4.3.2.1. Synopsis


   typedef SLPBoolean SLPSrvTypeCallback(SLPHandle hSLP,
                                         const char* pcSrvTypes,
                                         SLPError errCode,
                                         void *pvCookie);



4.3.2.2. Description

   The SLPSrvTypeCallback type is the type of the callback function
   parameter to SLPFindSrvTypes() function.  The client should return a
   SLPBoolean value indicating whether it is interested in seeing more
   data on this operation.


4.3.2.3. Parameters

      hSLP

         The SLPHandle used to initiate the operation.

      pcSrvTypes

         A character buffer containing a comma separated, null
         terminated list of service types.

      errCode

         An error code indicating if an error occured during the
         operation.  The callback should check this error code before
         processing the parameters.  If the error code is other than
         SLP_OK, then the API library may choose to terminate the
         outstanding operation.

      pvCookie

         Memory passed down from the client code that called the
         original API function, starting the operation.  May be NULL.


4.3.2.4. Returns

   The client code should return SLP_TRUE if more data is desired,
   otherwise SLP_FALSE.



Kempf, Guttman             Expires 30 October 1998             [Page 24]

Internet Draft             Service Location API              30 May 1998


4.3.3. SLPSrvURLCallback

4.3.3.1. Synopsis


   typedef SLPBoolean SLPSrvURLCallback(SLPHandle hSLP,
                                        const char* pcSrvURL,
                                        unsigned short sLifetime,
                                        SLPError errCode,
                                        void *pvCookie);



4.3.3.2. Description

   The SLPSrvURLCallback type is the type of the callback function
   parameter to SLPFindSrvs() function.  The client should return a
   SLPBoolean value indicating whether it is interested in seeing more
   data on this operation.


4.3.3.3. Parameters

      hSLP

         The SLPHandle used to initiate the operation.

      pcSrvURL

         A character buffer containing the returned service URL.

      sLifetime

         An unsigned short giving the life time of the service
         advertisement, in seconds.  The value must be an unsigned
         integer less than or equal to SLP_LIFETIME_MAXIMUM.

      errCode

         An error code indicating if an error occured during the
         operation.  The callback should check this error code before
         processing the parameters.  If the error code is other than
         SLP_OK, then the API library may choose to terminate the
         outstanding operation.

      pvCookie

         Memory passed down from the client code that called the
         original API function, starting the operation.  May be NULL.



Kempf, Guttman             Expires 30 October 1998             [Page 25]

Internet Draft             Service Location API              30 May 1998


4.3.3.4. Returns

   The client code should return SLP_TRUE if more data is desired,
   otherwise SLP_FALSE.


4.3.4. SLPAttrCallback

4.3.4.1. Synopsis


   typedef SLPBoolean SLPAttrCallback(SLPHandle hSLP,
                                      const char* pcAttrList,
                                      SLPError errCode,
                                      void *pvCookie);



4.3.4.2. Description

   The SLPAttrCallback type is the type of the callback function
   parameter to SLPFindAttrs() function.  The client should return a
   SLPBoolean value indicating whether it is interested in seeing more
   data on this operation.

   When the SLPFindAttrs() operation was originally called with a URL,
   the callback is called once regardless of whether the handle was
   opened asychronously or synchronously.  The pcAttrList parameter
   contains the requested attributes as a comma separated list (or is
   empty if no attributes matched the original tag list).  When the
   SLPFindAttrs() operation was originally called with a service type,
   the value of pcAttrList and calling behavior depend on whether the
   handle was opened asychronously or synchronously.  If the handle
   was opened asychronously, the callback is called every time the API
   library has results from a remote agent.  The pcAttrList parameter
   is uncollated between calls, and contains a comma separated list
   containing the results from the agent that immediately returned
   results.  If the handle was opened synchronously, the results are
   collated from all returning agents and the callback is called once,
   with the pcAttrList parameter set to the collated result.


4.3.4.3. Parameters

      hSLP

         The SLPHandle used to initiate the operation.





Kempf, Guttman             Expires 30 October 1998             [Page 26]

Internet Draft             Service Location API              30 May 1998


      pcAttrList

         A character buffer containing a comma separated, null
         terminated list of attribute id/value assignments, in SLP wire
         format; i.e.  "(attr-id=attr-value-list)" [11].

      errCode

         An error code indicating if an error occured during the
         operation.  The callback should check this error code before
         processing the parameters.  If the error code is other than
         SLP_OK, then the API library may choose to terminate the
         outstanding operation.

      pvCookie

         Memory passed down from the client code that called the
         original API function, starting the operation.  May be NULL.


4.3.4.4. Returns

   The client code should return SLP_TRUE if more data is desired,
   otherwise SLP_FALSE.


4.4. Opening and Closing the SLP Library

4.4.1. SLPOpen

4.4.1.1. Synopsis


   SLPError SLPOpen(const char *pcLang, SLPBoolean isAsync, SLPHandle *phSLP);



4.4.1.2. Description

   Returns a SLPHandle handle in the phSLP parameter for the language
   locale passed in as the pcLang parameter.  The client indicates if
   operations on the handle are to be synchronous or asychronous through
   the isAsync parameter.  The handle encapsulates the language locale
   for SLP requests issued through the handle, and any other resources
   required by the implementation.  SLP properties are not encapsulated
   by the handle, they are global.  The return value of the function
   is an SLPError code indicating the status of the operation.  Upon
   failure, the phSLP parameter is NULL.




Kempf, Guttman             Expires 30 October 1998             [Page 27]

Internet Draft             Service Location API              30 May 1998


   An SLPHandle can only be used for one SLP API operation at a time.
   If the original operation was started asychronously, any attempt
   to start an additional operation on the handle while the original
   operation is pending results in the return of an SLP_HANDLE_IN_USE
   error from the API function.  The SLPClose() API function terminates
   any outstanding calls on the handle.  If an implementation is unable
   to support either asychronous or synchronous operation, due to memory
   constraints or lack of threading support, the SLP_NOT_IMPLEMENTED
   flag may be returned when the isAsync flag has the appropriate value.


4.4.1.3. Parameters

      pcLang

         A pointer to an array of characters containing the RFC 1766
         Language Tag [10] for the natural language locale of requests
         and registrations issued on the handle.  May not be NULL.


4.4.2. SLPClose

4.4.2.1. Synopsis


   void SLPClose(SLPHandle hSLP);



4.4.2.2. Description

   Frees all resources associated with the handle.  If the handle was
   invalid, the function returns silently.  Any outstanding synchronous
   or asychronous operations are cancelled so their callback functions
   will not be called any further.


4.4.2.3. Parameters

      SLPHandle

         A SLPHandle handle returned from a call to SLPOpen().










Kempf, Guttman             Expires 30 October 1998             [Page 28]

Internet Draft             Service Location API              30 May 1998


4.5. Protocol API

4.5.1. SLPReg

4.5.1.1. Synopsis


   SLPError SLPReg(SLPHandle   hSLP,
                   const char  *pcSrvURL,
                   const unsigned short usLifetime,
                   const char  *pcSrvType,
                   const char  *pcScopeList,
                   const char  *pcAttrs
                   SLPBoolean  fresh,
                   SLPRegReport callback,
                   void *pvCookie);



4.5.1.2. Description

   Registers the URL in pcSrvURL having the lifetime sLifetime with the
   attribute list in pcAttrs.  The pcAttrs list is a comma separated
   list of attribute assignments in on the wire format (including
   escaping of reserved characters).  The sLifetime parameter must
   be nonzero and less than or equal to SLP_LIFETIME_MAXIMUM. The
   registration is done in scopes that are part of pcScopeList.  If
   the fresh flag is SLP_TRUE, then the registration is new (the
   SLP protocol FRESH flag is set) and the registration replaces
   any existing registrations.  If the fresh flag is SLP_FALSE, then
   an existing registration is updated.  Rules for new and updated
   registrations, and the format for pcAttrs can be found in [11].
   Registrations and updates take place in the language locale of the
   hSLP handle.

   The pcScopeList parameter supplies a comma delimited list of scopes
   for the registration.  This parameter MUST NOT be NULL or the empty
   string, "".  The scopes in the scope list SHOULD be one or more
   of the scopes obtainable from SLPFindScopes().  If an unsupported
   scope is specified, a SLP_SCOPE_NOT_SUPPORTED error MAY be returned.
   If the net.slp.useScopes parameter has been configured, then the
   pcScopeList parameter MUST be a supported scope.










Kempf, Guttman             Expires 30 October 1998             [Page 29]

Internet Draft             Service Location API              30 May 1998


4.5.1.3. Parameters

      hSLP

         The language specific SLPHandle on which to register the
         advertisement.  May not be NULL.

      pcSrvURL

         The URL to register.  May not be NULL or the empty string.

      usLifetime

         An unsigned short giving the life time of the service
         advertisement, in seconds.  The value must be an unsigned
         integer less than or equal to SLP_LIFETIME_MAXIMUM and greater
         than zero.

      pcSrvType

         The service type.  If pURL is a service:  URL, then this
         parameter is ignored.  May not be null.

      pcScopeList

         The comma separated list of scopes applying to the
         registration.  MUST contain all the scopes returned from the
         results of a SLPFindScopes() API invocation.  May not be NULL.

      pcAttrs

         A comma separated list of attribute assignment expressions for
         the attributes of the advertisement.  May not be NULL. Use
         empty string, "" for no attributes.

      callback

         A callback to report the operation completion status.  May not
         be NULL.

      pvCookie

         Memory passed to the callback code from the client.  May be
         NULL.








Kempf, Guttman             Expires 30 October 1998             [Page 30]

Internet Draft             Service Location API              30 May 1998


4.5.1.4. Returns

   If an error occurs in starting the operation, one of the SLPError
   codes is returned.


4.5.2. SLPDereg

4.5.2.1. Synopsys


   SLPError SLPDereg(SLPHandle  hSLP,
                     const char *pcURL,
                     const char *pcScopeList,
                     SLPRegReport callback,
                     void *pvCookie);



4.5.2.2. Description

   Deregisters the advertisment for URL pURL in all scopes where the
   service is registered and all language locales, not just the locale
   of the SLPHandle.


4.5.2.3. Parameters

      hSLP

         The language specific SLPHandle to use for deregistering.  May
         not be NULL.

      pcURL

         The URL to deregister.  May not be NULL.

      pcScopeList

         The comma separated list of scopes applying to the
         registration.  MUST contain all the scopes returned from the
         results of a SLPFindScopes() API invocation.  May not be NULL.

      callback

         A callback to report the operation completion status.  May not
         be NULL.





Kempf, Guttman             Expires 30 October 1998             [Page 31]

Internet Draft             Service Location API              30 May 1998


      pvCookie

         Memory passed to the callback code from the client.  May be
         NULL.


4.5.2.4. Returns

   If an error occurs in starting the operation, one of the SLPError
   codes is returned.


4.5.3. SLPDelAttrs

4.5.3.1. Synopsys


   SLPError SLPDelAttrs(SLPHandle   hSLP,
                        const char  *pcURL,
                        const char  *pcScopeList,
                        const char  *pcAttrs,
                        SLPRegReport callback,
                        void *pvCookie);



4.5.3.2. Description

   Delete the selected attributes in the locale of the SLPHandle.


4.5.3.3. Parameters

      hSLP

         The language specific SLPHandle to use for deleting attributes.
         May not be NULL.

      pURL

         The URL of the advertisement from which the attributes should
         be deleted.  May not be NULL.

      pcScopeList

         The comma separated list of scopes applying to the
         registration.  MUST contain all the scopes returned from the
         results of a SLPFindScopes() API invocation.  May not be NULL.




Kempf, Guttman             Expires 30 October 1998             [Page 32]

Internet Draft             Service Location API              30 May 1998


      pcAttrs

         A comma separated list of attribute ids for the attributes to
         deregister.  See Section 9.8 in [11] for a description of the
         list format.  May not be NULL.

      callback

         A callback to report the operation completion status.  May not
         be NULL.

      pvCookie

         Memory passed to the callback code from the client.  May be
         NULL.


4.5.3.4. Returns

   If an error occurs in starting the operation, one of the SLPError
   codes is returned.


4.5.4. SLPFindSrvTypes

4.5.4.1. Synopsis


   SLPError SLPFindSrvTypes(SLPHandle    hSLP,
                            const char  *pcNamingAuthority,
                            const char  *pcScopeList,
                            SLPSrvTypeCallback callback,
                            void *pvCookie);


   The SLPFindSrvType() function issues an SLP service type request
   for service types in the scopes indicated by the pcScopeList.  The
   results are returned through the callback parameter.  The service
   types are independent of language locale, but only for services
   registered in one of scopes and for the indicated naming authority.

   If the naming authority is "*", then results are returned for all
   naming authorities.  If the naming authority is the empty string,
   i.e.  "", then the default naming authority, "IANA", is used.  "IANA"
   is not a valid naming authority name, and it is a PARAMETER_BAD error
   to include it explicitly.

   The service type names are returned with the naming authority
   intact.  If the naming authority is the default (i.e.  empty string)



Kempf, Guttman             Expires 30 October 1998             [Page 33]

Internet Draft             Service Location API              30 May 1998


   then it is omitted, as is the separating ``.''.  See [12] for more
   information on the syntax of service type names.


4.5.4.2. Parameters

      hSLP

         The SLPHandle on which to search for types.  May not be NULL.

      pcNamingAuthority

         The naming authority to search.  Use "*" for all naming
         authorities and the empty string, "", for the default naming
         authority.  May not be NULL.

      pcScopeList

         A pointer to a char containing comma separated list of scope
         names to search for service types.  May not be NULL or the
         empty string, "".

      callback

         A callback function through which the results of the operation
         are reported.  May not be NULL.

      pvCookie

         Memory passed to the callback code from the client.  May be
         NULL.


4.5.4.3. Returns

   If an error occurs in starting the operation, one of the SLPError
   codes is returned.


4.5.5. SLPFindSrvs

4.5.5.1. Synopsis


   SLPError SLPFindSrvs(SLPHandle  hSLP,
                        const char *pcServiceType,
                        const char *pcScopeList,
                        const char *pcSearchFilter,
                        SLPSrvURLCallback callback,



Kempf, Guttman             Expires 30 October 1998             [Page 34]

Internet Draft             Service Location API              30 May 1998


                        void *pvCookie);


4.5.5.2. Description

   Issue the query for services on the language specific SLPHandle and
   return the results through the callback.  The parameters determine
   the results


4.5.5.3. Parameters

      hSLP

         The language specific SLPHandle on which to search for
         services.  May not be NULL.

      pcServiceType

         The Service Type String for the request, such as can be
         discovered using SLPSrvTypes().  This could be, for example
         "service:printer:lpr" or "service:nfs".  May not be NULL.

      pcScopeList

         A pointer to a char containing comma separated list of scope
         names.  May not be NULL or the empty string, "".

      pcSearchFilter

         A query formulated of attribute pattern matching expressions in
         the form of a LDAPv3 Search Filter, see [8].  If this filter
         is empty, ie.  "", all services of the requested type in the
         specified scopes are returned.  May not be NULL.

      callback

         A callback function through which the results of the operation
         are reported.  May not be NULL.

      pvCookie

         Memory passed to the callback code from the client.  May be
         NULL.








Kempf, Guttman             Expires 30 October 1998             [Page 35]

Internet Draft             Service Location API              30 May 1998


4.5.5.4. Returns

   If an error occurs in starting the operation, one of the SLPError
   codes is returned.


4.5.6. SLPFindAttrs

4.5.6.1. Synopsis


   SLPError SLPFindAttrs(SLPHandle   hSLP,
                         const char *pcURL,
                         const char *pcScopeList,
                         const char *pcAttrIds,
                         SLPAttrCallback callback,
                         void *pvCookie);



4.5.6.2. Description

   This function returns service attributes matching the attribute ids
   for the indicated full or partial URL. If pcURL is a complete URL,
   the attribute information returned is for that particular service in
   the language locale of the SLPHandle.  If pcURL is a partial URL,
   then all attributes for the service type are returned regardless
   of the language of registration.  Results are returned through the
   callback.

   The result is filtered with an SLP attribute request filter string
   parameter, the syntax of which is described in [11].  If the filter
   string is the empty string, i.e.  "", all attributes are returned.


4.5.6.3. Parameters

      hSLP

         The language specific SLPHandle on which to search for
         attributes.  May not be NULL.

      pcURL

         The full or partial URL. See [11] for partial URL syntax.  May
         not be NULL.






Kempf, Guttman             Expires 30 October 1998             [Page 36]

Internet Draft             Service Location API              30 May 1998


      pcScopeList

         A pointer to a char containing comma separated list of scope
         names.  May not be NULL or the empty string, "".

      pcAttrIds

         The filter string indicating which attribute values to return.
         Use empty string, "", to indicate all values.  Wildcards
         matching all attribute ids having a particular prefix or suffix
         are also possible.  See [11] for the exact format of the filter
         string.  May not be NULL.

      callback

         A callback function through which the results of the operation
         are reported.  May not be NULL.

      pvCookie

         Memory passed to the callback code from the client.  May be
         NULL.


4.5.6.4. Returns

   If an error occurs in starting the operation, one of the SLPError
   codes is returned.


4.6. Miscellaneous Functions

4.7. SLPFindScopes

4.7.0.5. Synopsis


   SLPError SLPFindScopes(SLPHandle hSLP,
                          const char* pcTypeHint,
                          char** ppcScopeList);



4.7.0.6. Description

   Sets ppcScopeList parameter to a pointer to a comma separated list
   including all available scope values.  The list of scopes comes from
   a variety of sources:  the configuration file's net.slp.useScopes
   property and the net.slp.DAAddresses property, DHCP, or through the



Kempf, Guttman             Expires 30 October 1998             [Page 37]

Internet Draft             Service Location API              30 May 1998


   DA discovery process.  If there is any order to the scopes, preferred
   scopes are listed before less desirable scopes.  There is always at
   least one name in the list, the default scope, "DEFAULT".


4.7.0.7. Parameters

      hSLP

         The SLPHandle on which to search for scopes.  May not be NULL.

      pcTypeHint

         A service type name to use as a hint if no scope information is
         available from DAs and SA discovery is used.  Must not be NULL.
         Note that the API is free to ignore the hint if SA discovery is
         not implemented or the API client passes in an empty string or
         syntactically invalid service type name.

      ppcScopeList

         A pointer to char pointer into which the buffer pointer is
         placed upon return.  The buffer is null terminated.  The memory
         should be freed by calling SLPFree().


4.7.0.8. Returns

   If no error occurs, returns SLP_OK, otherwise, the appropriate error
   code.


4.8. SLPParseSrvURL

4.8.0.9. Synopsis


   SLPError SLPParseSrvURL(char *pcSrvURL
                           SLPSrvURL** ppSrvURL);



4.8.0.10. Description

   Parses the URL passed in as the argument into a service URL structure
   and return it in the ppSrvURL pointer.  If a parse error occurs,
   returns SLP_PARSE_ERROR. The input buffer pcSrvURL is destructively
   modified during the parse and used to fill in the fields of the
   return structure.  The structure returned in ppSrvURL should be freed



Kempf, Guttman             Expires 30 October 1998             [Page 38]

Internet Draft             Service Location API              30 May 1998


   with SLPFreeURL().  If the URL has no service part, the s_pcSrvPart
   string is the empty string, "", i.e.  not NULL. If pcSrvURL is not
   a service:  URL, then the s_pcSrvType field in the returned data
   structure is the URL's scheme, which might not be the same as the
   service type under which the URL was registered.  If the transport is
   IP, the s_pcTransport field is the empty string.  If the transport is
   not IP or there is no port number, the s_iPort field is zero.


4.8.0.11. Parameters

      pcSrvURL

         A pointer to a character buffer containing the null terminated
         URL string to parse.  It is destructively modified to produce
         the output structure.  May not be NULL.

      ppSrvURL

         A pointer to a pointer for the SLPSrvURL structure to receive
         the parsed URL. May not be NULL. The memory should be freed by
         a call to SLPFree() when no longer needed.


4.8.0.12. Returns

   If no error occurs, the return value is the SLP_OK. Otherwise, if
   an error occurs, one of the SLPError codes is returned.  If no
   memory is available to allocate the character strings, returns
   SLP_COULD_NOT_ALLOCATE_MEMORY. If a parse error occurs, returns
   SLP_PROTOCOL_PARSE_ERROR.


4.9. SLPFree

4.9.0.13. Synopsis


   void SLPFree(void* pvMem);



4.9.0.14. Description

   Frees memory returned from SLPParseSrvURL(), SLPEscape(),
   SLPUnescape(), and SLPFindScopes().






Kempf, Guttman             Expires 30 October 1998             [Page 39]

Internet Draft             Service Location API              30 May 1998


4.9.0.15. Parameters

      pvMem

         A pointer to the storage allocated by the SLPParseSrvURL(),
         SLPEscape(), SLPUnescape(), or SLPFindScopes() function.
         Ignored if NULL.


4.10. SLPEscape

4.10.0.16. Synopsis


   SLPError SLPEscape(const char* pcInbuf,
                      char** ppcOutBuf,
                      SLPBoolean isTag);



4.10.0.17. Description

   Process the input string in pcInbuf and escape any SLP reserved
   characters.  If the isTag parameter is SLPTrue, then look for
   bad tag characters and signal an error if any are found with the
   SLP_PARSE_ERROR code.  The results are put into a buffer allocated by
   the API library and returned in the ppcOutBuf parameter.  This buffer
   should be deallocated using SLPFree() when the memory is no longer
   needed.


4.10.0.18. Parameters

      pcInbuf

         Pointer to he input buffer to process for escape characters.

      ppcOutBuf

         Pointer to a pointer for the output buffer with the SLP
         reserved characters escaped.  Must be freed using SLPFree()
         when the memory is no longer needed.

      isTag

         When true, the input buffer is checked for bad tag characters.






Kempf, Guttman             Expires 30 October 1998             [Page 40]

Internet Draft             Service Location API              30 May 1998


4.10.0.19. Returns

   Return SLP_PARSE_ERROR if any characters are bad tag characters and
   the isTag flag is true, otherwise SLP_OK.


4.11. SLPUnescape

4.11.0.20. Synopsis


   SLPError SLPUnescape(const char* pcInbuf,
                        char** ppcOutBuf,
                        SLPBoolean isTag);



4.11.0.21. Description

   Process the input string in pcInbuf and unescape any SLP reserved
   characters.  If the isTag parameter is SLPTrue, then look for
   bad tag characters and signal an error if any are found with the
   SLP_PARSE_ERROR code.  No transformation is performed if the input
   string is an opaque.  The results are put into a buffer allocated by
   the API library and returned in the ppcOutBuf parameter.  This buffer
   should be deallocated using SLPFree() when the memory is no longer
   needed.


4.11.0.22. Parameters

      pcInbuf

         Pointer to he input buffer to process for escape characters.

      ppcOutBuf

         Pointer to a pointer for the output buffer with the SLP
         reserved characters escaped.  Must be freed using SLPFree()
         when the memory is no longer needed.

      isTag

         When true, the input buffer is checked for bad tag characters.








Kempf, Guttman             Expires 30 October 1998             [Page 41]

Internet Draft             Service Location API              30 May 1998


4.11.0.23. Returns

   Return SLP_PARSE_ERROR if any characters are bad tag characters and
   the isTag flag is true, otherwise SLP_OK.


4.12. SLPGetProperty

4.12.0.24. Synopsis


   const char* SLPGetProperty(const char* pcName);



4.12.0.25. Description

   Returns the value of the corresponding SLP property name.  The
   returned string is owned by the library and MUST NOT be freed.


4.12.0.26. Parameters

      pcName

         Null terminated string with the property name, from
         Section 2.1.  May not be NULL.


4.12.0.27. Returns

   If no error, returns a pointer to the property value.  If the
   property was not set, returns the empty string, "".  If an error
   occurs, returns NULL. The returned string MUST NOT be freed.


4.13. SLPSetProperty

4.13.0.28. Synopsis


   void SLPSetProperty(const char *pcName,
                       const char *pcValue);









Kempf, Guttman             Expires 30 October 1998             [Page 42]

Internet Draft             Service Location API              30 May 1998


4.13.0.29. Description

   Sets the value of the SLP property to the new value.  The pcValue
   parameter should be the property value as a string.


4.13.0.30. Parameters

      pcName

         Null terminated string with the property name, from
         Section 2.1.  May not be NULL.

      pcValue

         Null terminated string with the property value, in character
         format.  May not be NULL.


4.14. Implementation Notes

4.14.1. Refreshing Registrations

   Because not all C platforms support multithreading, implementing
   automatic refreshing of registrations in the SA may be difficult.
   Therefore, automatic registration refreshing is not required of C
   implementations, however, implementations with multithreading are
   encouraged to support this important feature.


4.14.2. Syntax for String Parameters

   Query strings, attribute registration lists, attribute deregistration
   lists, scope lists, and attribute selection lists follow the syntax
   described in [11] for the appropriate requests.  The API directly
   reflects the strings passed in from clients into protocol requests,
   and directly reflects out strings returned from protocol replies to
   clients.  As a consequence, clients are responsible for formatting
   request strings, including escaping and converting opaque values to
   escaped byte encoded strings.  Similarly, on output, clients are
   required to unescape strings and convert escaped string encoded
   opaques to binary.  The functions SLPEscape() and SLPUnescape() can
   be used for escaping SLP reserved characters, but perform no opaque
   processing.

   Opaque values consist of a character buffer containing a UTF8-encoded
   string, the first characters of which are the nonUTF8 encoding '\ff'.
   Subsequent characters are the escaped values for the original bytes
   in the opaque.  The escape convention is relatively simple.  An



Kempf, Guttman             Expires 30 October 1998             [Page 43]

Internet Draft             Service Location API              30 May 1998


   escape consists of a backslash followed by the two hexadecimal digits
   encoding the byte.  in the ASCII subset of UTF8.  An example is '\2c'
   for the byte 0x2c.  Clients handle opaque processing themselves,
   since the algorithm is relatively simple and uniform.


4.14.3. Client Side Syntax Checking

   API implementations may do syntax checking of scope names, naming
   authority names, and service type names on the client side, but
   are not required to do so.  Since the C API is designed to be a
   thin layer over the protocol, some low memory SA implementations
   may find extensive syntax checking on the client side to be
   burdensome.  If syntax checking uncovers an error in a parameter, the
   SLP_PARAMETER_BAD error must be returned.  If any parameter is NULL
   and is required to be nonNULL, SLP_PARAMETER_BAD is returned.


4.14.4. System Properties

   The system properties established in the configuration file are
   accessable through the SLPGetProperty() and SLPSetProperty()
   functions.  The SLPSetProperty() function only modifies properties
   in the running process, not in the configuration file.  Errors
   are checked when the property is used and, as with parsing the
   configuration file, are logged.  Program execution continues without
   interruption by substituting the default for the erroneous parameter.
   In general, individual agents should rarely be required to override
   these properties, since they reflect properties of the SLP network
   that are not of concern to individual agents.  If changes are
   required, system administrators should modify the configuration file.


4.14.5. Memory Management

   The only API functions returning memory specifically requiring
   deallocation on the part of the client are SLPParseSrvURL(),
   SLPEscape(), SLPUnescape(), and SLPFindScopes().  This memory should
   be freed using SLPFree() when no longer needed.  Character strings
   returned via the SLPGetProperty() function should NOT be freed, they
   are owned by the SLP library.

   Memory passed to callbacks belongs to the library and MUST NOT be
   retained by the client code.  Otherwise, crashes are possible.
   Clients are required to copy data out of the callback parameters.  No
   other use of the memory in callback parameters is allowed.






Kempf, Guttman             Expires 30 October 1998             [Page 44]

Internet Draft             Service Location API              30 May 1998


4.14.6. Asychronous and Incremental Return Semantics

   If a handle parameter to an API function was opened asychronously,
   API function calls on the handle check the other parameters, open the
   appropriate operation and return immediately.  In an error occurs in
   the process of starting the operation, an error code is returned.  If
   the handle parameter was opened synchronously, the API function call
   blocks until all results are available, and returns only after the
   results are reported through the callback function.  The return code
   indicates whether any errors occured both starting and during the
   operation.

   The callback function is called whenever the API library has
   results to report.  The callback code is required to check the
   error code parameter before looking at the other parameters.  If
   the error code is not SLP_OK, the other parameters may be NULL or
   otherwise invalid.  The API library has the option of terminating
   any outstanding operation on which an error occurs.  The callback
   code can similarly indicate that the operation should be terminated
   by passing back SLP_FALSE. Callback functions are not permitted to
   recursively call into the API on the same SLPHandle.  If an attempt
   is made to recursively call into the API, the API function returns
   SLP_HANDLE_IN_USE. Prohibiting recursive callbacks on the same handle
   simplifies implementation of thread safe code, since locks held
   on the handle will not be in place during a second outcall on the
   handle.

   The total number of results received can be controlled by setting the
   net.slp.maxResults parameter.


4.15. Examples

4.15.1. Discovering one's mailbox

   A POP3 server might register itself with the SLP framework.  The
   attributes it registers are "USER", a comma delimited list of all
   users whose mail is available through the POP3 server.

   The POP3 server code could be the following:

   SLPHandle slph;
   SLPRegReport errCallback = POPRegErrCallback;

   /* Create an English SLPHandle, asynchronous processing. */

   SLPError err = SLPOpen("en", SLP_TRUE, &slph);

   if( err != SLP_OK ) {



Kempf, Guttman             Expires 30 October 1998             [Page 45]

Internet Draft             Service Location API              30 May 1998



 /* Deal with error. */

   }

   /* Create the service: URL and attribute parameters. */

   const char* surl = "service:pop3://mail.netsurf.de"; /* the URL */

   const char *pcScopeList = "default,engineering";

   const char *pcAttrs = "(user=sally,sue,sandra,zsuzsa)"

   err = SLPReg(slph,
                surl, SLP_LIFETIME_DEFAULT,
                pcScopeList, pcAttrs,
                errCallback, NULL);

   if (err != SLP_OK ) {

      /*Deal with error.*/

   }

   The errCallback reports any errors:

   void
   POPRegErrCallback(SLPHandle hSLP,
                     SLPError errCode,
                     void* pvCookie) {

      if( errCode != SLP_OK ) {

        /* Report error through a dialog, message, etc. */

      }
    }

   The POP3 client may locate the server for the user:

   /*
    * The client calls SLPOpen(), exactly as above.
    */

   const char *pcSrvType   = "service:pop3"; /* the service type  */
   const char *pcScopeList = "default";      /* the scope         */
   const char *pcFilter    = "(user=sue)";   /* the search filter */
   SLPSrvURLCallback srvCallback =           /* the callback      */
     POPSrvURLCallback;



Kempf, Guttman             Expires 30 October 1998             [Page 46]

Internet Draft             Service Location API              30 May 1998



   err = SLPFindSrvs(slph,
                     pcSrvType, pcScopeList, pcFilter,
                     srvCallback, NULL);

   if( err != SLP_OK ) {

       /* Deal with error. */

   }

   Within the callback, the client code can use the returned POP
   service:

  SLPBoolean
  POPSrvURLCallback(SLPHandle hSLP,
                    const char* pcSrvURL,
                    unsigned short sLifetime,
                    SLPError errCode,
                    void* pvCookie) {

     if( errCode != SLP_OK ) {

        /* Deal with error. */

     }

     SLPSrvURL* pSrvURL;

     errCode = SLPParseSrvURL(pcSrvURL, &pSrvURL);

     if (err != SLP_OK ) {

       /* Deal with error. */

     } else {

       /* get the server's address */

       struct hostent *phe = gethostbyname(pSrvURL.s_pcHost);

       /* use hostname in pSrvURL to connect to the POP3 server
        *     . . .
        */

       SLPFreeSrvURL(pSrvURL);         /* Free the pSrvURL storage */
     }

     return SLP_FALSE;                 /* Done! */



Kempf, Guttman             Expires 30 October 1998             [Page 47]

Internet Draft             Service Location API              30 May 1998


   }

   A client that wanted to discover all the users receiving mail at the
   server could do so with the following query:

   /*
    * The client calls SLPOpen(), exactly as above. We assume the
    * service: URL was retrieved into surl.
    */

   const char *pcScopeList = "default";      /* the scope            */
   const char *pcAttrFilter    = "use";      /* the attribute filter */
   SLPAttrCallback attrCallBack =            /* the callback         */
     POPUsersCallback


   err =
     SLPFindAttrs(slph,
                  surl,
                  pcScopeList, pcAttrFilter,
                  attrCallBack, NULL);

   if( err != SLP_OK ) {

        /* Deal with error. */

   }

   The callback processes the attributes:

   SLPBoolean
   POPUsersCallback(const char* pcAttrList,
                    SLPError errCode,
                    void* pvCookie) {

     if( errCode != SLP_OK ) {

       /* Deal with error. */

     } else {

       /* Parse attributes. */

     }

     return SLP_FALSE;  /* Done! */

   }




Kempf, Guttman             Expires 30 October 1998             [Page 48]

Internet Draft             Service Location API              30 May 1998


5. Java Language Binding

5.1. Introduction

   The Java API is designed to model the various SLP entities in
   classes and objects.  APIs are provided for SA, UA, and service type
   template access capabilities.  The ServiceLocationManager class
   contains methods that return instances of objects implementing SA
   and UA capability.  Each of these is modelled in an interface.
   The Locator interface provides UA capability and the Advertiser
   interface provides SA capability.  The TemplateRegistry abstract
   class contains methods that return objects for template introspection
   and attribute type checking.  The ServiceURL, ServiceType, and
   ServiceLocationAttribute classes model the basic SLP concepts.  A
   concrete subclass instance of TemplateRegistry is returned by a class
   method.

   All SLP classes and interfaces are located within a single package.
   The package name should begin with the name of the implementation and
   conclude with the suffix "slp".  Thus, the name for a hypothetical
   implementation from the University of Michigan would look like:

                             edu.umich.slp

   This follows the Java convention of prepending the top level DNS
   domain name for the organization implementing the package onto the
   organization's name and using that as the package prefix.


5.2. Exceptions and Errors

   Most parameters to API methods are required to be nonnull.  The
   API description indicates if a null parameter is acceptable, or
   if other restrictions constrain a parameter.  When parameters
   are checked for validity (such as not being null) or their
   syntax is checked, an error results in the RuntimeException
   subclass IllegalArgumentException being thrown.  Clients of the
   API are reminded that IllegalArgumentException, derived from
   RuntimeException, is unchecked by the compiler.  Clients should
   thus be careful to include try/catch blocks for it if the relevent
   parameters could be erroneous.

   Standard Java practice is to encode every exceptional condition as a
   seperate subclass of Exception.  Because of the relatively high cost
   in code size of Exception subclasses, the API contains only a single
   Exception subclass with different conditions being determined by an
   integer error code property.  A subset, appropriate to Java, of the
   error codes described in Section 3 are available as constants on the




Kempf, Guttman             Expires 30 October 1998             [Page 49]

Internet Draft             Service Location API              30 May 1998


   ServiceLocationException class.  The subset excludes error codes such
   as MEMORY_ALLOC_FAILED.


5.2.1. Class ServiceLocationException

5.2.1.1. Synopsis


   public class ServiceLocationException
   extends Exception



5.2.1.2. Description

   The ServiceLocationException class is thrown by all methods when
   exceptional conditions occur in the SLP framework.  The error
   code property determines the exact nature of the condition, and an
   optional message may provide more information.


5.2.1.3. Fields


   public static final short LANGUAGE_NOT_SUPPORTED;
   public static final short PARSE_ERROR;
   public static final short INVALID_REGISTRATION;
   public static final short SCOPE_NOT_SUPPORTED;
   public static final short AUTHENTICATION_FAILED;
   public static final short AUTHENTICATION_ABSENT;
   public static final short INVALID_UPDATE;
   public static final short NOT_IMPLEMENTED;
   public static final short NETWORK_INIT_FAILED;
   public static final short NETWORK_TIMED_OUT;
   public static final short NETWORK_ERROR;
   public static final short INTERNAL_SYSTEM_ERROR;
   public static final short TYPE_ERROR;



5.2.1.4. Instance Methods


   public short getErrorCode()


   Return the error code.  The error code takes on one of the static
   field values.



Kempf, Guttman             Expires 30 October 1998             [Page 50]

Internet Draft             Service Location API              30 May 1998


5.3. Basic Data Structures

5.3.1. Interface ServiceLocationEnumeration


   public interface ServiceLocationEnumeration
    extends Enumeration



5.3.1.1. Description

   The ServiceLocationEnumeration class is the return type for all
   Locator SLP operations.  The Java API library may implement this
   class to block until results are available from the SLP operation,
   so that the client can achieve asynchronous operation by retrieving
   results from the enumeration in a separate thread.  Clients use the
   superclass nextElement() method if they are unconcerned with SLP
   exceptions.


5.3.1.2. Instance Methods


   public abstract Object next() throws ServiceLocationException


   Return the next value or block until it becomes available.

   Throws:

      ServiceLocationException

         Thrown if the SLP operation encounters an error.

      NoSuchElementException

         If there are no more elements to return.


5.3.2. Class ServiceLocationAttribute

5.3.2.1. Synopsis


   public class ServiceLocationAttribute
     extends Object implements Serializable





Kempf, Guttman             Expires 30 October 1998             [Page 51]

Internet Draft             Service Location API              30 May 1998


5.3.2.2. Description

   The ServiceLocationAttribute class models SLP attributes.  Instances
   of this class are returned by Locator.findAttributes() and are
   communicated along with register/deregister requests.


5.3.2.3. Constructors


   public ServiceLocationAttribute(String id,Vector values)


   Construct a service location attribute.  Errors in the id or values
   vector result in an IllegalParameterException.

   Parameters:

      id

         The attribute name.  The String can consist of any Unicode
         character.

      values

         A Vector of one or more attribute values.  Vector contents
         must be uniform in type and one of Integer, String, Boolean,
         or byte[].  If the attribute is a keyword attribute, then
         parameter should be null.  String values can consist of any
         Unicode character.


5.3.2.4. Class Methods


   public static String escapeId(String id)
   throws ServiceLocationException


   Returns an escaped version of the id parameter, suitable for
   inclusion in a query.  Any reserved characters as specified in [11]
   are escaped using UTF8 encoding.

   Parameters:

      id

         The attribute id to escape.  ServiceLocationException is thrown
         if any characters are illegal in an id.



Kempf, Guttman             Expires 30 October 1998             [Page 52]

Internet Draft             Service Location API              30 May 1998



   public static String escapeValue(Object value)
   throws ServiceLocationException


   Returns a String containing the escaped value parameter as a String,
   suitable for inclusion in a query.  If the value parameter is a
   string, any reserved characters as specified in [11] are escaped
   using UTF8 encoding.  If the value parameter is a byte array, then
   the escaped string begins with the nonUTF8 sequence `\ff` and the
   rest of the string consists of the escaped bytes.  If the value
   parameter is a Boolean or Integer, then the returned string contains
   the object converted into a string.  If the value is any other type,
   an IllegalArgumentException is thrown.

   Parameters:

      value

         The attribute value to be converted into a string and escaped.


5.3.2.5. Instance Methods


   public Vector getValues()


   Returns a cloned vector of attribute values, or null if the attribute
   is a keyword attribute.  If the attribute is single-valued, then the
   vector contains only one object.


   public String getId()


   Returns the attribute's name.


   public boolean equals(Object o)


   Overrides Object.equals().  Two attributes are equal if their
   identifiers are equal and their value vectors contain the same number
   of equal values as determined by the Object equals() method.  Values
   having byte[] type are equal if the contents of all byte arrays in
   both vectors match.





Kempf, Guttman             Expires 30 October 1998             [Page 53]

Internet Draft             Service Location API              30 May 1998


   public String toString()


   Overrides Object.toString().


   public int hashCode()


   Overrides Object.hashCode().  Hashes on the attribute's id.


5.3.3. Class ServiceType

5.3.3.1. Synopsis


   public class ServiceType extends Object implements Serializable



5.3.3.2. Description

   The ServiceType object models the SLP service type.  It parses a
   string based service type specifier into its various components, and
   contains property accessors to return the components.  URL schemes,
   protocol service types, and abstract service types are all handled.


5.3.3.3. Constructors


   public ServiceType(String type)


   Construct a service type object from the service type specifier.
   Throws IllegalArgumentException if the type name is syntactically
   incorrect.

   Parameters:

      type

         The service type name as a String.  If the service type is from
         a service:  URL, the "service:" prefix must be intact.







Kempf, Guttman             Expires 30 October 1998             [Page 54]

Internet Draft             Service Location API              30 May 1998


5.3.3.4. Methods


   public boolean isServiceURL()


   Returns true if the type name contains the "service:" prefix.


   public boolean isServiceURL()


   Returns true if the type name contains the "service:" prefix.


   public boolean isAbstractType()


   Returns true if the type name is for an abstract type.


   public boolean isNADefault()


   Returns true if the naming authority is the default, i.e.  is the
   empty string.


   public String getConcreteTypeName()


   Returns the concrete type name in an abstract type, the protocol name
   in a protocol type, or the URL scheme if the type name is not for a
   service:  URL.


   public String getPrincipleTypeName()


   Returns the abstract type name for an abstract type or an empty
   string for a protocol type or URL scheme.


   public String getAbstractTypeName()


   If the type is an abstract type, returns the fully formatted abstract
   type name including the "service:" and naming authority but without
   the concrete type name or intervening colon.



Kempf, Guttman             Expires 30 October 1998             [Page 55]

Internet Draft             Service Location API              30 May 1998



   public String getNamingAuthority()


   Return the naming authority name, or the empty string if the naming
   authority is the default.


   public boolean equals(Object obj)


   Overrides Object.equals().  The two objects are equal if they are
   both ServiceType objects and the components of both are equal.


   public String toString()


   Returns the fully formatted type name, including the "service:" if
   the type was originally from a service:  URL.


   public int hashCode()


   Overrides Object.hashCode().  Hashes on the string value of the
   individual components of the service type name.


5.3.4. Class ServiceURL

5.3.4.1. Synopsis


   public class ServiceURL extends Object implements Serializable



5.3.4.2. Description

   The ServiceURL object models the advertised SLP service URL. It
   can be either a service:  URL or a regular URL. These objects are
   returned from service lookup requests, and describe the registered
   services.  This class should be a subclass of java.net.URL but can't
   since that class is final.







Kempf, Guttman             Expires 30 October 1998             [Page 56]

Internet Draft             Service Location API              30 May 1998


5.3.4.3. Class Variables


   public static final int NO_PORT


   Indicates that no port information is required or was returned for
   this URL.


   public static final int LIFETIME_NONE


   Indicates that the URL has a zero lifetime.  This value is never
   returned from the API, but can be used to create a ServiceURL object
   to deregister, delete attributes, or find attributes.


   public static final int LIFETIME_DEFAULT


   The default URL lifetime (3 hours) in seconds.


   public static final short LIFETIME_MAXIMUM


   The maximum URL lifetime (about 18 hours) in seconds.


5.3.4.4. Constructors


   public ServiceURL(String URL,short lifetime)


   Construct a service URL object having the specified lifetime.

   Parameters:

      URL

         The URL as a string.  Must be either a service:  URL or a valid
         regular URL.

      lifetime

         The service advertisement lifetime in seconds.  This value may
         be between LIFETIME_NONE and LIFETIME_MAXIMUM.



Kempf, Guttman             Expires 30 October 1998             [Page 57]

Internet Draft             Service Location API              30 May 1998


5.3.4.5. Methods


   public ServiceType getServiceType()


   Returns the service type object representing the service type name of
   the URL.


  public final void setServiceType(ServiceType type)
  throws ServiceLocationException


   Set the service type name to the object.  Ignored if the URL is a
   service:  URL.

   Parameters:

      type

         The service type object.


   public String getTransport()


   Get the network layer transport identifier.  If the transport is IP,
   an empty string, "", is returned.


   public String getHost()


   Returns the host identifier.  For IP, this will be the machine name
   or IP address.


   public int getPort()


   Returns the port number, if any.  For nonIP transports, always
   returns NO_PORT.


   public String getURLPath()


   Returns the URL path description, if any.



Kempf, Guttman             Expires 30 October 1998             [Page 58]

Internet Draft             Service Location API              30 May 1998



   public int getLifetime()


   Returns the service advertisement lifetime.  This will be a positive
   int between LIFETIME_NONE and LIFETIME_MAXIMUM.


   public boolean equals(Object obj)


   Compares the object to the ServiceURL and returns true if the two are
   the same.  Two ServiceURL objects are equal if their current service
   types match and they have the same host, port, transport, and URL
   path.


   public String toString()


   Returns formatted string with the URL. Overrides Object.toString().
   The returned URL has the original service type or URL scheme, not the
   current service type.


   public int hashCode()


   Overrides Object.hashCode().  Hashes on the current service type,
   transport, host, port, and URL part.


5.4. SLP Access Interfaces

5.4.1. Interface Advertiser

5.4.1.1. Synopsis


   public interface Advertiser



5.4.1.2. Description

   The Advertiser is the SA interface, allowing clients to register new
   service instances with SLP, to change the attributes of existing
   services, and to deregister service instances.  New registrations
   and modifications of attributes are made in the language locale



Kempf, Guttman             Expires 30 October 1998             [Page 59]

Internet Draft             Service Location API              30 May 1998


   with which the Advertiser was created, deregistrations of service
   instances are made for all locales.


5.4.1.3. Instance Methods


   public abstract Locale getLocale()


   Return the language locale with which this object was created.


   public abstract void register(ServiceURL URL,
                                 Vector     scopes,
                                 Vector     attributes)
   throws ServiceLocationException

   Register a new service with SLP having the given attributes and
   in the given scope.


   Parameters:

      URL

         The URL for the service.

      scopes

         A Vector of scope names.  Scope Strings MUST contain all
         the scopes returned from the results of a findScopes() API
         invocation.

      attributes

         A vector of ServiceLocationAttribute objects describing the
         service.


   public abstract void deregister(ServiceURL URL,Vector scopes)
   throws ServiceLocationException


   Deregister a service from the SLP framework.  This has the effect of
   deregistering the service from every language locale in the given
   scopes.

   Parameters:



Kempf, Guttman             Expires 30 October 1998             [Page 60]

Internet Draft             Service Location API              30 May 1998


      URL

         The URL for the service.

      scopes

         A Vector of scope names.  Scope Strings MUST contain all
         the scopes returned from the results of a findScopes() API
         invocation.


   public abstract void
   addAttributes(ServiceURL URL,
                 Vector scopes,
                 Vector attributes)
   throws ServiceLocationException


   Update the registration by adding the given attributes in the given
   scopes.

   Parameters:

      URL

         The URL for the service.

      scopes

         A Vector of scope names.  Scope Strings MUST contain all
         the scopes returned from the results of a findScopes() API
         invocation.

      attributes

         A Vector of ServiceLocationAttribute objects to add to the
         existing registration.  Use an empty vector to update the URL
         alone.  May not be null.


   public abstract void
   deleteAttributes(ServiceURL URL,
                    Vector scopes,
                    Vector attributeIds)
   throws ServiceLocationException


   Delete the attributes from a URL in all scopes for the locale with
   which the Advertiser was created.



Kempf, Guttman             Expires 30 October 1998             [Page 61]

Internet Draft             Service Location API              30 May 1998


   Parameters:

      URL

         The URL for the service.

      scopes

         A Vector of scope names.  Scope Strings MUST contain all
         the scopes returned from the results of a findScopes() API
         invocation.

      attributeIds

         A vector of Strings indicating the ids of the attributes to
         remove.  Use an empty vector to indicate all attributes.


5.4.2. Interface Locator

5.4.2.1. Synopsis


   public interface Locator



5.4.2.2. Description

   The Locator is the UA interface, allowing clients to query the SLP
   framework about existing service types, services instances, and about
   the attributes of an existing service instance or service type.
   Queries for services and attributes are made in the locale with which
   the Locator was created, queries for service types are independent of
   locale.


5.4.2.3. Instance Methods


   public abstract Locale getLocale()


   Return the language locale with which this object was created.


   public abstract ServiceLocationEnumeration
   findServiceTypes(String namingAuthority,
                    Vector scopes)



Kempf, Guttman             Expires 30 October 1998             [Page 62]

Internet Draft             Service Location API              30 May 1998


   throws ServiceLocationException


   Returns an enumeration of ServiceType objects giving known service
   types for the given scopes and given naming authority.  If no service
   types are found, an empty enumeration is returned.

   Parameters:

      namingAuthority

         The naming authority.  Use "" for the default naming authority
         and "*" for all naming authorities.

      scopes

         A Vector of scope names.  Scope Strings SHOULD be selected from
         the results of a findScopes() API invocation.  Use "DEFAULT"
         for the default scope.


   public abstract ServiceLocationEnumeration
   findServices(ServiceType type,
                Vector scopes,
                String searchFilter)
   throws ServiceLocationException


   Returns a vector of ServiceURL objects for services matching the
   query, and having a matching type in the given scopes.  If no
   services are found, an empty enumeration is returned.

   Parameters:

      type

         The SLP service type of the service.

      scopes

         A Vector of scope names.  Scope Strings SHOULD be selected from
         the results of a findScopes() API invocation.  Use "DEFAULT"
         for the default scope.

      searchFilter

         An LDAPv3 [8] string encoded query.  If the filter is empty,
         ie.  "", all services of the requested type in the specified
         scopes are returned.  SLP reserved characters must be escaped



Kempf, Guttman             Expires 30 October 1998             [Page 63]

Internet Draft             Service Location API              30 May 1998


         in the query.  Use ServiceLocationAttribute.escapeId() and
         ServiceLocatinAttribute.escapeValue() to construct the query.


   public abstract ServiceLocationEnumeration
   findAttributes(ServiceURL URL,
                  Vector     scopes,
                  Vector     attributeIds)
   throws ServiceLocationException


   For the URL and scope, return a Vector of ServiceLocationAttribute
   objects whose ids match the String patterns in the attributeIds
   Vector.  The request is made in the language locale of the Locator.
   If no attributes match, an empty enumeration is returned.

   Parameters:

      URL

         The URL for which the attributes are desired.

      scopes

         A Vector of scope names.  Scope Strings SHOULD be selected from
         the results of a findScopes() API invocation.  Use "DEFAULT"
         for the default scope.

      attributeIds

         A Vector of String patterns identifying the desired attributes.
         An empty vector means return all attributes.  As described
         in [11], the patterns may include wildcards to match
         all prefixes or suffixes.  The patterns may include SLP
         reserved characters, they will be escaped by the API before
         transmission.


   public abstract ServiceLocationEnumeration
   findAttributes(ServiceType type,
                  Vector scopes,
                  Vector attributeIds)
   throws ServiceLocationException


   For the type and scope, return a Vector of all ServiceLocationAttribute
   objects whose ids match the String patterns in the attributeIds
   Vector.  The request is made independent of language locale.  If no
   attributes are found, an empty vector is returned.



Kempf, Guttman             Expires 30 October 1998             [Page 64]

Internet Draft             Service Location API              30 May 1998


   Parameters:

      serviceType

         The service type.

      scopes

         A Vector of scope names.  Scope Strings SHOULD be selected from
         the results of a findScopes() API invocation.  Use "DEFAULT"
         for the default scope.

      attributeIds

         A Vector of String patterns identifying the desired attributes.
         An empty vector means return all attributes.  As described
         in [11], the patterns may include wildcards to match
         all prefixes or suffixes.  The patterns may include SLP
         reserved characters, they will be escaped by the API before
         transmission.


5.5. The Service Location Manager

5.5.1. Class ServiceLocationManager

5.5.1.1. Synopsis


    public class ServiceLocationManager
    extends Object



5.5.1.2. Description

   The ServiceLocationManager manages access to the service location
   framework.  Clients obtain the Locator and Advertiser objects
   for UA and SA, and a Vector of known scope names from the
   ServiceLocationManager.


5.5.1.3. Class Methods


 public static Vector findScopes(ServiceType typeHint)
 throws ServiceLocationException





Kempf, Guttman             Expires 30 October 1998             [Page 65]

Internet Draft             Service Location API              30 May 1998


   Returns an Vector of strings with all available scope names.  The
   list of scopes comes from a variety of sources.  Scope names obtained
   through DHCP have first priority, followed by scope names in the
   net.slp.useScopes property.  These names are used to filter names
   obtained from the net.slp.DAAddresses property and through active
   and passive discovery.  There is always at least one string in the
   Vector, the default scope, "DEFAULT".

   Parameters:

      typeHint

         A service type name to use as a hint if no scope information is
         available from DAs and SA discovery is used.  May be null if SA
         discovery is not desired.  Note that the API is free to ignore
         the hint if SA discovery is not implemented.


   public static Locator
   getLocator(Locale locale)
   throws ServiceLocationException


   Return a Locator object for the given language Locale.  If the
   implementation does not support UA functionality, returns null.

   Parameters:

      locale

         The language locale of the Locator.  The default SLP locale is
         used if null.


   public static Advertiser
   getAdvertiser(Locale locale)
   throws ServiceLocationException


   Return an Advertiser object for the given language locale.  If the
   implementation does not support SA functionality, returns null.

   Parameters:

      locale

         The language locale of the Advertiser.  The default SLP locale
         is used if null.




Kempf, Guttman             Expires 30 October 1998             [Page 66]

Internet Draft             Service Location API              30 May 1998


5.6. Service Template Introspection

5.6.1. Abstract Class TemplateRegistry

5.6.1.1. Synopsis


   public abstract class TemplateRegistry



5.6.1.2. Description

   Subclasses of the TemplateRegistry abstract class provide
   access to service location templates [12].  Classes implementing
   TemplateRegistry perform a variety of functions.  They manage the
   registration and access of service type template documents.  They
   create attribute verifiers from service templates, for verification
   of attributes and introspection on template documents.  Note that
   clients of the Advertiser are not required to verify attributes
   before registering (though they may get a TYPE_ERROR if the
   implementation supports type checking and there is a mismatch with
   the template).


5.6.1.3. Class Methods


   public static TemplateRegistry getTemplateRegistry();


   Returns the distinguished TemplateRegistry object for performing
   operations on and with service templates.  Returns null if the
   implementation doesn't support TemplateRegistry functionality.


5.6.1.4. Instance Methods


   public abstract void
   registerServiceTemplate(ServiceType type,
                           String documentURL,
                           Locale locale,
                           String version)
   throws ServiceLocationException


   Register the service template with the template registry.




Kempf, Guttman             Expires 30 October 1998             [Page 67]

Internet Draft             Service Location API              30 May 1998


   Parameters:

      type

         The service type.

      documentURL

         The URL of the template document.

      locale

         A Locale object containing the language locale of the template.

      version

         The version number of template document.


   public abstract void
   deregisterServiceTemplate(ServiceType type,
                             Locale locale,
                             String version)
   throws ServiceLocationException


   Deregister the template for the service type.

   Parameters:

      type

         The service type.

      locale

         A Locale object containing the language locale of the template.

      version

         A String containing the version number.  Use null to indicate
         the latest version.


   public abstract
   String findTemplateURL(ServiceType type,
                          Locale locale,
                          String version)
   throws ServiceLocationException



Kempf, Guttman             Expires 30 October 1998             [Page 68]

Internet Draft             Service Location API              30 May 1998




   Returns the URL for the template document.

   Parameters:

      type

         The service type.

      locale

         A Locale object containing the language locale of the template.

      version

         A String containing the version number.  Use null to indicate
         the latest version.


   public abstract
   ServiceLocationAttributeVerifier
   attributeVerifier(String documentURL)
   throws ServiceLocationException


   Reads the template document URL and returns an attribute verifier
   for the service type.  The attribute verifier can be used for
   verifying that registration attributes match the template, and for
   introspection on the template definition.

   Parameters:

      documentURL

         A String containing the template document's URL.


5.6.2. Interface ServiceLocationAttributeVerifier

5.6.2.1. Synopsis


   public interface ServiceLocationAttributeVerifier








Kempf, Guttman             Expires 30 October 1998             [Page 69]

Internet Draft             Service Location API              30 May 1998


5.6.2.2. Description

   The ServiceLocationAttributeVerifier provides access to service
   templates.  Classes implementing this interface parse SLP template
   definitions, provide information on attribute definitions for
   service types, and verify whether a ServiceLocationAttribute object
   matches a template for a particular service type.  Clients obtain
   ServiceLocationAttributeVerifier objects for specific SLP service
   types through the TemplateRegistry.


5.6.2.3. Instance Methods


   public abstract ServiceType getServiceType()


   Returns the SLP service type for which this is the verifier.


   public abstract Vector
   getTemplateAttributeDescriptors()


   Returns a Vector of ServiceLocationAttributeDescriptor objects
   describing the template service type attributes.  The template
   service type attributes are:

      service-type

         The SLP service type name (a String).

      version

         The version number of the template (a String).

      language

         The RFC 1766 [10] Language Tag locale of the template (a
         String).

      description

         A natural language description of the service in the language
         of the language locale (a String).







Kempf, Guttman             Expires 30 October 1998             [Page 70]

Internet Draft             Service Location API              30 May 1998


      url-syntax

         An ABNF [9] description for the of the service type's URL (a
         String).


   public abstract Vector
   getTemplateAttributes()


   Returns a Vector of ServiceLocationAttribute objects for the template
   attributes of this service type.  The template attributes are listed
   above.  The ServiceLocationAttribute objects in this vector have the
   actual values of the template attributes.


   public abstract ServiceLocationAttributeDescripton
   getAttributeDescriptor(String attrId)


   Return the ServiceLocationAttributeDescription for the attribute
   having the named id.  If no such attribute exists in this template,
   return null.  This method is primarily for GUI tools to display
   attribute information.  Programmatic verification of attributes
   should use the verifyAttribute() method.


   public abstract Enumeration
   getAttributeDescriptors()


   Returns an Enumeration allowing introspection on the attribute
   definition in the service template.  The Enumeration returns
   ServiceLocationAttributeDescriptor objects for the attributes.
   This method is primarily for GUI tools to display attribute
   information.  Programmatic verification of attributes should use the
   verifyAttribute() method.


   public abstract void
   verifyAttribute(
     ServiceLocationAttribute attribute)
   throws ServiceLocationException


   Verify that the attribute matches the template definition.  If the
   attribute doesn't match, ServiceLocationException is thrown with the
   error code as ServiceLocationException.PARSE_ERROR.




Kempf, Guttman             Expires 30 October 1998             [Page 71]

Internet Draft             Service Location API              30 May 1998


   Parameters:

      attribute

         The ServiceLocationAttribute object to be verified.


   public abstract void
   verifyRegistration(
     Vector attributeVector)
   throws ServiceLocationException


   Verify that the Vector of ServiceLocationAttribute objects matches
   the template for this service type.  The vector must contain all the
   required attributes, and all attributes must match their template
   definitions.  If the attributes don't match, ServiceLocationException
   is thrown with the error code as ServiceLocationException.PARSE_ERROR

   Parameters:

      attributeVector

         A Vector of ServiceLocationAttribute objects for the
         registration.


5.6.3. Interface ServiceLocationAttributeDescriptor

5.6.3.1. Synopsis


   public interface
   ServiceLocationAttributeDescriptor



5.6.3.2. Description

   The ServiceLocationAttributeDescriptor interface provides
   introspection on a template attribute defintion.  Classes
   implementing the ServiceLocationAttributeDescriptor interface return
   information on a particular service location attribute definition
   from the service template.  This information is primarily for GUI
   tools.  Programmatic attribute verification should be done through
   the ServiceLocationAttributeVerifier.






Kempf, Guttman             Expires 30 October 1998             [Page 72]

Internet Draft             Service Location API              30 May 1998


5.6.3.3. Instance Methods


   public abstract String getId()


   Return a String containing the attribute's id.


   public abstract String getValueType()


   Return a String containing the fully package-qualified Java type of
   the attribute.  SLP types are translated into Java types as follows:

      STRING

         "java.lang.String"

      INTEGER

         "java.lang.Integer"

      BOOLEAN

         "java.lang.Boolean"

      OPAQUE

         "[B" (i.e.  array of byte, byte[])

      KEYWORD

         empty string, ""


 public abstract String getDescription()


   Return a String containing the attribute's help text.


   public abstract Enumeration
   getAllowedValues()


   Return an Enumeration of allowed values for the attribute type.
   For keyword attributes returns null.  For no allowed values (i.e.
   unrestricted) returns an empty Enumeration.



Kempf, Guttman             Expires 30 October 1998             [Page 73]

Internet Draft             Service Location API              30 May 1998



   public abstract Enumeration
   getDefaultValues()


   Return an Enumeration of default values for the attribute type.
   For keyword attributes returns null.  For no allowed values (i.e.
   unrestricted) returns an empty Enumeration.


   public abstract boolean getIsMultivalued()


   Returns true if the "M" flag is set.


   public abstract boolean getIsOptional()


   Returns true if the "O"" flag is set.


   public abstract boolean
   getRequiredAttribute()


   Returns true if the "X"" flag is set, indicating that the attribute
   SHOULD be included in an any Locator.findServices() request search
   filter.


   public abstract boolean getIsLiteral()


   Returns true if the "L" flag is set.


   public abstract boolean getIsKeyword()


   Returns true if the attribute is a keyword attribute.











Kempf, Guttman             Expires 30 October 1998             [Page 74]

Internet Draft             Service Location API              30 May 1998


5.7. Implementation Notes

5.7.1. Refreshing Registrations

   Because Java supports threads at the language level, automatic
   refreshing of service advertisements in the Advertiser API is
   required.


5.7.2. Parsing Alternate Transports in ServiceURL

   The ServiceURL class is designed to handle multiple transports.  The
   standard API performs no additional processing on transports other
   than IP. However, implementations are free to subclass ServiceURL
   and support additional methods that provide more detailed parsing of
   alternate transport information.  For IP transport, the port number,
   if any, is returned from the getPort() method.  For nonIP transports,
   the getPort() method returns NO_PORT.


5.7.3. Client Side Syntax Checking

   The syntax of scope names, service type names, naming authority
   names, and URLs is described in [11] and [12].  The various methods
   and classes taking String parameters for these entities should
   type check the parameters for syntax errors on the client side,
   and throw an IllegalArgumentException if an error occurs.  In
   addition, character escaping should be implemented before network
   transmission for escapable characters in attribute ids and String
   values.  This reduces the number of error messages transmitted.  The
   ServiceLocationAttribute class provides methods for obtaining escaped
   attribute id and value strings to facilitate query construction.


5.7.4. Language Locale Handling

   The Locator and Advertiser interfaces are created with a Locale
   parameter.  The language locale with which these objects are created
   is used in all SLP requests issued through the object.  If the Locale
   parameter is null, the default SLP locale is used.  The default SLP
   locale is determined by, first, checking the net.slp.locale System
   property.  If that is unset, then the default SLP locale [11] is
   used, namely "en".  The net.slp.locale property is the only SLP
   system property that a client of the API would routinely override.








Kempf, Guttman             Expires 30 October 1998             [Page 75]

Internet Draft             Service Location API              30 May 1998


5.7.5. Setting SLP System Properties

   SLP system properties that are originally set in the configuration
   file can be overridden programmatically in API clients by simply
   invoking the System.getProperties() operation to get a copy of the
   system properties, modifying or adding the SLP property in question,
   then using System.setProperties() to set the properties to the
   modified Property object.  Errors are checked when the property
   is used and, as with parsing the configuration file, are logged.
   Program execution continues without interruption by substituting the
   default for the erroneous parameter.  In general, individual agents
   should rarely be required to override these properties, since they
   reflect properties of the SLP network that are not of concern to
   individual agents.  If changes are required, system administrators
   should modify the configuration file.


5.7.6. Multithreading

   Thread-safe operation are relatively easy to achieve in Java.  By
   simply making each method in the classes implementing the Locator
   and Advertiser interfaces synchronized, and by synchronizing access
   to any shared data structures within the class the Locator and
   Advertiser interfaces are made safe.  Alternatively, finer grained
   synchronization is also possible within the classes implementing
   Advertiser and Locator.


5.7.7. Modular Implementations

   While, at first glance, the API may look rather heavyweight, the
   design has been carefully arranged so that modular implementations
   that provide only SA, only UA, or only service template access
   capability, or any combination of the three, are possible.

   Because the objects returned from the ServiceLocationManager.getLocator()
   and ServiceLocationManager.getAdvertiser() operations are interfaces,
   and because the objects returned through those interfaces are in
   the set of base data structures, an implementation is free to omit
   either UA or SA capability by simply returning null from the instance
   creation operation if the classes implementing the missing function
   is cannot be dynamically linked.  API clients are encouraged to check
   for such a contingency, and to signal an exception if it occurs.
   Similarly, the TemplateRegistry subclass can simply be omitted from
   an implementation that only supports UA and/or SA clients, and
   the getRegistry() method can return null.  In this way, the API
   implementation can be taylored for the particular memory requirements
   at hand.




Kempf, Guttman             Expires 30 October 1998             [Page 76]

Internet Draft             Service Location API              30 May 1998


   In addition, if an implementation only supports the minimal subset of
   SLP [11], the unsupported Locator and Advertiser interface operations
   can throw an exception with ServiceLocationException.NOT_IMPLEMENTED
   as the error code.  This supports better source portablity between
   low and high memory platforms.


5.7.8. Asynchronous and Incremental Return Semantics

   The Java API contains no specific support for asychronous operation.
   Incremental return is not needed for the Advertiser because service
   registrations can be broken up into pieces when large.  Asychronous
   return is also not needed because clients can always issue the
   Advertiser operation in a separate thread if the calling thread can't
   block.

   The Locator can be implemented either sychronously or
   asychronously.  Since the return type for Locator calls is
   ServiceLocationEnumeration, a Java API implementation that supports
   asynchronous semantics can implement ServiceLocationEnumeration
   to dole results out as they come in, blocking when no results are
   available.  If the client code needs to support other processing
   while the results are trickling in, the call into the enumeration to
   retrieve the results can be done in a separate thread.

   Unlike the C case, collation semantics for return of attributes when
   the request is made with a service type require that the API collate
   returned values so that only one attribute having a collation of all
   returned values appear to the API client.  In practice, this may
   limit the amount of asychronony possible with the findAttributes()
   method.  This requirement is imposed because memory management is
   much easier in Java and so implementing collation as part of the API
   should not be as difficult as in C, and it saves the client from
   having to do the collation.


5.8. Examples

   In this example, a printer server advertises its availability to
   clients.  Additionally, the server advertises a service template for
   use by client software in validating service requests:


  //Get the Advertiser and TemplateRegistry.

  Advertiser adv = null;
  TemplateRegistry tr = null

  try {



Kempf, Guttman             Expires 30 October 1998             [Page 77]

Internet Draft             Service Location API              30 May 1998



    adv = ServiceLocationManager.getAdvertiser("en");

    tr = TemplateRegistry.getTemplateRegistry();

  } catch( ServiceLocationException ex ) { } //Deal with error.

  if( adv == null ) {

    //Serious error as printer can't be registered
    //  if the implementation doesn't support SA
    //  functionality.

  }

  //Get the scopes in which we are supposed to
  //  register.

  Vector scopes = ServiceLocationManager.findScopes();

  //Get the printer's attributes, from a file or
  //  otherwise. We assume that the attributes
  //  conform to the template, otherwise, we
  //  could register the template here and verify
  //  them.

  Vector attributes = getPrinterAttributes();

  //Create the service: URL for the printer.

  ServiceURL printerURL =
    new ServiceURL(
      "service:printer:lpr://printshop/color2",
      ServiceURL.LIFETIME_MAXIMUM);

  try {

    //Register the printer in all scopes.

    adv.register(printerURL, scopes, attributes);

    //If the template registry is available,
    //  register the printer's template.

    if( tr != null ) {
      tr.registerServiceTemplate(
        new ServiceType("service:printer"),
        "http://shop.arv/printer/printer-lpr.slp",
        new Locale("en",""),



Kempf, Guttman             Expires 30 October 1998             [Page 78]

Internet Draft             Service Location API              30 May 1998


        "1.0");

   }

  } catch( ServiceLocationException ex ) { } //Deal with error.


   Suppose a client is looking for color printer.  The following code
   might be used to issue a request for printer advertisements:


  Locator loc = null;
  TemplateRegistry tr = null;

  try {

    loc = ServiceLocationManager.getLocator("en");

  } catch( ServiceLocationException ex ) { } //Deal with error.

  if( loc == null ) {

    //Serious error as client can't be located
    //  if the implementation doesn't support
    //  UA functionality.

  }

  //We want a color printer that does CMYK
  //  and prints at least 600 dpi.

  String query = "(&(marker-type=CMYK)(resolution=600))";

  //Get scopes.

  Vector scopes = ServiceLocationManager.findScopes();

  Enumeration services;

  try {

    services =
      loc.findServices(new ServiceType("service:printer"),scopes,query);

  } catch { } //Deal with error.

  if (services.hasMoreElements() ) {

    //Printers can now be used.



Kempf, Guttman             Expires 30 October 1998             [Page 79]

Internet Draft             Service Location API              30 May 1998


    ServiceURL surl = (ServiceURL) services.next();

    Socket sock = new Socket(surl.getHost, surl.getPort());

    // Use the Socket...

  }



6. Internationalization Considerations

6.1. service URL

   The service URL itself must be encoded using the rules set forth
   in [2].  The character set encoding is limited to specific ranges
   within the UTF8 character set [7].

   The attribute information associated with the service URL may be
   expressed in any character set, and in any language.  See [12] for
   attribute internationalization guidelines.


6.2. Character Set Encoding

   Configuration and serialized registration files are encoded in
   the UTF8 character set [7].  This is fully compatible with ASCII
   character values.  C platforms that do not support UTF8 are required
   to check the top bit of input bytes to determine whether the incoming
   character is multibyte.  If it is, the character should be dealt with
   accordingly.  Since the SLP wire protocol requires that strings are
   encoded as UTF8, C platforms without UTF8 support need to supply
   their own support, if only in the form of multibyte string handling.

   At the API level, the character encoding is specified to be Unicode
   for Java and UTF8 for C. Unicode is the default in Java.  For C, the
   standard ASCII 8 bits per character, null terminated C strings are
   a subset of the UTF8 character set, and so work in the API. Because
   the C API is very simple, the API library needs to do a minimum of
   processing on UTF8 strings.  They primarily just need to be reflected
   into the outgoing SLP messages, and reflected out of the API from
   incoming SLP messages.


6.3. Language Tagging

   All SLP requests and registrations are tagged to indicate in which
   language the strings included are encoded.  This allows multiple
   languages to be supported.  It also presents the possibility that



Kempf, Guttman             Expires 30 October 1998             [Page 80]

Internet Draft             Service Location API              30 May 1998


   error conditions result when a request is made in a language that is
   not supported.  In this case, an error is only returned when there is
   data available, but not obtainable in the language requested.

   The dialect portion of the Language Tag is used on 'best effort'
   basis for matching strings by SLP. Dialects that match are prefered
   over those which don't.  Dialects that do not match will not prevent
   string matching or comparisons to occur.


7. Security Considerations

   SLP makes use of an existing host based authentication framework once
   it becomes available as an Internet Standard. [5]

   An adversary could delete valid service advertisements, provide false
   service information and deny UAs knowledge of existing services
   unless the mechanisms in SLP for authenticating SLP messages are
   used.  These mechanisms allow DA Adverts, SA Adverts, Service URLs
   and Service Attributes to be verified using digital cryptography.
   For this reason, all SLP agents SHOULD be configured to use protected
   scopes and DA Advertisement verifying cryptographic keys.  See [11]
   for a description of how these mechanisms work.


8. Acknowledgements

   The authors would like to thank Don Provan for his pioneering work
   during the initial stages of API definition.























Kempf, Guttman             Expires 30 October 1998             [Page 81]

Internet Draft             Service Location API              30 May 1998


References

    [1] ANSI.  Coded Character Set -- 7-bit American Standard code for
        Information Interchange.  X3.4-1986, 1986.

    [2] T. Berners-Lee, R. Fielding, and L. Masinter.  Uniform Resource
        Locators (URL): Generic Syntax and Semantics.  RFC1738 as
        amended by RFC1808 and updated by draft-fielding-url-syntax-05.txt,
        May 1997.  (work in progress).

    [3] J. Veizades, E. Guttman, C. Perkins, and S. Kaplan.  Service
        Location Protocol.  RFC 2165, July 1997.

    [4] IANA  IANA Character Set Registry
        <URL:http://www.isi.edu/in-notes/iana/assignments/character-sets>

    [5] R. Atkinson  Security Architecture for the Internet  RFC 1825
        July 1995

    [6] Geneva ISO  Code for the representation of names of languages
        ISO 639:1998 (E/F)  1998

    [7] F. Yerfeau  UTF-8, a transformation format of ISO 10646.  RFC
        2279  January 1998.

    [8] T. Howes  The String Representation of LDAP Search Filters  RFC
        2254  December 1997.

    [9] D. Crocker and P Overell.  Augmented BNF for Syntax
        Specifications:  ABNF.  RFC 2234  November 1997.

   [10] H. Alvestrand.  Tags for the Identification of Languages.  RFC
        1766  March 1995.

   [11] E. Guttman, C. Perkins, J. Veizades, and M. Day.  Service
        Location Protocol.  draft-ietf-svrloc-protocol-v2-04.txt  A work
        in progress  March 1998.

   [12] E. Guttman, C. Perkins, J. Kempf  Service Templates and service:
        Schemes  draft-ietf-svrloc-service-scheme-09.txt  A work in
        progress  March 1998.











Kempf, Guttman             Expires 30 October 1998             [Page 82]

Internet Draft             Service Location API              30 May 1998


Authors' Addresses

   Questions about this memo can be directed to:

James Kempf                                  Erik Guttman
Sun Microsystems                             Sun Microsystems
901 San Antonio Rd.                          Bahnstr. 2
Palo Alto, CA, 94303                         74915 Waibstadt
USA                                          Germany
+1 650 786 5890                              +49 7263 911 701
+1 650 786 6445 (fax)
james.kempf@sun.com                          erik.guttman@sun.com








































Kempf, Guttman             Expires 30 October 1998             [Page 83]
