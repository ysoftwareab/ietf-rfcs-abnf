H_0 = H(p, T, m, t, v, y, length(P), P, length(S), S,
                  length(K), K, length(X), X)

C = B[0][q-1] XOR B[1][q-1] XOR ... XOR B[p-1][q-1]
r = ceil(T/32)-2
V_1 = H_64(T||X)
V_2 = H_64(V_1)
V_r = H_64(V_{r-1})
w=ceil(q/128) blocks Y_1,Y_2,...,Y_w. application of the 2-round
Y_i=( r || l || s || m' || t || y || i || 0 ), where

x = floor(J_1**2 / 2**32);
y = floor((|R| * x) / 2**32);
z = |R| - 1 - y;

data_independent_addressing = (instance->type == Argon2_i);

pseudo_rands = (uint64_t *)malloc(sizeof(uint64_t) *
                                       (instance->segment_length));

starting_index = 0;

starting_index = 2;
curr_offset = position.lane * instance->lane_length +
                   position.slice * instance->segment_length +
                   starting_index;

prev_offset = curr_offset + instance->lane_length - 1;
prev_offset = curr_offset - 1;
prev_offset = curr_offset - 1;
pseudo_rand = pseudo_rands[i];
pseudo_rand = instance->memory[prev_offset].v[0];
ref_lane = ((pseudo_rand >> 32)) % instance->lanes;

ref_lane = position.lane;
ref_index = index_alpha(instance, &position,
                               pseudo_rand & 0xFFFFFFFF,
ref_lane == position.lane);

ref_block = instance->memory +
                   instance->lane_length * ref_lane + ref_index;
curr_block = instance->memory + curr_offset;
reference_area_size =
reference_area_size = position->slice *
                                 instance->segment_length +
                                 position->index - 1;
reference_area_size = position->slice *
                                 instance->segment_length +
                                 ((position->index == 0) ? (-1) : 0);
reference_area_size = instance->lane_length -
                               instance->segment_length +
                               position->index - 1;
reference_area_size = instance->lane_length -
                               instance->segment_length +
                               ((position->index == 0) ? (-1) : 0);
relative_position = pseudo_rand;
relative_position = relative_position * relative_position >> 32;
relative_position = reference_area_size - 1 -
                         (reference_area_size * relative_position >> 32);

start_position = 0;

start_position = (position->slice == ARGON2_SYNC_POINTS - 1)
                         ? 0
                         : (position->slice + 1) *
                         instance->segment_length;
absolute_position = (start_position + relative_position) %
                          instance->lane_length; /* absolute position */
thread = calloc(instance->lanes, sizeof(argon2_thread_handle_t));
thr_data = calloc(instance->lanes, sizeof(argon2_thread_data));
rc = argon2_thread_join(thread[l - instance->threads]);
rc = argon2_thread_create(&thread[l], &fill_segment_thr,
                                     (void *)&thr_data[l]);
rc = argon2_thread_join(thread[l]);
