K = MD4(UNICODE(password)) 
         
T = 0 in the generation of sequence number for the MIC token  
T = 0 in the generation of sequence number for the WRAP token  
T = 0 in the generation of encrypted data for the WRAPPED token 
    
Ksign = HMAC(K, "signaturekey")  //includes zero octet at end 
tmp = MD5(concat(T, data)) 
CHKSUM = HMAC(Ksign, tmp) 
    
    
T = the message type, encoded as a little-endian four byte integer. 
    
        OCTET L40[14] = "fortybits"; 
        OCTET SK = "signaturekey"; 
         
K3 = HMAC (K1, edata.Checksum); 
         
K3 = HMAC (K1, edata.Checksum); 
         
checksum = HMAC (K2, concat(edata.Confounder, edata.Data)); 
Ksign = HMAC(Kss, "signaturekey"); 
                                  // length includes terminating null 
         
Sgn_Cksum = MD5((int32)15, Token.Header, data); 
         
Sgn_Cksum = HMAC(Ksign, Sgn_Cksum); 
Kseq = HMAC(Kss, "fortybits", (int32)0); 
                                     // len includes terminating null 
Kseq = HMAC(Kss, (int32)0); 
Kseq = HMAC(Kseq, Token.SGN_CKSUM); 
         
Ksign = HMAC(Kss, "signaturekey"); 
         
Sgn_Cksum = MD5((int32)15, Token.Header, 
                                Token.Confounder); 
         
Kcrypt = HMAC(Klocal, "fortybits", (int32)0); 
                                    // len includes terminating null 
Kcrypt = HMAC(Klocal, (int32)0); 
  
Kcrypt = HMAC(Kcrypt, (int32)seq); 
         
Sgn_Cksum = HMAC(Ksign, Sgn_Cksum); 
Kseq = HMAC(Kss, "fortybits", (int32)0); 
                                      // len includes terminating null 
Kseq = HMAC(Kss, (int32)0); 
Kseq = HMAC(Kseq, Token.SGN_CKSUM); 
         
