<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Traversal Using Relays around NAT (TURN): Relay
    Extensions to Session Traversal Utilities for NAT (STUN)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Traversal Using Relays around NAT (TURN): Relay
    Extensions to Session Traversal Utilities for NAT (STUN)">
<meta name="keywords" content="NAT, TURN, STUN, ICE">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">BEHAVE WG</td><td class="header">J. Rosenberg</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Cisco</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">R. Mahy</td></tr>
<tr><td class="header">Expires: January 14, 2009</td><td class="header">Plantronics</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">P. Matthews</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">(Unaffiliated)</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">July 13, 2008</td></tr>
</table></td></tr></table>
<h1><br />Traversal Using Relays around NAT (TURN): Relay
    Extensions to Session Traversal Utilities for NAT (STUN)<br />draft-ietf-behave-turn-09</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 14, 2009.</p>

<h3>Abstract</h3>

<p>If a host is located behind a NAT, then in certain situations it can
      be impossible for that host to communicate directly with other hosts
      (peers) located behind other NATs. In these situations, it is necessary
      for the host to use the services of an intermediate node that acts as a
      communication relay. This specification defines a protocol, called TURN
      (Traversal Using Relays around NAT), that allows the host to control the
      operation of the relay and to exchange packets with its peers using the
      relay.
</p>
<p>The TURN protocol can be used in isolation, but is more properly used
      as part of the ICE (Interactive Connectivity Establishment) approach to
      NAT traversal.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Overview of Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-transports">2.1.</a>&nbsp;
Transports<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.2.</a>&nbsp;
Allocations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.3.</a>&nbsp;
Exchanging Data with Peers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">2.4.</a>&nbsp;
Channels<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#perms">2.5.</a>&nbsp;
Permissions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">2.6.</a>&nbsp;
Preserving vs. Non-Preserving Allocations<br />
<a href="#anchor7">3.</a>&nbsp;
Terminology<br />
<a href="#sec-general-behavior">4.</a>&nbsp;
General Behavior<br />
<a href="#sec-allocations">5.</a>&nbsp;
Allocations<br />
<a href="#sec-create-allocation">6.</a>&nbsp;
Creating an Allocation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">6.1.</a>&nbsp;
Sending an Allocate Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-rcv-allocate">6.2.</a>&nbsp;
Receiving an Allocate Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">6.3.</a>&nbsp;
Receiving an Allocate Response<br />
<a href="#sec-refreshing-allocation">7.</a>&nbsp;
Refreshing an Allocation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">7.1.</a>&nbsp;
Sending a Refresh Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">7.2.</a>&nbsp;
Receiving a Refresh Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">7.3.</a>&nbsp;
Receiving a Refresh Response<br />
<a href="#sec-permissions">8.</a>&nbsp;
Permissions<br />
<a href="#sec-sendanddata">9.</a>&nbsp;
Send and Data Indications<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-forming-indication">9.1.</a>&nbsp;
Sending a Send Indication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">9.2.</a>&nbsp;
Receiving a Send Indication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-sending-data-indication">9.3.</a>&nbsp;
Receiving a UDP Datagram<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">9.4.</a>&nbsp;
Receiving a Data Indication<br />
<a href="#sec-channels">10.</a>&nbsp;
Channels<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">10.1.</a>&nbsp;
Sending a ChannelBind Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-receiving-ChannelBind">10.2.</a>&nbsp;
Receiving a ChannelBind Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">10.3.</a>&nbsp;
Receiving a ChannelBind Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-channeldata-msg">10.4.</a>&nbsp;
The ChannelData Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-sending-channeldata-msg">10.5.</a>&nbsp;
Sending a ChannelData Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">10.6.</a>&nbsp;
Receiving a ChannelData Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-channel-relaying">10.7.</a>&nbsp;
Relaying Data from the Peer<br />
<a href="#sec-ip-and-icmp">11.</a>&nbsp;
IP and ICMP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">11.1.</a>&nbsp;
IP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">11.2.</a>&nbsp;
ICMP<br />
<a href="#sec-stun-methods">12.</a>&nbsp;
New STUN Methods<br />
<a href="#sec-stun-attributes">13.</a>&nbsp;
New STUN Attributes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#channelnums">13.1.</a>&nbsp;
CHANNEL-NUMBER<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">13.2.</a>&nbsp;
LIFETIME<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">13.3.</a>&nbsp;
PEER-ADDRESS<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">13.4.</a>&nbsp;
DATA<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">13.5.</a>&nbsp;
RELAYED-ADDRESS<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">13.6.</a>&nbsp;
REQUESTED-PROPS<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-requested-transport">13.7.</a>&nbsp;
REQUESTED-TRANSPORT<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">13.8.</a>&nbsp;
RESERVATION-TOKEN<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">13.9.</a>&nbsp;
ICMP<br />
<a href="#sec-stun-errors">14.</a>&nbsp;
New STUN Error Response Codes<br />
<a href="#sec-security">15.</a>&nbsp;
Security Considerations<br />
<a href="#anchor27">16.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor28">17.</a>&nbsp;
IAB Considerations<br />
<a href="#anchor29">18.</a>&nbsp;
Example<br />
<a href="#anchor30">19.</a>&nbsp;
Open Issues<br />
<a href="#anchor31">20.</a>&nbsp;
Changes from Previous Versions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">20.1.</a>&nbsp;
Changes from -08 to -09<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">20.2.</a>&nbsp;
Changes from -07 to -08<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">20.3.</a>&nbsp;
Changes from -06 to -07<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">20.4.</a>&nbsp;
Changes from -05 to -06<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">20.5.</a>&nbsp;
Changes from -04 to -05<br />
<a href="#sec-open-issues">21.</a>&nbsp;
Open Issues<br />
<a href="#anchor37">22.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">23.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">23.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">23.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Session Traversal Utilities for NAT (STUN) <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a> provides a suite of tools
      for facilitating the traversal of NAT. Specifically, it defines the
      Binding method, which is used by a client to determine its reflexive
      transport address towards the STUN server. The reflexive transport
      address can be used by the client for receiving packets from peers, but
      only when the client is behind "good" NATs. In particular, if a client
      is behind a NAT whose mapping behavior <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a> is
      address or address and port dependent (sometimes called "bad" NATs), the
      reflexive transport address will not be usable for communicating with a
      peer.
</p>
<p>The only reliable way to obtain a UDP transport address that can be
      used for corresponding with a peer through such a NAT is to make use of
      a relay. The relay sits on the public side of the NAT, and allocates
      transport addresses to clients reaching it from behind the private side
      of the NAT. These allocated transport addresses, called relayed
      transport address, are IP addresses and ports on the relay. When the
      relay receives a packet on one of these allocated addresses, the relay
      forwards it toward the client.
</p>
<p>This specification defines an extension to STUN, called TURN, that
      allows a client to request a relayed transport address on a TURN
      server.
</p>
<p>Though a relayed transport address is highly likely to work when
      corresponding with a peer, it comes at high cost to the provider of the
      relay service. As a consequence, relayed transport addresses should only
      be used as a last resort. Protocols using relayed transport addresses
      should make use of mechanisms to dynamically determine whether such an
      address is actually needed. One such mechanism, defined for multimedia
      session establishment protocols based on the offer/answer protocol in
      <a class='info' href='#RFC3264'>RFC 3264<span> (</span><span class='info'>Rosenberg, J. and H. Schulzrinne, &ldquo;An Offer/Answer Model with Session Description Protocol (SDP),&rdquo; June&nbsp;2002.</span><span>)</span></a> [RFC3264], is Interactive Connectivity
      Establishment (ICE) <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>.
</p>
<p>TURN was originally invented to support multimedia sessions signaled
      using SIP. Since SIP supports forking, TURN supports multiple peers per
      client; a feature not supported by other approaches (e.g., SOCKS <a class='info' href='#RFC1928'>[RFC1928]<span> (</span><span class='info'>Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, &ldquo;SOCKS Protocol Version 5,&rdquo; March&nbsp;1996.</span><span>)</span></a>). However, care has been taken in the later
      stages of its development to make sure that TURN is suitable for other
      types of applications.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Overview of Operation</h3>

<p>This section gives an overview of the operation of TURN. It is
      non-normative.
</p>
<p>In a typical configuration, a TURN client is connected to a <a class='info' href='#RFC1918'>private network<span> (</span><span class='info'>Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E. Lear, &ldquo;Address Allocation for Private Internets,&rdquo; February&nbsp;1996.</span><span>)</span></a> [RFC1918] and through one or more NATs to
      the public Internet. On the public Internet is a TURN server. Elsewhere
      in the Internet are one or more peers that the TURN client wishes to
      communicate with. These peers may or may not be behind one or more
      NATs.
</p><br /><hr class="insert" />
<a name="fig-turn-model"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                                                          +---------+
                                                          |         |
                                                          |         |
                                                        / |  Peer A |
    Client's              TURN                        //  |         |
    Host Transport        Server                     /    |         |
    Address               Address              +-+ //     +---------+
 10.1.1.2:17240       192.0.2.15:3478          |N|/  192.168.100.2:16400
       |                    |                  |A|
       |        +-+         |                 /|T|
       |        | |         |                / +-+
       v        | |         |               /       192.0.2.210:18200
 +---------+    | |         |+---------+   /              +---------+
 |         |    |N|         ||         | //               |         |
 | TURN    |    | |         v|  TURN   |/                 |         |
 | Client  |----|A|----------|  Server |------------------|  Peer B |
 |         |    | |^         |         |^                ^|         |
 |         |    |T||         |         ||                ||         |
 +---------+    | ||         +---------+|                |+---------+
                | ||                    |                |
                | ||                    |                |
                +-+|                    |                |
                   |                    |                |
                   |                    |                |
             Client's                   |            Peer B
             Server-Reflexive    Relayed             Transport
             Transport Address   Transport Address   Address
             192.0.2.1:7000      192.0.2.15:9000     192.0.2.210:18200
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p><a class='info' href='#fig-turn-model'>Figure&nbsp;1</a> shows a typical deployment. In
      this figure, the TURN client and the TURN server are separated by a NAT,
      with the client on the private side and the server on the public side of
      the NAT. This NAT is assumed to be a &ldquo;bad&rdquo; NAT; for example,
      it might have a mapping property of address-and-port-dependent mapping
      (see <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a> for a description of what this
      means).
</p>
<p>The client has allocated a local port on one of its addresses for use
      in communicating with the server. The combination of an IP address and a
      port is called a TRANSPORT ADDRESS and since this (IP address, port)
      combination is located on the client and not on the NAT, it is called
      the client&rsquo;s HOST transport address.
</p>
<p>The client sends TURN messages from its host transport address to a
      transport address on the TURN server which is known as the TURN SERVER
      ADDRESS. The client learns the server&rsquo;s address through some
      unspecified means (e.g., configuration), and this address is typically
      used by many clients simultaneously. The TURN server address is used by
      the client to send both commands and data to the server; the commands
      are processed by the TURN server, while the data is relayed on to the
      peers.
</p>
<p>Since the client is behind a NAT, the server sees these packets as
      coming from a transport address on the NAT itself. This address is known
      as the client&rsquo;s SERVER-REFLEXIVE transport address; packets sent
      by the server to the client&rsquo;s server-reflexive transport address
      will be forwarded by the NAT to the client&rsquo;s host transport
      address.
</p>
<p>The client uses TURN commands to allocate a RELAYED TRANSPORT
      ADDRESS, which is an transport address located on the TURN server. The
      server ensures that there is a one-to-one relationship between the
      client&rsquo;s server-reflexive transport address and the relayed
      transport address; thus a packet received at the relayed transport
      address can be unambiguously relayed by the server to the client.
</p>
<p>The client will typically communicate this relayed transport address
      to one or more peers through some mechanism not specified here (e.g., an
      ICE offer or answer <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>). Once
      this is done, the client can send data to the server to relay towards
      its peers. In the reverse direction, peers can send data to the relayed
      transport address of the client. The server will relay this data to the
      client as long as the client explicitly created a permission (see <a class='info' href='#perms'>Section&nbsp;2.5<span> (</span><span class='info'>Permissions</span><span>)</span></a>) for the IP address of the peer.
</p>
<a name="sec-transports"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Transports</h3>

<p>TURN as defined in this specification only allows the use of UDP
        between the server and the peer. However, this specification allows
        the use of any one of UDP, TCP, or TLS over TCP to carry the TURN
        messages between the client and the server.
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center">
<tr><th align="center">TURN client to TURN server</th><th align="center">TURN server to peer</th></tr>
<tr>
<td align="center">UDP</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">TLS over TCP</td>
<td align="center">UDP</td>
</tr>
</table>
<br clear="all" />

<p>If TCP or TLS over TCP is used between the client and the server,
        then the server will convert between these transports and UDP
        transport when relaying data to/from the peer.
</p>
<p>TURN supports TCP transport between the client and the server
        because some firewalls are configured to block UDP entirely. These
        firewalls block UDP but not TCP in part because TCP has properties
        that make the intention of the nodes being protected by the firewall
        more obvious to the firewall. For example, TCP has a three-way
        handshake that makes in clearer that the protected node really wishes
        to have that particular connection established, while for UDP the best
        the firewall can do is guess which flows are desired by using
        filtering rules. Also, TCP has explicit connection teardown, while for
        UDP the firewall has to use timers to guess when the flow is
        finished
</p>
<p>TURN supports TLS over TCP transport between the client and the
        server because TLS provides additional security properties not
        provided by TURN's default digest authentication; properties which
        some clients may wish to take advantage of. In particular, TLS
        provides a way for the client to ascertain that it is talking to the
        server that it intended to, and also provides for confidentiality of
        TURN control messages. TURN does not require TLS because the overhead
        of using TLS is higher than that of digest authentication; for
        example, using TLS likely means that most application data will be
        doubly encrypted (once by TLS and once to ensure it is still encrypted
        in the UDP datagram).
</p>
<p>There is a planned extension to TURN to add support for TCP between
        the server and the peers <a class='info' href='#I-D.ietf-behave-turn-tcp'>[I&#8209;D.ietf&#8209;behave&#8209;turn&#8209;tcp]<span> (</span><span class='info'>Perreault, S. and J. Rosenberg, &ldquo;Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations,&rdquo; March&nbsp;2010.</span><span>)</span></a>. For this reason,
        allocations that use UDP between the server and the peers are known as
        UDP allocations, while allocations that use TCP between the server and
        the peers are known as TCP allocations. This specification describes
        only UDP allocations.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Allocations</h3>

<p>To allocate a relayed transport address, the client uses an
        Allocate transaction. The client sends a Allocate request to the
        server, and the server replies with an Allocate response containing
        the allocated relayed transport address. The client can include
        attributes in the Allocate request that describe the type of
        allocation it desires (e.g., the lifetime of the allocation). And
        since relaying data may require lots of bandwidth, the server
        typically requires that the client authenticate itself using
        STUN&rsquo;s long-term credential mechanism, to show that it is
        authorized to use the server.
</p>
<p>Once a relayed transport address is allocated, a client must keep
        the allocation alive. To do this, the client periodically sends a
        Refresh request to the server with the allocated related transport
        address. TURN deliberately uses a different method (Refresh rather
        than Allocate) for refreshes to ensure that the client is informed if
        the allocation vanishes for some reason.
</p>
<p>The frequency of the Refresh transaction is determined by the
        lifetime of the allocation. The client can request a lifetime in the
        Allocate request and may modify its request in a Refresh request, and
        the server always indicates the actual lifetime in the response. The
        client must issue a new Refresh transaction within 'lifetime' seconds
        of the previous Allocate or Refresh transaction. If a client no longer
        wishes to use an Allocation, it should do a Refresh transaction with a
        requested lifetime of 0.
</p>
<p>Note that sending or receiving data from a peer DOES NOT refresh
        the allocation.
</p>
<p>Both the server and the client keeps track of the client transport
        address and port, the server transport address and port, and the
        protocol used by the client to communicate with the server. These 5
        values are collectively referred to as the 5-TUPLE. The server
        remembers the 5-tuple used in the Allocate request. Subsequent
        transactions between the client and the server use this same 5-tuple.
        In this way, the server knows which client owns the allocated relayed
        transport address. If the client wishes to allocate a second relayed
        transport address, it must use a different 5-tuple for this allocation
        (e.g., by using a different client host address or port).,
</p>
<p></p>
<blockquote class="text">
<p>NOTE: While the terminology used in this document refers to
            5-tuples, the TURN server can store whatever identifier it likes
            that yields identical results. Specifically, many implementations
            use a file-descriptor in place of a 5-tuple to represent a TCP
            connection.
</p>
</blockquote>
<blockquote class="text">
<p><p>NOTE: In some applications of TURN, a client may send and
            receive packets other than TURN packets on the address and port it
            is using to communicate with the TURN server. This can happen, for
            example, when using TURN with ICE <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>. In these cases, the client
            can examine the 5-tuple for an arriving packet and use the 5-tuple
            to distinguish packets received from the TURN server from packets
            received from other nodes. 
</p>
</blockquote>

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Exchanging Data with Peers</h3>

<p>There are two ways for the client and peers to exchange data using
        the TURN server. The first way uses Send and Data indications, the
        second way uses channels. Common to both ways is the ability of the
        client to communicate with multiple peers using a single allocated
        relayed transport address; thus both ways include a means for the
        client to indicate to the server which peer to forward the data to,
        and for the server to indicate which peer sent the data.
</p>
<p>When using the first way, the client sends a Send indication to the
        TURN server containing, in attributes inside the indication, the
        transport address of the peer and the data to be sent to that peer.
        When the TURN server receives the Send indication, it extracts the
        data from the Send indication and sends it in a UDP datagram to the
        peer, using the allocated relay address as the source address. In the
        reverse direction, UDP datagrams arriving at the relay address on the
        TURN server are converted into Data indications and sent to the
        client, with the transport address of the peer included in an
        attribute in the Data indication.
</p><br /><hr class="insert" />
<a name="fig-send-data"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                   TURN          Peer          Peer
client                 server         A             B
  |--- Allocate Req  --&gt;|             |             |
  |&lt;-- Allocate Resp ---|             |             |
  |                     |             |             |
  |--- Send (Peer A)---&gt;|             |             |
  |                     |=== data ===&gt;|             |
  |                     |             |             |
  |                     |&lt;== data ====|             |
  |&lt;-- Data (Peer A)----|             |             |
  |                     |             |             |
  |--- Send (Peer B)---&gt;|             |             |
  |                     |=== data =================&gt;|
  |                     |             |             |
  |                     |&lt;== data ==================|
  |&lt;-- Data (Peer B)----|             |             |
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In the figure above, the client first allocates a relayed transport
        address. It then sends data to Peer A using a Send indication; at the
        server, the data is extracted and forwarded in a UDP datagram to Peer
        A, using the relayed transport address as the source transport
        address. When a UDP datagram from Peer A is received at the relayed
        transport address, the contents are placed into a Data indication and
        forwarded to the client. A similar exchange happens with Peer B.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Channels</h3>

<p>For some applications (e.g. Voice over IP), the 36 bytes of
        overhead that a Send or Data indication adds to the application data
        can substantially increase the bandwidth required between the client
        and the server. To remedy this, TURN offers a second way for the
        client and server to associate data with a specific peer.
</p>
<p>This second way uses an alternate packet format known as the
        ChannelData message. The ChannelData message does not use the STUN
        header used by other TURN messages, but instead has a 4-byte header
        that includes a number known as a channel number. Each channel number
        in use is bound to a specific peer and thus serves as a shorthand for
        the peer's address.
</p>
<p>To bind a channel to a peer, the client sends a ChannelBind request
        to the server, and includes an unbound channel number and the
        transport address of the peer. Once the channel is bound, the client
        can use a ChannelData message to send the server data destined for the
        peer. Similarly, the server can relay data from that peer towards the
        client using a ChannelData message.
</p>
<p>Channel bindings last for 10 minutes unless refreshed. Channel
        bindings are refreshed by sending ChannelData messages from the client
        to the server, or by rebinding the channel to the peer.
</p>
<p>
</p><br /><hr class="insert" />
<a name="fig-channels"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                   TURN          Peer          Peer
client                 server         A             B
  |--- Allocate Req  --&gt;|             |             |
  |&lt;-- Allocate Resp ---|             |             |
  |                     |             |             |
  |--- Send (Peer A)---&gt;|             |             |
  |                     |=== data ===&gt;|             |
  |                     |             |             |
  |                     |&lt;== data ====|             |
  |&lt;-- Data (Peer A)----|             |             |
  |                     |             |             |
  |- ChannelBind Req --&gt;|             |             |
  | (Peer A to 0x4001)  |             |             |
  |                     |             |             |
  |&lt;- ChannelBind Resp -|             |             |
  |                     |             |             |
  |-- [0x4001] data ---&gt;|             |             |
  |                     |=== data ===&gt;|             |
  |                     |             |             |
  |                     |&lt;== data ====|             |
  |&lt;- [0x4001] data ---&gt;|             |             |
  |                     |             |             |
  |--- Send (Peer B)---&gt;|             |             |
  |                     |=== data =================&gt;|
  |                     |             |             |
  |                     |&lt;== data ==================|
  |&lt;-- Data (Peer B)----|             |             |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The figure above shows the channel mechanism in use. The client
        begins by allocating a relayed transport address, and then uses that
        address to exchange data with Peer A. After a bit, the client decides
        to bind a channel to Peer A. To do this, it sends a ChannelBind
        request to the server, specifying the transport address of Peer A and
        a channel number (0x4001). After that, the client can send application
        data encapsulated inside ChannelData messages to Peer A: this is shown
        as "[0x4001] data" where 0x4001 is the channel number.
</p>
<p>Note that ChannelData messages can only be used for peers to which
        the client has bound a channel. In the example above, Peer A has been
        bound to a channel, but Peer B has not, so application data to and
        from Peer B uses Send and Data indications.
</p>
<p>Channel bindings are always initiated by the client.
</p>
<a name="perms"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5"></a><h3>2.5.&nbsp;
Permissions</h3>

<p>To ease concerns amongst enterprise IT administrators that TURN
        could be used to bypass corporate firewall security, TURN includes the
        notion of permissions. TURN permissions mimic the address-restricted
        filtering mechanism of NATs that comply with <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>.
</p>
<p>The client can install a permission by sending data to a peer (or
        by doing certain other things). Once a permission is installed, any
        peer with the same IP address (the ports numbers can differ) is
        permitted to send data to the client. After 5 minutes, the permission
        times out and the server drops any UDP datagrams arriving at the
        relayed transport from that IP address. Note that permissions are
        within the context of an allocation, so adding or expiring a
        permission in one allocation does not affect other allocations.
</p>
<p>Data received from the peer DOES NOT refresh the permission.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.6"></a><h3>2.6.&nbsp;
Preserving vs. Non-Preserving Allocations</h3>

<p>Some applications that use TURN are quite tolerant of the different
        possible ways a TURN server could set the Diff-Serv, ECN, TTL / Hop
        Limit, and Flow Label fields in the IP header of the outgoing packet.
        Other applications require that the TURN server set these fields in a
        specific way, and also require that the TURN server relay ICMP error
        packets. Applications in the second class typically wish to do Path
        MTU Discovery or end-to-end QOS.
</p>
<p>Unfortunately, reading and manipulating fields in the IP header and
        relaying ICMP messages usually requires the server to have special
        permissions (e.g., access to RAW sockets or be loaded into the
        kernel), something that the person setting up the server may be
        unwilling or unable to grant. This is especially true when the server
        is part of a larger application, for example a peer-to-peer
        application. It is also significantly more difficult to implement this
        type of server than just relaying at the UDP layer.
</p>
<p>To allow TURN to cater to both usage scenarios, TURN defines the
        concept of Preserving vs. Non-Preserving allocations. A Preserving
        allocation sets the fields in the outgoing IP header correctly, and
        also relays ICMP messages, while a Non-Preserving allocation may not
        relay correctly in every case. The relaying rules for a Preserving are
        designed to guarantee the following:</p>
<ul class="text">
<li>Path MTU Discovery works end-to-end (i.e. client-to-peer),
            using either the old algorithm (<a class='info' href='#RFC1191'>[RFC1191]<span> (</span><span class='info'>Mogul, J. and S. Deering, &ldquo;Path MTU discovery,&rdquo; November&nbsp;1990.</span><span>)</span></a> and
            <a class='info' href='#RFC1981'>[RFC1981]<span> (</span><span class='info'>McCann, J., Deering, S., and J. Mogul, &ldquo;Path MTU Discovery for IP version 6,&rdquo; August&nbsp;1996.</span><span>)</span></a>) or the new one (<a class='info' href='#RFC4821'>[RFC4821]<span> (</span><span class='info'>Mathis, M. and J. Heffner, &ldquo;Packetization Layer Path MTU Discovery,&rdquo; March&nbsp;2007.</span><span>)</span></a>);
</li>
<li>ECN and Diff-Serv works end-to-end;
</li>
<li>Loops are prevented by copying and decrementing the TTL/Hop
            Count field.
</li>
</ul>

<p>If the client knows its application or usage scenario requires a
        Preserving allocation, then it can request one in its Allocate
        request. If the server is unable to grant this request, then it
        rejects the Allocate request.
</p>
<p>Note that a Preserving allocation only makes sense when the
        transport protocol to the client is UDP; when the transport is TCP or
        TLS, the allocation is always Non-Preserving.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Terminology</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<p>Readers are expected to be familar with <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a> and the terms defined
      there.
</p>
<p>The following terms are used in this document:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>TURN:</dt>
<dd>A protocol spoken between a TURN client and a
          TURN server. It is an extension to the STUN protocol <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>. The protocol allows a
          client to allocate and use a relayed transport address.
</dd>
<dt>TURN client:</dt>
<dd>A STUN client that implements this
          specification.
</dd>
<dt>TURN server:</dt>
<dd>A STUN server that implements this
          specification. It relays data between a TURN client and its
          peer(s).
</dd>
<dt>Peer:</dt>
<dd>A host with which the TURN client wishes to
          communicate. The TURN server relays traffic between the TURN client
          and its peer(s). The peer does not interact with the TURN server
          using the protocol defined in this document; rather, the peer
          receives data sent by the TURN server and the peer sends data
          towards the TURN server.
</dd>
<dt>Host Transport Address:</dt>
<dd>A transport address allocated
          on a host.
</dd>
<dt>Server-Reflexive Transport Address:</dt>
<dd>A transport
          address on the "public side" of a NAT. This address is allocated by
          the NAT to correspond to a specific host transport address.
</dd>
<dt>Relayed Transport Address:</dt>
<dd>A transport address that
          exists on a TURN server. If a permission exists, packets that arrive
          at this address are relayed towards the TURN client.
</dd>
<dt>Allocation:</dt>
<dd>The relayed transport address granted to a
          client through an Allocate request, along with related state, such
          as permissions and expiration timers.
</dd>
<dt>5-tuple:</dt>
<dd>The combination (client IP address and port,
          server IP address and port, and transport protocol (UDP or TCP))
          used to communicate between the client and the server . The 5-tuple
          uniquely identifies this communication stream. The 5-tuple also
          uniquely identifies the Allocation on the server.
</dd>
<dt>Permission:</dt>
<dd>The IP address and transport protocol (but
          not the port) of a peer that is permitted to send traffic to the
          TURN server and have that traffic relayed to the TURN client. The
          TURN server will only forward traffic to its client from peers that
          match an existing permission.
</dd>
<dt>Preserving Allocation</dt>
<dd>An allocation that sets the the
          fields in the IP header in a specific manner when relaying
          application data, and which also relays ICMP messages. An allocation
          that may not do this in some cases is called a Non-Preserving
          allocation.
</dd>
</dl></blockquote>

<a name="sec-general-behavior"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
General Behavior</h3>

<p>This section contains general TURN processing rules that apply to all
      TURN messages.
</p>
<p>TURN is an extension to STUN. All TURN messages, with the exception
      of the ChannelData message, are STUN-formatted messages. All the base
      processing rules described in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a> apply to STUN-formatted
      messages. This means that all the message-forming and -processing
      descriptions in this document are implicitly prefixed with the rules of
      <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>.
</p>
<p>In addition, the server SHOULD require that all TURN requests use the
      Long-Term Credential mechanism described in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>, and the client MUST be
      prepared to authenticate requests if required. The server's
      administrator MUST choose a realm value that will uniquely identify the
      username and password combination that the client must use, even if the
      client uses multiple servers under different administrations. The
      server's administrator MAY choose to allocate a unique username to each
      client, or MAY choose to allocate the same username to more than one
      client (for example, to all clients from the same department or
      company).
</p>
<p>The client and/or the server MAY include the FINGERPRINT attribute in
      any of the methods defined in this document. The client and server
      SHOULD include the SOFTWARE-TYPE attribute in all requests and
      responses, but SHOULD NOT include it in Send and Data indications. TURN
      does not use the backwards-compatibility mechanism described in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>.
</p>
<p>By default, TURN runs on the same port as STUN. However, either the
      SRV procedures or the ALTERNATE-SERVER procedures described in <a class='info' href='#sec-create-allocation'>Section&nbsp;6<span> (</span><span class='info'>Creating an Allocation</span><span>)</span></a> may be used to run TURN on a
      different port.
</p>
<a name="sec-allocations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Allocations</h3>

<p>All TURN operations revolve around allocations, and all TURN messages
      are associated with an allocation. An allocation conceptually consists
      of the following state data:</p>
<ul class="text">
<li>the relayed transport address
</li>
<li>The 5-tuple: client IP address, client port, server IP address,
          server port, transport protocol
</li>
<li>the username
</li>
<li>the transaction ID of the Allocate request
</li>
<li>the time-to-expiry
</li>
<li>A list of permissions
</li>
<li>A list of channel to peer bindings
</li>
<li>A flag indicating whether or not the allocation is Preserving
</li>
</ul><p>The relayed transport address is the transport address
      allocated by the server for communicating with peers, while the 5-tuple
      describes the communication path between the client and the server. Both
      of these MUST be unique across all allocations, so either one can be
      used to uniquely identify the allocation.
</p>
<p>When a TURN message arrives at the server from the client, the server
      uses the 5-tuple in the message to identify the associated allocation.
      For all TURN messages (including ChannelData) EXCEPT an Allocate
      request, if the 5-tuple does not identify an existing allocation, then
      the message MUST either be rejected with a 437 Allocation Mismatch error
      (if it is a request), or silently ignored (if it is an indication or a
      ChannelData message). A client receiving a 437 error response to a
      request other than Allocate MUST assume the allocation no longer
      exists.
</p>
<p>The username and password of the allocation is the username and
      password of the authenticated Allocate request that creates the
      allocation. Subsequent requests on an allocation use the same username
      as that used to create the allocation, to prevent attackers from
      hijacking the client's allocation. Specifically, if the server requires
      the use of the Long-Term Credential mechanism, and if a non-Allocate
      request passes authentication under this mechanism, and if the 5-tuple
      identifies an existing allocation, but the request does not use the same
      username as used to create the allocation, then the request MUST be
      rejected with a 441 (Wrong Credentials) error.
</p>
<p>The transaction ID of the allocation is the transaction ID used in
      the Allocate request. This is used to detect retransmissions of the
      Allocate request over UDP (see <a class='info' href='#sec-rcv-allocate'>Section&nbsp;6.2<span> (</span><span class='info'>Receiving an Allocate Request</span><span>)</span></a>
      for details).
</p>
<p>The time-to-expiry is the time in seconds left until the allocation
      expires. Each Allocate or Refresh transaction sets this timer, which
      then ticks down towards 0. By default, each Allocate or Refresh
      transaction resets this timer to 600 seconds (10 minutes), but the
      client can request a different value in the Allocate and Refresh
      request. Allocations can only be refreshed using the Refresh request;
      sending data to a peer does not refresh an allocation. When an
      allocation expires, the state data associated with the allocation can be
      freed. However the server MUST ensure that neither the relayed transport
      address nor the client reflexive transport address from the 5-tuple are
      re-used in other allocations until 2 minutes after the allocation
      expires; this ensures that any messages that are in transit when the
      allocation expires are gone before either of these transport addresses
      are re-used.
</p>
<p>The list of permissions is described in <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a> and the list of channels is described
      in <a class='info' href='#sec-channels'>Section&nbsp;10<span> (</span><span class='info'>Channels</span><span>)</span></a>.
</p>
<p>The differences between a Preserving and a Non-Preserving allocation
      are described in <a class='info' href='#sec-ip-and-icmp'>Section&nbsp;11<span> (</span><span class='info'>IP and ICMP</span><span>)</span></a>.
</p>
<a name="sec-create-allocation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Creating an Allocation</h3>

<p>An allocation on the server is created using an Allocate
      transaction.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Sending an Allocate Request</h3>

<p>The client forms an Allocate request as follows.
</p>
<p>The client first needs to pick a host transport address that the
        server does not think is currently in use, or was recently in use. The
        client SHOULD pick a currently-unused transport address on the
        client's host (typically by allowing its OS to pick a currently-unused
        port for a new socket).
</p>
<p>The client needs to pick a transport protocol to use between the
        client and the server. The transport protocol MUST be one of UDP, TCP,
        or TLS over TCP. Since this specification only allows UDP between the
        server and the peers, it is RECOMMENDED that the client pick UDP
        unless it has a reason to use a different transport. One reason to
        pick a different transport would be that the client believes, either
        through configuration or by experiment, that it is unable to contact
        any TURN server using UDP. See <a class='info' href='#sec-transports'>Section&nbsp;2.1<span> (</span><span class='info'>Transports</span><span>)</span></a>
        for more discussion.
</p>
<p>The client must also pick a server transport address. Typically,
        this is done by the client learning (perhaps through configuration)
        one or more domain names for TURN servers. In this case, the client
        uses the DNS procedures described in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>, but using an SRV service
        name of "turn" (or "turns" for TURN over TLS) instead of "stun" (or
        "stuns"). For example, to find servers in the example.com domain, the
        client performs a lookup for '_turn._udp.example.com',
        '_turn._tcp.example.com', and '_turns._tcp.example.com' if the client
        wants to communicate with the server using UDP, TCP, or TLS over TCP,
        respectively.
</p>
<p>The client MUST include a REQUESTED-TRANSPORT attribute in the
        request. This attribute specifies the transport protocol between the
        server and the peers (note that this is NOT the transport protocol
        that appears in the 5-tuple). In this specification, the
        REQUESTED-TRANSPORT type is always UDP. This attribute is included to
        allow future extensions specify other protocols (e.g., <a class='info' href='#I-D.ietf-behave-turn-tcp'>[I&#8209;D.ietf&#8209;behave&#8209;turn&#8209;tcp]<span> (</span><span class='info'>Perreault, S. and J. Rosenberg, &ldquo;Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations,&rdquo; March&nbsp;2010.</span><span>)</span></a>).
</p>
<p>If the client wishes the server to initialize the time-to-expire
        field of the allocation to some value other the default lifetime, then
        it MAY include a LIFETIME attribute specifying its desired value. This
        is just a request, and the server may elect to use a different value.
        Note that the server will ignore requests to initialize the field to
        less than the default value.
</p>
<p>If the client required the allocation to satisfy certain
        properties, then the client includes the REQUESTED-PROPS attribute.
        This attribute is optional, and can be omitted if no special
        properties are required.
</p>
<p>Using the E and R bits in the REQUESTED-PROPS attribute, the client
        can request:</p>
<ul class="text">
<li>(E=1, R=0 ) That the server allocate a relayed transport
            address with an even port number; OR
</li>
<li>(E=1, R=1) That the server reserve a pair of relayed transport
            addresses with adjacent port numbers N and N+1, where N is even
            and N+1 is odd, and then use port N for the current allocation. In
            this case, the server returns a RESERVATION-TOKEN attribute in the
            response which the client can then include in a subsequent
            Allocate request to create an allocation with port number N+1.
</li>
</ul><p>Note that the client cannot request a pair of adjacent ports
        unless it also requests that the lower numbered port be even. Thus the
        combination (E=0, R=1) is not allowed.
</p>
<p>Similarly, by setting the P bit to 1 in the REQUESTED-PROPS
        attribute, the client can request that the server allocate a
        Preserving allocation.
</p>
<p>For all the various REQUESTED-PROPS flags, if the server cannot
        satisfy the request, the Allocate request is rejected.
</p>
<p>The client MAY also include a RESERVATION-TOKEN attribute in the
        request to ask the server to use a previously reserved port for the
        allocation. If the RESERVATION-TOKEN attribute is included, then the
        client MUST either omit the REQUESTED-PROPS attribute or set E=0 and
        R=0, since doing otherwise would make no sense.
</p>
<p>Once constructed, the client sends the Allocate request on the
        5-tuple.
</p>
<a name="sec-rcv-allocate"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Receiving an Allocate Request</h3>

<p>When the server receives an Allocate request, it performs the
        following checks:</p>
<ol class="text">
<li>The server checks the credentials of the request, as per the
            Long-Term Credential mechanism of <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>.
</li>
<li>The server checks if the 5-tuple is currently in use by an
            existing allocation, or was it in use by another allocation within
            the last 2 minutes. If yes, then there are two sub-cases:
<ul class="text">
<li>If the transport protocol in the 5-tuple is UDP, and if the
                5-tuple is currently in use by an existing allocation, and if
                the transaction id of the request matches the transaction id
                stored with the allocation, then the request is a
                retransmission of the original request. The server replies
                either with a stored copy of the original response, or with a
                response rebuilt from the stored state data. If the server
                chooses to rebuild the response, then (a) it need not parse
                the request further, but can immediately start building a
                success response, (b) the value of the LIFETIME attribute can
                be set to the current value of the time-to-expire timer, and
                (c) the server may need to include an extra field in the
                allocation to store the token returned in a RESERVATION-TOKEN
                attribute.
</li>
<li>Otherwise, the server rejects the request with a 437
                (Allocation Mismatch) error.
</li>
</ul>NOTE: If the request includes credentials that are
            acceptable to server, but the 5-tuple is already in use, then it
            is important that the server reject the request with a 437
            (Allocation Mismatch) error rather than a 401 (Unauthorized)
            error. This ensures that the client knows that the problem is with
            the 5-tuple, rather than (wrongly) believing that the problem lies
            with its credentials.
</li>
<li>The server checks if the request contain a REQUESTED-TRANPORT
            attribute. If the REQUESTED-TRANSPORT attribute is not included or
            is malformed, the server rejects the request with a 400 (Bad
            Request) error. Otherwise, if the attribute is included but
            specifies a protocol other that UDP, the server rejects the
            request with a 422 (Unsupported Transport Protocol) error.
</li>
<li>The server checks if the request contains a REQUESTED-PROPS
            attribute. If yes, then the server checks that it understands and
            can satisfy all the flags that are set to 1. If a flag is not
            understood, or if the server cannot satisfy the request, then the
            server rejects the request with a 508 (Insufficient Port Capacity)
            error. The server includes in its error response a REQUESTED-PROPS
            attribute with all the flags the server understands set to 1 and
            all others set to 0. Note that the combination (E=0, R=1) MUST be
            treated as unsupported.
</li>
<li>The server checks if the request contains a RESERVATION-TOKEN
            attribute. If yes, and the request also contains a REQUESTED-PROPS
            attribute with the E and R flags set to any combination other than
            E=0 and R=0, then the server rejectes the request with a 400 (Bad
            Request) error. Otherwise it checks to see if the token is valid
            (i.e., the token is in range and has not expired, and the
            corresponding relayed transport address is still available). If
            the token is not valid for some reason, the server rejects the
            request with a 508 (Insufficient Port Capacity) error.
</li>
<li>At any point, the server MAY also choose to reject the request
            with a 486 (Allocation Quota Reached) error if it feels the client
            is trying to exceed some locally-defined allocation quota. The
            server is free to define this allocation quota any way it wishes,
            but SHOULD define it based on the username used to authenticate
            the request, and not on the client's transport address.
</li>
</ol>

<p>If the server rejects the request with one of the error codes 422
        (Unsupported Transport Protocol), 486 (Allocation Quota Reached) or
        508 (Insufficient Port Capacity), it MAY include an ALTERNATE-SERVER
        attribute in the error response redirecting the client to another
        server that it believes will accept the request. If the attribute is
        included, the address MUST be from the same address family as the
        server's transport address. Note that, if the attribute is included,
        the client will try this alternate server before trying the other
        servers given by the SRV procedures.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: When UDP transport is used between the client and the
            server, the client will restransmit an Allocate request if it does
            not receive a response within a certain timeout period <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>. Because of this, the
            server may receive two (or more) Allocate requests with the same
            5-tuple and same transaction id. Check #2 (above) handles the case
            where the first Allocate request is accepted and generates a
            success response, but it does not handle the case where the first
            request is rejected but the second request is accepted (because
            conditions on the server have changed in the brief intervening
            time period). If the client receives the first (failure) response,
            it will ignore the second (success) response and believe that an
            allocation was not created. An allocation created in this matter
            will eventually timeout, since the client will not refresh it.
            Furthermore, if the client later retries with the same 5-tuple but
            different transaction id, it will receive a 437 (Allocation
            Mismatch), which should cause it to retry with a different
            5-tuple.
</p>
<p>Server implementors MAY elect to prevent this second case by
            remembering recent failure responses and returning the saved
            failure response when receiving a retransmitted Allocate request.
            This optional behavior may be appropriate when the server
            implements some sort of charging mechanism or a per-user quota.
            Alternatively, servers may use a smaller maximum lifetime value to
            mimize the lifetime of this "orphaned" allocation (see below).
</p>
<p>Server implementors debating whether to implement this optional
            feature should be aware that there are other scenarios in TURN
            that lead to such "orphaned" allocations.
</p>
</blockquote>

<p>If all the checks pass, the server creates the allocation. The
        5-tuple is set to the 5-tuple from the Allocate request, while the
        list of permissions and the list of channels are initially empty.
</p>
<p>When allocating a relayed transport address for the allocation, the
        server MUST allocate an IP address from the same family (e.g, IPv4 vs.
        IPv6) as that on which the request was received (i.e., the server's IP
        address in the 5-tuple for the allocation). </p>
<blockquote class="text">
<p>NOTE: An extension to TURN to allow an address from a different
            address family is currently in progress <a class='info' href='#I-D.ietf-behave-turn-ipv6'>[I&#8209;D.ietf&#8209;behave&#8209;turn&#8209;ipv6]<span> (</span><span class='info'>Camarillo, G., Novo, O., and S. Perreault, &ldquo;Traversal Using Relays around NAT (TURN) Extension for IPv6,&rdquo; March&nbsp;2010.</span><span>)</span></a>.
</p>
</blockquote><p>In addition, the server SHOULD only allocate ports from the
        range 49152 &ndash; 65535 (the Dynamic and/or Private Port range <a class='info' href='#Port-Numbers'>[Port&#8209;Numbers]<span> (</span><span class='info'>, &ldquo;IANA Port Numbers Registry,&rdquo; .</span><span>)</span></a>), unless the TURN server application
        knows, through some means not specified here, that other applications
        running on the same host as the TURN server application will not be
        impacted by allocating ports outside this range. This condition can
        often be satisfied by running the TURN server application on a
        dedicated machine and/or by arranging that any other applications on
        the machine allocate ports before the TURN server application starts.
        In any case, the TURN server SHOULD NOT allocate ports in the range 0
        - 1023 (the Well-Known Port range) to discourage clients from using
        TURN to run standard services.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: The IETF is currently investigating the topic of
            randomized port assignments to avoid certain types of attacks (see
            <a class='info' href='#I-D.ietf-tsvwg-port-randomization'>[I&#8209;D.ietf&#8209;tsvwg&#8209;port&#8209;randomization]<span> (</span><span class='info'>Larsen, M. and F. Gont, &ldquo;Transport Protocol Port Randomization Recommendations,&rdquo; April&nbsp;2010.</span><span>)</span></a>). It is
            recommended that a TURN implementor keep abreast of this topic
            and, if appropriate, implement a randomized port assignment
            algorithm. This is especially applicable to servers that choose to
            pre-allocate a number of ports from the underlying OS and then
            later assign them to allocations; for example, a server may choose
            this technique to implement the E and R flags in the
            REQUESTED-PROPS attribute (see below).
</p>
</blockquote>

<p>If the request contains a REQUESTED-PROPS attribute with the E flag
        set, then the server looks for an even port number to use for the
        relayed transport address.
</p>
<p>If the request contains a REQUESTED-PROPS attribute with both the E
        and R flags set, then the server looks for a pair of port numbers N
        and N+1 on the same IP address, where N is even. Port N is used in the
        current allocation, while the relayed transport address with port N+1
        is assigned a token and reserved for a future allocation. The server
        MUST hold this reservation for at least 30 seconds, and MAY choose to
        hold longer (e.g. until the allocation with port N expires). The
        server then includes the token in a RESERVATION-TOKEN attribute in the
        success response.
</p>
<p>If the request contains a RESERVATION-TOKEN, the server uses the
        previously-reserved transport address corresponding to the included
        token (if it is still available).
</p>
<p></p>
<blockquote class="text">
<p>NOTE: The port N+1 reservation is a global reservation and is
            not specific to a particular allocation, since the Allocate
            request containing the RESERVATION-TOKEN will use a different
            5-tuple and will create a different allocation. The 5-tuple for
            the subsequent Allocate request can be any allowed 5-tuple; the
            subsequent Allocate request can use a 5-tuple with a different
            client IP address and port, a different transport protocol, and
            even different server IP address and port (provided, of course,
            that the server IP address and port is one that the server is
            listening for TURN requests on).
</p>
</blockquote>

<p>Otherwise (i.e., the E and R flags are not set, and
        RESERVATION-TOKEN is not included), the server allocates any port in
        the range described above.
</p>
<p>The server determines the initial value of the time-to-expire field
        as follows. If the request contains a LIFETIME attribute, and the
        proposed lifetime value is greater than the default lifetime, and the
        proposed lifetime value is otherwise acceptable to the server, then
        the server uses that value. Otherwise, the server uses the default
        lifetime. It is RECOMMENDED that the server impose a maximum lifetime
        of no more than 3600 seconds (1 hour). Servers that implement
        allocation quotas or charge users for allocations in some way may wish
        to use a smaller maximum lifetime (perhaps as small as the default
        lifetime) to more quickly remove orphaned allocations (that is,
        allocations where the corresponding client has crashed or terminated
        or the client connection has been lost for some reason). Also note
        that the time-to-expire is recomputed with each successful Refresh
        request, and thus the value computed here applies only until the first
        refresh.
</p>
<p>Once the allocation is created, the server replies with a success
        response. The success response contains:</p>
<ul class="text">
<li>A RELAYED-ADDRESS attribute containing the relayed transport
            address;
</li>
<li>A LIFETIME attribute containing the current value of the
            time-to-expire timer;
</li>
<li>A RESERVATION-TOKEN attribute (if a second relayed transport
            address was reserved).
</li>
<li>An XOR-MAPPED-ADDRESS attribute containing the client's IP
            address and port (from the 5-tuple);
</li>
</ul>

<p></p>
<blockquote class="text">
<p>NOTE: The XOR-MAPPED-ADDRESS attribute is included in the
            response as a convenience to the client. TURN itself does not make
            use of this value, but clients running ICE can often need this
            value and can thus avoid having to do an extra Binding transaction
            with some STUN server to learn it.
</p>
</blockquote>

<p>The response (either success or error) is sent back to the client
        on the 5-tuple.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Receiving an Allocate Response</h3>

<p>If the client receives a success response, then it MUST check that
        the relayed transport address is in an address family that the client
        understands and is prepared to deal with. This specification only
        covers the case where the relayed transport address is of the same
        address family as the client's transport address. If the relayed
        transport address is not in an address family that the client is
        prepared to deal with, then the client MUST delete the allocation
        (<a class='info' href='#sec-refreshing-allocation'>Section&nbsp;7<span> (</span><span class='info'>Refreshing an Allocation</span><span>)</span></a>) and MUST NOT
        attempt to create another allocation on that server until it believes
        the mismatch has been fixed.
</p>
<p></p>
<blockquote class="text">
<p>The IETF is currently considering mechanisms for transitioning
            between IPv4 and IPv6 that could result in a client originating an
            Allocate request over IPv4, but the request would arrive at the
            server over IPv6, or vica-versa. Hence the importance of this
            check.
</p>
</blockquote>

<p>Otherwise, the client creates its own copy of the allocation data
        structure to track what is happening on the server. In particular, the
        client needs to remember the actual lifetime received back from the
        server, rather than the value sent to the server in the request. The
        client must also remember the 5-tuple used for the request and the
        username and password it used to authenticate the request to ensure
        that it reuses them for subsequent messages. The client also needs to
        track the channels and permissions it establishes on the server.
</p>
<p>The client will probably wish to send the relayed transport address
        to peers (using some method not specified here) so the peers can
        communicate with it. The client may also wish to use the
        server-reflexive address it receives in the XOR-MAPPED-ADDRESS
        attribute in its ICE processing.
</p>
<p>If the client receives an error response, then the processing
        depends on the actual error code returned:</p>
<ul class="text">
<li>(Request timed out): There is either a problem with the server,
            or a problem reaching the server with the chosen transport. The
            client MAY choose to try again using a different transport (e.g.,
            TCP instead of UDP), or the client MAY try a different server.
</li>
<li>400 (Bad Request): The server believes the client's request is
            malformed for some reason. The client MAY notify the user or
            operator and SHOULD NOT retry the same request with this server
            until it believes the problem has been fixed. The client MAY try a
            different server.
</li>
<li>401 (Unauthorized): If the client has followed the procedures
            of the Long-Term Credential mechanism and still gets this error,
            then the server is not accepting the client's credentials. The
            client SHOULD notify the user or operator and SHOULD NOT send any
            further requests to this server until it believes the problem has
            been fixed. The client MAY try a different server.
</li>
<li>437 (Allocation Mismatch): This indicates that the client has
            picked a 5-tuple which the server sees as already in use or which
            was recently in use. One way this could happen is if an
            intervening NAT assigned a mapped transport address that was
            recently used by another allocation. The client SHOULD pick
            another client transport address and retry the Allocate request
            (using a different transaction id). The client SHOULD try three
            different client transport addresses before giving up on this
            server. Once the client gives up on the server, it SHOULD NOT try
            to create another allocation on the server for 2 minutes.
</li>
<li>441 (Wrong Credentials): The client should not receive this
            error in response to a Allocate request. The client MAY notify the
            user or operator and SHOULD NOT retry the same request with this
            server until it believes the problem has been fixed. The client
            MAY try a different server.
</li>
<li>442 (Unsupported Transport Address): The client should not
            receive this error in response to a request for a UDP allocation.
            The client MAY notify the user or operator and SHOULD NOT retry
            the same request with this server until it believes the problem
            has been fixed. The client MAY try a different server.
</li>
<li>486 (Allocation Quota Reached): The server is currently unable
            to create any more allocations with this username. The client
            SHOULD wait at least 1 minute before trying to create any more
            allocations on the server. The client MAY try a different
            server.
</li>
<li>508 (Insufficient Port Capacity): The server has no more
            relayed transport addresses avaiable, or has none with the
            requested properties, or the one that was reserved is no longer
            available. If the client is using either the REQUESTED-PROPS or
            the RESERVATION-TOKEN attribute, then the client MAY choose to
            remove or modify this attribute and try again immediately.
            Otherwise, the client SHOULD wait at least 1 minute before trying
            to create any more allocations on this server. The client MAY try
            a different server.
</li>
</ul><p>If the error response contains an ALTERNATE-SERVER attribute,
        and the client elects to try a different server, the the client SHOULD
        try the alternate server specified in that attribute (while obeying
        the rules in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a> for
        avoiding redirection loops) before trying any other servers found
        using the SRV procedures of <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>.
</p>
<a name="sec-refreshing-allocation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Refreshing an Allocation</h3>

<p>A Refresh transaction can be used to either (a) refresh an existing
      allocation and update its time-to-expire, or (b) delete an existing
      allocation.
</p>
<p>If a client wishes to continue using an allocation, then the client
      MUST refresh it before it expires. It is suggested that the client
      refresh the allocation roughly 1 minute before it expires. If a client
      no longer wishes to use an allocation, then it SHOULD explicitly delete
      the allocation. A client MAY also change the time-to-expire of an
      allocation at any time for other reasons.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Sending a Refresh Request</h3>

<p>If the client wishes to immediately delete an existing allocation,
        it includes a LIFETIME attribute with a value of 0. All other forms of
        the request refresh the allocation.
</p>
<p>The Refresh transaction updates the time-to-expire timer of an
        allocation. If the client wishes the server to set the time-to-expire
        timer to something other than the default lifetime, it includes a
        LIFETIME attribute with the requested value. The server then computes
        a new time-to-expire value in the same way as it does for an Allocate
        transaction, with the exception that a requested lifetime of 0 causes
        the server to immediately delete the allocation.
</p>
<p>The Refresh transaction is sent on the 5-tuple for the
        allocation.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Receiving a Refresh Request</h3>

<p>When the server receives a Refresh request, it processes it as
        follows:</p>
<ol class="text">
<li>The server checks the credentials of the request, as per the
            Long-Term Credential mechanism of <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>.
</li>
<li>The server computes a value called the "desired lifetime" as
            follows: If the request contains a LIFETIME attribute and the
            attribute value is 0, then the desired lifetime is 0. Otherwise,
            if the request contains a LIFETIME attribute and the attribute
            value is greater than the default lifetime, and if the attribute
            value is otherwise acceptable to the server, then the the desired
            lifetime is the attribute value. Otherwise the desired lifetime is
            the default value.
</li>
<li>The processing then depends on whether or not the 5-tuple
            corresponds to an existing allocation:
<ul class="text">
<li>If there is no existing allocation and the desired lifetime
                is 0, then the request suceeeds (as it is OK to delete a
                non-existent allocation).
</li>
<li>If there is no existing allocation and the desired lifetime
                is non-zero, then the server rejects the request with a 437
                Allocation Mismatch error.
</li>
<li>If there is an existing allocation and the desired lifetime
                is 0, then the request succeeds and the allocation is
                deleted.
</li>
<li>If there is an existing allocation and the desired lifetime
                is non-zero, then the request succeeds and the allocation's
                time-to-expiry is set to the desired lifetime
</li>
</ul>If the request succeeds, then server sends a success
            response containing:
<ul class="text">
<li>A LIFETIME attribute containing the current value of the
                time-to-expire timer.
</li>
</ul>
</li>
</ol>

<p>If the Refresh request is carried over UDP, then it is possible
        that it can be retransmitted. The server need not do anything special
        to handle this case since it is OK to delete a non-existent allocation
        and it is also OK to refresh an existing allocation twice in rapid
        succession.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Receiving a Refresh Response</h3>

<p>If the client receives a success response to its Refresh request,
        it updates its copy of the allocation data structure with the
        time-to-expire value contained in the response.
</p>
<p>If the client receives an 437 (Allocation Mismatch) error response
        to its Refresh request, then it must consider the allocation as having
        expired, as described in <a class='info' href='#sec-general-behavior'>Section&nbsp;4<span> (</span><span class='info'>General Behavior</span><span>)</span></a>.
        All other errors indicate a software error on the part of either the
        client or the server.
</p>
<a name="sec-permissions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Permissions</h3>

<p>For each allocation, the server keeps a list of zero or more
      permissions. Each permission consists of an IP address which uniquely
      identifies the permission, and an associated time-to-expiry. The IP
      address describes a peer that is allowed to send data to the client, and
      the time-to-expiry is the number of seconds until the permission
      expires.
</p>
<p>Various events, as described in subsequent sections, can cause a
      permission for a given IP address to be installed or refreshed. This
      causes one of two things to happen:</p>
<ul class="text">
<li>If no permission for that IP address exists, then a permission is
          created with the given IP address and a time-to-expiry equal to the
          default permission lifetime.
</li>
<li>If a permission for that IP address already exists, then the
          lifetime for that permission is reset to the default permission
          lifetime.
</li>
</ul><p>The default permission lifetime MUST be 300 seconds (= 5
      minutes).
</p>
<p>Each permission&rsquo;s time-to-expire decreases down once per second
      until it reaches 0, at which point the permission expires and is
      deleted.
</p>
<p>When a UDP datagram arrives at the relayed transport address for the
      allocation, the server checks the list of permissions for that
      allocation. If there is a permission with an IP address that is equal to
      the source IP address of the UDP datagram, then the UDP datagram can be
      relayed to the client. Otherwise, the UDP datagram is silently
      discarded. Note that only IP addresses are compared; port numbers are
      irrelevant.
</p>
<p>The permissions for one allocation are totally unrelated to the
      permissions for a different allocation. If an allocation expires, all
      its permissions expire with it.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: Though TURN permissions expire after 5 minutes, many NATs
          deployed at the time of publication expire their UDP bindings
          considerably faster. Thus an application using TURN will probably
          wish to send some sort of keep-alive traffic at a much faster rate.
          Applications using ICE should follow the keep-alive guidelines of
          ICE <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>, and applications not
          using ICE are advised to do something similar.
</p>
</blockquote>

<a name="sec-sendanddata"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Send and Data Indications</h3>

<p>TURN supports two ways to send and receive data from peers. This
      section describes the use of Send and Data indications, while <a class='info' href='#sec-channels'>Section&nbsp;10<span> (</span><span class='info'>Channels</span><span>)</span></a> describes the use of the Channel
      Mechanism.
</p>
<a name="sec-forming-indication"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Sending a Send Indication</h3>

<p>A client can use a Send indication to pass data to the server for
        relaying to a peer. A client can also use a Send indication without a
        DATA attribute to install or refresh a permission for the specified IP
        address. A client may use a Send indication to send data to a peer
        even if a channel is bound to that peer.
</p>
<p>When forming a Send indication, the client MUST include a
        PEER-ADDRESS attribute and MAY include a DATA attribute. If the DATA
        attribute is included, then the DATA attribute contains the actual
        application data to be sent to the peer, and the PEER-ADDRESS
        attribute contains the transport address of the peer to which the data
        is to be sent. If the DATA attribute is not present, then the
        PEER-ADDRESS attribute contains the IP address for which a permission
        is to be installed or refreshed; in this case the port specified in
        the attribute is ignored.
</p>
<p>Note that no authentication attributes are included, since
        indications cannot be authenticated using the Long-Term Credential
        mechanism.
</p>
<p>The Send indication MUST be sent using the same 5-tuple used for
        the original allocation.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
Receiving a Send Indication</h3>

<p>When the server receives a Send indication, it processes it as
        follows.
</p>
<p>If the received Send indication contains a DATA attribute, then it
        forms a UDP datagram as follows:</p>
<ul class="text">
<li>the source transport address is the relayed transport address
            of the allocation, where the allocation is determined by the
            5-tuple on which the Send indication arrived;
</li>
<li>the destination transport address is taken from the
            PEER-ADDRESS attribute;
</li>
<li>the data following the UDP header is the contents of the value
            field of the DATA attribute.
</li>
</ul><p>The resulting UDP datagram is then sent to the peer. If any
        errors are detected during this process (e.g., the Send indication
        does not contain a PEER-ADDRESS attribute), the received indication is
        silently discarded and no UDP datagram is sent.
</p>
<p>Clients are not allowed to use Send indications to send ICMP
        messages to peers. Thus the server MUST silently ignore a Send
        indication containing the ICMP attribute.
</p>
<p>When the server receives a valid Send indication, either with or
        without a DATA attribute, it also installs or refreshes a permission
        for the IP address contained in the PEER-ADDRESS attribute (see <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a>).
</p>
<a name="sec-sending-data-indication"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.3"></a><h3>9.3.&nbsp;
Receiving a UDP Datagram</h3>

<p>When the server receives a UDP datagram at a currently allocated
        relayed transport address, the server looks up the allocation
        associated with the relayed transport address. It then checks to see
        if relaying is permitted, as described in <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a>.
</p>
<p>If relaying is permitted, then the server checks if there is a
        channel bound to the peer that sent the UDP datagram (see <a class='info' href='#sec-channels'>Section&nbsp;10<span> (</span><span class='info'>Channels</span><span>)</span></a>). If a channel is bound, then processing
        proceeds as described in <a class='info' href='#sec-channel-relaying'>Section&nbsp;10.7<span> (</span><span class='info'>Relaying Data from the Peer</span><span>)</span></a>.
</p>
<p>If relaying is permitted but no channel is bound to the peer, then
        the server forms and sends a Data indication. The Data indication MUST
        contain both a PEER-ADDRESS and a DATA attribute and MUST NOT contain
        an ICMP attribute. The DATA attribute is set to the value of the
        &lsquo;data octets&rsquo; field from the datagram, and the
        PEER-ADDRESS attribute is set to the source transport address of the
        received UDP datagram. The Data indication is then sent on the 5-tuple
        associated with the allocation.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.4"></a><h3>9.4.&nbsp;
Receiving a Data Indication</h3>

<p>When the client receives a Data indication, it checks that the Data
        indication contains both a PEER-ADDRESS and a DATA attribute, and
        discards the indication if it does not.
</p>
<p>The client then checks for the presence of the ICMP attribute. If
        it is present, the Data indication contains an ICMP message as
        described in <a class='info' href='#sec-ip-and-icmp'>Section&nbsp;11<span> (</span><span class='info'>IP and ICMP</span><span>)</span></a>.
</p>
<p>If the Data indication does not contain an ICMP attribute, the
        client delivers the data octets inside the DATA attribute to the
        application, along with an indication that they were received from the
        peer whose transport address is given by the PEER-ADDRESS
        attribute.
</p>
<a name="sec-channels"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Channels</h3>

<p>Channels provide a way for the client and server to send application
      data using ChannelData messages, which have less overhead than Send and
      Data indications.
</p>
<p>Channel bindings are always initiated by the client. The client can
      bind a channel to a peer at any time during the lifetime of the
      allocation. The client may bind a channel to a peer before exchanging
      data with it, or after exchanging data with it (using Send and Data
      indications) for some time, or may choose never to bind a channel it.
      The client can also bind channels to some peers while not binding
      channels to other peers.
</p>
<p>Channel bindings are specific to an allocation, so that a binding in
      one allocation has no relationship to a binding in any other allocation.
      If an allocation expires, all its channel bindings expire with it.
</p>
<p>A channel binding consists of:</p>
<ul class="text">
<li>A channel number;
</li>
<li>A transport address (of the peer);
</li>
<li>A time-to-expiry timer.
</li>
</ul><p>Within the context of an allocation, a channel binding is
      uniquely identified either by the channel number or by the transport
      address. Thus the same channel cannot be bound to two different
      transport addresses, nor can the same transport address be bound to two
      different channels.
</p>
<p>A channel binding lasts for 10 minutes unless refreshed. Refreshing
      the binding (by the server receiving either a ChannelBind request
      rebinding the channel to the same peer, or by the server receiving a
      ChannelData message on that channel) resets the time-to-expire timer
      back to 10 minutes. When the channel binding expires, the channel
      becomes unbound and available for binding to a different transport
      address.
</p>
<p>When binding a channel to a peer, the client SHOULD be prepared to
      receive ChannelData messages on the channel from the server as soon as
      it has sent the ChannelBind request. Over UDP, it is possible for the
      client to receive ChannelData messages from the server before it
      receives a ChannelBind success response.
</p>
<p>In the other direction, the client MAY elect to send ChannelData
      messages before receiving the ChannelBind success response. Doing so,
      however, runs the risk of having the ChannelData messages dropped by the
      server if the ChannelBind request does not succeed for some reason
      (e.g., packet lost if the request is sent over UDP, or the server being
      unable to fulfill the request). A client that wishes to be safe should
      either queue the data, or use Send indications until the channel binding
      is confirmed.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
Sending a ChannelBind Request</h3>

<p>A channel binding is created using a ChannelBind transaction. A
        channel binding can also be refreshed using a ChannelBind
        transaction.
</p>
<p>To initiate the ChannelBind transaction, the client forms a
        ChannelBind request. The channel to be bound is specified in a
        CHANNEL-NUMBER attribute, and the peer's transport address is
        specified in a PEER-ADDRESS attribute. <a class='info' href='#sec-receiving-ChannelBind'>Section&nbsp;10.2<span> (</span><span class='info'>Receiving a ChannelBind Request</span><span>)</span></a> describes the restrictions
        on these attributes.
</p>
<p>Note that rebinding a channel to the same transport address that it
        is already bound to provides a way to refresh a channel binding
        without sending data to the peer.
</p>
<p>Once formed, the ChannelBind request is sent using the 5-tuple for
        the allocation.
</p>
<a name="sec-receiving-ChannelBind"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
Receiving a ChannelBind Request</h3>

<p>When the server receives a ChannelBind request, it checks the
        following:</p>
<ul class="text">
<li>The request contains both a CHANNEL-NUMBER and a PEER-ADDRESS
            attribute;
</li>
<li>The channel number is in the range 0x4000 to 0xFFFE
            (inclusive);
</li>
<li>The channel number is not currently bound to a different
            transport address (same transport address is OK);
</li>
<li>The transport address is not currently bound to a different
            channel number.
</li>
</ul><p>If any of these tests fail, the server replies with an error
        response with error code 400 "Bad Request". Otherwise, the ChannelBind
        request is valid and the server replies with a ChannelBind success
        response. There are no required attributes in a ChannelBind
        response.
</p>
<p>If ChannelBind request is valid, then the server creates or
        refreshes the channel binding using the channel number in the
        CHANNEL-ADDRESS attribute and the transport address in the
        PEER-ADDRESS attribute. The server also installs or refreshes a
        permission for the IP address in the PEER-ADDRESS attribute.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
Receiving a ChannelBind Response</h3>

<p>When the client receives a successful ChannelBind response, it
        updates its data structures to record that the channel binding is now
        active.
</p>
<a name="sec-channeldata-msg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.4"></a><h3>10.4.&nbsp;
The ChannelData Message</h3>

<p>The ChannelData message is used to carry application data between
        the client and the server. It has the following format:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Channel Number        |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                       Application Data                        /
/                                                               /
|                                                               |
|                               +-------------------------------+
|                               |
+-------------------------------+</pre></div>
<p>The Channel Number field specifies the number of the channel on
        which the data is traveling, and thus the address of the peer that is
        sending or is to receive the data. The channel number MUST be in the
        range 0x4000 &ndash; 0xFFFF, with channel number 0xFFFF being reserved
        for possible future extensions.
</p>
<p>Channel numbers 0x0000 &ndash; 0x3FFF cannot be used because bits 0
        and 1 are used to distinguish ChannelData messages from STUN-formatted
        messages (i.e., Allocate, Send, Data, ChannelBind, etc).
        STUN-formatted messages always have bits 0 and 1 as &ldquo;00&rdquo;,
        while ChannelData messages use combinations &ldquo;01&rdquo;,
        &ldquo;10&rdquo;, and &ldquo;11&rdquo;.
</p>
<p>The Length field specifies the length in bytes of the application
        data field (i.e., it does not include the size of the ChannelData
        header). Note that 0 is a valid length.
</p>
<p>The Application Data field carries the data the client is trying to
        send to the peer, or that the peer is sending to the client.
</p>
<a name="sec-sending-channeldata-msg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.5"></a><h3>10.5.&nbsp;
Sending a ChannelData Message</h3>

<p>Once a client has bound a channel to a peer, then when the client
        has data to send to that peer it may use either a ChannelData message
        or a Send indication; that is, the client is not obligated to use the
        channel when it exists and may freely intermix the two message types
        when sending data to the peer. The server, on the other hand, MUST use
        the ChannelData message if a channel has been bound to the peer.
</p>
<p>The fields of the ChannelData message are filled in as described in
        <a class='info' href='#sec-channeldata-msg'>Section&nbsp;10.4<span> (</span><span class='info'>The ChannelData Message</span><span>)</span></a>.
</p>
<p>Over stream transports, the ChannelData message MUST be padded to a
        multiple of four bytes in order to ensure the alignment of subsequent
        messages. The padding is not reflected in the length field of the
        ChannelData message, so the actual size of a ChannelData message
        (including padding) is (4 + Length) rounded up to the nearest multiple
        of 4. Over UDP, the padding is not required but MAY be included.
</p>
<p>The ChannelData message is then sent on the 5-tuple associated with
        the allocation.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6"></a><h3>10.6.&nbsp;
Receiving a ChannelData Message</h3>

<p>The receiver of the ChannelData message uses bits 0 and 1 to
        distinguish it from STUN-formatted messages, as described in <a class='info' href='#sec-channeldata-msg'>Section&nbsp;10.4<span> (</span><span class='info'>The ChannelData Message</span><span>)</span></a>.
</p>
<p>If the ChannelData message is received in a UDP datagram, and if
        the UDP datagram is too short to contain the claimed length of the
        ChannelData message (i.e., the UDP header length field value is less
        than the ChannelData header length field value + 4 + 8), then the
        message is silently discarded.
</p>
<p>If the ChannelData message is received over TCP or over TLS over
        TCP, then the actual length of the ChannelData message is as described
        in <a class='info' href='#sec-sending-channeldata-msg'>Section&nbsp;10.5<span> (</span><span class='info'>Sending a ChannelData Message</span><span>)</span></a>.
</p>
<p>If the ChannelData message is received on a channel which is not
        bound to any peer, then the message is silently discarded.
</p>
<p>If no errors are detected, the server relays the application data
        to the peer by forming a UDP datagram as follows:</p>
<ul class="text">
<li>the source transport address is the relayed transport address
            of the allocation, where the allocation is determined by the
            5-tuple on which the ChannelData message arrived;
</li>
<li>the destination transport address is the transport address to
            which the channel is bound;
</li>
<li>the data following the UDP header is the contents of the data
            field of the ChannelData message.
</li>
</ul><p>The resulting UDP datagram is then sent to the peer. Note
        that if the Length field in the ChannelData message is 0, then there
        will be no data in the UDP datagram, but the UDP datagram is still
        formed and sent.
</p>
<p>If the ChannelData message is valid, then the server refreshes the
        channel binding, and also installs or refreshes a permission for the
        IP address part of the transport address to which the UDP datagram is
        sent (see <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a>).
</p>
<a name="sec-channel-relaying"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.7"></a><h3>10.7.&nbsp;
Relaying Data from the Peer</h3>

<p>When the server receives a UDP datagram on the relayed transport
        address associated with an allocation, the server processes it as
        described in <a class='info' href='#sec-sending-data-indication'>Section&nbsp;9.3<span> (</span><span class='info'>Receiving a UDP Datagram</span><span>)</span></a>. If
        that section indicates that a ChannelData message should be sent
        (because there is a channel bound to the peer that sent to UDP
        datagram), then the server forms and sends a ChannelData message as
        described in <a class='info' href='#sec-sending-channeldata-msg'>Section&nbsp;10.5<span> (</span><span class='info'>Sending a ChannelData Message</span><span>)</span></a>.
</p>
<a name="sec-ip-and-icmp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
IP and ICMP</h3>

<p>This section describes how the server sets various fields in the IP
      header when relaying between the client and the peer or vica-versa. It
      also describes how the server relays ICMP messages. The descriptions in
      this section apply: (a) when the server receives a Send indication or
      ChannelData message from the client and sends a UDP datagram to the
      peer, (b) when the server receives a UDP datagram on the
      relayed-transport address and sends a Data indication or ChannelData
      message to the client, or (c) when the server receives an ICMP message.
      This section does not apply when the server sends TURN control
      messages.
</p>
<p>The descriptions below have two parts: a preferred behavior and an
      alternate behavior. A Preserving allocation MUST implement the preferred
      behavior. A non-preserving allocation with UDP transport to the client
      SHOULD implement the preferred behavior, but if that is not possible for
      a particular field, then it SHOULD implement the alternative behavior. A
      non-preserving allocation with TCP or TLS transport to client SHOULD
      implement the alternate behavior, except where this conflicts with
      standard TCP or TLS behavior.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.1"></a><h3>11.1.&nbsp;
IP</h3>

<p>This section describes the preferred and alternate behavior for
        various fields in the IP header.
</p>
<p>Time to Live (IPv4) or Hop Count (IPv6)</p>
<blockquote class="text">
<p>Preferred Behavior: If the incoming value is 0, then send an
            ICMP Time Exceeded message back to the sender. Otherwise set the
            outgoing Time to Live/Hop Count to one less than the incoming
            value.
</p>
<p>Alternate Behavior: Set the outgoing value to the default for
            outgoing packets.
</p>
</blockquote>

<p><br />
<br />

</p>
<p>Diff-Serv Code Point </p>
<blockquote class="text">
<p>Preferred Behavior: Set the outgoing value to the incoming
            value, unless the server includes a differentiated services
            classifier and marker <a class='info' href='#RFC2474'>[RFC2474]<span> (</span><span class='info'>Nichols, K., Blake, S., Baker, F., and D. Black, &ldquo;Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers,&rdquo; December&nbsp;1998.</span><span>)</span></a>.
</p>
<p>Alternate Behavior: Set the outgoing value to a fixed value,
            which by default is Best Effort unless configured otherwise.
</p>
<p>In both cases, if the server is immediately adjacent to a
            differentiated services classifier and marker, then DSCP MAY be
            set to any arbitrary value in the direction towards the
            classifier.
</p>
</blockquote>

<p><br />
<br />

</p>
<p>ECN</p>
<blockquote class="text">
<p>Preferred Behavior: Set the outgoing value to the incoming
            value, UNLESS the server is doing Active Queue Management, the
            incoming ECN field is 01 or 10, and the server wishes to indicate
            that congestion has been experienced, in which case set the
            outgoing value to 11.
</p>
<p>Alternate Behavior: Set the outgoing value to 00 (ECN not
            supported)
</p>
</blockquote>

<p><br />
<br />

</p>
<p>Flow Label </p>
<blockquote class="text">
<p>Preferred Behavior: Set the outgoing flow label to 0.
</p>
<p>Alternate Behavior: Same as the Preferred behavior.
</p>
</blockquote>

<p><br />
<br />

</p>
<p>IPv4 Fragmentation</p>
<blockquote class="text">
<p>Preferred Behavior: </p>
<blockquote class="text">
<p>If the outgoing packet size does not exceed the outgoing
                link's MTU, then send the outgoing packet unfragmented. Set
                the DF bit in the outgoing packet to the value of the DF bit
                in the incoming packet, and set the other fragmentation fields
                (Identification, MF, Fragment Offset) as appropriate for a
                packet originating from the server.
</p>
<p>Otherwise, if the outgoing link's MTU is exceeded and the
                incoming DF bit is 0, then fragment the packet before sending.
                Set the outgoing DF to 0, and set the other fragmentation
                fields as appropriate for fragments originated from the
                server.
</p>
<p>Otherwise [link MTU exceeded and incoming DF set], drop the
                outgoing packet and send an ICMP message of type 3 code 4
                ("fragmentation needed and DF set") to the sender of the
                incoming packet.
</p>
</blockquote>

<p>Alternate Behavior: As described in the Preferred Behavior,
            except always assume the incoming DF bit is 0.
</p>
</blockquote>

<p><br />
<br />

</p>
<p>IPv6 Fragmentation</p>
<blockquote class="text">
<p>Preferred Behavior: </p>
<blockquote class="text">
<p>If the incoming packet did not include a Fragmentation
                header and the outgoing packet size does not exceed the
                outgoing link's MTU, then send the outgoing packet without a
                Fragmentation header.
</p>
<p>If the incoming packet included a Fragment header and if
                the outgoing packet size (with a Fragmentation header
                included) does not exceed the outgoing link's MTU, then send
                the outgoing packet with a Fragmentation header. Set the
                fields of the Fragmentation header as appropriate for a packet
                originating from the server.
</p>
<p>If the incoming packet did not include a Fragmentation
                header and the outgoing packet size exceeds the outgoing
                link's MTU , then drop the outgoing packet and send an ICMP
                message of type 2 code 0 ("Packet too big") to the sender of
                the incoming packet. If the packet is being sent to the peer,
                then reduce the MTU reported in the ICMP message by 48 bytes
                to allow room for the overhead of a Data indication.
</p>
<p>Otherwise, if the link's MTU is exceeded and the incoming
                packet contained a Fragmentation header, then fragment the
                outgoing packet into fragments of no more than 1280 bytes. Set
                the fields of the Fragmentation header as appropriate for a
                packet originating from the server.
</p>
</blockquote>

<p>Alternate Behavior: As described in the Preferred Behavior,
            except always assume incoming packet has a Fragmentation
            header.
</p>
</blockquote>

<p><br />
<br />

</p>
<p>IPv4 Options</p>
<blockquote class="text">
<p>Preferred Behavior: The outgoing packet is sent without any
            IPv4 options.
</p>
<p>Alternate Behavior: Same as preferred.
</p>
</blockquote>

<p><br />
<br />

</p>
<p>IPv6 Extention Headers</p>
<blockquote class="text">
<p>Preferred Behavior: The outgoing packet is sent without any
            IPv6 extension headers, with the exception of the Fragmentation
            header as described above
</p>
<p>Alternate Behavior: Same as preferred.
</p>
</blockquote>

<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.2"></a><h3>11.2.&nbsp;
ICMP</h3>

<p>This sub-section describes the preferred behavior of ICMP relaying.
        The corresponding alternate behavior is to not relay ICMP
        messages.
</p>
<p>When an ICMP message arrives at the server, the copy of the
        original IP packet present inside the ICMP message is examined. The
        server first checks that the original IP packet header is immediately
        followed by a UDP protocol header, such that the original source
        transport address was X and the original destination transport address
        was Y. The server also checks that the type and code values in the
        ICMP header are one of those relayed (see below). Other ICMP messages
        are either ignored, or used by the server internally in an unspecified
        manner.
</p>
<p>The server then checks if one of the following two cases
        applies:
</p>
<p>Case 1: X is a relayed-transport-address currently assigned to an
        active allocation on the server, and there exists a permission for the
        IP address of Y in the allocation.
</p>
<p>In this case, the original IP packet was traveling from the server
        to a peer, so the the server relays the ICMP message back to the
        client. The server creates a Data indication where the PEER-ADDRESS
        attribute contains Y, and the ICMP attribute contains the type and
        code from the incoming ICMP message, and the DATA attribute contains
        application data from the original IP packet starting AFTER the UDP
        header. The server SHOULD include as much application data as possible
        consistent with not exceeding a total IP packet size of either 576
        bytes (for IPv4) or 1280 bytes (for IPv6). </p>
<blockquote class="text">
<p>Note that there is no point in including the original IP or UDP
            header in the DATA attribute because those headers were generated
            by the server, not the client.
</p>
</blockquote>

<p>Case 2: There is an active allocation where X is the server
        transport address, Y is the client transport address, and UDP is used
        as transport between the client and the server. Furthermore, the
        packet after the UDP header is either (a) a ChannelData header which
        contains an active channel number in the allocation, or (b) a Data
        indication whose PEER-ADDRESS attribute contains an IP address for
        which there exists a permission in the allocation.
</p>
<p>In this case, the original IP packet was traveling from the server
        to the client, so the server creates and sends an ICMP message to the
        peer. The outgoing ICMP message contains the type and code fields from
        the incoming ICMP message and then contains an approximation to the
        original IP packet sent from the peer to the server (the one the
        server was trying to relay to the client inside the ChannelData or
        Data indication). This approximation contains a synthesized IP header,
        a synthesized UDP header, and some application data. The synthesis is
        done as follows:</p>
<ul class="text">
<li>The destination transport address is the
            relayed-transport-address of the allocation;
</li>
<li>The source transport address is the peer's transport address
            determined from either (a) the channel number or (b) the
            PEER-ADDRESS attribute;
</li>
<li>The application data is taken from either (a) the ChannelData
            message or (b) the DATA attribute. The server SHOULD include as
            much application data as possible consistent with not exceeding
            either 576 bytes (for IPv4) or 1280 bytes (for IPv6).
</li>
</ul><p>The remaining fields in the IP and UDP headers are simply set
        to sensible values, since for most of them there is no way to
        reconstruct the original values.
</p>
<p>The server SHOULD relay all ICMP type/code combinations and MUST
        relay at least the following combinations. For IPv4:</p>
<blockquote class="text">
<p>Type 3, code 4: Fragmentation needed and DF set
</p>
</blockquote><p>For IPv6:</p>
<blockquote class="text">
<p>Type 2, code &lt;any&gt;: Packet too big
</p>
</blockquote>

<p>Note that the ICMP attribute appears only in Data indications; the
        client cannot use the ICMP attribute in a Send indication to send ICMP
        messages to the peer.
</p>
<a name="sec-stun-methods"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
New STUN Methods</h3>

<p>This section lists the codepoints for the new STUN methods defined in
      this specification. See elsewhere in this document for the semantics of
      these new methods.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>  Request/Response Transactions
    0x003  :  Allocate
    0x004  :  Refresh
    0x009  :  ChannelBind

  Indications
    0x006  :  Send
    0x007  :  Data
</pre></div>
<a name="sec-stun-attributes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
New STUN Attributes</h3>

<p>This STUN extension defines the following new
        attributes:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0x000C: CHANNEL-NUMBER
  0x000D: LIFETIME
  0x0010: Reserved (was BANDWIDTH)
  0x0012: PEER-ADDRESS
  0x0013: DATA
  0x0016: RELAYED-ADDRESS
  0x0018: REQUESTED-PROPS
  0x0019: REQUESTED-TRANSPORT
  0x0022: RESERVATION-TOKEN
  0x0030: ICMP
</pre></div>
<a name="channelnums"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.1"></a><h3>13.1.&nbsp;
CHANNEL-NUMBER</h3>

<p>The CHANNEL-NUMBER attribute contains the number of the channel. It
        is a 16-bit unsigned integer, followed by a two-octet RFFU (Reserved
        For Future Use) field which MUST be set to 0 on transmission and MUST
        be ignored on reception.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |        Channel Number         |         RFFU = 0              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.2"></a><h3>13.2.&nbsp;
LIFETIME</h3>

<p>The lifetime attribute represents the duration for which the server
        will maintain an allocation in the absence of a refresh. It is a
        32-bit unsigned integral value representing the number of seconds
        remaining until expiration.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.3"></a><h3>13.3.&nbsp;
PEER-ADDRESS</h3>

<p>The PEER-ADDRESS specifies the address and port of the peer as seen
        from the TURN server. It is encoded in the same way as
        XOR-MAPPED-ADDRESS.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.4"></a><h3>13.4.&nbsp;
DATA</h3>

<p>The DATA attribute is present in all Data indications and most Send
        indications. The contents of DATA attribute is the application data
        (that is, the data that would immediately follow the UDP header if the
        data was been sent directly between the client and the peer).
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.5"></a><h3>13.5.&nbsp;
RELAYED-ADDRESS</h3>

<p>The RELAYED-ADDRESS is present in Allocate responses. It specifies
        the address and port that the server allocated to the client. It is
        encoded in the same way as XOR-MAPPED-ADDRESS.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.6"></a><h3>13.6.&nbsp;
REQUESTED-PROPS</h3>

<p>This attribute allows the client to request that the allocation
        have certain properties, and by the server to indicate which
        properties are supported. The attribute is 32 bits long. Its format
        is:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |E|R|P|                      MUST be 0                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>
</p>
<p>The first part of the attribute value contains a number of one-bit
        flags. These are:</p>
<blockquote class="text"><dl>
<dt>E:</dt>
<dd>If 1, the port number for the
            relayed-transport-address must be even. If 0, the port number can
            be even or odd.
</dd>
<dt>R:</dt>
<dd>If 1, the server must reserve the next highest
            port for a subsequent allocation. If 0, no such reservation is
            requested. If the client sets the R bit to 1, it MUST also set the
            E bit to 1 (however, the E bit may be 1 when the R bit is 0).
</dd>
<dt>P:</dt>
<dd>If 1, the allocation must be a Preserving
            allocation. If 0, the allocation can be either Preserving or
            Non-Preserving.
</dd>
</dl></blockquote><p>All these flags have the property that if the bit is 1, and
        the server cannot create an allocation that satisfies the request,
        then the Allocate request is rejected. To allow future TURN extensions
        to define new flags that also have this property, the client MUST set
        the rest of the attribute to zero, and the server MUST fail the
        Allocate request if any bits which the server does not support are set
        to 1. By doing this, any new flags that are not recognized by the
        server will cause the Allocate request to fail.
</p>
<a name="sec-requested-transport"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.7"></a><h3>13.7.&nbsp;
REQUESTED-TRANSPORT</h3>

<p>This attribute is used by the client to request a specific
        transport protocol for the allocated transport address. It has the
        following format:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Protocol   |                    RFFU                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>The Protocol field specifies the desired protocol. The codepoints
        used in this field are taken from those allowed in the Protocol field
        in the IPv4 header and the NextHeader field in the IPv6 header <a class='info' href='#Protocol-Numbers'>[Protocol&#8209;Numbers]<span> (</span><span class='info'>, &ldquo;IANA Protocol Numbers Registry,&rdquo; 2005.</span><span>)</span></a>. This specification only allows the
        use of codepoint 17 (User Datagram Protocol).
</p>
<p>The RFFU field MUST be set to zero on transmission and MUST be
        ignored on reception. It is reserved for future uses.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.8"></a><h3>13.8.&nbsp;
RESERVATION-TOKEN</h3>

<p>The RESERVATION-TOKEN attribute contains a token that uniquely
        identifies a relayed transport address being held in reserve by the
        server. The server includes this attribute in a success response to
        tell the client about the token, and the client includes this
        attribute in a subsequent Allocate request to request the server use
        that relayed transport address for the allocation.
</p>
<p>The attribute value is a 64-bit-long field containing the token
        value.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.9"></a><h3>13.9.&nbsp;
ICMP</h3>

<p>This attribute is included by the server in a Data indication to
        indicate that the Data indication contains information from an ICMP
        message that was received by the server. The attribute has the
        following format:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |     Code      |           MUST be 0           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>The Type and Code fields of the attribute are taken from the Type
        and Code fields in the ICMP message received by the server.
</p>
<a name="sec-stun-errors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
New STUN Error Response Codes</h3>

<p>This document defines the following new error response codes:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>437</dt>
<dd>(Allocation Mismatch): A request was received by
          the server that requires an allocation to be in place, but there is
          none, or a request was received which requires no allocation, but
          there is one.
</dd>
<dt>441</dt>
<dd>(Wrong Credentials): The credentials in the
          (non-Allocate) request, though otherwise acceptable to the server,
          do not match those used to create the allocation.
</dd>
<dt>442</dt>
<dd>(Unsupported Transport Protocol): The Allocate
          request asked the server to use a transport protocol between the
          server and the peer that the server does not support. NOTE: This
          does NOT refer to the transport protocol used in the 5-tuple.
</dd>
<dt>486</dt>
<dd>(Allocation Quota Reached): No more allocations
          using this username can be created at the present time.
</dd>
<dt>508</dt>
<dd>(Insufficient Port Capacity): The server has no
          more relayed transport addresses available right now, or has none
          with the requested properties, or the one that corresponds to the
          specified token is not available.
</dd>
</dl></blockquote>

<a name="sec-security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
Security Considerations</h3>

<p>TBD: Update this section to match changes to the TURN protocol.
</p>
<p>TURN servers allocate resources to clients, in contrast to the
      Binding method defined in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>. Therefore, a TURN server
      may require the authentication and authorization of STUN requests. This
      authentication is provided by mechanisms defined in the STUN
      specification itself, in particular digest authentication.
</p>
<p>Because TURN servers allocate resources, they can be susceptible to
      denial-of-service attacks. All Allocate transactions are authenticated,
      so that an unknown attacker cannot launch an attack. An authenticated
      attacker can generate multiple Allocate requests, however. To prevent a
      single malicious user from allocating all of the resources on the
      server, it is RECOMMENDED that a server implement a per user limit on
      the number of allocations that can active at one time. Such a mechanism
      does not prevent a large number of malicious users from each requesting
      a small number of allocations. Attacks such as these are possible using
      botnets, and are difficult to detect and prevent. Implementors of TURN
      should keep up with best practices around detection of anomalous botnet
      attacks.
</p>
<p>A client will use the transport address learned from the
      RELAYED-ADDRESS attribute of the Allocate response to tell other users
      how to reach them. Therefore, a client needs to be certain that this
      address is valid, and will actually route to them. Such validation
      occurs through the message integrity checks provided in the Allocate
      response. They can guarantee the authenticity and integrity of the
      allocated addresses. Note that TURN is not susceptible to the attacks
      described in Section 12.2.3, 12.2.4, 12.2.5 or 12.2.6 of <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a> [[TODO: Update section
      number references to 3489bis]]. These attacks are based on the fact that
      a STUN server mirrors the source IP address, which cannot be
      authenticated. STUN does not use the source address of the Allocate
      request in providing the RELAYED-ADDRESS, and therefore, those attacks
      do not apply.
</p>
<p>TURN attempts to adhere as closely as possible to common firewall
      policies, consistent with allowing data to flow. TURN has fairly limited
      applicability, requiring a user to explicitly authorize permission to
      receive data from a peer, one IP address at a time. Thus, it does not
      provide a general technique for externalizing sockets. Rather, it has
      similar security properties to the placement of an address-restricted
      NAT in the network, allowing messaging in from a peer only if the
      internal client has sent a packet out towards the IP address of that
      peer. This limitation means that TURN cannot be used to run, for
      example, SIP servers, NTP servers, FTP servers or other network servers
      that service a large number of clients. Rather, it facilitates
      rendezvous of NATted clients that use some other protocol, such as SIP,
      to communicate IP addresses and ports for communications.
</p>
<p>Confidentiality of the transport addresses learned through Allocate
      transactions does not appear to be that important. If required, it can
      be provided by running TURN over TLS.
</p>
<p>TURN does not and cannot guarantee that UDP data is delivered in
      sequence or to the correct address. As most TURN clients will only
      communicate with a single peer, the use of a single channel number will
      be very common. Consider an enterprise where Alice and Bob are involved
      in separate calls through the enterprise NAT to their corporate TURN
      server. If the corporate NAT reboots, it is possible that Bob will
      obtain the exact NAT binding originally used by Alice. If Alice and Bob
      were using identical channel numbers, Bob will receive unencapsulated
      data intended for Alice and will send data accidentally to Alice's peer.
      This is not a problem with TURN. This is precisely what would happen if
      there was no TURN server and Bob and Alice instead provided a (STUN)
      reflexive transport address to their peers. If detecting this
      misdelivery is a problem, the client and its peer need to use message
      integrity on their data.
</p>
<p>Relay servers are useful even for users not behind a NAT. They can
      provide a way for truly anonymous communications. A user can cause a
      call to have its media routed through a TURN server, so that the user's
      IP addresses are never revealed.
</p>
<p>Any relay addresses learned through an Allocate request will not
      operate properly with <a class='info' href='#RFC4302'>IPSec Authentication Header
      (AH)<span> (</span><span class='info'>Kent, S., &ldquo;IP Authentication Header,&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4302] in transport or tunnel mode. However, tunnel-mode <a class='info' href='#RFC4303'>IPSec ESP<span> (</span><span class='info'>Kent, S., &ldquo;IP Encapsulating Security Payload (ESP),&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4303] should still operate.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16"></a><h3>16.&nbsp;
IANA Considerations</h3>

<p>Since TURN is an extension to STUN <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>, the methods, attributes and
      error codes defined in this specification are new method, attributes,
      and error codes for STUN. This section directs IANA to add these new
      protocol elements to the IANA registry of STUN protocol elements.
</p>
<p>The codepoints for the new STUN methods defined in this specification
      are listed in <a class='info' href='#sec-stun-methods'>Section&nbsp;12<span> (</span><span class='info'>New STUN Methods</span><span>)</span></a>.
</p>
<p>The codepoints for the new STUN attributes defined in this
      specification are listed in <a class='info' href='#sec-stun-attributes'>Section&nbsp;13<span> (</span><span class='info'>New STUN Attributes</span><span>)</span></a>.
</p>
<p>The codepoints for the new STUN error codes defined in this
      specification are listed in <a class='info' href='#sec-stun-errors'>Section&nbsp;14<span> (</span><span class='info'>New STUN Error Response Codes</span><span>)</span></a>.
</p>
<p>Extensions to TURN can be made through IETF consensus.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17"></a><h3>17.&nbsp;
IAB Considerations</h3>

<p>The IAB has studied the problem of "Unilateral Self Address Fixing",
      which is the general process by which a client attempts to determine its
      address in another realm on the other side of a NAT through a
      collaborative protocol reflection mechanism <a class='info' href='#RFC3424'>[RFC3424]<span> (</span><span class='info'>Daigle, L. and IAB, &ldquo;IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation,&rdquo; November&nbsp;2002.</span><span>)</span></a>. The TURN extension is an example of a protocol
      that performs this type of function. The IAB has mandated that any
      protocols developed for this purpose document a specific set of
      considerations.
</p>
<p>TURN is an extension of the STUN protocol. As such, the specific
      usages of STUN that use the TURN extensions need to specifically address
      these considerations. Currently the only STUN usage that uses TURN is
      <a class='info' href='#I-D.ietf-mmusic-ice'>ICE<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a> [I&#8209;D.ietf&#8209;mmusic&#8209;ice].
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18"></a><h3>18.&nbsp;
Example</h3>

<p>TBD
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19"></a><h3>19.&nbsp;
Open Issues</h3>

<p>This section lists the known issues in this version of the
      specification.
</p>
<p></p>
<ol class="text">
<li>Detecting in-use channels. Do we need a way for a client to
          determine if a channel is currently bound? Right now, the only way
          is to try to bind it to an address.
</li>
<li>Public TURN servers. The spec currently hints (but does not say
          anything solid) that the way to run a publicly-accessable TURN
          server is to not require authentication. But perhaps a better way is
          to require authentication but have some unspecified method to allow
          any user to create an account on the server.
</li>
<li>IPv6. Currently, TURN supports IPv4-to-IPv4 relaying, and
          IPv6-to-IPv6 relaying, but does not support IPv4-to-IPv6 relaying.
          To ensure this, a server requires that the family of the relayed
          address match that of the 5-tuple as seen by the server. However,
          some people would like to see a different rule.
</li>
<li>ALTERNATE-SERVER and Anycast. The details of ALTERNATE-SERVER
          support are still under discussion. In particular, some people would
          like to use ALTERNATE-SERVER to support anycast discovery of a TURN
          server.
</li>
<li>Authenticated Permission Refresh. Currently, permissions can be
          refreshed by unauthenticated Send indications and ChannelData
          messages. Some have suggested that this is a security issue.
</li>
<li>PMTUD for non-preserving allocations. Some people would like a
          way to do PMTUD even if the allocation is non-preserving, and have
          suggested that a way for the client to indicate to the server (in a
          Send indication) that the DF bit should be set when sending to the
          peer might allow this.
</li>
<li>Security. The security consideration section is out-of-date with
          the changes to the rest of the draft, and it has been suggested that
          TURN might require TLS to provide proper security. Updating the
          security consideration section will answer this question.
</li>
</ol>

<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.20"></a><h3>20.&nbsp;
Changes from Previous Versions</h3>

<p>Note to RFC Editor: Please remove this section prior to publication
      of this document as an RFC.
</p>
<p>This section lists the changes between the various versions of this
      specification.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.20.1"></a><h3>20.1.&nbsp;
Changes from -08 to -09</h3>

<p></p>
<ul class="text">
<li>Added text to properly define the ICMP attribute. This
            attribute was introduced in TURN-08, but not fully defined due to
            an oversight. Clarified that the attribute can appear in a Data
            indication, but not a Send indication. Added text to the section
            on receiving a Data indication that points out that this attribute
            may be present.
</li>
<li>Changed the wording around the handling of the DSCP field to
            allow the server to set the DSCP to an arbitrary value if the next
            hop is a Diff-Serv classifier and marker.
</li>
<li>When the server generates a 508 response due to an unsupported
            flag in the REQUESTED-PROPS attribute, the server now includes the
            REQUESTED-PROPS attribute in the response with all the flags it
            supports set to 1. This allows the client to see if the server
            does not understand one of its flags. Similarly, the client is now
            allowed to immediately retry the request if it modifies the
            included REQUESTED-PROPS attribute.
</li>
<li>Clarified that the REQUESTED-PROPS attribute can be used in
            conjunction with the RESERVATION-TOKEN attribute as long as both
            the E and R bits are 0. The spec previously contradicted itself on
            this point.
</li>
<li>Clarified that when the server receives a ChannelData message
            with a length field of 0, it sends a UDP Datagram to the peer that
            contains no application data.
</li>
<li>Rewrote some text around relaying incoming UDP Datagrams to
            avoid duplication of text in the Data indication and Channel
            sections.
</li>
<li>Added a note that points out that the on-going work on
            randomizing port allocations <a class='info' href='#I-D.ietf-tsvwg-port-randomization'>[I&#8209;D.ietf&#8209;tsvwg&#8209;port&#8209;randomization]<span> (</span><span class='info'>Larsen, M. and F. Gont, &ldquo;Transport Protocol Port Randomization Recommendations,&rdquo; April&nbsp;2010.</span><span>)</span></a> may be
            applicable to TURN.
</li>
<li>Clarified that the Allocate request containing a
            RESERVATION-TOKEN attribute can use any 5-tuple, and that 5-tuple
            need not have any specific relationship to the 5-tuple of the
            Allocate request that created the reservation.
</li>
<li>Added a note that discusses retransmitted Allocate requests
            over UDP where the first request receives a failure response, but
            the second receives a success response. The server may elect to
            remember transmitted failure responses to avoid this
            situation.
</li>
<li>Added text about the usage of the SOFTWARE-TYPE attribute
            (formerly known as the SERVER attribute) in TURN messages.
</li>
<li>Rewrote the text in the Overview that motivates why TURN
            supports TCP and TLS between the client and the server. The
            previous text had been identified by various readers as inadequate
            and misleading.
</li>
<li>Rewrote the section how a server handles a Refresh request to
            clarify processing in various error conditions. The new text makes
            it clear that it is OK to delete a non-existent allocation. It
            also clarifies how to handle retransmissions of Refresh requests
            over UDP.
</li>
<li>Renamed the "RELAY-ADDRESS" attribute to "RELAYED-ADDRESS",
            since the text consistently uses the term "relayed transport
            address" for the concept and ICE uses the term "relayed
            candidate". 
</li>
<li>Changed the codepoint assigned to the error code "Wrong
            Credentials" from 438 to 441 to avoid a conflict with the "Stale
            Nonce" error code of STUN.
</li>
<li>Changed the text to consistently use non-capitalized "request",
            "response" and "indication", except in headings, error code names,
            etc.
</li>
<li>Added a note mentioning that TURN packets can be demuxed from
            other packets arriving on the same socket by looking at the
            5-tuple of the arriving packet.
</li>
<li>Clarified that there are no required attributes is a
            ChannelBind success response.
</li>
</ul>

<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.20.2"></a><h3>20.2.&nbsp;
Changes from -07 to -08</h3>

<p></p>
<ul class="text">
<li>Removed the BANDWIDTH attribute and all associated text
            (including error code 507 "Insufficient Bandwidth Capacity"), as
            the requirements for this feature were not clear and it was felt
            the feature could be easily added later.
</li>
<li>Changed the format of the REQUESTED-PROPS attribute from a
            one-byte field to a set of bit flags. Changed the semantics of the
            unused portion of the value from RFFU to "MUST be 0" to give a
            more desirable behavior when new flags are defined.
</li>
<li>Introduced the concept of Preserving vs. Non-Preserving
            allocations. As a result, completely revamped the rules for how to
            set the fields in the IP header, and added rules for relaying ICMP
            messages when the allocation is Preserving.
</li>
</ul>

<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.20.3"></a><h3>20.3.&nbsp;
Changes from -06 to -07</h3>

<p></p>
<ul class="text">
<li>Rewrote the General Behavior section, making various changes in
            the process.
</li>
<li>Changed the usage of authentication from MUST to SHOULD.
</li>
<li>Changed the requirement that subsequent requests use the same
            username and password from MUST to SHOULD to allow for the
            possibility of changing the credentials using some unspecified
            mechanism.
</li>
<li>Introduced a 438 (Wrong Credentials) error which is used when a
            non-Allocate request authenticates but does not use the same
            username and password as the Allocate request. Having a separate
            error code for this case avoids the client being confused over
            what the error actually is.
</li>
<li>The server must now prevent the relayed transport address and
            the 5-tuple from being reused in different allocations for 2
            minutes after the allocation expires.
</li>
<li>Changed the usage of FINGERPRINT from MUST NOT to MAY, to allow
            for the possible multiplexing of TURN with some other
            protocol.
</li>
<li>Rewrote much of the section on Allocations, splitting it into
            three new sections (one on allocations in general, one on creating
            an allocation, and one on refreshing an allocation).
</li>
<li>Replaced the mechanism for requesting relayed transport
            addresses with specific properties. The new mechanism is less
            powerful: a client can request an even port, or a pair of ports,
            but cannot request a single odd port or a specific port as was
            possible under the old mechanism. Nor can the client request a
            specific IP address.
</li>
<li>Changed the rules for handling ALTERNATE-SERVER, removing the
            requirement that the referring server have "positive knowledge"
            about the state of the alternate server. The new rules instead
            rely on text in STUN to prevent referral loops.
</li>
<li>Changed the rules for allocation lifetimes. Allocations
            lifetimes are now a minimum of 10 minutes; the client can ask for
            longer values, but requests for shorter values are ignored. The
            text now recommends that the client refresh an allocation one
            minute before it expires.
</li>
<li>Put in temporary procedures for handling the BANDWIDTH
            attribute, modelled on the LIFETIME attribute. These procedures
            are mostly placeholders and likely to change in the next
            revision.
</li>
<li>Added a detailed description of how a client reacts to the
            various errors it can receive in reply to an Allocate request.
            This replaces the various descriptions that were previously
            scattered throughout the document, which were inconsistent and
            sometimes contradictory.
</li>
<li>Added a new section that gives the normative rules for
            permissions.
</li>
<li>Changed the rules around permission lifetimes. The text used to
            recommend a value of one minute; it MUST now be 5 minutes.
</li>
<li>Removed the errors "Channel Missing or Invalid", "Peer Address
            Missing or Invalid" and "Lifetime Malformed or Invalid" and used
            400 "Bad Request" instead.
</li>
<li>Rewrote portions of the section on Send and Data indications
            and the section on Channels to try to make the client vs. server
            behavior clearer.
</li>
<li>Channel bindings now expire after 10 minutes, and must be
            refreshed to keep them alive.
</li>
<li>Binding a channel now installs or refreshes a permission for
            the IP address of corresponding peer.
</li>
<li>Changed the wording describing the situation when the client
            sends a ChannelData message before receiving the ChannelBind
            success response. -06 said that client SHOULD NOT do this; -07 now
            says that a client MAY, but describes the consequences of doing
            it.
</li>
<li>Added a section discussing the setting of fields in the IP
            header.
</li>
<li>Replaced the REQUESTED-PORT-PROPS attribute with the
            REQUESTED-PROPS attribute that has a different format and
            semantics, but reuses the same code point.
</li>
<li>Replaced the REQUESTED-IP attribute with the RESERVATION-TOKEN
            attribute, which has a different format and semantics, but reuses
            the same code point.
</li>
<li>Removed error codes 443 and 444, and replaced them with 508
            (Insufficient Port Capacity). Also changed the error text for code
            507 from "Insufficient Capacity" to "Insufficient Bandwidth
            Capacity".
</li>
</ul>

<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.20.4"></a><h3>20.4.&nbsp;
Changes from -05 to -06</h3>

<p></p>
<ul class="text">
<li>Changed the mechanism for allocating channels to the one
            proposed by Eric Rescorla at the Dec 2007 IETF meeting.
</li>
<li>Removed the framing mechanism (which was used to frame all
            messages) and replaced it with the ChannelData message. As part of
            this change, noted that the demux of ChannelData messages from
            TURN messages can be done using the first two bits of the
            message.
</li>
<li>Rewrote the sections on transmitted and receiving data as a
            result of the above to changes, splitting it into a section on
            Send and Data indications and a separate section on channels.
</li>
<li>Clarified the handling of Allocate request messages. In
            particular, subsequent Allocate request messages over UDP with the
            same transaction id are not an error but a retransmission.
</li>
<li>Restricted the range of ports available for allocation to the
            Dynamic and/or Private Port range, and noted when ports outside
            this range can be used.
</li>
<li>Changed the format of the REQUESTED-TRANSPORT attribute. The
            previous version used 00 for UDP and 01 for TCP; the new version
            uses protocol numbers from the IANA protocol number registry. The
            format of the attribute also changed.
</li>
<li>Made a large number of changes to the non-normative portion of
            the document to reflect technical changes and improve the
            presentation.
</li>
<li>Added the Issues section.
</li>
</ul>

<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.20.5"></a><h3>20.5.&nbsp;
Changes from -04 to -05</h3>

<p></p>
<ul class="text">
<li>Removed the ability to allocate addresses for TCP relaying.
            This is now covered in a separate document. However, communication
            between the client and the server can still run over TCP or
            TLS/TCP. This resulted in the removal of the Connect method and
            the TIMER-VAL and CONNECT-STAT attributes.
</li>
<li>Added the concept of channels. All communication between the
            client and the server flows on a channel. Channels are numbered
            0..65535. Channel 0 is used for TURN messages, while the remaining
            channels are used for sending unencapsulated data to/from a remote
            peer. This concept adds a new Channel Confirmation method and a
            new CHANNEL-NUMBER attribute. The new attribute is also used in
            the Send and Data methods.
</li>
<li>The framing mechanism formally used just for stream-oriented
            transports is now also used for UDP, and the former Type and
            Reserved fields in the header have been replaced by a Channel
            Number field. The length field is zero when running over UDP.
</li>
<li>TURN now runs on its own port, rather than using the STUN port.
            The use of channels requires this.
</li>
<li>Removed the SetActiveDestination concept. This has been
            replaced by the concept of channels.
</li>
<li>Changed the allocation refresh mechanism. The new mechanism
            uses a new Refresh method, rather than repeating the Allocation
            transaction.
</li>
<li>Changed the syntax of SRV requests for secure transport. The
            new syntax is "_turns._tcp" rather than the old "_turn._tls". This
            change mirrors the corresponding change in STUN SRV syntax.
</li>
<li>Renamed the old REMOTE-ADDRESS attribute to PEER-ADDRESS, and
            changed it to use the XOR-MAPPED-ADDRESS format.
</li>
<li>Changed the RELAY-ADDRESS attribute to use the
            XOR-MAPPED-ADDRESS format (instead of the MAPPED-ADDRESS
            format)).
</li>
<li>Renamed the 437 error code from "No Binding" to "Allocation
            Mismatch".
</li>
<li>Added a discussion of what happens if a client's public binding
            on its outermost NAT changes.
</li>
<li>The document now consistently uses the term "peer" as the name
            of a remote endpoint with which the client wishes to
            communicate.
</li>
<li>Rewrote much of the document to describe the new concepts. At
            the same time, tried to make the presentation clearer and less
            repetitive.
</li>
</ul>

<a name="sec-open-issues"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21"></a><h3>21.&nbsp;
Open Issues</h3>

<p>NOTE to RFC Editor: Please remove this section prior to publication
      of this document as an RFC.
</p>
<p>Bandwidth: How should bandwidth be specified? What are the right
      rules around bandwidth?
</p>
<p>Alternate Server: Do we still want this mechanism? Is the current
      proposal acceptable? Note that the usage of the ALTERNATE-SERVER
      attribute in this document is inconsistent with its usage in STUN. In
      STUN, if the ALTERNATE-SERVER attribute is used, then the error that the
      server would otherwise generate is replaced by a 300 (Try Alternate)
      code. In this document, the 300 error code is not used, and the server
      returns an appropriate error code and then includes the ALTERNATE-SERVER
      attribute in the response. In this way, the client can see the actual
      error code, rather than always seeing error code 300, and can thus make
      a more intelligent decision on whether it wishes to try the alternate
      server.
</p>
<p>Public TURN servers: The text currently says that a server "SHOULD"
      use the Long-Term Credential mechanism, with the unstated idea that a
      public TURN server would not use it. But this really weakens the
      security of TURN. Is there a better way to allow public servers? Or
      should we just drop the notion of a public server entirely?
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.22"></a><h3>22.&nbsp;
Acknowledgements</h3>

<p>The authors would like to thank the various participants in the
      BEHAVE working group for their many comments on this draft. Marc
      Petit-Huguenin, Remi Denis-Courmont, Derek MacDonald, Cullen Jennings,
      Lars Eggert, Magnus Westerlund, and Eric Rescorla have been particularly
      helpful, with Eric also suggesting the channel allocation mechanism, and
      Cullen suggesting the REQUESTED-PROPS mechanism. Christian Huitema was
      an early contributor to this document and was a co-author on the first
      few drafts. Finally, the authors would like to thank Dan Wing for both
      his contributions to the text and his huge help in restarting progress
      on this draft after work had stalled.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.23"></a><h3>23.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>23.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-rfc3489bis">[I-D.ietf-behave-rfc3489bis]</a></td>
<td class="author-text">Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-18.txt">Session Traversal Utilities for (NAT) (STUN)</a>,&rdquo; draft-ietf-behave-rfc3489bis-18 (work in progress), July&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-18.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2474">[RFC2474]</a></td>
<td class="author-text"><a href="mailto:kmn@cisco.com">Nichols, K.</a>, <a href="mailto:slblake@torrentnet.com">Blake, S.</a>, <a href="mailto:fred@cisco.com">Baker, F.</a>, and <a href="mailto:black_david@emc.com">D. Black</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2474">Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</a>,&rdquo; RFC&nbsp;2474, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2474.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2474.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2474.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3697">[RFC3697]</a></td>
<td class="author-text">Rajahalme, J., Conta, A., Carpenter, B., and S. Deering, &ldquo;<a href="http://tools.ietf.org/html/rfc3697">IPv6 Flow Label Specification</a>,&rdquo; RFC&nbsp;3697, March&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3697.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>23.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1918">[RFC1918]</a></td>
<td class="author-text"><a href="mailto:yakov@cisco.com">Rekhter, Y.</a>, <a href="mailto:rgm3@is.chrysler.com">Moskowitz, R.</a>, <a href="mailto:Daniel.Karrenberg@ripe.net">Karrenberg, D.</a>, <a href="mailto:GeertJan.deGroot@ripe.net">Groot, G.</a>, and <a href="mailto:lear@sgi.com">E. Lear</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1918">Address Allocation for Private Internets</a>,&rdquo; BCP&nbsp;5, RFC&nbsp;1918, February&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1918.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1981">[RFC1981]</a></td>
<td class="author-text"><a href="mailto:mccann@zk3.dec.com">McCann, J.</a>, <a href="mailto:deering@parc.xerox.com">Deering, S.</a>, and <a href="mailto:mogul@pa.dec.com">J. Mogul</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1981">Path MTU Discovery for IP version 6</a>,&rdquo; RFC&nbsp;1981, August&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1981.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3264">[RFC3264]</a></td>
<td class="author-text">Rosenberg, J. and H. Schulzrinne, &ldquo;<a href="http://tools.ietf.org/html/rfc3264">An Offer/Answer Model with Session Description Protocol (SDP)</a>,&rdquo; RFC&nbsp;3264, June&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3264.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4302">[RFC4302]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4302">IP Authentication Header</a>,&rdquo; RFC&nbsp;4302, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4302.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4303">[RFC4303]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>,&rdquo; RFC&nbsp;4303, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4303.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3424">[RFC3424]</a></td>
<td class="author-text">Daigle, L. and IAB, &ldquo;<a href="http://tools.ietf.org/html/rfc3424">IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation</a>,&rdquo; RFC&nbsp;3424, November&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3424.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mmusic-ice">[I-D.ietf-mmusic-ice]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-19.txt">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>,&rdquo; draft-ietf-mmusic-ice-19 (work in progress), October&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-19.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4787">[RFC4787]</a></td>
<td class="author-text">Audet, F. and C. Jennings, &ldquo;<a href="http://tools.ietf.org/html/rfc4787">Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</a>,&rdquo; BCP&nbsp;127, RFC&nbsp;4787, January&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4787.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-turn-tcp">[I-D.ietf-behave-turn-tcp]</a></td>
<td class="author-text">Perreault, S. and J. Rosenberg, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-tcp-06.txt">Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations</a>,&rdquo; draft-ietf-behave-turn-tcp-06 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-tcp-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-turn-ipv6">[I-D.ietf-behave-turn-ipv6]</a></td>
<td class="author-text">Camarillo, G., Novo, O., and S. Perreault, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-ipv6-09.txt">Traversal Using Relays around NAT (TURN) Extension for IPv6</a>,&rdquo; draft-ietf-behave-turn-ipv6-09 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-ipv6-09.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tsvwg-udp-guidelines">[I-D.ietf-tsvwg-udp-guidelines]</a></td>
<td class="author-text">Eggert, L. and G. Fairhurst, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-udp-guidelines-11.txt">Unicast UDP Usage Guidelines for Application Designers</a>,&rdquo; draft-ietf-tsvwg-udp-guidelines-11 (work in progress), October&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-udp-guidelines-11.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tsvwg-port-randomization">[I-D.ietf-tsvwg-port-randomization]</a></td>
<td class="author-text">Larsen, M. and F. Gont, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-port-randomization-07.txt">Transport Protocol Port Randomization Recommendations</a>,&rdquo; draft-ietf-tsvwg-port-randomization-07 (work in progress), April&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-port-randomization-07.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1191">[RFC1191]</a></td>
<td class="author-text"><a href="mailto:mogul@decwrl.dec.com">Mogul, J.</a> and <a href="mailto:deering@xerox.com">S. Deering</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1191">Path MTU discovery</a>,&rdquo; RFC&nbsp;1191, November&nbsp;1990 (<a href="http://www.rfc-editor.org/rfc/rfc1191.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4821">[RFC4821]</a></td>
<td class="author-text">Mathis, M. and J. Heffner, &ldquo;<a href="http://tools.ietf.org/html/rfc4821">Packetization Layer Path MTU Discovery</a>,&rdquo; RFC&nbsp;4821, March&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4821.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1928">[RFC1928]</a></td>
<td class="author-text"><a href="mailto:mleech@bnr.ca">Leech, M.</a>, Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, &ldquo;<a href="http://tools.ietf.org/html/rfc1928">SOCKS Protocol Version 5</a>,&rdquo; RFC&nbsp;1928, March&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1928.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Port-Numbers">[Port-Numbers]</a></td>
<td class="author-text">&ldquo;<a href="http://www.iana.org/assignments/port-numbers">IANA Port Numbers Registry</a>.&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="Protocol-Numbers">[Protocol-Numbers]</a></td>
<td class="author-text">&ldquo;<a href="http://www.iana.org/assignments/protocol-numbers">IANA Protocol Numbers Registry</a>,&rdquo; 2005.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jonathan Rosenberg</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Edison, NJ</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jdrosen@cisco.com">jdrosen@cisco.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.jdrosen.net">http://www.jdrosen.net</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Rohan Mahy</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Plantronics, Inc.</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:rohan@ekabal.com">rohan@ekabal.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Philip Matthews</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">(Unaffiliated)</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:philip_matthews@magma.ca">philip_matthews@magma.ca</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href=""></a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
