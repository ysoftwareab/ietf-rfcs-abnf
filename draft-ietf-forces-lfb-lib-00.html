<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>ForCES LFB Library</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="ForCES LFB Library">
<meta name="keywords" content="ForCES, LFB, Library">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Internet Engineering Task Force</td><td class="header">W. Wang</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Zhejiang Gongshang University</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">E. Haleplidis</td></tr>
<tr><td class="header">Expires: January 1, 2010</td><td class="header">University of Patras</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">K. Ogawa</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">NTT Corporation</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">F. Jia</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">National Digital Switching</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Center(NDSC)</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">J. Halpern</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Ericsson</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">June 30, 2009</td></tr>
</table></td></tr></table>
<h1><br />ForCES LFB Library<br />draft-ietf-forces-lfb-lib-00</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 1, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>The forwarding and Control Element Separation (ForCES) protocol 
   defines a standard communication and control mechanism through which 
   a Control Element (CE) can control the behavior of a Forwarding 
   Element (FE). That control is accomplished through manipulating 
   components of Logical Function Blocks (LFBs), whose structure is 
   defined in a model RFC produced by the working group.In order to build an actual solution using this
   protocol, there needs to be a set of Logical Function Block
   definitions that can be instantiated by FEs and controlled by CEs.
   This document provides a sample space of such definitions.  It is
   anticipated that additional defining documents will be produced over
   time.

</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Terminology and Conventions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Requirements Language<br />
<a href="#anchor3">2.</a>&nbsp;
Definitions<br />
<a href="#anchor4">3.</a>&nbsp;
Introduction<br />
<a href="#anchor5">4.</a>&nbsp;
Base Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">4.1.</a>&nbsp;
Framedefs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.2.</a>&nbsp;
DataTypeDefs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">4.3.</a>&nbsp;
MetaDataDefs<br />
<a href="#anchor9">5.</a>&nbsp;
LFB Descriptions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">5.1.</a>&nbsp;
Core LFBs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">5.1.1.</a>&nbsp;
FEObject LFB<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">5.1.2.</a>&nbsp;
FEProtocol LFB<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">5.2.</a>&nbsp;
Port LFBs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">5.2.1.</a>&nbsp;
GenericConnectivityLFB<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">5.2.2.</a>&nbsp;
EtherPort<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">5.2.3.</a>&nbsp;
EtherDecap<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">5.2.4.</a>&nbsp;
EtherEncap<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">5.3.</a>&nbsp;
Address LFBs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">5.3.1.</a>&nbsp;
IPv6AddrResolution<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">5.3.2.</a>&nbsp;
Arp<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">5.3.3.</a>&nbsp;
ICMPGenerator<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">5.3.4.</a>&nbsp;
ICMPv6Generator<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">5.3.5.</a>&nbsp;
IPv4Validator<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">5.3.6.</a>&nbsp;
IPv6Validator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">5.4.</a>&nbsp;
Forwarding LFBs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">5.4.1.</a>&nbsp;
IPv4UcastLPM<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">5.4.2.</a>&nbsp;
IPv4NextHopApplicator<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">5.4.3.</a>&nbsp;
IPv6UcastLPM<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">5.4.4.</a>&nbsp;
IPv6UcastNexthopApplicator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">5.5.</a>&nbsp;
Queue and scheduler LFBs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">5.5.1.</a>&nbsp;
Scheduler<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">5.5.2.</a>&nbsp;
Queue<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">5.5.3.</a>&nbsp;
WRRSched<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">5.6.</a>&nbsp;
Miscellanious LFBs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">5.6.1.</a>&nbsp;
ExtendHeaderProc<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">5.6.2.</a>&nbsp;
MetadataClassifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">5.6.3.</a>&nbsp;
OptionProc<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">5.6.4.</a>&nbsp;
RedirectLFB<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor39">5.6.5.</a>&nbsp;
PacketTrimmer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">5.6.6.</a>&nbsp;
Duplicator<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor41">5.6.7.</a>&nbsp;
ArbitraryClassifierLFB<br />
<a href="#anchor42">6.</a>&nbsp;
LFB Library Definition<br />
<a href="#anchor43">7.</a>&nbsp;
LFB Use Case<br />
<a href="#anchor44">8.</a>&nbsp;
Contributors<br />
<a href="#Acknowledgements">9.</a>&nbsp;
Acknowledgements<br />
<a href="#IANA">10.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">11.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">12.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">12.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Terminology and Conventions</h3>

<p>
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Definitions</h3>

<p>This document follows the terminology defined by the ForCES
   Requirements in <a class='info' href='#RFC3654'>[RFC3654]<span> (</span><span class='info'>Khosravi, H. and T. Anderson, &ldquo;Requirements for Separation of IP Control and Forwarding,&rdquo; November&nbsp;2003.</span><span>)</span></a>and by the ForCES framework in <a class='info' href='#RFC3746'>[RFC3746]<span> (</span><span class='info'>Yang, L., Dantu, R., Anderson, T., and R. Gopal, &ldquo;Forwarding and Control Element Separation (ForCES) Framework,&rdquo; April&nbsp;2004.</span><span>)</span></a>.
   The definitions below are repeated below for clarity.
</p>
<p>
        </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>Control Element (CE) - A logical entity that implements the ForCES
   protocol and uses it to instruct one or more FEs on how to process
   packets.  CEs handle functionality such as the execution of control
   and signaling protocols.
</dd>
<dt></dt>
<dd>Forwarding Element (FE) - A logical entity that implements the ForCES
   protocol.  FEs use the underlying hardware to provide per-packet
   processing and handling as directed/controlled by one or more CEs via
   the ForCES protocol.
</dd>
<dt></dt>
<dd>ForCES Network Element (NE) - An entity composed of one or more CEs
   and one or more FEs.  To entities outside an NE, the NE represents a
   single point of management.  Similarly, an NE usually hides its
   internal organization from external entities.
</dd>
<dt></dt>
<dd>LFB (Logical Function Block) - The basic building block that is
   operated on by the ForCES protocol.  The LFB is a well defined,
   logically separable functional block that resides in an FE and is
   controlled by the CE via ForCES protocol.  The LFB may reside at the
   FE's datapath and process packets or may be purely an FE control or
   configuration entity that is operated on by the CE.  Note that the
   LFB is a functionally accurate abstraction of the FE's processing
   capabilities, but not a hardware-accurate representation of the FE
   implementation.
</dd>
<dt></dt>
<dd>FE Topology - A representation of how the multiple FEs within a
   single NE are interconnected.  Sometimes this is called inter-FE
   topology, to be distinguished from intra-FE topology (i.e., LFB
   topology).
</dd>
<dt></dt>
<dd>LFB Class and LFB Instance - LFBs are categorized by LFB Classes.  An
   LFB Instance represents an LFB Class (or Type) existence.  There may
   be multiple instances of the same LFB Class (or Type) in an FE.  An
   LFB Class is represented by an LFB Class ID, and an LFB Instance is
   represented by an LFB Instance ID.  As a result, an LFB Class ID
   associated with an LFB Instance ID uniquely specifies an LFB
   existence.
</dd>
<dt></dt>
<dd>LFB Metadata - Metadata is used to communicate per-packet state from
   one LFB to another, but is not sent across the network.  The FE model
   defines how such metadata is identified, produced and consumed by the
   LFBs.  It defines the functionality but not how metadata is encoded
   within an implementation.
</dd>
<dt></dt>
<dd>LFB Component - Operational parameters of the LFBs that must be
   visible to the CEs are conceptualized in the FE model as the LFB
   components.  The LFB components include, for example, flags, single
   parameter arguments, complex arguments, and tables that the CE can
   read and/or write via the ForCES protocol (see below).
</dd>
<dt></dt>
<dd>LFB Topology - Representation of how the LFB instances are logically
   interconnected and placed along the datapath within one FE. Sometimes
    it is also called intra-FE topology, to be distinguished from inter-FE topology.
</dd>
<dt></dt>
<dd>ForCES Protocol - While there may be multiple protocols used within
   the overall ForCES architecture, the term "ForCES protocol" and
   "protocol" refer to the Fp reference points in the ForCES Framework
   in [RFC3746].  This protocol does not apply to CE-to-CE
   communication, FE-to-FE communication, or to communication between FE
   and CE managers.  Basically, the ForCES protocol works in a master-
   slave mode in which FEs are slaves and CEs are masters.  This
   document defines the specifications for this ForCES protocol.
</dd>
</dl></blockquote><p>
      
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Introduction</h3>

<p>XXX: Editorial Note: This is an initial rough copy of the document 
    which will undergo heavy review and modification. It was published
    to beat the meeting deadline.
</p>
<p>Forwarding and Control Element Separation (ForCES) defines an
   architectural framework and associated protocols to standardize
   information exchange between the control plane and the forwarding
   plane in a ForCES Network Element (ForCES NE).  <a class='info' href='#RFC3654'>[RFC3654]<span> (</span><span class='info'>Khosravi, H. and T. Anderson, &ldquo;Requirements for Separation of IP Control and Forwarding,&rdquo; November&nbsp;2003.</span><span>)</span></a>has defined
   the ForCES requirements, and <a class='info' href='#RFC3746'>[RFC3746]<span> (</span><span class='info'>Yang, L., Dantu, R., Anderson, T., and R. Gopal, &ldquo;Forwarding and Control Element Separation (ForCES) Framework,&rdquo; April&nbsp;2004.</span><span>)</span></a> has defined the ForCES
   framework.
</p>
<p>  The ForCES protocol Protocol <a class='info' href='#I-D.ietf-forces-protocol'>FE-protocol<span> (</span><span class='info'>Dong, L., Doria, A., Gopal, R., HAAS, R., Salim, J., Khosravi, H., and W. Wang, &ldquo;ForCES Protocol Specification,&rdquo; March&nbsp;2009.</span><span>)</span></a> [I&#8209;D.ietf&#8209;forces&#8209;protocol]
   defines a protocol by which Control Elements (CEs) communicated with and 
   control the behavior of Forwarding Elements (FEs).  That control is 
   expressed in terms of manipulations of components of Logical Function Blocks (LFBs).
   The structure and abstract semantics of LFBs is defined in Model 
   <a class='info' href='#I-D.ietf-forces-model'>FE-MODEL<span> (</span><span class='info'>Halpern, J. and J. Salim, &ldquo;ForCES Forwarding Element Model,&rdquo; October&nbsp;2008.</span><span>)</span></a> [I&#8209;D.ietf&#8209;forces&#8209;model].
   That document also defines a single LFB Class for gaining access to
   FE properties including the set of LFBs and their interconnection.
   The Protocol document defines an LFB class for manipulating the
   protocol properties of the FE.

</p>
<p>In order for the protocol to be useful to control any behavior, there
   must be a set of LFB class definitions for the LFBs which provide
   that behavior.  This document provides a set of such
   definitions.  This document is intended to provide an initial LFB library.
   It is expected that other definitions will be developed over time, and documented in other RFCs.
  
</p>
<p>  An LFB performs a well-defined action or computation on the packets
   passing through it.  Upon completion of its prescribed function,
   either the packets are modified in certain ways (e.g., decapsulator,
   marker), or some results are generated and stored, often in the form
   of metadata (e.g., classifier).  Each LFB typically performs a single
   action.  Classifiers, shapers and meters are all examples of such
   LFBs.
</p>
<p>In general, multiple LFBs are contained in one FE. An LFB, may have inputs, outputs and components
   that can be queried and manipulated by the CE via the ForCES Protocol. An LFB can have one or more inputs.
   Each input takes a pair of a packet and its associated metadata. The LFB processes the input, and produces
   one or more outputs, each of which is a pair of a packet and its associated metadata.
  
</p>
<p>For further information regarding the LFB model, the reader is referenced to <a class='info' href='#I-D.ietf-forces-model'>FE-MODEL<span> (</span><span class='info'>Halpern, J. and J. Salim, &ldquo;ForCES Forwarding Element Model,&rdquo; October&nbsp;2008.</span><span>)</span></a> [I&#8209;D.ietf&#8209;forces&#8209;model].
</p>
<p>XXX: The above text is redundant. The definition gives some intro to LFBs and the model and all the other docs before this tell us what an LFB is
</p>
<p>In this document we first define base structures used in building the LFBs in section 4 then use those base definitions to define various LFBs. 
</p>
<p>To simplify the understanding of these LFBs - we have chosen to group them by functionality. The following groups of LFBs will be described in section 5:
</p>
<p>
        </p>
<ol class="text">
<li>Core LFBs.
</li>
<li>Port LFBs.
</li>
<li>Address LFBs.
</li>
<li>Forwarding LFBs.
</li>
<li>Queue manager and scheduler LFBs.
</li>
<li>Miscellanious LFBs.
</li>
</ol><p>
      
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Base Definitions</h3>

<p>This section povides a base set of LFB frame, data type, and meta
         data definitions for use by all any LFB Class definitions (in this or
         other documents. This section provides no actual LFB Class
         definitions.
     
</p>
<p>These are then used in each subsequent definition by the statement:
      </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;load library="Base"/&gt;
</pre></div><p>

      
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Framedefs</h3>

<p>The following Frames are defined:
</p>
<p>
          </p>
<ol class="text">
<li>EthernetII - An Ethernet II frame type.
</li>
<li>Ethernet802.3 - An Ethernet 802.3 frame type.
</li>
<li>Ethernet802.2 - An Ethernet 802.2 frame type.
</li>
<li>Ethernet802.2SNAP - An Ethernet 802.2 with SNAP frame.
</li>
<li>IPv4Frame - An IPv4 packet.
</li>
<li>IPv6Frame - An IPv6 packet.
</li>
<li>TaggedFrame - A frame of any type with associated metadata.
</li>
<li>MetadataFrame - Frame only contains meta data.
</li>
<li>Arbitrary - Any kind of frame except Metadata Frame.
</li>
</ol><p>
        
</p>
<p>
          </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;frameDefs&gt;
  &lt;frameDef&gt;
    &lt;name&gt;EthernetII&lt;/name&gt;
    &lt;synopsis&gt;An Ethernet II frame type&lt;/synopsis&gt;
  &lt;/frameDef&gt;
  &lt;frameDef&gt;
    &lt;name&gt;Ethernet802.3&lt;/name&gt;
    &lt;synopsis&gt;An Ethernet 802.3 frame type&lt;/synopsis&gt;
  &lt;/frameDef&gt;
  &lt;frameDef&gt;
    &lt;name&gt;Ethernet802.2&lt;/name&gt;
    &lt;synopsis&gt;An Ethernet 802.2 frame type&lt;/synopsis&gt;
  &lt;/frameDef&gt;
  &lt;frameDef&gt;
    &lt;name&gt;Ethernet802.2SNAP&lt;/name&gt;
    &lt;synopsis&gt;An Ethernet 802.2 with SNAP frame&lt;/synopsis&gt;
  &lt;/frameDef&gt;
  &lt;frameDef&gt;
    &lt;name&gt;IPv4Frame&lt;/name&gt;
    &lt;synopsis&gt;An IPv4 packet&lt;/synopsis&gt;
  &lt;/frameDef&gt;
  &lt;frameDef&gt;
    &lt;name&gt;IPv6Frame&lt;/name&gt;
    &lt;synopsis&gt;An IPv6 packet&lt;/synopsis&gt;
  &lt;/frameDef&gt;
  &lt;frameDef&gt;
    &lt;name&gt;taggedFrame&lt;/name&gt;
    &lt;synopsis&gt;A frame of any type with associated metadata.&lt;/synopsis&gt;
  &lt;/frameDef&gt;
  &lt;frameDef&gt;
    &lt;name&gt;MetadataFrame&lt;/name&gt;
    &lt;synopsis&gt;Frame only contains meta data&lt;/synopsis&gt;
  &lt;/frameDef&gt;
  &lt;frameDef&gt;
    &lt;name&gt;Arbitrary&lt;/name&gt;
    &lt;synopsis&gt;Any kind of frame except Metadata Frame.&lt;/synopsis&gt;
  &lt;/frameDef&gt;
&lt;/frameDefs&gt;</pre></div><p>

        
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
DataTypeDefs</h3>

<p>The following Data Types are defined:
</p>
<p>
          </p>
<ol class="text">
<li>ifIndex - A Port Identifier.
</li>
<li>IEEEMAC - IEEE MAC Address.
</li>
<li>NetSpeedType - Network speed values.
</li>
<li>IEEENegotiationType - IEEENegotiation types.
</li>
<li>PortStatsType - Port statistics.
</li>
<li>PortStatusValues - The possible values of status Used for both administrative and operation status.
</li>
<li>LocalIpAddrType - Local IP address belonging to FE.
</li>
<li>LocalIpv6AddrType - The device local IPv6 address infomation.
</li>
<li>IPv4Addr - IPv4 address.
</li>
<li>IPv6Addr - IPv6 address.
</li>
<li>IPv4Prefix - IPv4 prefix defined by an address and a prefix length.
</li>
<li>IPv4NextHopInfoType - IPv4 nexthop information,include nexthop ip address,output FE and interface etc.
</li>
<li>IPv4FibEntryType - IPv4 forwarding table entry.
</li>
<li>IPv4PrefixTableEntry - IPv4 prefix table entry.
</li>
<li>IPv4UcastLPMStatisticsType - Statistics of IPv4UcastLPM LFB.
</li>
<li>IPv4ValidatorStatisticsType - IPv4 validator LFB statistics type.
</li>
<li>IPv6Prefix - IPv6 prefix defined by an address and a prefix length.
</li>
<li>IPv6NextHopInfoType - IPv6 next hop information, include next hop ip address,output FE and interfac eetc.
</li>
<li>IPv6PrefixTableEntry - IPv6 prefix table entry.
</li>
<li>IPv6LPMClassiferStatisticsType - Statistics of IPv6 LPM ClassifierLFB.
</li>
<li>IPv6ValidatorStatisticsType - IPv6 validator LFB statistics type.
</li>
<li>NextHopFlagsType - Flags used to define different next hop behaviors.
</li>
<li>WeightTableEntryType - Weight table for queues.
</li>
<li>NbrState - IPv6 neighbour entry resolution state.
</li>
<li>ArpTableEntryType - Arp Entry.
</li>
<li>NbrTableEntryType - IPv6 neighbour table entry.
</li>
<li>DCHostTableEntryTypev4 - Direct connected arp table entry for IPv4.
</li>
<li>DCHostTableEntryTypev6 - Direct connected arp table entry for IPv6.
</li>
<li>IPPacketType - The packet type code.
</li>
<li>IPDispatchTableType - The dispatch table type.
</li>
<li>MetaType - Metadata type definition.
</li>
<li>MetadataClassTableType - The meta data classifying table.
</li>
<li>LinkEncapType - Encapsulation type.
</li>
<li>IPAddress - IP layer address.
</li>
<li>ArpStateType - The arp entry state.
</li>
<li>MatchTargetType - Indicator for the kind of field to be matched by this entry in a classifier.
</li>
<li>MatchTargetIdentifier - Identify the specific target of a match condition.
</li>
<li>MatchBitString - A bit string for use in a match condition.
</li>
<li>MatchCondition - Structure for a single condition to be applied.
</li>
<li>MatchConditiontType - Indicator for the kind of match condition to be applied.
</li>
<li>MatchMetaDataAction - An action to set a metadata item to either a specific value or a field from the incoming meta data or packet.
</li>
<li>NextHopIndex - An index used by the next hop table Typically stored in and generated as metadata by the longest-prefix-match LFB.
</li>
</ol><p>
        
</p>
<p>
          </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;dataTypeDefs&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;ifIndex&lt;/name&gt;
    &lt;synopsis&gt;A Port Identifier&lt;/synopsis&gt;
    &lt;typeRef&gt;uint32&lt;/typeRef&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IEEEMAC&lt;/name&gt;
    &lt;synopsis&gt;IEEE MAC Address&lt;/synopsis&gt;
    &lt;typeRef&gt;byte[6]&lt;/typeRef&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;NetSpeedType&lt;/name&gt;
    &lt;synopsis&gt;Network speed values&lt;/synopsis&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uint32&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="0x00000001"&gt;
          &lt;name&gt;LAN_SPEED_10M&lt;/name&gt;
          &lt;synopsis&gt;10M Ethernet&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000002"&gt;
          &lt;name&gt;LAN_SPEED_100M&lt;/name&gt;
          &lt;synopsis&gt;100M Ethernet&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000003"&gt;
          &lt;name&gt;LAN_SPEED_1G&lt;/name&gt;
          &lt;synopsis&gt;1000M Ethernet&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000004"&gt;
          &lt;name&gt;LAN_SPEED_10G&lt;/name&gt;
          &lt;synopsis&gt;10G Ethernet&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000005"&gt;
          &lt;name&gt;LAN_SPEED_AUTO&lt;/name&gt;
          &lt;synopsis&gt;LAN speed auto&lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
&lt;!--XXX:This doesnt look like the SNMP
  definitions. We should look at the SNMP
  definitions for guidance; we should not have
  limitations that SNMP has such as being
  restricted to 32 bits"
  "refer to RFC 3635 ifSpeed and ifHighSpeed"
--&gt;
   &lt;/atomic&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IEEENegotiationType&lt;/name&gt;
    &lt;synopsis&gt;IEEENegotiation types&lt;/synopsis&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uint32&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="0x00000001"&gt;
          &lt;name&gt;Auto&lt;/name&gt;
          &lt;synopsis&gt;Auto negotitation.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000002"&gt;
          &lt;name&gt;Half-duplex&lt;/name&gt;
          &lt;synopsis&gt;port negotitation half duplex&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000003"&gt;
          &lt;name&gt;Full-duplex&lt;/name&gt;
          &lt;synopsis&gt;port negotitation full duplex&lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
&lt;!--XXX:This is very IEEE specific--&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;PortStatsType&lt;/name&gt;
    &lt;synopsis&gt;Port statistics&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;InUcastPkts&lt;/name&gt;
        &lt;synopsis&gt;Number of unicast packets received&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;InMulticastPkts&lt;/name&gt;
        &lt;synopsis&gt;Number of multicast packets received&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;InBroadcastPkts&lt;/name&gt;
        &lt;synopsis&gt;Number of broadcast packets received&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;InOctets&lt;/name&gt;
        &lt;synopsis&gt;number of octets received&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="5"&gt;
        &lt;name&gt;OutUcastPkts&lt;/name&gt;
        &lt;synopsis&gt;Number of unicast packets transmitted&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="6"&gt;
        &lt;name&gt;OutMulticastPkts&lt;/name&gt;
        &lt;synopsis&gt;Number of multicast packets transmitted&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="7"&gt;
        &lt;name&gt;OutBroadcastPkts&lt;/name&gt;
        &lt;synopsis&gt;Number of broadcast packets transmitted&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="8"&gt;
        &lt;name&gt;OutOcetes&lt;/name&gt;
        &lt;synopsis&gt;Number of octets transmitted&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="9"&gt;
        &lt;name&gt;InErrorPkts&lt;/name&gt;
        &lt;synopsis&gt;Number of input error packets&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="10"&gt;
        &lt;name&gt;OutErrorPkts&lt;/name&gt;
        &lt;synopsis&gt;Number of output error packets&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
&lt;!--XXX:Make sure we validate with SNMP Port Stats--&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;PortStatusValues&lt;/name&gt;
    &lt;synopsis&gt;
            The possible values of status.  Used for both
            administrative and operation status&lt;/synopsis&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uchar&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="0"&gt;
          &lt;name&gt;Disabled&lt;/name&gt;
          &lt;synopsis&gt;the port is operatively disabled.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="1"&gt;
          &lt;name&gt;UP&lt;/name&gt;
          &lt;synopsis&gt;the port is up.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="2"&gt;
          &lt;name&gt;Down&lt;/name&gt;
          &lt;synopsis&gt;The port is down.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
&lt;!--XXX:Need to conform with Administrative and operational status--&gt;
    &lt;/atomic&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;LocalIpAddrType&lt;/name&gt;
    &lt;synopsis&gt;Local IP address belonging to FE.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;FEID&lt;/name&gt;
        &lt;synopsis&gt;The FE on which the port ip resides&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
&lt;!--XXX:FEID is know to the Object LFB. Do we need it here?--&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;IfIndex&lt;/name&gt;
        &lt;synopsis&gt;port index on the specified FE&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
&lt;!--XXX:We need to support the model that says that a local IP has
multiple ports. Should this be an array of uint32--&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;IPaddr&lt;/name&gt;
        &lt;synopsis&gt;IP address of the port&lt;/synopsis&gt;
        &lt;typeRef&gt;IPAddr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;netmask&lt;/name&gt;
        &lt;synopsis&gt;netmask of this ip address&lt;/synopsis&gt;
        &lt;typeRef&gt;IPAddr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="5"&gt;
       &lt;name&gt;BcastAddr&lt;/name&gt;
        &lt;synopsis&gt;The associated Broadcast address of the
                                                  ip address&lt;/synopsis&gt;
        &lt;typeRef&gt;IPAddr&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;LocalIpv6AddrType&lt;/name&gt;
    &lt;synopsis&gt;The device local IPv6 address infomation&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;FEID&lt;/name&gt;
        &lt;synopsis&gt;The FE on which the port ip resides&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
&lt;!--XXX:FEID is know to the Object LFB. Do we need it here?--&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;IfIndex&lt;/name&gt;
        &lt;synopsis&gt;port index on the specified FE&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
&lt;!--XXX:We need to support the model that says that a local IP has
multiple ports. Should this be an array of uint32--&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;IPv6addr&lt;/name&gt;
        &lt;synopsis&gt;IP address of the port&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;prefixlen&lt;/name&gt;
        &lt;synopsis&gt;prefix length of this ip address&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv4Addr&lt;/name&gt;
    &lt;synopsis&gt;IPv4 address&lt;/synopsis&gt;
    &lt;typeRef&gt;byte[4]&lt;/typeRef&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv6Addr&lt;/name&gt;
    &lt;synopsis&gt;IPv6 address&lt;/synopsis&gt;
    &lt;typeRef&gt;byte[16]&lt;/typeRef&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv4Prefix&lt;/name&gt;
    &lt;synopsis&gt;IPv4 prefix defined by an address and a prefix length
                                                            &lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;address&lt;/name&gt;
        &lt;synopsis&gt;Address part&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv4addr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;prefixlen&lt;/name&gt;
        &lt;synopsis&gt;Prefix length part&lt;/synopsis&gt;
        &lt;atomic&gt;
          &lt;baseType&gt;uchar&lt;/baseType&gt;
          &lt;rangeRestriction&gt;
            &lt;allowedRange min="0" max="32"/&gt;
          &lt;/rangeRestriction&gt;
        &lt;/atomic&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv4NextHopInfoType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;IPv4 nexthop information,include nexthop ip address,
                                output FE and interface etc.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;NexthopID&lt;/name&gt;
        &lt;synopsis&gt;nexthop id&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;FEID&lt;/name&gt;
        &lt;synopsis&gt;output FE id&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;Egress&lt;/name&gt;
        &lt;synopsis&gt;output port index&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;MTU&lt;/name&gt;
        &lt;synopsis&gt;The maximum transmition unit of the nexthop link.
                                                            &lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="5"&gt;
        &lt;name&gt;Flags&lt;/name&gt;
        &lt;synopsis&gt;Associated flags of the nexthop,such as local
                                     delivery,multicast etc.&lt;/synopsis&gt;
        &lt;typeRef&gt;NextHopFlagsType&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="6"&gt;
        &lt;name&gt;NexthopIPaddr&lt;/name&gt;
        &lt;synopsis&gt;IP address of the nexthop&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv4Addr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="7"&gt;
        &lt;name&gt;L2Index&lt;/name&gt;
        &lt;synopsis&gt;index into the L2 link layer table,such as IPv4 ARP
                                    table or IPv6 NBR table.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="8"&gt;
        &lt;name&gt;EncapNeeded&lt;/name&gt;
        &lt;synopsis&gt;The type of encapsulation needed on the packet.
                                                            &lt;/synopsis&gt;
        &lt;typeRef&gt;LinkEncapType&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv4FibEntryType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;IPv4 forwarding table entry.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;prefix&lt;/name&gt;
        &lt;synopsis&gt;IPv4 prefix.&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv4Prefix&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;FEID&lt;/name&gt;
        &lt;synopsis&gt;output FE id&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;Egress&lt;/name&gt;
        &lt;synopsis&gt;output port index&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;MTU&lt;/name&gt;
        &lt;synopsis&gt;The maximum transmition unit of the nexthop link.
                                                            &lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="5"&gt;
        &lt;name&gt;Flags&lt;/name&gt;
        &lt;synopsis&gt;Associated flags of the nexthop,such as local
                                     delivery,multicast etc.&lt;/synopsis&gt;
        &lt;typeRef&gt;NextHopFlagsType&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="6"&gt;
        &lt;name&gt;NexthopIPaddr&lt;/name&gt;
        &lt;synopsis&gt;IP address of the nexthop&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv4Addr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="7"&gt;
        &lt;name&gt;L2Index&lt;/name&gt;
        &lt;synopsis&gt;index into the L2 link layer table,such as IPv4 ARP
                                    table or IPv6 NBR table.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="8"&gt;
        &lt;name&gt;EncapNeeded&lt;/name&gt;
        &lt;synopsis&gt;Type of encapsulation needed on the packet&lt;/synopsis&gt;
        &lt;typeRef&gt;LinkEncapType&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv4PrefixTableEntry&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;IPv4 prefix table entry&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;Prefix&lt;/name&gt;
        &lt;synopsis&gt;IPv4 address prefix&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv4Prefix&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;NexthopID&lt;/name&gt;
        &lt;synopsis&gt;Index into the nexthop table.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv4UcastLPMStatisticsType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;statistics of IPv4UcastLPM LFB&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;InRcvdPkts&lt;/name&gt;
        &lt;synopsis&gt;The total number of input packets received from
               interfaces, including those received in error&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;FwdPkts&lt;/name&gt;
        &lt;synopsis&gt;IPv4 packet forwarded by this LFB&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;NoRoutePkts&lt;/name&gt;
        &lt;synopsis&gt;The number of IP datagrams discarded because no route
       could be found to transmit them to their destination.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
       &lt;component componentID="4"&gt;
         &lt;name&gt;InDeliverPkts&lt;/name&gt;
         &lt;synopsis&gt;The total number of input datagrams successfully
         delivered to IP user-protocols (including ICMP).&lt;/synopsis&gt;
         &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv4ValidatorStatisticsType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;IPv4 validator LFB statistics type&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;badHeaderPkts&lt;/name&gt;
        &lt;synopsis&gt;The total number of input datagrams with bad ip
                                                      header&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;badTotalLengthPkts&lt;/name&gt;
        &lt;synopsis&gt;The total number of input datagrams with bad length
                                                            &lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;badTTLPkts&lt;/name&gt;
        &lt;synopsis&gt;The total number of input datagrams with bad TTL
                                                            &lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;badChecksum&lt;/name&gt;
        &lt;synopsis&gt;The total number of input datagrams with bad checksum
                                                            &lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv6Prefix&lt;/name&gt;
    &lt;synopsis&gt;IPv6 prefix&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;IPv6addr&lt;/name&gt;
        &lt;synopsis&gt;address part of the prefix&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;prefixlen&lt;/name&gt;
        &lt;synopsis&gt;length of the prefix&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv6NextHopInfoType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;IPv6 nexthop information,including nexthop ip address,
                                output FE and interface etc.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;NexthopID&lt;/name&gt;
        &lt;synopsis&gt;nexthop id&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;FEID&lt;/name&gt;
        &lt;synopsis&gt;output FE id&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;Egress&lt;/name&gt;
        &lt;synopsis&gt;output port index&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;MTU&lt;/name&gt;
        &lt;synopsis&gt;The maximum transmition unit of the nexthop link.
                                                            &lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="5"&gt;
        &lt;name&gt;Flags&lt;/name&gt;
        &lt;synopsis&gt;Associated flags of the nexthop,such as local
                                     delivery,multicast etc.&lt;/synopsis&gt;
        &lt;typeRef&gt;NextHopFlagsType&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="6"&gt;
        &lt;name&gt;NexthopIPv6addr&lt;/name&gt;
        &lt;synopsis&gt;IP address of the nexthop&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="7"&gt;
        &lt;name&gt;L2Index&lt;/name&gt;
        &lt;synopsis&gt;index into the L2 table&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="8"&gt;
        &lt;name&gt;EncapNeeded&lt;/name&gt;
        &lt;synopsis&gt;Type of encapsulation needed on the packet&lt;/synopsis&gt;
        &lt;typeRef&gt;LinkEncapType&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv6PrefixTableEntry&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;IPv6 prefix table entry&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;Prefix&lt;/name&gt;
        &lt;synopsis&gt;IPv6 address prefix&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv6Prefix&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;NexthopID&lt;/name&gt;
        &lt;synopsis&gt;index to the nexthop table.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv6LPMClassiferStatisticsType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;statistics of IPv6LPMClassifier LFB&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;InRcvdPkts&lt;/name&gt;
        &lt;synopsis&gt;The total number of input packets received from
               interfaces, including those received in error&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;FwdPkts&lt;/name&gt;
        &lt;synopsis&gt;IPv4 packet forwarded by this LFB&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;NoRoutePkts&lt;/name&gt;
        &lt;synopsis&gt;The number of IP datagrams discarded because no route
       could be found to transmit them to their destination.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;InDeliverPkts&lt;/name&gt;
        &lt;synopsis&gt;The total number of input datagrams successfully
         delivered to IP user-protocols (including ICMP).&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPv6ValidatorStatisticsType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;IPv6 validator LFB statistics type&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;badHeaderPkts&lt;/name&gt;
        &lt;synopsis&gt;The total number of input datagrams with bad ip
                                                      header&lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;badTotalLengthPkts&lt;/name&gt;
        &lt;synopsis&gt;The total number of input datagrams with bad length
                                                            &lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;badTTLPkts&lt;/name&gt;
        &lt;synopsis&gt;The total number of input datagrams with bad TTL
                                                            &lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;badChecksum&lt;/name&gt;
        &lt;synopsis&gt;The total number of input datagrams with bad checksum
                                                            &lt;/synopsis&gt;
        &lt;typeRef&gt;uint64&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;NextHopFlagsType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;Flags to define different nexthop behaviors&lt;/synopsis&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uint32&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="0x00000001"&gt;
          &lt;name&gt;local&lt;/name&gt;
          &lt;synopsis&gt;Packets match the nexthop entry with this flag are
                   delivered to the higher level protocols.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000002"&gt;
          &lt;name&gt;drop&lt;/name&gt;
          &lt;synopsis&gt;Packets match the nexthop entry with this flag are
                                             to be dropped.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000004"&gt;
          &lt;name&gt;broadcast&lt;/name&gt;
          &lt;synopsis&gt;The route associated with this nexthop is a
                                                  broadcast.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000008"&gt;
          &lt;name&gt;multicast&lt;/name&gt;
          &lt;synopsis&gt;The route associated with this nexthop is multicast
                                                            &lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;WeightTableEntryType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;Weight table for queues.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;QueueID&lt;/name&gt;
        &lt;synopsis&gt;queue id&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;weight&lt;/name&gt;
        &lt;synopsis&gt;weight of the queue.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;NbrState&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;IPv6 neighbour entry resolution state.&lt;/synopsis&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uchar&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="0x01"&gt;
          &lt;name&gt;INCOMPLETE&lt;/name&gt;
          &lt;synopsis&gt;Address resolution is being performed on the entry.
                Specifically, a Neighbor Solicitation has been sent to
                the solicited-node multicast address of the target,
                but the corresponding Neighbor Advertisement has not
                yet been received.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x02"&gt;
          &lt;name&gt;REACHABLE&lt;/name&gt;
          &lt;synopsis&gt;Positive confirmation was received within the last
            ReachableTime milliseconds that the forward path to the
            neighbor was functioning properly. While REACHABLE, no
            special action takes place as packets are sent.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x03"&gt;
          &lt;name&gt;STALE&lt;/name&gt;
          &lt;synopsis&gt;More than ReachableTime milliseconds have elapsed
                since the last positive confirmation was received that
                the forward path was functioning properly.  While
                stale, no action takes place until a packet is sent.
                The STALE state is entered upon receiving an
                unsolicited Neighbor Discovery message that updates
                the cached link-layer address.  Receipt of such a
                message does not confirm reachability, and entering
                the STALE state insures reachability is verified
                quickly if the entry is actually being used.  However,
                reachability is not actually verified until the entry
                is actually used.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x04"&gt;
          &lt;name&gt;DELAY&lt;/name&gt;
          &lt;synopsis&gt;More than ReachableTime milliseconds have elapsed
                since the last positive confirmation was received that
                the forward path was functioning properly, and a
                packet was sent within the last DELAY_FIRST_PROBE_TIME
                seconds.  If no reachability confirmation is received
                within DELAY_FIRST_PROBE_TIME seconds of entering the
                DELAY state, send a Neighbor Solicitation and change
                the state to PROBE.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x05"&gt;
          &lt;name&gt;PROBE&lt;/name&gt;
          &lt;synopsis&gt;A reachability confirmation is actively sought by
                retransmitting Neighbor Solicitations every
                RetransTimer milliseconds until a reachability
                confirmation is received.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;ArpTableEntryType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;Arp entry.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;Index&lt;/name&gt;
        &lt;synopsis&gt;Index of the arp table.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;NeighborIP&lt;/name&gt;
        &lt;synopsis&gt;IP address of the neighbour.&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv4Addr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;SrcMac&lt;/name&gt;
        &lt;synopsis&gt;Source MAC.&lt;/synopsis&gt;
        &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;NeighborMac&lt;/name&gt;
        &lt;synopsis&gt;Mac of the Neighbor.&lt;/synopsis&gt;
        &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="5"&gt;
        &lt;name&gt;State&lt;/name&gt;
        &lt;synopsis&gt;State of the address resolution progress.&lt;/synopsis&gt;
        &lt;typeRef&gt;ArpStateType&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;NbrTableEntryType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;IPv6 neighbour table entry.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;Index&lt;/name&gt;
        &lt;synopsis&gt;Index of the arp table.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;NeighborIPv6&lt;/name&gt;
        &lt;synopsis&gt;IP address of the neighbour.&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;SrcMac&lt;/name&gt;
        &lt;synopsis&gt;Source MAC.&lt;/synopsis&gt;
        &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;NeighborMac&lt;/name&gt;
        &lt;synopsis&gt;Mac of the Neighbor.&lt;/synopsis&gt;
        &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="5"&gt;
        &lt;name&gt;State&lt;/name&gt;
        &lt;synopsis&gt;State of the entry's resolution progress.&lt;/synopsis&gt;
        &lt;typeRef&gt;NbrState&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;DCHostTableEntryTypev4&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;Direct connected arp table entry for IPv4.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;NeighbourIP&lt;/name&gt;
        &lt;synopsis&gt;IP address of the neighbour.&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv4Addr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;SrcMac&lt;/name&gt;
        &lt;synopsis&gt;Source MAC.&lt;/synopsis&gt;
        &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;NeighborMac&lt;/name&gt;
        &lt;synopsis&gt;Mac of the Neighbor.&lt;/synopsis&gt;
        &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;DCHostTableEntryTypev6&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;Direct connected arp table entry for IPv6.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;NeighbourIPv6&lt;/name&gt;
        &lt;synopsis&gt;IP address of the neighbour.&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;SrcMac&lt;/name&gt;
        &lt;synopsis&gt;Source MAC.&lt;/synopsis&gt;
        &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;NeighborMac&lt;/name&gt;
        &lt;synopsis&gt;Mac of the Neighbor.&lt;/synopsis&gt;
        &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPPacketType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;The packet type code.&lt;/synopsis&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uchar&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="1"&gt;
          &lt;name&gt;IPv4Ucast&lt;/name&gt;
          &lt;synopsis&gt;IPv4 unicast packet.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="2"&gt;
          &lt;name&gt;IPv4Mcast&lt;/name&gt;
          &lt;synopsis&gt;IPv4 multicast packet.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="3"&gt;
          &lt;name&gt;IPv6Ucast&lt;/name&gt;
          &lt;synopsis&gt;IPv6 unicast packet.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="4"&gt;
          &lt;name&gt;IPv6Mcast&lt;/name&gt;
          &lt;synopsis&gt;IPv6 multicast packet.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPDispatchTableType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;The dispatch table type.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;IPPacketType&lt;/name&gt;
        &lt;synopsis&gt;The type of the packet.IPv4Uncast,IPv6Ucast,
                                IPv4Mulcast,IPv6Mulcast etc.&lt;/synopsis&gt;
        &lt;typeRef&gt;IPPacketType&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;index&lt;/name&gt;
        &lt;synopsis&gt;The index of the output group to output the packets
                                                            &lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;MetaType&lt;/name&gt;
    &lt;synopsis&gt;Metadata type definition.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;MetadataID&lt;/name&gt;
        &lt;synopsis&gt;The ID of the metadata,the value is standardalized in
                      the corresponding LFB definition RFCs.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;MetadataName&lt;/name&gt;
        &lt;synopsis&gt;The name of the metadata.&lt;/synopsis&gt;
        &lt;typeRef&gt;String&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;MetadataClassTableType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;The meta data classifying table.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;value&lt;/name&gt;
        &lt;synopsis&gt;Value of the meta data.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;index&lt;/name&gt;
        &lt;synopsis&gt;The index of the port in the output group to use for
                                      outputing the packets.&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;LinkEncapType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;Encapsulation type.&lt;/synopsis&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uchar&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="1"&gt;
          &lt;name&gt;Link&lt;/name&gt;
          &lt;synopsis&gt;Link layer encapsulation such as Ethernet and PPP.
                                                            &lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="2"&gt;
          &lt;name&gt;InterFE&lt;/name&gt;
          &lt;synopsis&gt;Inter FE communication encapsulation.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="3"&gt;
          &lt;name&gt;Tunnel&lt;/name&gt;
          &lt;synopsis&gt;Tunnel encapsulation such as IP-in-IP.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;IPAddress&lt;/name&gt;
&lt;!--XXX:Do we need a union of IPAddressess?--&gt;
    &lt;synopsis&gt;IP layer address.&lt;/synopsis&gt;
    &lt;union&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;Ipv4&lt;/name&gt;
        &lt;synopsis&gt;IPv4 address.&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv4Addr&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;Ipv6&lt;/name&gt;
        &lt;synopsis&gt;IPv6 address.&lt;/synopsis&gt;
        &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/union&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;ArpStateType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;The arp entry state.&lt;/synopsis&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uchar&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="1"&gt;
          &lt;name&gt;Manual&lt;/name&gt;
          &lt;synopsis&gt;The entry is manually set.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="2"&gt;
          &lt;name&gt;InSolicit&lt;/name&gt;
          &lt;synopsis&gt;The peer's level 2 address is still in requesting.
                                                            &lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="4"&gt;
          &lt;name&gt;Valid&lt;/name&gt;
          &lt;synopsis&gt;The address resolution have been completed
         successfully.Now it can be used in the data packets forwarding
                                                            &lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
   &lt;name&gt;MatchTargetType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;
       Indicator for the kind of field to be matched by this
       entry in a classifier.&lt;/synopsis&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uchar&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="0"&gt;
          &lt;name&gt;MatchNone&lt;/name&gt;
          &lt;synopsis&gt;A matcher against no field&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="1"&gt;
          &lt;name&gt;MatchMetaData&lt;/name&gt;
          &lt;synopsis&gt;A matcher against a metadata item&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="2"&gt;
          &lt;name&gt;MatchPacketField&lt;/name&gt;
          &lt;synopsis&gt;A matcher that works against an identified packet
                                                      field.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="3"&gt;
          &lt;name&gt;MatchOffsetLength&lt;/name&gt;
          &lt;synopsis&gt;
             The match target is a specified portion of the packet.
          &lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;MatchTargetIdentifier&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;
       Identify the specific target of a match condition.
    &lt;/synopsis&gt;
    &lt;union&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;MetaDataID&lt;/name&gt;
        &lt;synopsis&gt;The ID of a metadata item&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;packetFieldID&lt;/name&gt;
        &lt;synopsis&gt;
           The identifier for a packet Field, such as SA, DA,
           Protocol, SPort, DPort, etc.  These identifiers allow
           references to fields with varialbe amounts before them.
        &lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;OffSetLengthPacketField&lt;/name&gt;
        &lt;synopsis&gt;
           A field in the packet identified by its offset and
           length in bits.  This does not allow for matching fields
           whose position depends upon earlier field sizes.
        &lt;/synopsis&gt;
        &lt;struct&gt;
          &lt;component componentID="1"&gt;
            &lt;name&gt;fieldOffset&lt;/name&gt;
            &lt;synopsis&gt;The offset in bits from the start of the packet
                                  to the start of the field.&lt;/synopsis&gt;
            &lt;typeRef&gt;uint32&lt;/typeRef&gt;
          &lt;/component&gt;
          &lt;component componentID="2"&gt;
           &lt;name&gt;fieldLength&lt;/name&gt;
            &lt;synopsis&gt;The length of the field, in bits&lt;/synopsis&gt;
            &lt;typeRef&gt;uint32&lt;/typeRef&gt;
          &lt;/component&gt;
        &lt;/struct&gt;
      &lt;/component&gt;
    &lt;/union&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;MatchBitString&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;A bit string for use in a match condition.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;MatchBits&lt;/name&gt;
        &lt;synopsis&gt;The bits to match&lt;/synopsis&gt;
        &lt;typeRef&gt;octetstring[16]&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;MatchLength&lt;/name&gt;
        &lt;synopsis&gt;The number of bits to match&lt;/synopsis&gt;
        &lt;typeRef&gt;uchar&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;name&gt;MatchCondition&lt;/name&gt;
    &lt;synopsis&gt;Structure for a single condition to be applied&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;TargetType&lt;/name&gt;
        &lt;synopsis&gt;The category of target to match&lt;/synopsis&gt;
        &lt;typeRef&gt;MatchTargetType&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;TargetID&lt;/name&gt;
        &lt;synopsis&gt;The specific target to compare&lt;/synopsis&gt;
        &lt;typeRef&gt;MatchTargetIdentifier&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;MatchType&lt;/name&gt;
        &lt;synopsis&gt;The kind of match to apply.&lt;/synopsis&gt;
        &lt;typeRef&gt;MatchConditionType&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="4"&gt;
        &lt;name&gt;MatchParamOne&lt;/name&gt;
        &lt;synopsis&gt;The first parameter for the match&lt;/synopsis&gt;
        &lt;optional/&gt;
        &lt;typeRef&gt;MatchBitString&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="5"&gt;
        &lt;name&gt;MatchParamTwo&lt;/name&gt;
        &lt;synopsis&gt;The second parameter for the match&lt;/synopsis&gt;
        &lt;optional/&gt;
        &lt;typeRef&gt;MatchBitString&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;MatchConditiontType&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;
       Indicator for the kind of match condition to be applied.
    &lt;/synopsis&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uchar&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="0"&gt;
          &lt;name&gt;MatchNone&lt;/name&gt;
          &lt;synopsis&gt;A matcher which always fails&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="1"&gt;
          &lt;name&gt;MatchExact&lt;/name&gt;
          &lt;synopsis&gt;
             The target and the match value must be the same, with no
             padding. Only the first value of the match condition is
             used.  The first match value must be occur.
          &lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="2"&gt;
          &lt;name&gt;MatchLeft&lt;/name&gt;
          &lt;synopsis&gt;
             The target must begin with the first match value.
             If there is a second match value, the remainder of the
             target must match repeated occurrances of the second
             value.  Thus, this can be used to allow any terminal
             content, or specific ending pad. The first match value
             must occur.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="3"&gt;
          &lt;name&gt;MatchRight&lt;/name&gt;
          &lt;synopsis&gt;
             The target must end with the first match value.
             If there is a second match value, the preceding part
             of the target must match repeated occurrances of the
             second value.  Thus, this can be used to allow any
             leading content, or specific leading fill.  The first
             match value must occur.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="4"&gt;
          &lt;name&gt;MatchRange&lt;/name&gt;
          &lt;synopsis&gt;
             The match values will be considered as numbers, and
             the target must be greater than or equal to the
             first match value, and less than or equal to the
             second match value.  An omitted match value means
             that end of the range is unlimitted.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="5"&gt;
          &lt;name&gt;MatchMaskedValue&lt;/name&gt;
          &lt;synopsis&gt;
             The target the the first value are each anded with the
             second value.  The match succeeds if the results of these
             and operations are identical.  Both values are required.
          &lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="6"&gt;
          &lt;name&gt;MatchSucceed&lt;/name&gt;
          &lt;synopsis&gt;A Match which always succeeds&lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;name&gt;MatchMetaDataAction&lt;/name&gt;
    &lt;synopsis&gt;
       An action to set a metadata item to either a specific value
       or a field from the incoming meta data or packet.&lt;/synopsis&gt;
    &lt;struct&gt;
      &lt;component componentID="1"&gt;
        &lt;name&gt;MetaDataToSet&lt;/name&gt;
        &lt;synopsis&gt;The Meta Data Item to set&lt;/synopsis&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="2"&gt;
        &lt;name&gt;ExplicitValueToSet&lt;/name&gt;
        &lt;synopsis&gt;A value to set the metadata to&lt;/synopsis&gt;
        &lt;optional/&gt;
        &lt;typeRef&gt;octetstring[16]&lt;/typeRef&gt;
      &lt;/component&gt;
      &lt;component componentID="3"&gt;
        &lt;name&gt;ValueFromCondition&lt;/name&gt;
        &lt;synopsis&gt;
           This is an index into the corresponding match conditions,
           and the meta data will be set to the value that was tested
           by that condition.&lt;/synopsis&gt;
        &lt;optional/&gt;
        &lt;typeRef&gt;uint32&lt;/typeRef&gt;
      &lt;/component&gt;
    &lt;/struct&gt;
  &lt;/dataTypeDef&gt;
  &lt;dataTypeDef&gt;
    &lt;name&gt;NextHopIndex&lt;/name&gt;
    &lt;synopsis&gt;
       An index used by the next hop table.
       Typically stored in and generated as metadata by
       the longest-prefix-match LFB.&lt;/synopsis&gt;
     &lt;typeRef&gt;int32&lt;/typeRef&gt;
  &lt;/dataTypeDef&gt;
&lt;/dataTypeDefs&gt;</pre></div><p>

        
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
MetaDataDefs</h3>

<p>The following MetaData Types are defined:
</p>
<p>
          </p>
<ol class="text">
<li>NextHopID - An index into a Next Hop entry in Nexthop table.
</li>
<li>ExceptionID - Exception Types.
</li>
<li>IngressPort - At which interface the packet arrive.
</li>
<li>EgressPort - The interface out which the packet will emmit.
</li>
<li>NextHopIP - Nexthop IPv4 address.
</li>
<li>NexthopIPv6 - Nexthop IPv6 address.
</li>
<li>PacketLength - The length of the packet in octets.
</li>
<li>IPPacketType - Type of the packet.
</li>
<li>QueueID - The queue ID.
</li>
<li>QueueOperationCmd - The type of operation on the queue,there are two types defined here: enqueue and dequeue.
</li>
<li>SrcFEID - Source FE ID.
</li>
<li>DstFEID - Destination FE ID.
</li>
<li>NexthopIndex - Next hop index into the link layer address resolution table.
</li>
<li>NHEncapMethod - How should the following LFBs do to encapsulate the packets.
</li>
<li>ErrorId - Error Type.
</li>
</ol><p>
        
</p>
<p>
          </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;metadataDefs&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;NextHopID&lt;/name&gt;
    &lt;synopsis&gt;An index into a Next Hop entry in Nexthop table&lt;/synopsis&gt;
    &lt;metadataID&gt;1&lt;/metadataID&gt;
    &lt;typeRef&gt;NextHopIndex&lt;/typeRef&gt;
 &lt;/metadataDef&gt;
 &lt;metadataDef&gt;
   &lt;name&gt;ExceptionID&lt;/name&gt;
&lt;!--XXX:Needs more discussion. See that it applies to all LFBs.--&gt;
    &lt;synopsis&gt;Exception Types&lt;/synopsis&gt;
    &lt;metadataID&gt;2&lt;/metadataID&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uint32&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="0x00000001"&gt;
          &lt;name&gt;Options&lt;/name&gt;
          &lt;synopsis&gt;Packets with options,for IPv6 Packet with
                    next-header set to hop-by-hop header(0).&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000002"&gt;
          &lt;name&gt;LengthMismatch&lt;/name&gt;
          &lt;synopsis&gt;The packet length reported by link layer is less
                                than the total length field.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000003"&gt;
          &lt;name&gt;BadTTL&lt;/name&gt;
          &lt;synopsis&gt;The packet can't be forwarded as the TTL has
                                                    expired.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000004"&gt;
          &lt;name&gt;Multicast&lt;/name&gt;
          &lt;synopsis&gt;Packet received is a multicast packet.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000005"&gt;
          &lt;name&gt;FragRequired&lt;/name&gt;
          &lt;synopsis&gt;The MTU for outgoing interface is less than the
                                                packet size.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000006"&gt;
          &lt;name&gt;Redirect&lt;/name&gt;
          &lt;synopsis&gt;The outgoing port is same as the one on which the
                                         packet is received.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000007"&gt;
          &lt;name&gt;LocalDelivery&lt;/name&gt;
          &lt;synopsis&gt;The packet is for a local interface.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00000008"&gt;
          &lt;name&gt;LimitedBroadcast&lt;/name&gt;
          &lt;synopsis&gt;The packet received as limited broadcast&lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;IngressPort&lt;/name&gt;
    &lt;synopsis&gt;At which interface the packet arrive.&lt;/synopsis&gt;
    &lt;metadataID&gt;3&lt;/metadataID&gt;
    &lt;typeRef&gt;ifIndex&lt;/typeRef&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;EgressPort&lt;/name&gt;
    &lt;synopsis&gt;The interface out which the packet will emmit.&lt;/synopsis&gt;
    &lt;metadataID&gt;4&lt;/metadataID&gt;
    &lt;typeRef&gt;ifIndex&lt;/typeRef&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;NextHopIP&lt;/name&gt;
&lt;!--XXX:Needs more discussion if this is metadata--&gt;
    &lt;synopsis&gt;Nexthop IPv4 address&lt;/synopsis&gt;
    &lt;metadataID&gt;5&lt;/metadataID&gt;
    &lt;typeRef&gt;IP4Addr&lt;/typeRef&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;NexthopIPv6&lt;/name&gt;
&lt;!--XXX:Needs more discussion if this is metadata--&gt;
    &lt;synopsis&gt;Nexthop IPv6 address&lt;/synopsis&gt;
    &lt;metadataID&gt;6&lt;/metadataID&gt;
    &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;PacketLength&lt;/name&gt;
    &lt;synopsis&gt;The length of the packet in octets.&lt;/synopsis&gt;
    &lt;metadataID&gt;7&lt;/metadataID&gt;
    &lt;typeRef&gt;uint32&lt;/typeRef&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;IPPacketType&lt;/name&gt;
&lt;!--XXX: Needs more discussion. Should match frameDefs.--&gt;
    &lt;synopsis&gt;Type of the packet&lt;/synopsis&gt;
    &lt;metadataID&gt;8&lt;/metadataID&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uint32&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="0x8000"&gt;
          &lt;name&gt;IPv4&lt;/name&gt;
          &lt;synopsis&gt;IPv4 packet&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x86DD"&gt;
          &lt;name&gt;IPv6&lt;/name&gt;
          &lt;synopsis&gt;IPv6 packet&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="3"&gt;
          &lt;name&gt;TaggedFrame&lt;/name&gt;
          &lt;synopsis&gt;packet with metadata&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="4"&gt;
          &lt;name&gt;MetaDataFrame&lt;/name&gt;
          &lt;synopsis&gt;meta data only&lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;QueueID&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;The queue ID&lt;/synopsis&gt;
    &lt;metadataID&gt;9&lt;/metadataID&gt;
    &lt;typeRef&gt;uint32&lt;/typeRef&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;QueueOperationCmd&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;The type of operation on the queue,there are two types
                          defined here: enqueue and dequeue.&lt;/synopsis&gt;
    &lt;metadataID&gt;10&lt;/metadataID&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;uchar&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="1"&gt;
          &lt;name&gt;Enqueue&lt;/name&gt;
          &lt;synopsis&gt;Enqueue command.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="2"&gt;
          &lt;name&gt;Dequeue&lt;/name&gt;
          &lt;synopsis&gt;Dequeue command.&lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;SrcFEID&lt;/name&gt;
    &lt;synopsis&gt;Source FE ID.&lt;/synopsis&gt;
    &lt;metadataID&gt;11&lt;/metadataID&gt;
    &lt;typeRef&gt;uint32&lt;/typeRef&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
     &lt;name&gt;DstFEID&lt;/name&gt;
    &lt;synopsis&gt;Destination FE ID.&lt;/synopsis&gt;
    &lt;metadataID&gt;12&lt;/metadataID&gt;
    &lt;typeRef&gt;uint32&lt;/typeRef&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;NexthopIndex&lt;/name&gt;
&lt;!--XXX:This should be removed--&gt;
    &lt;synopsis&gt;Nexthop index into the link layer address resolution
                                                      table.&lt;/synopsis&gt;
    &lt;metadataID&gt;13&lt;/metadataID&gt;
    &lt;typeRef&gt;uint&lt;/typeRef&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;NHEncapMethod&lt;/name&gt;
&lt;!--XXX: Is there any value in this?--&gt;
    &lt;synopsis&gt;how should the following LFBs do to encapsulate the
    packets,such as link encapsulation which means the packets need to
    encapsulate link layer header before sending to media;inter FE
    communication encapsulation which means the packets need to first
    encapsulate inter FE communication header before transimiting to
    other FEs;tunnel encapsulation which means the packet need do extra
    tunnel encapsulation before sending out to media.&lt;/synopsis&gt;
    &lt;metadataID&gt;14&lt;/metadataID&gt;
    &lt;typeRef&gt;LinkEncapType&lt;/typeRef&gt;
  &lt;/metadataDef&gt;
  &lt;metadataDef&gt;
    &lt;name&gt;ErrorId&lt;/name&gt;
&lt;!--XXX:Needs more discussion--&gt;
    &lt;synopsis&gt;Error Type.&lt;/synopsis&gt;
    &lt;metadataID&gt;15&lt;/metadataID&gt;
    &lt;atomic&gt;
      &lt;baseType&gt;int32&lt;/baseType&gt;
      &lt;specialValues&gt;
        &lt;specialValue value="0x00030001"&gt;
          &lt;name&gt;WrongIpVersion&lt;/name&gt;
          &lt;synopsis&gt;the IP version wrong&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x00030002"&gt;
          &lt;name&gt;WrongLength&lt;/name&gt;
          &lt;synopsis&gt;
               the packet length is not as long as
               the header indicates&lt;/synopsis&gt;
        &lt;/specialValue&gt;
        &lt;specialValue value="0x000300FF"&gt;
          &lt;name&gt;otherError&lt;/name&gt;
          &lt;synopsis&gt;The errors we not defined now&lt;/synopsis&gt;
        &lt;/specialValue&gt;
      &lt;/specialValues&gt;
    &lt;/atomic&gt;
  &lt;/metadataDef&gt;
&lt;/metadataDefs&gt;</pre></div><p>

        
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
LFB Descriptions</h3>

<p>As specified in section 3.1.2 the LFBs have been grouped together for better understanding. The following groups have been created
</p>
<p>
        </p>
<ol class="text">
<li>Core LFBs, including FE Object LFB and FE Protocol LFB.
</li>
<li>Port LFBs. These LFBs are intended to provide media and 
     encapsulation oriented capabilities associated with an interface. The 
     interfaces may be between FEs inside NE or to the outside world. 
     Allowing for the complicated features of different interface 
     technology.
</li>
<li>Address LFBs. LFBs to model Addresses like IPv4, IPv6 addresses.
</li>
<li>Forwarding LFBs. LFBs to model the 
     IPv4 and IPv6 forwarding function, e.g., IPv4Validor LFB, IPv4UcastLPM LFB, 
     IPv4NextHopApplicator LFB, ARP LFB, ICMPProc LFB, OptionProc LFB, IPv6Validator LFB,
     IPv6UcastLPM LFB, ExtendHeaderProc LFB, IPv6NexthopApplicator LFB,IPv6AddrResolutionLFB 
     LFB, ICMPv6Proc LFB.
</li>
<li>Queue manager and scheduler LFBs. LFB that model queues 
     and schedulers. A basic queue LFB and scheduler LFB are defined. 
     Queues and scheduler can be cascaded together to build more 
     complicated schedulers.
</li>
<li>Miscellanious LFBs. LFBs that capture the functionality broadly used in FEs 
     but are not part of any category, e.g., RedirectSink LFB, 
     RedirectSource LFB, MetaClassifier LFB, GeneralClassifier LFB.
</li>
</ol><p>
      
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Core LFBs</h3>

<p>Currently there are only two core LFBs defined. These two LFBs are core LFBs for ForCES. It's required that each FE must 
     implement these two LFBs for CE to control it.
</p>
<p>
          </p>
<ol class="text">
<li>FEObjectLFB
</li>
<li>FEProtocolLFB
</li>
</ol><p>
        
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
FEObject LFB</h3>

<p>The FEObject LFB is described in detail in the <a class='info' href='#I-D.ietf-forces-model'>FE-MODEL<span> (</span><span class='info'>Halpern, J. and J. Salim, &ldquo;ForCES Forwarding Element Model,&rdquo; October&nbsp;2008.</span><span>)</span></a> [I&#8209;D.ietf&#8209;forces&#8209;model]. The 
     reader is refered there for further detail.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2"></a><h3>5.1.2.&nbsp;
FEProtocol LFB</h3>

<p>The FEProtocol LFB is described in detail in the <a class='info' href='#I-D.ietf-forces-protocol'>FE-protocol<span> (</span><span class='info'>Dong, L., Doria, A., Gopal, R., HAAS, R., Salim, J., Khosravi, H., and W. Wang, &ldquo;ForCES Protocol Specification,&rdquo; March&nbsp;2009.</span><span>)</span></a> [I&#8209;D.ietf&#8209;forces&#8209;protocol]. The 
     reader is refered there for further detail.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Port LFBs</h3>

<p>The Port LFBs that are defined in this library are:
</p>
<p>
          </p>
<ol class="text">
<li>GenericConnectivityLFB
</li>
<li>EtherPort
</li>
<li>EtherDecap
</li>
<li>EtherEncap
</li>
</ol><p>
        
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
GenericConnectivityLFB</h3>

<p>This LFB Class provides a generic basis for representing
           connectivity between the FE and the outside world.
           The LFB has one or more ports for packets that the FE
           processing logic is forwrding for transmission by this
           Connectivity LFB.  It has one or more ports for packets
           that the Connectivity LFB has received and is handing to
           the FE processing logic.
           Multiple ports for handline packets are supported so that
           protocol specific encapsulation and demultiplexing can be
           provided by this LFB.
           This LFB also has ports for sending packets to lower layer
           Connectivity LFBs and receiving packets from such lower
           layer Connectivity LFBs.  This enables support for the
           processing components of interface stacks, such as PPP over
           Ethernet or Ethernet over MPLS.
           For packets arriving from Media or lower layer connectivity,
           this LFB will perform appropriate media validation, then
           remove media specific headers, and place the relevant
           information in meta-data.  For ethernet, the Source MAC would
           be in meta-data.  For Frame Relay or ATM, a circuit identifier
           would be in meta-data.  For Ethernet with VLANs, this
           meta-data would indicate which VLAN the packet came from.
           For packets to be transmitted, meta-data indicating the
           destination (destination MAC or outgoing circuit, etc.) is
           required.
           This LFB will also include statistical components such as the
           number of octets and packets sent and received, the number of
           various input and output errors, etc.
         
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
EtherPort</h3>

<p>LFB for Ethernet ports
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3"></a><h3>5.2.3.&nbsp;
EtherDecap</h3>

<p>An LFB class for definition of Ethernet decapsulation and Ethernet filtering functions.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4"></a><h3>5.2.4.&nbsp;
EtherEncap</h3>

<p>An LFB classifier definition for completes ethernet encapsulation fuctions.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Address LFBs</h3>

<p>The Address LFBs that are defined in this library are:
</p>
<p>
          </p>
<ol class="text">
<li>IPv6AddrResolution
</li>
<li>Arp
</li>
<li>ICMPGenerator
</li>
<li>ICMPv6Generator
</li>
<li>IPv4Validator
</li>
<li>IPv6Validator
</li>
</ol><p>
        
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
IPv6AddrResolution</h3>

<p>This LFB class provides the function of IPv6 address resolution part of neighbor discovery protocol.It provides an offload of ND protocol processing to FE.It process the following ND messages:neighbour solicitation and neighbour advertisement.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2"></a><h3>5.3.2.&nbsp;
Arp</h3>

<p>This LFB class provides the function of address resolution for IPv4 nodes.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.3"></a><h3>5.3.3.&nbsp;
ICMPGenerator</h3>

<p>This LFB class provide some basic ICMP function,it only generate the following ICMP messages:ICMP destination unreachable and time excceeded.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.4"></a><h3>5.3.4.&nbsp;
ICMPv6Generator</h3>

<p>This LFB class provide some basic ICMPv6 function,it only generate the following ICMP messages for the packets that need some basic icmp processing:destination not reachable and time excceeded.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.5"></a><h3>5.3.5.&nbsp;
IPv4Validator</h3>

<p>An LFB Class definition for validates the IPv4 packet.
</p>
<p>This LFB validates the IP version and header length
           fields, including verifying that the packet length
           is at least as long as the header indicates.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.6"></a><h3>5.3.6.&nbsp;
IPv6Validator</h3>

<p>An LFB Class definition for validates the IPv6 packet.
</p>
<p>This LFB validates the IP version and header length
           fields, including verifying that the packet length
           is at least as long as the header indicates.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Forwarding LFBs</h3>

<p>The Forwarding LFBs that are defined in this library are:
</p>
<p>
          </p>
<ol class="text">
<li>IPv4UcastLPM
</li>
<li>IPv4NextHopApplicator
</li>
<li>IPv6UcastLPM
</li>
<li>IPv6UcastNexthopApplicator
</li>
</ol><p>
        
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
IPv4UcastLPM</h3>

<p>IPv4 Longest Prefix Match Lookup LFB
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.2"></a><h3>5.4.2.&nbsp;
IPv4NextHopApplicator</h3>

<p>An LFB definition for applicating next hop action to IPv4 packets,the actions include:TTL operation,checksum recalculation.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.3"></a><h3>5.4.3.&nbsp;
IPv6UcastLPM</h3>

<p>An LFB class definition for IPv6 longest prefix lookup function.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.4"></a><h3>5.4.4.&nbsp;
IPv6UcastNexthopApplicator</h3>

<p>An LFB for applicating next hop action to IPv6 packets,actions mainly inlcude TTL incrementation and checksum recalculation.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
Queue and scheduler LFBs</h3>

<p>
   To build an actual forwarder, one must include some limited for of
   queueing and scheduling.  Queues are entities which store packets.
   Schedulers are entities which react to the state of queues and cause
   packets to be emitted from queues.
</p>
<p>The actual interaction between queues and schedulers (and their real
   world degree of separation) is quite complex.  A very complex LFB
   model would be required to represent all the complexity. Additionally, there is the issue of representing the relationship
   between the queue and the scheduler.  A simple approach has been
   taken in these class definitions.
</p>
<p>A queue element consists of an input port (called InData) on which it
   receives data packets, and output port (called OutData) on which it
   will send packets when permitted by its definition or the scheduler.
   Its relationship to scheduluers is represented by a set of output
   ports (the group OutCountrol) and an input port (called InControl).
   These ports are defined to carry packets consisting only of meta-
   data.  In fact, these ports are an abstraction, and what one might
   call a legal fiction.  An element of the OutControl group represents
   the fact that a scheduler is aware of the state of that queue
   element.  The InControl port represents the fact that one or more
   schedulers connected to that port are controlling that queue.  There
   is no meta-data defined for actual exchange on these ports, as their
   real world realization is highly implementation dependent.  To
   complete this picture, a schedule has a group of input ports
   (Watchers) representing the connectivity to queues it is aware of,
   and a group of output ports (Controllers) representing control over
   queues.  This allows for the simple case of a controller who monitors
   and controls a single set of queues, and more interesting cases where
   the control of certain queues may depend upon the state of queues
   whihc are not under the control of the scheduler.
</p>
<p>The Queues and schedulers LFBs that are defined in this library are:
</p>
<p>
          </p>
<ol class="text">
<li>Scheduler
</li>
<li>Queue
</li>
<li>WRRSched
</li>
</ol><p>
        
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.1"></a><h3>5.5.1.&nbsp;
Scheduler</h3>

<p>This defines a base LFB class for schedulers.  Schedulers have an
   Input Port group called Watchers for representing the queues they
   watch, and an Output Port group called Controllers fro representing
   the queues they control.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.2"></a><h3>5.5.2.&nbsp;
Queue</h3>

<p>Queues have a packet input, a packet output, a control input, and a
   group of control outputs. The control ports represent the control relationships with scheduluers.

</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.3"></a><h3>5.5.3.&nbsp;
WRRSched</h3>

<p>Weighted round robin scheduler.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6"></a><h3>5.6.&nbsp;
Miscellanious LFBs</h3>

<p>The Miscellanious LFBs that are defined in this library are:
</p>
<p>
          </p>
<ol class="text">
<li>ExtendHeaderProc
</li>
<li>MetadataClassifier
</li>
<li>OptionProc
</li>
<li>RedirectLFB
</li>
<li>PacketTrimmer
</li>
<li>Duplicator
</li>
<li>ArbitraryClassifierLfb
</li>
</ol><p>
        
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6.1"></a><h3>5.6.1.&nbsp;
ExtendHeaderProc</h3>

<p>This LFB class process the IPv6 packet with extended header,For the moment,the packets to this LFB are redirect to RedirectSink LFB by default.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6.2"></a><h3>5.6.2.&nbsp;
MetadataClassifier</h3>

<p>This LFB class provides the function of classify packets according to the meta data.Now it only works on one meta data.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6.3"></a><h3>5.6.3.&nbsp;
OptionProc</h3>

<p>This LFB class process the IPv4 packet with options,it can process on the following options:Router-alert option.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6.4"></a><h3>5.6.4.&nbsp;
RedirectLFB</h3>

<p>An LFB Class definition for exchanging data packets between the FE and the CE.
</p>
<p>This LFB represents a point of exchagne of data packets between the CE and the FE. Packets with meta-data are exchanged.  It is expected that the output port of a RedirectLFB, if it is connected at all, will be connected to a meta-data redirector.
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6.5"></a><h3>5.6.5.&nbsp;
PacketTrimmer</h3>

<p>LFB removes data from the front of a packet.
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6.6"></a><h3>5.6.6.&nbsp;
Duplicator</h3>

<p>An LFB Class definition for packet duplicator LFB. Any packet received on an input port is logically copied and sent to all output ports.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6.7"></a><h3>5.6.7.&nbsp;
ArbitraryClassifierLFB</h3>

<p> This is a class definition for an Arbitrary Classifier LFB.  The
   input is a port group, and the match conditions can include the port
   in their test.  This allows the topology to carry some information if
   desired.  The match conditions can select an output from the
   SuccessOuput output port group.  If no condition matches, the packet
   will be sesnt to the FailOutput port.
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
LFB Library Definition</h3>

<p>
        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;LFBLibrary provides="Library" xmlns="urn:ietf:params:xml:ns:forces:
lfbmodel:1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="urn:ietf:params:xml:ns:forces:lfbmodel:1.0
SchemaFile.xsd"&gt;
  &lt;frameDefs&gt;
    &lt;frameDef&gt;
      &lt;name&gt;EthernetII&lt;/name&gt;
      &lt;synopsis&gt;an Ethernet II frame type&lt;/synopsis&gt;
    &lt;/frameDef&gt;
    &lt;frameDef&gt;
      &lt;name&gt;Ethernet802.3&lt;/name&gt;
      &lt;synopsis&gt;An Ethernet 802.3 frame type&lt;/synopsis&gt;
    &lt;/frameDef&gt;
    &lt;frameDef&gt;
      &lt;name&gt;Ethernet802.2&lt;/name&gt;
      &lt;synopsis&gt;An Ethernet 802.2 frame type&lt;/synopsis&gt;
    &lt;/frameDef&gt;
    &lt;frameDef&gt;
      &lt;name&gt;Ethernet802.2SNAP&lt;/name&gt;
      &lt;synopsis&gt;An Ethernet 802.2 with SNAP frame&lt;/synopsis&gt;
    &lt;/frameDef&gt;
    &lt;frameDef&gt;
      &lt;name&gt;IPv4Frame&lt;/name&gt;
      &lt;synopsis&gt;An IPv4 packet&lt;/synopsis&gt;
    &lt;/frameDef&gt;
    &lt;frameDef&gt;
      &lt;name&gt;IPv6Frame&lt;/name&gt;
      &lt;synopsis&gt;An IPv6 packet&lt;/synopsis&gt;
    &lt;/frameDef&gt;
    &lt;frameDef&gt;
      &lt;name&gt;taggedFrame&lt;/name&gt;
      &lt;synopsis&gt;A frame of any type with associated metadata&lt;/synopsis&gt;
    &lt;/frameDef&gt;
    &lt;frameDef&gt;
      &lt;name&gt;MetadataFrame&lt;/name&gt;
      &lt;synopsis&gt;Frame only contains meta data&lt;/synopsis&gt;
    &lt;/frameDef&gt;
    &lt;frameDef&gt;
      &lt;name&gt;Arbitrary&lt;/name&gt;
      &lt;synopsis&gt;Any kind of frame except Metadata Frame.&lt;/synopsis&gt;
    &lt;/frameDef&gt;
  &lt;/frameDefs&gt;
  &lt;dataTypeDefs&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;ifIndex&lt;/name&gt;
      &lt;synopsis&gt;A Port Identifier&lt;/synopsis&gt;
      &lt;typeRef&gt;uint32&lt;/typeRef&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IEEEMAC&lt;/name&gt;
      &lt;synopsis&gt;IEEE MAC Address&lt;/synopsis&gt;
      &lt;typeRef&gt;byte[6]&lt;/typeRef&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;NetSpeedType&lt;/name&gt;
      &lt;synopsis&gt;Network speed values&lt;/synopsis&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uint32&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="0x00000001"&gt;
            &lt;name&gt;LAN_SPEED_10M&lt;/name&gt;
            &lt;synopsis&gt;10M Ethernet&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000002"&gt;
            &lt;name&gt;LAN_SPEED_100M&lt;/name&gt;
            &lt;synopsis&gt;100M Ethernet&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000003"&gt;
            &lt;name&gt;LAN_SPEED_1G&lt;/name&gt;
            &lt;synopsis&gt;1000M Ethernet&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000004"&gt;
            &lt;name&gt;LAN_SPEED_10G&lt;/name&gt;
            &lt;synopsis&gt;10G Ethernet&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000005"&gt;
            &lt;name&gt;LAN_SPEED_AUTO&lt;/name&gt;
            &lt;synopsis&gt;LAN speed auto&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
        &lt;!-- XXX: This doesnt look like the SNMP
  definitions. We should look at the SNMP
  definitions for guidance; we should not have
  limitations that SNMP has such as being
  restricted to 32 bits"
  "refer to RFC 3635 ifSpeed and ifHighSpeed"
--&gt;
      &lt;/atomic&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IEEENegotiationType&lt;/name&gt;
      &lt;synopsis&gt;IEEENegotiation types&lt;/synopsis&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uint32&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="0x00000001"&gt;
            &lt;name&gt;Auto&lt;/name&gt;
            &lt;synopsis&gt;Auto negotitation.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000002"&gt;
            &lt;name&gt;Half-duplex&lt;/name&gt;
            &lt;synopsis&gt;port negotitation half duplex&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000003"&gt;
            &lt;name&gt;Full-duplex&lt;/name&gt;
            &lt;synopsis&gt;port negotitation full duplex&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
      &lt;!-- XXX: This is very IEEE specific --&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;PortStatsType&lt;/name&gt;
      &lt;synopsis&gt;Port statistics&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;InUcastPkts&lt;/name&gt;
          &lt;synopsis&gt;Number of unicast packets received&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;InMulticastPkts&lt;/name&gt;
          &lt;synopsis&gt;Number of multicast packets received&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;InBroadcastPkts&lt;/name&gt;
          &lt;synopsis&gt;Number of broadcast packets received&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;InOctets&lt;/name&gt;
          &lt;synopsis&gt;number of octets received&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="5"&gt;
          &lt;name&gt;OutUcastPkts&lt;/name&gt;
          &lt;synopsis&gt;Number of unicast packets transmitted&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="6"&gt;
          &lt;name&gt;OutMulticastPkts&lt;/name&gt;
          &lt;synopsis&gt;Number of multicast packets transmitted&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="7"&gt;
          &lt;name&gt;OutBroadcastPkts&lt;/name&gt;
          &lt;synopsis&gt;Number of broadcast packets transmitted&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="8"&gt;
          &lt;name&gt;OutOcetes&lt;/name&gt;
          &lt;synopsis&gt;Number of octets transmitted&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="9"&gt;
          &lt;name&gt;InErrorPkts&lt;/name&gt;
          &lt;synopsis&gt;Number of input error packets&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="10"&gt;
          &lt;name&gt;OutErrorPkts&lt;/name&gt;
          &lt;synopsis&gt;Number of output error packets&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
      &lt;!-- XXX: Make sure we validate with SNMP Port Stats --&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;PortStatusValues&lt;/name&gt;
      &lt;synopsis&gt;
              The possible values of status.  Used for both
              administrative and operation status
           &lt;/synopsis&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uchar&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="0"&gt;
            &lt;name&gt;Disabled &lt;/name&gt;
            &lt;synopsis&gt;the port is operatively disabled.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="1"&gt;
            &lt;name&gt;UP&lt;/name&gt;
            &lt;synopsis&gt;the port is up.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="2"&gt;
            &lt;name&gt;Down&lt;/name&gt;
            &lt;synopsis&gt;The port is down.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
&lt;!--XXX:Need to conform with Administrative and operational status--&gt;
      &lt;/atomic&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;LocalIpAddrType&lt;/name&gt;
      &lt;synopsis&gt;Local IP address belonging to FE.&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;FEID&lt;/name&gt;
          &lt;synopsis&gt;The FE on which the port ip resides&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
&lt;!-- XXX: FEID is know to the Object LFB. Do we need it here? --&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;IfIndex&lt;/name&gt;
          &lt;synopsis&gt;port index on the specified FE&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
&lt;!-- XXX: We need to support the model that says that a local IP has
multiple ports. Should this be an array of uint32 --&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;IPaddr&lt;/name&gt;
          &lt;synopsis&gt;IP address of the port&lt;/synopsis&gt;
          &lt;typeRef&gt;IPAddr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;netmask&lt;/name&gt;
          &lt;synopsis&gt;netmask of this ip address&lt;/synopsis&gt;
          &lt;typeRef&gt;IPAddr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="5"&gt;
          &lt;name&gt;BcastAddr&lt;/name&gt;
          &lt;synopsis&gt;The associated Broadcast address of the ip address
          &lt;/synopsis&gt;
          &lt;typeRef&gt;IPAddr&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;LocalIpv6AddrType&lt;/name&gt;
      &lt;synopsis&gt;The device local IPv6 address infomation&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;FEID&lt;/name&gt;
          &lt;synopsis&gt;The FE on which the port ip resides&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
&lt;!-- XXX: FEID is know to the Object LFB. Do we need it here? --&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;IfIndex&lt;/name&gt;
          &lt;synopsis&gt;port index on the specified FE&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
&lt;!-- XXX: We need to support the model that says that a local IP has
multiple ports. Should this be an array of uint32 --&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;IPv6addr&lt;/name&gt;
          &lt;synopsis&gt;IP address of the port&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;prefixlen&lt;/name&gt;
          &lt;synopsis&gt;prefix length of this ip address&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPv4Addr&lt;/name&gt;
      &lt;synopsis&gt;IPv4 address&lt;/synopsis&gt;
      &lt;typeRef&gt;byte[4]&lt;/typeRef&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPv6Addr&lt;/name&gt;
      &lt;synopsis&gt;IPv6 address&lt;/synopsis&gt;
      &lt;typeRef&gt;byte[16]&lt;/typeRef&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPv4Prefix&lt;/name&gt;
      &lt;synopsis&gt;IPv4 prefix defined by an address and a prefix length
      &lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;address&lt;/name&gt;
          &lt;synopsis&gt;Address part&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv4addr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;prefixlen&lt;/name&gt;
          &lt;synopsis&gt;Prefix length part&lt;/synopsis&gt;
          &lt;atomic&gt;
            &lt;baseType&gt;uchar&lt;/baseType&gt;
            &lt;rangeRestriction&gt;
              &lt;allowedRange min="0" max="32"/&gt;
            &lt;/rangeRestriction&gt;
          &lt;/atomic&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPv4NextHopInfoType &lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;IPv4 nexthop information,include nexthop ip address,
      output FE and interface etc.&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;NexthopID&lt;/name&gt;
          &lt;synopsis&gt;nexthop id&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;FEID&lt;/name&gt;
          &lt;synopsis&gt;output FE id&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;Egress&lt;/name&gt;
          &lt;synopsis&gt;output port index&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;MTU&lt;/name&gt;
          &lt;synopsis&gt;The maximum transmition unit of the nexthop link.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="5"&gt;
          &lt;name&gt; Flags &lt;/name&gt;
          &lt;synopsis&gt;Associated flags of the nexthop,such as local
          delivery,multicast etc.&lt;/synopsis&gt;
          &lt;typeRef&gt;NextHopFlagsType&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="6"&gt;
          &lt;name&gt; NexthopIPaddr &lt;/name&gt;
          &lt;synopsis&gt;IP address of the nexthop&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv4Addr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="7"&gt;
          &lt;name&gt; L2Index &lt;/name&gt;
          &lt;synopsis&gt;index into the L2 link layer table,such as IPv4 ARP
          table or IPv6 NBR table.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="8"&gt;
          &lt;name&gt; EncapNeeded &lt;/name&gt;
          &lt;synopsis&gt;The type of encapsulation needed on the packet.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;LinkEncapType&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPv4FibEntryType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;IPv4 forwarding table entry.&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;prefix&lt;/name&gt;
          &lt;synopsis&gt;IPv4 prefix.&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv4Prefix&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;FEID&lt;/name&gt;
          &lt;synopsis&gt;output FE id&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;Egress&lt;/name&gt;
          &lt;synopsis&gt;output port index&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;MTU&lt;/name&gt;
          &lt;synopsis&gt;The maximum transmition unit of the nexthop link.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="5"&gt;
          &lt;name&gt; Flags &lt;/name&gt;
          &lt;synopsis&gt;Associated flags of the nexthop,such as local
          delivery,multicast etc.&lt;/synopsis&gt;
          &lt;typeRef&gt;NextHopFlagsType&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="6"&gt;
          &lt;name&gt; NexthopIPaddr &lt;/name&gt;
          &lt;synopsis&gt;IP address of the nexthop&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv4Addr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="7"&gt;
          &lt;name&gt; L2Index &lt;/name&gt;
          &lt;synopsis&gt;index into the L2 link layer table,such as IPv4 ARP
          table or IPv6 NBR table.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="8"&gt;
          &lt;name&gt; EncapNeeded &lt;/name&gt;
          &lt;synopsis&gt;The type of encapsulation needed on the packet.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;LinkEncapType&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPv4PrefixTableEntry&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;IPv4 prefix table entry&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;Prefix&lt;/name&gt;
          &lt;synopsis&gt;IPv4 address prefix&lt;/synopsis&gt;
          &lt;typeRef&gt; IPv4Prefix &lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;NexthopID&lt;/name&gt;
          &lt;synopsis&gt;Index into the nexthop table.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPv4UcastLPMStatisticsType &lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;statistics of IPv4UcastLPM LFB&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;InRcvdPkts&lt;/name&gt;
          &lt;synopsis&gt;The total number of input packets received from
          interfaces, including those received in error&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;FwdPkts&lt;/name&gt;
          &lt;synopsis&gt;IPv4 packet forwarded by this LFB&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt; NoRoutePkts &lt;/name&gt;
          &lt;synopsis&gt;The number of IP datagrams discarded because no
          route could be found to transmit them to their destination.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;InDeliverPkts&lt;/name&gt;
          &lt;synopsis&gt;The total number of input datagrams successfully
          delivered to IP user-protocols (including ICMP).&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPv4ValidatorStatisticsType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;IPv4 validator LFB statistics type&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;badHeaderPkts&lt;/name&gt;
          &lt;synopsis&gt;The total number of input datagrams with bad ip
          header&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;badTotalLengthPkts&lt;/name&gt;
          &lt;synopsis&gt;The total number of input datagrams with bad length
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;badTTLPkts&lt;/name&gt;
          &lt;synopsis&gt;The total number of input datagrams with bad TTL
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;badChecksum&lt;/name&gt;
          &lt;synopsis&gt;The total number of input datagrams with bad
          checksum&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPv6Prefix&lt;/name&gt;
      &lt;synopsis&gt;IPv6 prefix&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;IPv6addr&lt;/name&gt;
          &lt;synopsis&gt;address part of the prefix&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;prefixlen&lt;/name&gt;
          &lt;synopsis&gt;length of the prefix&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPv6NextHopInfoType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;IPv6 nexthop information,include nexthop ip address,
      output FE and interface etc.&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;NexthopID&lt;/name&gt;
          &lt;synopsis&gt;nexthop id&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;FEID&lt;/name&gt;
          &lt;synopsis&gt;output FE id&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;Egress&lt;/name&gt;
          &lt;synopsis&gt;output port index&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;MTU&lt;/name&gt;
          &lt;synopsis&gt;The maximum transmition unit of the nexthop link.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="5"&gt;
          &lt;name&gt; Flags &lt;/name&gt;
          &lt;synopsis&gt;Associated flags of the nexthop,such as local
          delivery,multicast etc.&lt;/synopsis&gt;
          &lt;typeRef&gt;NextHopFlagsType&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="6"&gt;
          &lt;name&gt; NexthopIPv6addr &lt;/name&gt;
          &lt;synopsis&gt;IP address of the nexthop&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="7"&gt;
          &lt;name&gt; L2Index &lt;/name&gt;
          &lt;synopsis&gt;index into the L2 table&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="8"&gt;
          &lt;name&gt; EncapNeeded &lt;/name&gt;
          &lt;synopsis&gt;The type of encapsulation needed on the packet.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;LinkEncapType&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPv6PrefixTableEntry&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;IPv6 prefix table entry&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt; Prefix &lt;/name&gt;
          &lt;synopsis&gt;IPv6 address prefix&lt;/synopsis&gt;
          &lt;typeRef&gt; IPv6Prefix &lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt; NexthopID &lt;/name&gt;
          &lt;synopsis&gt;index to the nexthop table.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt; IPv6LPMClassiferStatisticsType &lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;statistics of IPv6LPMClassifier LFB&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt; InRcvdPkts &lt;/name&gt;
          &lt;synopsis&gt;The total number of input packets received from
          interfaces, including those received in error&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt; FwdPkts &lt;/name&gt;
          &lt;synopsis&gt;IPv4 packet forwarded by this LFB&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt; NoRoutePkts &lt;/name&gt;
          &lt;synopsis&gt;The number of IP datagrams discarded because no
          route could be found to transmit them to their destination.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;InDeliverPkts&lt;/name&gt;
          &lt;synopsis&gt;The total number of input datagrams successfully
          delivered to IP user-protocols (including ICMP).&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt; IPv6ValidatorStatisticsType &lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;IPv6 validator LFB statistics type&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt; badHeaderPkts &lt;/name&gt;
          &lt;synopsis&gt;The total number of input datagrams with bad ip
          header&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt; badTotalLengthPkts &lt;/name&gt;
          &lt;synopsis&gt;The total number of input datagrams with bad length
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt; badTTLPkts &lt;/name&gt;
          &lt;synopsis&gt;The total number of input datagrams with bad TTL
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt; badChecksum&lt;/name&gt;
          &lt;synopsis&gt;The total number of input datagrams with bad
          checksum&lt;/synopsis&gt;
          &lt;typeRef&gt;uint64&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt; NextHopFlagsType &lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;Flags used to define different nexthop behaviors
      &lt;/synopsis&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uint32&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="0x00000001"&gt;
            &lt;name&gt;local&lt;/name&gt;
            &lt;synopsis&gt;Packets match the nexthop entry with this flag
            are delivered to the higher level protocols.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000002"&gt;
            &lt;name&gt;drop&lt;/name&gt;
            &lt;synopsis&gt;Packets match the nexthop entry with this flag
            are to be dropped.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000004"&gt;
            &lt;name&gt;broadcast&lt;/name&gt;
            &lt;synopsis&gt;The route associated with this nexthop is a
            broadcast.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000008"&gt;
            &lt;name&gt;multicast&lt;/name&gt;
            &lt;synopsis&gt;The route associated with this nexthop is
            multicast.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;WeightTableEntryType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;Weight table for queues.&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;QueueID&lt;/name&gt;
          &lt;synopsis&gt;queue id&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;weight&lt;/name&gt;
          &lt;synopsis&gt;weight of the queue.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;NbrState&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;IPv6 neighbour entry resolution state.&lt;/synopsis&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uchar&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="0x01"&gt;
            &lt;name&gt;INCOMPLETE &lt;/name&gt;
            &lt;synopsis&gt;Address resolution is being performed on entry.
            Specifically,a Neighbor Solicitation has been sent to the
            solicited-node multicast address of the target, but the
            corresponding Neighbor Advertisement has not yet been
            received.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x02"&gt;
            &lt;name&gt;REACHABLE&lt;/name&gt;
            &lt;synopsis&gt;Positive confirmation was received within the
            last reachableTime milliseconds that the forward path to
            the neighbor was functioning properly. While reachable, no
            special action takes place as packets are sent.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x03"&gt;
            &lt;name&gt;STALE&lt;/name&gt;
            &lt;synopsis&gt;More than ReachableTime milliseconds have elapsed
            since the last positive confirmation was received that the
            forward path was functioning properly. While STALE, no
            action takes place until a packet is sent. The STALE state
            is entered upon receiving an unsolicited Neighbor Discovery
            message that updates the cached link-layer address. Receipt
            of such a message does not confirm reachability, and
            entering the STALE state insures reachability is verified
            quickly if the entry is actually being used. However,
            reachability is not actually verified until the entry is
            actually used.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x04"&gt;
            &lt;name&gt;DELAY&lt;/name&gt;
            &lt;synopsis&gt;More than ReachableTime milliseconds have elapsed
            since the last positive confirmation was received that the
            forward path was functioning properly, and a packet was
            sent within the last DELAY_FIRST_PROBE_TIME seconds. If no
            reachability confirmation is received within
            DELAY_FIRST_PROBE_TIME seconds of entering the DELAY state,
            send a Neighbor Solicitation and change the state to PROBE.
            &lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x05"&gt;
            &lt;name&gt;PROBE&lt;/name&gt;
            &lt;synopsis&gt;A reachability confirmation is actively sought by
            retransmitting Neighbor Solicitations every RetransTimer
            milliseconds until a reachability confirmation is received.
            &lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;ArpTableEntryType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;Arp entry.&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;Index&lt;/name&gt;
          &lt;synopsis&gt;Index of the arp table.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;NeighborIP&lt;/name&gt;
          &lt;synopsis&gt;IP address of the neighbour.&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv4Addr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;SrcMac&lt;/name&gt;
          &lt;synopsis&gt;Source MAC.&lt;/synopsis&gt;
          &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;NeighborMac&lt;/name&gt;
          &lt;synopsis&gt;Mac of the Neighbor.&lt;/synopsis&gt;
          &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="5"&gt;
          &lt;name&gt;State&lt;/name&gt;
          &lt;synopsis&gt;State of the address resolution progress&lt;/synopsis&gt;
          &lt;typeRef&gt;ArpStateType&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;NbrTableEntryType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;IPv6 neighbour table entry.&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;Index&lt;/name&gt;
          &lt;synopsis&gt;Index of the arp table.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;NeighborIPv6&lt;/name&gt;
          &lt;synopsis&gt;IP address of the neighbour.&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;SrcMac&lt;/name&gt;
          &lt;synopsis&gt;Source MAC.&lt;/synopsis&gt;
          &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;NeighborMac&lt;/name&gt;
          &lt;synopsis&gt;Mac of the Neighbor.&lt;/synopsis&gt;
          &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="5"&gt;
          &lt;name&gt;State&lt;/name&gt;
          &lt;synopsis&gt;State of the entry's resolution progress&lt;/synopsis&gt;
          &lt;typeRef&gt;NbrState&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;DCHostTableEntryTypev4&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;Direct connected arp table entry for IPv4. &lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;NeighbourIP&lt;/name&gt;
          &lt;synopsis&gt;IP address of the neighbour.&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv4Addr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;SrcMac&lt;/name&gt;
          &lt;synopsis&gt;Source MAC.&lt;/synopsis&gt;
          &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;NeighborMac&lt;/name&gt;
          &lt;synopsis&gt;Mac of the Neighbor.&lt;/synopsis&gt;
          &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;DCHostTableEntryTypev6&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;Direct connected arp table entry for IPv6. &lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;NeighbourIPv6&lt;/name&gt;
          &lt;synopsis&gt;IP address of the neighbour.&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;SrcMac&lt;/name&gt;
          &lt;synopsis&gt;Source MAC.&lt;/synopsis&gt;
          &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;NeighborMac&lt;/name&gt;
          &lt;synopsis&gt;Mac of the Neighbor.&lt;/synopsis&gt;
          &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPPacketType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;The packet type code.&lt;/synopsis&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uchar&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="1"&gt;
            &lt;name&gt;IPv4Ucast&lt;/name&gt;
            &lt;synopsis&gt;IPv4 unicast packet.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="2"&gt;
            &lt;name&gt;IPv4Mcast&lt;/name&gt;
            &lt;synopsis&gt;IPv4 multicast packet.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="3"&gt;
            &lt;name&gt;IPv6Ucast&lt;/name&gt;
            &lt;synopsis&gt;IPv6 unicast packet.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="4"&gt;
            &lt;name&gt;IPv6Mcast&lt;/name&gt;
            &lt;synopsis&gt;IPv6 multicast packet.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPDispatchTableType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;The dispatch table type.&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;IPPacketType&lt;/name&gt;
          &lt;synopsis&gt;The type of the packet.IPv4Uncast,IPv6Ucast,
          IPv4Mulcast,IPv6Mulcast etc.&lt;/synopsis&gt;
          &lt;typeRef&gt;IPPacketType&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;index&lt;/name&gt;
          &lt;synopsis&gt;The index of the output group to output the packets
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;MetaType&lt;/name&gt;
      &lt;synopsis&gt;Metadata type definition.&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;MetadataID&lt;/name&gt;
          &lt;synopsis&gt;The ID of the metadata,the value is standardalized
          in the corresponding LFB definition RFCs.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;MetadataName&lt;/name&gt;
          &lt;synopsis&gt;The name of the metadata.&lt;/synopsis&gt;
          &lt;typeRef&gt;String&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;MetadataClassTableType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;The meta data classifying table.&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;value&lt;/name&gt;
          &lt;synopsis&gt;Value of the meta data.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;index&lt;/name&gt;
          &lt;synopsis&gt;The index of the port in the output group to use
          for outputing the packets.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;LinkEncapType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;Encapsulation type.&lt;/synopsis&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uchar&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="1"&gt;
            &lt;name&gt;Link&lt;/name&gt;
            &lt;synopsis&gt;Link layer encapsulation such as Ethernet and
            PPP.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="2"&gt;
            &lt;name&gt;InterFE&lt;/name&gt;
            &lt;synopsis&gt;Inter FE communication encapsulation.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="3"&gt;
            &lt;name&gt;Tunnel&lt;/name&gt;
            &lt;synopsis&gt;Tunnel encapsulation such as IP-in-IP.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;IPAddress&lt;/name&gt;
      &lt;!-- XXX: Do we need a union of IPAddressess?--&gt;
      &lt;synopsis&gt;IP layer address.&lt;/synopsis&gt;
      &lt;union&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;Ipv4&lt;/name&gt;
          &lt;synopsis&gt;IPv4 address.&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv4Addr&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;Ipv6&lt;/name&gt;
          &lt;synopsis&gt;IPv6 address.&lt;/synopsis&gt;
          &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/union&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;ArpStateType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;The arp entry state.&lt;/synopsis&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uchar&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="1"&gt;
            &lt;name&gt;Manual&lt;/name&gt;
            &lt;synopsis&gt;The entry is manually set.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="2"&gt;
            &lt;name&gt;InSolicit&lt;/name&gt;
            &lt;synopsis&gt;The peer's level 2 address is still in requesting
            &lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="4"&gt;
            &lt;name&gt;Valid&lt;/name&gt;
            &lt;synopsis&gt;The address resolution have been completed
            successfully,it now can be used in the data packets
            forwarding.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;MatchTargetType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;
         Indicator for the kind of field to be matched by this
         entry in a classifier.
       &lt;/synopsis&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uchar&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="0"&gt;
            &lt;name&gt;MatchNone&lt;/name&gt;
            &lt;synopsis&gt;A matcher against no field&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="1"&gt;
            &lt;name&gt;MatchMetaData&lt;/name&gt;
            &lt;synopsis&gt;A matcher against a metadata item&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="2"&gt;
            &lt;name&gt;MatchPacketField&lt;/name&gt;
            &lt;synopsis&gt; A matcher that works against an identified
            packet field.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="3"&gt;
            &lt;name&gt;MatchOffsetLength&lt;/name&gt;
            &lt;synopsis&gt;The match target is a specified portion of the
            packet.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;MatchTargetIdentifier&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;
         Identify the specific target of a match condition.
       &lt;/synopsis&gt;
      &lt;union&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;MetaDataID&lt;/name&gt;
          &lt;synopsis&gt;The ID of a metadata item&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;packetFieldID&lt;/name&gt;
          &lt;synopsis&gt;The identifier for a packet Field, such as SA, DA,
          Protocol, SPort, DPort, etc.  These identifiers allow
          references to fields with varialbe amounts before them.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;OffSetLengthPacketField&lt;/name&gt;
          &lt;synopsis&gt;A field in the packet identified by its offset and
          length in bits.  This does not allow for matching fields
          whose position depends upon earlier field sizes.&lt;/synopsis&gt;
          &lt;struct&gt;
            &lt;component componentID="1"&gt;
              &lt;name&gt;fieldOffset&lt;/name&gt;
              &lt;synopsis&gt;The offset in bits from the start of the packet
               to the start of the field.&lt;/synopsis&gt;
              &lt;typeRef&gt;uint32&lt;/typeRef&gt;
            &lt;/component&gt;
            &lt;component componentID="2"&gt;
              &lt;name&gt;fieldLength&lt;/name&gt;
              &lt;synopsis&gt;The length of the field, in bits&lt;/synopsis&gt;
              &lt;typeRef&gt;uint32&lt;/typeRef&gt;
            &lt;/component&gt;
          &lt;/struct&gt;
        &lt;/component&gt;
      &lt;/union&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;MatchBitString&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;A bit string for use in a match condition.&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;MatchBits&lt;/name&gt;
          &lt;synopsis&gt;The bits to match&lt;/synopsis&gt;
          &lt;typeRef&gt;octetstring[16]&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;MatchLength&lt;/name&gt;
          &lt;synopsis&gt;The number of bits to match&lt;/synopsis&gt;
          &lt;typeRef&gt;uchar&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;MatchCondition&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;
         structure for a single condition to be applied.
       &lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;TargetType&lt;/name&gt;
          &lt;synopsis&gt;The category of target to match&lt;/synopsis&gt;
          &lt;typeRef&gt;MatchTargetType&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;TargetID&lt;/name&gt;
          &lt;synopsis&gt;The specific target to compare&lt;/synopsis&gt;
          &lt;typeRef&gt;MatchTargetIdentifier&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;MatchType&lt;/name&gt;
          &lt;synopsis&gt;The kind of match to apply.&lt;/synopsis&gt;
          &lt;typeRef&gt;MatchConditionType&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;MatchParamOne&lt;/name&gt;
          &lt;synopsis&gt;The first parameter for the match&lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;typeRef&gt;MatchBitString&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="5"&gt;
          &lt;name&gt;MatchParamTwo&lt;/name&gt;
          &lt;synopsis&gt;The second parameter for the match&lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;typeRef&gt;MatchBitString&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;MatchConditiontType&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;
         Indicator for the kind of match condition to be applied.
       &lt;/synopsis&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uchar&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="0"&gt;
            &lt;name&gt;MatchNone&lt;/name&gt;
            &lt;synopsis&gt;A matcher which always fails&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="1"&gt;
            &lt;name&gt;MatchExact&lt;/name&gt;
            &lt;synopsis&gt; The target and the match value must be the same,
             with no padding.Only the first value of the match condition
             is used. The first match value must be occur.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="2"&gt;
            &lt;name&gt;MatchLeft&lt;/name&gt;
            &lt;synopsis&gt;The target must begin with the first match value.
            If there is a second match value, the remainder of the
            target must match repeated occurrances of the second value.
            Thus, this can be used to allow any terminal content, or
            specific ending pad. The first match value must occur.
            &lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="3"&gt;
            &lt;name&gt;MatchRight&lt;/name&gt;
            &lt;synopsis&gt; The target must end with the first match value.
            If there is a second match value, the preceding part of the
            target must match repeated occurrances of the second value.
            Thus, this can be used to allow any leading content, or
            specific leading fill. The first match value must occur.
            &lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="4"&gt;
            &lt;name&gt;MatchRange&lt;/name&gt;
            &lt;synopsis&gt; The match values will be considered as numbers,
            and the target must be greater than or equal to the first
            match value, and less than or equal to the second match
            value. An omitted match value means that end of the range
            is unlimitted.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="5"&gt;
            &lt;name&gt;MatchMaskedValue&lt;/name&gt;
            &lt;synopsis&gt; The target the the first value are each anded
            with the second value. The match succeeds if the results of
            these and operations are identical. Both values are
            required.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="6"&gt;
            &lt;name&gt;MatchSucceed&lt;/name&gt;
            &lt;synopsis&gt;A Match which always succeeds&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;MatchMetaDataAction&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;An action to set a metadata item to either a specific
      value or a field from the incoming meta data or packet&lt;/synopsis&gt;
      &lt;struct&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;MetaDataToSet&lt;/name&gt;
          &lt;synopsis&gt;The Meta Data Item to set&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;ExplicitValueToSet&lt;/name&gt;
          &lt;synopsis&gt;A value to set the metadata to&lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;typeRef&gt;octetstring[16]&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;ValueFromCondition&lt;/name&gt;
          &lt;synopsis&gt; This is an index into the corresponding match
          conditions, and the meta data will be set to the value that
          was tested by that condition. &lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/struct&gt;
    &lt;/dataTypeDef&gt;
    &lt;dataTypeDef&gt;
      &lt;name&gt;NextHopIndex&lt;/name&gt;
      &lt;synopsis&gt;An index used by the next hop table.Typically stored in
      and generated as metadata by the longest-prefix-match LFB
      &lt;/synopsis&gt;
      &lt;typeRef&gt;int32&lt;/typeRef&gt;
    &lt;/dataTypeDef&gt;
  &lt;/dataTypeDefs&gt;
  &lt;metadataDefs&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;NextHopID&lt;/name&gt;
      &lt;synopsis&gt;Index into a Next Hop entry in Nexthop table&lt;/synopsis&gt;
      &lt;metadataID&gt;1&lt;/metadataID&gt;
      &lt;typeRef&gt;NextHopIndex&lt;/typeRef&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;ExceptionID&lt;/name&gt;
&lt;!-- XXX: Needs more discussion. See that it applies to all LFBs. --&gt;
      &lt;synopsis&gt;Exception Types&lt;/synopsis&gt;
      &lt;metadataID&gt;2&lt;/metadataID&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uint32&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="0x00000001"&gt;
            &lt;name&gt;Options&lt;/name&gt;
            &lt;synopsis&gt;Packets with options,for IPv6 Packet with
            next-header set to hop-by-hop header(0).&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000002"&gt;
            &lt;name&gt;LengthMismatch&lt;/name&gt;
            &lt;synopsis&gt;The packet length reported by link layer is less
            than the total length field.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000003"&gt;
            &lt;name&gt; BadTTL &lt;/name&gt;
            &lt;synopsis&gt;The packet can't be forwarded as the TTL has
            expired.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000004"&gt;
            &lt;name&gt; Multicast &lt;/name&gt;
            &lt;synopsis&gt;The packet received is a multicast packet.
            &lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000005"&gt;
            &lt;name&gt;FragRequired&lt;/name&gt;
            &lt;synopsis&gt;The MTU for outgoing interface is less than the
            packet size.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000006"&gt;
            &lt;name&gt;Redirect&lt;/name&gt;
            &lt;synopsis&gt;The outgoing port is same as the one on which the
            packet is received.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000007"&gt;
            &lt;name&gt;LocalDelivery&lt;/name&gt;
            &lt;synopsis&gt;The packet is for a local interface.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00000008"&gt;
            &lt;name&gt;LimitedBroadcast&lt;/name&gt;
            &lt;synopsis&gt;Packet received as limited broadcast.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;IngressPort&lt;/name&gt;
      &lt;synopsis&gt;At which interface the packet arrive.&lt;/synopsis&gt;
      &lt;metadataID&gt;3&lt;/metadataID&gt;
      &lt;typeRef&gt;ifIndex&lt;/typeRef&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;EgressPort&lt;/name&gt;
      &lt;synopsis&gt;Interface out which the packet will emmit.&lt;/synopsis&gt;
      &lt;metadataID&gt;4&lt;/metadataID&gt;
      &lt;typeRef&gt;ifIndex&lt;/typeRef&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;NextHopIP&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion if this is metadata--&gt;
      &lt;synopsis&gt;Nexthop IPv4 address&lt;/synopsis&gt;
      &lt;metadataID&gt;5&lt;/metadataID&gt;
      &lt;typeRef&gt;IP4Addr &lt;/typeRef&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;NexthopIPv6&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion if this is metadata--&gt;
      &lt;synopsis&gt;Nexthop IPv6 address&lt;/synopsis&gt;
      &lt;metadataID&gt;6&lt;/metadataID&gt;
      &lt;typeRef&gt;IPv6Addr&lt;/typeRef&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;PacketLength&lt;/name&gt;
      &lt;synopsis&gt;The length of the packet in octets.&lt;/synopsis&gt;
      &lt;metadataID&gt;7&lt;/metadataID&gt;
      &lt;typeRef&gt;uint32&lt;/typeRef&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;IPPacketType &lt;/name&gt;
      &lt;!--XXX: Needs more discussion. Should match frameDefs.--&gt;
      &lt;synopsis&gt;Type of the packet&lt;/synopsis&gt;
      &lt;metadataID&gt;8&lt;/metadataID&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uint32&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="0x8000"&gt;
            &lt;name&gt; IPv4 &lt;/name&gt;
            &lt;synopsis&gt;IPv4 packet&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x86DD"&gt;
            &lt;name&gt; IPv6 &lt;/name&gt;
            &lt;synopsis&gt;IPv6 packet&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="3"&gt;
            &lt;name&gt; TaggedFrame &lt;/name&gt;
            &lt;synopsis&gt;packet with metadata&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="4"&gt;
            &lt;name&gt; MetaDataFrame &lt;/name&gt;
            &lt;synopsis&gt;meta data only&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;QueueID &lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;The queue ID&lt;/synopsis&gt;
      &lt;metadataID&gt;9&lt;/metadataID&gt;
      &lt;typeRef&gt; uint32&lt;/typeRef&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;QueueOperationCmd&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;The type of operation on the queue,there are two types
      defined here: enqueue and dequeue.&lt;/synopsis&gt;
      &lt;metadataID&gt;10&lt;/metadataID&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;uchar&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="1"&gt;
            &lt;name&gt;Enqueue&lt;/name&gt;
            &lt;synopsis&gt;Enqueue command.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="2"&gt;
            &lt;name&gt;Dequeue&lt;/name&gt;
            &lt;synopsis&gt;Dequeue command.&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;SrcFEID&lt;/name&gt;
      &lt;synopsis&gt;Source FE ID.&lt;/synopsis&gt;
      &lt;metadataID&gt;11&lt;/metadataID&gt;
      &lt;typeRef&gt;uint32&lt;/typeRef&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;DstFEID&lt;/name&gt;
      &lt;synopsis&gt;Destination FE ID.&lt;/synopsis&gt;
      &lt;metadataID&gt;12&lt;/metadataID&gt;
      &lt;typeRef&gt;uint32&lt;/typeRef&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;NexthopIndex&lt;/name&gt;
      &lt;!-- XXX: This should be removed --&gt;
      &lt;synopsis&gt;Nexthop index into the link layer address resolution
      table.&lt;/synopsis&gt;
      &lt;metadataID&gt;13&lt;/metadataID&gt;
      &lt;typeRef&gt;uint&lt;/typeRef&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;NHEncapMethod&lt;/name&gt;
      &lt;!--XXX: Is there any value in this?--&gt;
      &lt;synopsis&gt;how should the following LFBs do to encapsulate the
      packets,such as link encapsulation which means the packets need
      to encapsulate link layer header before sending to media;inter FE
      communication encapsulation which means the packets need to first
      encapsulate inter FE communication header before transimiting to
      other FEs;tunnel encapsulation which means the packet need do
      extra tunnel encapsulation before sending out to media&lt;/synopsis&gt;
      &lt;metadataID&gt;14&lt;/metadataID&gt;
      &lt;typeRef&gt;LinkEncapType&lt;/typeRef&gt;
    &lt;/metadataDef&gt;
    &lt;metadataDef&gt;
      &lt;name&gt;ErrorId&lt;/name&gt;
      &lt;!-- XXX: Needs more discussion --&gt;
      &lt;synopsis&gt;Error Type.&lt;/synopsis&gt;
      &lt;metadataID&gt;15&lt;/metadataID&gt;
      &lt;atomic&gt;
        &lt;baseType&gt;int32&lt;/baseType&gt;
        &lt;specialValues&gt;
          &lt;specialValue value="0x00030001"&gt;
            &lt;name&gt;WrongIpVersion&lt;/name&gt;
            &lt;synopsis&gt;the IP version wrong&lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x00030002"&gt;
            &lt;name&gt;WrongLength&lt;/name&gt;
            &lt;synopsis&gt;
                 the packet length is not as long as
                 the header indicates
               &lt;/synopsis&gt;
          &lt;/specialValue&gt;
          &lt;specialValue value="0x000300FF"&gt;
            &lt;name&gt;otherError&lt;/name&gt;
            &lt;synopsis&gt;The errors we not defined now&lt;/synopsis&gt;
          &lt;/specialValue&gt;
        &lt;/specialValues&gt;
      &lt;/atomic&gt;
    &lt;/metadataDef&gt;
  &lt;/metadataDefs&gt;
  &lt;LFBClassDefs&gt;
    &lt;LFBClassDef LFBClassID="3"&gt;
      &lt;name&gt;EtherPort&lt;/name&gt;
      &lt;!--XXX:Should this be one LFB merged with the other Ether LFBs--&gt;
      &lt;synopsis&gt;LFB for Ethernet ports&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;derivedFrom&gt;GenericConnectivityLFB&lt;/derivedFrom&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PacketsFromProcessingUnit&lt;/name&gt;
          &lt;synopsis&gt;Ports for receiving packets from processing unit
          such as NP,that will be sent to media.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;EthernetII&lt;/ref&gt;
            &lt;/frameExpected&gt;
            &lt;metadataExpected&gt;
              &lt;ref&gt;OutputPort&lt;/ref&gt;
            &lt;/metadataExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PacketsFromMedia&lt;/name&gt;
          &lt;synopsis&gt;Ports for receiving packets from ethernet media.
          &lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;EthernetII&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;PacketsToProcessingUnit&lt;/name&gt;
          &lt;synopsis&gt;Ports for sending packets to processing unit such
          as NP for further processing.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;EthernetII&lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref&gt;InputPort&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;PacketsToMedia&lt;/name&gt;
          &lt;synopsis&gt;Ports for sending packets to media.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;EthernetII&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;IfIndex&lt;/name&gt;
          &lt;synopsis&gt;A unique value for each interface. Its value ranges
          between 1 and the value of total number of interfaces in the
          system. The value for each interface must remain constant at
          least from one re-initialization of the entity's network
          management system to the next re-initialization.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;IfName&lt;/name&gt;
          &lt;synopsis&gt;Name of this port&lt;/synopsis&gt;
          &lt;typeRef&gt;string[16]&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;LinkSpeed&lt;/name&gt;
          &lt;synopsis&gt;Speed of this port&lt;/synopsis&gt;
          &lt;typeRef&gt;NetSpeedType&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;MTU&lt;/name&gt;
          &lt;synopsis&gt;Maximum transmition unit&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="5" access="read-only"&gt;
          &lt;name&gt;OperaStatus&lt;/name&gt;
          &lt;synopsis&gt;Operate state of this port.&lt;/synopsis&gt;
          &lt;typeRef&gt;PortStatusValues&lt;/typeRef&gt;
          &lt;defaultValue&gt;"down"&lt;/defaultValue&gt;
        &lt;/component&gt;
        &lt;component componentID="6"&gt;
          &lt;name&gt;AdminStatus&lt;/name&gt;
          &lt;synopsis&gt;Administrator's state of this port&lt;/synopsis&gt;
          &lt;typeRef&gt;PortStatusValues&lt;/typeRef&gt;
          &lt;defaultValue&gt;"down"&lt;/defaultValue&gt;
        &lt;/component&gt;
        &lt;component componentID="7"&gt;
          &lt;name&gt;PromiscuousMode&lt;/name&gt;
          &lt;synopsis&gt;Whether the interface is in promiscuous mode
          &lt;/synopsis&gt;
          &lt;typeRef&gt;booleanType&lt;/typeRef&gt;
          &lt;defaultValue&gt;"no"&lt;/defaultValue&gt;
        &lt;/component&gt;
        &lt;component componentID="8" access="read-only"&gt;
          &lt;name&gt;CarrierStatus&lt;/name&gt;
          &lt;synopsis&gt;whether the port is linked with an connector.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;booleanType&lt;/typeRef&gt;
          &lt;defaultValue&gt;"no"&lt;/defaultValue&gt;
        &lt;/component&gt;
        &lt;component componentID="9"&gt;
          &lt;name&gt;OperMode&lt;/name&gt;
          &lt;synopsis&gt;The port operation mode,must be one of the
          following values:Auto,Half-duplex,Full-duplex&lt;/synopsis&gt;
          &lt;typeRef&gt;IEEENegotiationType&lt;/typeRef&gt;
          &lt;defaultValue&gt;"auto"&lt;/defaultValue&gt;
        &lt;/component&gt;
        &lt;component componentID="10"&gt;
          &lt;name&gt;SrcNegotiationTypeMACAddr&lt;/name&gt;
          &lt;synopsis&gt;source MAC&lt;/synopsis&gt;
          &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="11"&gt;
          &lt;name&gt;MacAliasTable&lt;/name&gt;
          &lt;synopsis&gt;A series of MACs that the port can receive frame
          on.&lt;/synopsis&gt;
          &lt;array&gt;
            &lt;typeRef&gt;IEEEMAC&lt;/typeRef&gt;
          &lt;/array&gt;
        &lt;/component&gt;
        &lt;component componentID="12"&gt;
          &lt;name&gt;StatsEnable&lt;/name&gt;
          &lt;synopsis&gt;whether enable the statistics in this LFB.
          &lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;typeRef&gt;booleanType&lt;/typeRef&gt;
          &lt;defaultValue&gt;"no"&lt;/defaultValue&gt;
        &lt;/component&gt;
        &lt;component componentID="13" access="read-reset"&gt;
          &lt;name&gt;PortStats&lt;/name&gt;
          &lt;synopsis&gt;port statistics.&lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;typeRef&gt;PortStatsType&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="14"&gt;
          &lt;name&gt;Ipaddr&lt;/name&gt;
          &lt;synopsis&gt;IP layer Address.&lt;/synopsis&gt;
          &lt;typeRef&gt;IPAddress&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/components&gt;
      &lt;events baseID="100"&gt;
        &lt;event eventID="1"&gt;
          &lt;name&gt;PortStatusChanged&lt;/name&gt;
          &lt;synopsis&gt;Port status has changed since last time reporting.
          &lt;/synopsis&gt;
          &lt;eventTarget&gt;
            &lt;eventField&gt;OperaStatus&lt;/eventField&gt;
          &lt;/eventTarget&gt;
          &lt;eventChanged/&gt;
          &lt;eventReports&gt;
            &lt;eventReport&gt;
              &lt;eventField&gt;OperaStatus&lt;/eventField&gt;
            &lt;/eventReport&gt;
          &lt;/eventReports&gt;
        &lt;/event&gt;
      &lt;/events&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="4"&gt;
      &lt;name&gt;EtherDecap&lt;/name&gt;
      &lt;!--XXX:Should this be merged with the EtherPort?--&gt;
      &lt;synopsis&gt;An LFB class for definition of Ethernet decapsulation
      and Ethernet filtering functions&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;derivedFrom&gt;GenericConnectivityLFB&lt;/derivedFrom&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PacketsIn&lt;/name&gt;
          &lt;synopsis&gt;Packets from other LFB.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;EthernetII&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort group="true"&gt;
          &lt;name&gt;DecapOut&lt;/name&gt;
          &lt;synopsis&gt;Ethernet decapsulation output.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;Arbitrary&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;DispatchTable&lt;/name&gt;
          &lt;synopsis&gt;This table is used for selecting output in the
          ouput group for the incoming packet stream.&lt;/synopsis&gt;
          &lt;typeRef&gt;IPDispatchTableType&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/components&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="6"&gt;
      &lt;name&gt;IPv4UcastLPM&lt;/name&gt;
      &lt;synopsis&gt;IPv4 Longest Prefix Match Lookup LFB&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PktIn&lt;/name&gt;
          &lt;synopsis&gt;The port to receive IPv4 packets from other LFBs
          &lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;SuccessOut&lt;/name&gt;
          &lt;synopsis&gt;Successful output when all is fine.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref availability="conditional"&gt;NextHopID&lt;/ref&gt;
              &lt;ref availability="conditional"&gt;FEID&lt;/ref&gt;
              &lt;ref availability="conditional"&gt;Egress&lt;/ref&gt;
              &lt;ref availability="conditional"&gt;MTU&lt;/ref&gt;
              &lt;ref availability="conditional"&gt;Flags&lt;/ref&gt;
              &lt;ref availability="conditional"&gt;NexthopIPAddr&lt;/ref&gt;
              &lt;ref availability="conditional"&gt;NHEncapMethod&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;ExceptionOut&lt;/name&gt;
          &lt;synopsis&gt;Exception output&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref&gt;Ingress &lt;/ref&gt;
              &lt;ref&gt;ExceptionID&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;FailOutput&lt;/name&gt;
          &lt;synopsis&gt;Dropper&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt; IPv4 &lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt; PrefixTable &lt;/name&gt;
          &lt;synopsis&gt;IPv4 prefix table&lt;/synopsis&gt;
          &lt;array type="variable-size"&gt;
            &lt;typeRef&gt; IPv4PrefixTableEntry &lt;/typeRef&gt;
            &lt;contentKey contentKeyID="1"&gt;
              &lt;contentKeyField&gt;IPv4PrefixTableEntry.prefix
              &lt;/contentKeyField&gt;
            &lt;/contentKey&gt;
          &lt;/array&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;Fib&lt;/name&gt;
          &lt;synopsis&gt;IPv4 unicast forwarding table.&lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;array type="variable-size"&gt;
            &lt;typeRef&gt;IPv4FibEntryType&lt;/typeRef&gt;
            &lt;contentKey contentKeyID="1"&gt;
              &lt;contentKeyField&gt;IPv4FibEntryType.prefix
              &lt;/contentKeyField&gt;
            &lt;/contentKey&gt;
          &lt;/array&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;LocalIpAddrTable&lt;/name&gt;
          &lt;synopsis&gt;The table of interfaces's ip address infomation on
          the local device&lt;/synopsis&gt;
          &lt;typeRef&gt;LocalIpAddrType&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;IPv4Stats&lt;/name&gt;
          &lt;synopsis&gt;The IPv4 associated statistics&lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;typeRef&gt; IPv4UcastLPMStatisticsType &lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/components&gt;
      &lt;capabilities&gt;
        &lt;capability componentID="1"&gt;
          &lt;name&gt;PrefixTableLimit&lt;/name&gt;
          &lt;synopsis&gt;maxium number of prefix supported by this LFB
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
        &lt;capability componentID="2"&gt;
          &lt;name&gt;LocalIpAddrTableLimit&lt;/name&gt;
          &lt;synopsis&gt;maxium number of IP address entrys supported by
          this LFB&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
      &lt;/capabilities&gt;
      &lt;description&gt;This LFB represents the IPv4 longest prefix match
      lookup operation.&lt;/description&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="7"&gt;
      &lt;name&gt; IPv4NextHopApplicator &lt;/name&gt;
      &lt;synopsis&gt;An LFB definition for applicating next hop action to
      IPv4 packets,the actions include:TTL operation,checksum
      recalculation.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PktIn&lt;/name&gt;
          &lt;synopsis&gt;Port used to receive IPv4 packets from other LFBs
          &lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt; IPv4 &lt;/ref&gt;
            &lt;/frameExpected&gt;
            &lt;metadataExpected&gt;
              &lt;ref dependency="optional" defaultValue="0xff"&gt;NextHopID
              &lt;/ref&gt;
              &lt;ref dependency="optional" defaultValue="0xff"&gt;FEID&lt;/ref&gt;
              &lt;ref dependency="optional" defaultValue="0xff"&gt;Egress
              &lt;/ref&gt;
              &lt;ref dependency="optional" defaultValue="0xff"&gt;MTU&lt;/ref&gt;
              &lt;ref dependency="optional" defaultValue="0xff"&gt;Flags
              &lt;/ref&gt;
              &lt;ref dependency="optional" defaultValue="0xff"&gt;
              NexthopIPAddr&lt;/ref&gt;
              &lt;ref dependency="optional" defaultValue="0xff"&gt;
              NHEncapMethod&lt;/ref&gt;
            &lt;/metadataExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;SuccessOut&lt;/name&gt;
          &lt;synopsis&gt;Output port for packet successfully fulfill the
          nexthop application.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt; IPv4 &lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref&gt;DstFEID&lt;/ref&gt;
              &lt;ref&gt;Egress&lt;/ref&gt;
              &lt;ref availability="conditional"&gt;L2Index&lt;/ref&gt;
              &lt;ref&gt;NextHopIP&lt;/ref&gt;
              &lt;ref availability="conditional"&gt;NHEncapMethod&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;ExceptionOut&lt;/name&gt;
          &lt;synopsis&gt;Output for packets need deep dealt by higher level
          protocol stacks.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt; IPv4 &lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref&gt;Ingress&lt;/ref&gt;
              &lt;ref&gt;ExceptionID&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;FailOutput&lt;/name&gt;
          &lt;synopsis&gt;Output for packets failed the nexthop application
          operation.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt; IPv4 &lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt; NextHopTable &lt;/name&gt;
          &lt;synopsis&gt;Nexthop table&lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;array type="variable-size"&gt;
            &lt;typeRef&gt; IPv4NextHopInfoType &lt;/typeRef&gt;
          &lt;/array&gt;
        &lt;/component&gt;
      &lt;/components&gt;
      &lt;capabilities&gt;
        &lt;capability componentID="2"&gt;
          &lt;name&gt;NextHopTableLimit&lt;/name&gt;
          &lt;synopsis&gt;Maxium number of nexthops this LFB supports
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
      &lt;/capabilities&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="9"&gt;
      &lt;name&gt;IPv6UcastLPM&lt;/name&gt;
      &lt;synopsis&gt;An LFB class definition for IPv6 longest prefix lookup
      function.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PktIn&lt;/name&gt;
          &lt;synopsis&gt;The port to receive IPv6 packets needed to do IPv4
          LPM.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;SuccessOut&lt;/name&gt;
          &lt;synopsis&gt;Output for packets that have find the correct
          route.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref&gt;NextHopID&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;FailOutput&lt;/name&gt;
          &lt;synopsis&gt;LPM failed.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt; IPv6 &lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt; PrefixTable &lt;/name&gt;
          &lt;synopsis&gt;IPv6 prefix table&lt;/synopsis&gt;
          &lt;array type="variable-size"&gt;
            &lt;typeRef&gt; IPv6PrefixTableEntry &lt;/typeRef&gt;
            &lt;contentKey contentKeyID="1"&gt;
              &lt;contentKeyField&gt;IPv6PrefixTableEntry.prefix
              &lt;/contentKeyField&gt;
            &lt;/contentKey&gt;
          &lt;/array&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;LocalIpv6AddrTable&lt;/name&gt;
          &lt;synopsis&gt;The table of interfaces's ip address infomation on
          the local device&lt;/synopsis&gt;
          &lt;typeRef&gt;LocalIpv6AddrType&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3" access="read-reset"&gt;
          &lt;name&gt;IPv6Stats&lt;/name&gt;
          &lt;synopsis&gt;The IPv6 associated statistics&lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;typeRef&gt; IPv6LPMClassiferStatisticsType &lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/components&gt;
      &lt;capabilities&gt;
        &lt;capability componentID="1"&gt;
          &lt;name&gt;PrefixTableLimit&lt;/name&gt;
          &lt;synopsis&gt;maxium number of prefix supported by this LFB
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
        &lt;capability componentID="2"&gt;
          &lt;name&gt;LocalIpv6AddrTableLimit&lt;/name&gt;
          &lt;synopsis&gt;maxium number of IPv6 address entrys supported by
          this LFB&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
      &lt;/capabilities&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="10"&gt;
      &lt;name&gt;IPv6UcastNexthopApplicator&lt;/name&gt;
      &lt;synopsis&gt;An LFB for applicating next hop action to IPv6 packets,
      actions mainly inlcude TTL incrementation and checksum
      recalculation.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PktIn&lt;/name&gt;
          &lt;synopsis&gt;Input port for packets to be applicate nexthop.
          &lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt; IPv6 &lt;/ref&gt;
            &lt;/frameExpected&gt;
            &lt;metadataExpected&gt;
              &lt;ref&gt;NextHopID&lt;/ref&gt;
            &lt;/metadataExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;SuccessOut&lt;/name&gt;
          &lt;synopsis&gt;Output port for packet successfully fulfill the
          nexthop application.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt; IPv6 &lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref&gt;FEID&lt;/ref&gt;
              &lt;ref&gt;Egress&lt;/ref&gt;
              &lt;ref availability="conditional"&gt;L2Index&lt;/ref&gt;
              &lt;ref&gt;NextHopIPv6&lt;/ref&gt;
              &lt;ref availability="conditional"&gt;NHEncapMethod&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;ExceptionOut&lt;/name&gt;
          &lt;synopsis&gt;Output port for exception packet.The following
          packets are identified as Exception packet:1 Packet with Hop
          Limit zero.2 The MTU for outgoing interface is less than the
          packet size.3 The outgoing port is same as the one on which
          the packet is received.4 The packet is for a local interface.
          &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt; IPv6 &lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref&gt;Ingress&lt;/ref&gt;
              &lt;ref&gt;ExceptionID&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;FailOutput&lt;/name&gt;
          &lt;synopsis&gt;Output for packets failed the nexthop application
          operation.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt; IPv6 &lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt; NextHopTable &lt;/name&gt;
          &lt;synopsis&gt;Nexthop table&lt;/synopsis&gt;
          &lt;array type="variable-size"&gt;
            &lt;typeRef&gt; IPv6NextHopInfoType &lt;/typeRef&gt;
          &lt;/array&gt;
        &lt;/component&gt;
      &lt;/components&gt;
      &lt;capabilities&gt;
        &lt;capability componentID="1"&gt;
          &lt;name&gt;NextHopTableLimit&lt;/name&gt;
          &lt;synopsis&gt;Maxium number of nexthops this LFB supports
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
      &lt;/capabilities&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="11"&gt;
      &lt;name&gt;EtherEncap&lt;/name&gt;
      &lt;!--XXX:Should this be merged with the EtherPort?--&gt;
      &lt;synopsis&gt;An LFB classifier definition for completes ethernet
      encapsulation fuctions&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;derivedFrom&gt;GenericConnectivityLFB&lt;/derivedFrom&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;EncapIn&lt;/name&gt;
          &lt;synopsis&gt;Port for receiving packets needed to build Ethernet
          encapsulation.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameExpected&gt;
            &lt;metadataExpected&gt;
              &lt;ref dependency="optional" defaultValue="0"&gt;L2Index&lt;/ref&gt;
              &lt;one-of&gt;
                &lt;ref&gt;NextHopIP&lt;/ref&gt;
                &lt;ref&gt;NextHopIPv6&lt;/ref&gt;
              &lt;/one-of&gt;
              &lt;ref&gt;IPPacketType&lt;/ref&gt;
            &lt;/metadataExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;SuccessOut&lt;/name&gt;
          &lt;synopsis/&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;EthernetII&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort group="true"&gt;
          &lt;name&gt;ExceptionOut&lt;/name&gt;
          &lt;synopsis&gt;packet can't find the associated L2 information
          &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;ArpTable&lt;/name&gt;
          &lt;synopsis&gt;Ethernet arp table.&lt;/synopsis&gt;
          &lt;array&gt;
            &lt;typeRef&gt;ArpTableEntryType&lt;/typeRef&gt;
          &lt;/array&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;NbrTable&lt;/name&gt;
          &lt;synopsis&gt;IPv6 neighbour table.&lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;array&gt;
            &lt;typeRef&gt;NbrTableEntryType&lt;/typeRef&gt;
          &lt;/array&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;DCHostTablev4&lt;/name&gt;
          &lt;synopsis&gt;Direct connected host arp table for IPv4&lt;/synopsis&gt;
          &lt;array&gt;
            &lt;typeRef&gt;DCHostTableEntryTypev4&lt;/typeRef&gt;
          &lt;/array&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;DCHostTablev6&lt;/name&gt;
          &lt;synopsis&gt;Direct connected host arp table for IPv6&lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;array&gt;
            &lt;typeRef&gt;DCHostTableEntryTypev6&lt;/typeRef&gt;
          &lt;/array&gt;
        &lt;/component&gt;
      &lt;/components&gt;
      &lt;capabilities&gt;
        &lt;capability componentID="1"&gt;
          &lt;name&gt;ArpTableLimit&lt;/name&gt;
          &lt;synopsis&gt;Max number of arp entries in arp table.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
        &lt;capability componentID="2"&gt;
          &lt;name&gt;NbrTableLimit&lt;/name&gt;
          &lt;synopsis&gt;Max number of neighbours in neighbour table.
          &lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
        &lt;capability componentID="3"&gt;
          &lt;name&gt;DCHostTablev4Limit&lt;/name&gt;
          &lt;synopsis&gt;The limit on Direct connected host table for IPv4.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
        &lt;capability componentID="4"&gt;
          &lt;name&gt;DCHostTablev6Limit&lt;/name&gt;
          &lt;synopsis&gt;The limit on Direct connected host table for IPv6.
          &lt;/synopsis&gt;
          &lt;optional/&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
      &lt;/capabilities&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="12"&gt;
      &lt;name&gt;Scheduler&lt;/name&gt;
      &lt;synopsis&gt;Base scheduler LFB.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort group="true"&gt;
          &lt;name&gt;Watcher&lt;/name&gt;
          &lt;synopsis&gt;Input for watching the queues to be scheduled.
          Queues to be scheduled can transmit packet enqueue and
          dequeue infomation to scheduler through these port&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;MetadataFrame&lt;/ref&gt;
            &lt;/frameExpected&gt;
            &lt;metadataExpected&gt;
              &lt;ref&gt;QueueID&lt;/ref&gt;
              &lt;ref&gt;PacketLength&lt;/ref&gt;
              &lt;ref&gt;QueueOperationCmd&lt;/ref&gt;
            &lt;/metadataExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort group="true"&gt;
          &lt;name&gt;OutControl&lt;/name&gt;
          &lt;synopsis&gt;Control output,this output is used by scheduler to
          communicate commands to it's controlled queues such as
          dequeue a packet.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;MetadataFrame&lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref&gt;QueueOperationCmd&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;capabilities&gt;
        &lt;capability componentID="1"&gt;
          &lt;name&gt;QueueScheduledLimit&lt;/name&gt;
          &lt;synopsis&gt;Max number of queues that can be scheduled by this
          scheduler.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
      &lt;/capabilities&gt;
      &lt;description&gt;This defines a base LFB class for schedulers.
      Schedulers have an Input Port group called Watchers for
      representing the queues they watch, and an Output Port group
      called Controllers fro representing the queues they control.
                                                      &lt;/description&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="13"&gt;
      &lt;name&gt;Queue &lt;/name&gt;
      &lt;synopsis&gt;Queue LFB.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;InControl&lt;/name&gt;
          &lt;synopsis&gt;Input from scheduler&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;metadataExpected&gt;
              &lt;ref&gt;QueueOperationCmd&lt;/ref&gt;
            &lt;/metadataExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
        &lt;inputPort&gt;
          &lt;name&gt;InData&lt;/name&gt;
          &lt;synopsis&gt;Input port for data packet.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;Arbitrary&lt;/ref&gt;
            &lt;/frameExpected&gt;
            &lt;metadataExpected&gt;
              &lt;ref&gt;PacketLength&lt;/ref&gt;
            &lt;/metadataExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;OutToController&lt;/name&gt;
          &lt;synopsis&gt;Output to queue controller&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;MetadataFrame&lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref&gt;QueueID&lt;/ref&gt;
              &lt;ref&gt;PacketLength&lt;/ref&gt;
              &lt;ref&gt;QueueOperationCmd&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;OutData&lt;/name&gt;
          &lt;synopsis&gt;Data packet output&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;Arbitrary&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;CurLen&lt;/name&gt;
          &lt;synopsis&gt;Current length of the queue in number of packets.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/components&gt;
      &lt;capabilities&gt;
        &lt;capability componentID="1"&gt;
          &lt;name&gt;QueueLenLimit&lt;/name&gt;
          &lt;synopsis&gt;Maximum length of the queue in number of packets.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
      &lt;/capabilities&gt;
      &lt;description&gt;Queues have a packet input, a packet output, a
      control input, and a group of control outputs. The control ports
      represent the control relationships with scheduluers.
                                                         &lt;/description&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="16"&gt;
      &lt;name&gt;WRRSched&lt;/name&gt;
      &lt;synopsis&gt;Weighted round robin scheduler.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;derivedFrom&gt;Scheduler&lt;/derivedFrom&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;WeightTable&lt;/name&gt;
          &lt;synopsis&gt;Weight table for queues to be scheduled.
          &lt;/synopsis&gt;
          &lt;array type="variable-size"&gt;
            &lt;typeRef&gt;WeightTableEntryType&lt;/typeRef&gt;
          &lt;/array&gt;
        &lt;/component&gt;
      &lt;/components&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="17"&gt;
      &lt;name&gt;IPv6AddrResolution&lt;/name&gt;
      &lt;synopsis&gt;This LFB class provides the function of IPv6 address
      resolution part of neighbor discovery protocol.It provides an
      offload of ND protocol processing to FE.It process the following
      ND messages:neighbour solicitation and neighbour advertisement.
      &lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;AddrResDataPktIn&lt;/name&gt;
          &lt;synopsis&gt;The IPv6 data packet that need to do the address
          resolution.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
        &lt;inputPort&gt;
          &lt;name&gt;AddrResProtoPktIn&lt;/name&gt;
          &lt;synopsis&gt;The neighbour discovery packet related to address
          resolution.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;AddrResDataPktOut&lt;/name&gt;
          &lt;synopsis&gt;The IPv6 packet that have encapsulated with the
          correct ethernet L2 info and need to be sent out to link.
          &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;EthernetII&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;AddrResProtoPktOut&lt;/name&gt;
          &lt;synopsis&gt;The IPv6 neighbour discovey packet wich has been
          encapsulation with the correct ethernet L2 info.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;EthernetII&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;Nbrtable&lt;/name&gt;
          &lt;synopsis&gt;This table is an alias to the IPv6 neighbour table
          in the EtherEncap LFB.&lt;/synopsis&gt;
          &lt;alias&gt;NbrTable&lt;/alias&gt;
        &lt;/component&gt;
      &lt;/components&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="18"&gt;
      &lt;name&gt;ICMPv6Generator&lt;/name&gt;
      &lt;synopsis&gt;This LFB class provide some basic ICMPv6 function,it
      only generate the following ICMP messages for the packets that
      need some basic icmp processing:destination not reachable and
      time excceeded.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PktIn&lt;/name&gt;
          &lt;synopsis&gt;The IPv6 packet that need icmp processing.
          &lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameExpected&gt;
            &lt;metadataExpected&gt;
              &lt;ref&gt;ExceptionID&lt;/ref&gt;
            &lt;/metadataExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;ICMPv6PktOut&lt;/name&gt;
          &lt;synopsis&gt;The output for the ICMPv6 packets generated
          according to the input IPv6 packet and the ExceptionID.
          &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="19"&gt;
      &lt;name&gt;ExtendHeaderProc&lt;/name&gt;
      &lt;synopsis&gt;This LFB class process the IPv6 packet with extended
      header,For the moment,the packets to this LFB are redirect to
      RedirectSink LFB by default.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PktIn&lt;/name&gt;
          &lt;synopsis&gt;The IPv6 packet with extended header in.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort group="true"&gt;
          &lt;name&gt;PktOut&lt;/name&gt;
          &lt;synopsis&gt;According to the Extended header type the packet
          may have different next proccesing LFB.Now by default we send
          all the packet with extended header to CE.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="20"&gt;
      &lt;name&gt;arp&lt;/name&gt;
      &lt;synopsis&gt;This LFB class provides the function of address
      resolution for IPv4 nodes.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;AddrResDataPktIn&lt;/name&gt;
          &lt;synopsis&gt;The IPv4 data packet that need to do the address
          resolution.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
        &lt;inputPort&gt;
          &lt;name&gt;ArpPktIn&lt;/name&gt;
          &lt;synopsis&gt;The neighbour discovery packet related to address
          resolution.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;AddrResDataPktOut&lt;/name&gt;
          &lt;synopsis&gt;The IPv4 packet that have been encapsulated with
          the correct ethernet L2 info and need to be sent out to link.
          &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;EthernetII&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;ArpOut&lt;/name&gt;
          &lt;synopsis&gt;The arp packet out.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;EthernetII&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;Arptable&lt;/name&gt;
          &lt;synopsis&gt;This table is an alias of the arp table in the
          EtherEncap LFB.&lt;/synopsis&gt;
          &lt;alias&gt;ArpTable&lt;/alias&gt;
        &lt;/component&gt;
      &lt;/components&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="21"&gt;
      &lt;name&gt;ICMPGenerator&lt;/name&gt;
      &lt;synopsis&gt;This LFB class provide some basic ICMP function,it only
      generate the following ICMP messages:ICMP destination
      unreachable and time excceeded.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PktIn&lt;/name&gt;
          &lt;synopsis&gt;IPv4 packet that need icmp processing.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
            &lt;/frameExpected&gt;
            &lt;metadataExpected&gt;
              &lt;ref&gt;ExceptionID&lt;/ref&gt;
            &lt;/metadataExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;ICMPPktOut&lt;/name&gt;
          &lt;synopsis&gt;The output for the ICMP packets generated according
          to the input packet and the ExceptionID.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="22"&gt;
      &lt;name&gt;MetadataClassifier&lt;/name&gt;
      &lt;synopsis&gt;This LFB class provides the function of classify
      packets according to the meta data.Now it only works on one meta
      data.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PktIn&lt;/name&gt;
          &lt;synopsis&gt;Packets need to do the classification.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;Arbitrary&lt;/ref&gt;
            &lt;/frameExpected&gt;
            &lt;metadataExpected&gt;
              &lt;ref&gt;Arbitrary&lt;/ref&gt;
            &lt;/metadataExpected&gt;
&lt;!-- XXX:how to express here that we only need one meta data of any
kind?The model says that variable  tag metadata do this need but
doesn't show how to use it.--&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort group="true"&gt;
          &lt;name&gt;ClassifiedOut&lt;/name&gt;
          &lt;synopsis&gt;Output group for the classified packets.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;Arbitrary&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1"&gt;
          &lt;name&gt;MetaDataID&lt;/name&gt;
          &lt;synopsis&gt;The metadata id that this classifier works on.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="2"&gt;
          &lt;name&gt;MetaDataName&lt;/name&gt;
          &lt;synopsis&gt;The name of the meta data that this classifier
          works on.&lt;/synopsis&gt;
          &lt;typeRef&gt;string&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="3"&gt;
          &lt;name&gt;MetadataClassifyTable&lt;/name&gt;
          &lt;synopsis&gt;The meta data classifying table.&lt;/synopsis&gt;
          &lt;typeRef&gt;MetadataClassTableType&lt;/typeRef&gt;
        &lt;/component&gt;
        &lt;component componentID="4"&gt;
          &lt;name&gt;OutNumOfPorts&lt;/name&gt;
          &lt;synopsis&gt;The number of ports in the output group.&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/components&gt;
      &lt;capabilities&gt;
        &lt;capability componentID="1"&gt;
          &lt;name&gt;MaxOutNumOfPorts&lt;/name&gt;
          &lt;synopsis&gt;Maxium number of ports in the output group.
          &lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/capability&gt;
      &lt;/capabilities&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="23"&gt;
      &lt;name&gt;OptionProc&lt;/name&gt;
      &lt;synopsis&gt;This LFB class process the IPv4 packet with options,it
      can process on the following options:Router-alert option.
      &lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PktIn&lt;/name&gt;
          &lt;synopsis&gt;The IPv4 packet with options in.&lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort group="true"&gt;
          &lt;name&gt;PktOut&lt;/name&gt;
          &lt;synopsis&gt;According to the Option type the packet may have
          different next proccesing LFB.Now by default we send all the
          packet with extended header to CE.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="65537"&gt;
      &lt;name&gt;GenericConnectivityLFB&lt;/name&gt;
      &lt;synopsis&gt;
           An LFB Class for providing connectivity between an FE and
           communications media.
         &lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;description&gt;This LFB Class provides a generic basis for
      representing connectivity between the FE and the outside world.
      The LFB has one or more ports for packets that the FE processing
      logic is forwrding for transmission by this Connectivity LFB. It
      has one or more ports for packets that the Connectivity LFB has
      received and is handing to the FE processing logic. Multiple
      ports for handline packets are supported so that protocol
      specific encapsulation and demultiplexing can be provided by this
      LFB. This LFB also has ports for sending packets to lower layer
      Connectivity LFBs and receiving packets from such lower layer
      Connectivity LFBs. This enables support for the processing
      components of interface stacks, such as PPP over Ethernet or
      Ethernet over MPLS.For packets arriving from Media or lower layer
      connectivity, this LFB will perform appropriate media validation,
      then remove media specific headers, and place the relevant
      information in meta-data.  For ethernet, the Source MAC would be
      in meta-data.  For Frame Relay or ATM, a circuit identifier would
      be in meta-data. For Ethernet with VLANs, this meta-data would
      indicate which VLAN the packet came from. For packets to be
      transmitted, meta-data indicating the destination (destination
      MAC or outgoing circuit, etc.) is required. This LFB will also
      include statistical components such as the number of octets and
      packets sent and received, the number of various input and output
      errors, etc.&lt;/description&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="65538"&gt;
      &lt;name&gt;RedirectLFB&lt;/name&gt;
      &lt;synopsis&gt;An LFB Class definition for exchanging data packets
      between the FE and the CE.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;RedirectToCE&lt;/name&gt;
          &lt;synopsis&gt;
               Port for frames to send to the CE.
             &lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;taggedFrame&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;RedirectFromCE&lt;/name&gt;
          &lt;synopsis&gt;
               Port for frames to send to the CE
             &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;taggedFrame&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;description&gt;This LFB represents a point of exchagne of data
      packets between the CE and the FE. Packets with meta-data are
      exchanged.  It is expected that the output port of a RedirectLFB,
      if it is connected at all, will be connected to a meta-data
      redirector&lt;/description&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="65539"&gt;
      &lt;name&gt;IPv4Validator&lt;/name&gt;
      &lt;synopsis&gt;An LFB Class definition for validates the IPv4 packet.
      &lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;ValidatorIn&lt;/name&gt;
          &lt;synopsis&gt;
               Normal packet input.
             &lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;ValidatorOut&lt;/name&gt;
          &lt;synopsis&gt;
               Normal packet Output.
             &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;IPv4packet&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;FailOutput&lt;/name&gt;
          &lt;synopsis&gt;The port to send packets that do not match any
          entries.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;taggedFrame&lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref&gt;errorid&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;description&gt;This LFB validates the IP version and header length
      fields, including verifying that the packet length is at least as
      long as the header indicates.&lt;/description&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="65540"&gt;
      &lt;name&gt;IPv6Validator&lt;/name&gt;
      &lt;synopsis&gt;An LFB Class definition for validates the IPv6 packet.
      &lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;ValidatorIn&lt;/name&gt;
          &lt;synopsis&gt;
               Normal packet input.
             &lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;ValidatorOut&lt;/name&gt;
          &lt;synopsis&gt;
               Normal packet Output.
             &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;IPv6packet&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;FailOutput&lt;/name&gt;
          &lt;synopsis&gt;The port to send packets that do not match any
          entries.&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;taggedFrame&lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;metadataProduced&gt;
              &lt;ref&gt;errorid&lt;/ref&gt;
            &lt;/metadataProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;description&gt;This LFB validates the IP version and header length
      fields, including verifying that the packet length is at least as
       long as the header indicates.&lt;/description&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="65541"&gt;
      &lt;name&gt;PacketTrimmer&lt;/name&gt;
      &lt;!--XXX:Needs further discussion--&gt;
      &lt;synopsis&gt;LFB removes data from the front of a packet.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PacketIn&lt;/name&gt;
          &lt;synopsis&gt;
               Normal packet input.
             &lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;Packet&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort&gt;
          &lt;name&gt;PacketOut&lt;/name&gt;
          &lt;synopsis&gt;
               Normal packet Output.
             &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;Packet&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort&gt;
          &lt;name&gt;FailOut&lt;/name&gt;
          &lt;synopsis&gt;
               For packets without enough bytes to remove
             &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;Packet&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1" access="read-write"&gt;
          &lt;name&gt;TrimLength&lt;/name&gt;
          &lt;synopsis&gt;amount to trim from each packet&lt;/synopsis&gt;
          &lt;typeRef&gt;uint32&lt;/typeRef&gt;
        &lt;/component&gt;
      &lt;/components&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="65543"&gt;
      &lt;name&gt;Duplicator&lt;/name&gt;
      &lt;!--XXX:Needs further discussion--&gt;
      &lt;synopsis&gt;An LFB Class definition for packet duplicator LFB. Any
      packet received on an input port is logically copied and sent to
      all output ports.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort&gt;
          &lt;name&gt;PacketIn&lt;/name&gt;
          &lt;synopsis&gt;
                  Normal packet input.
                &lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameExpected&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort group="true"&gt;
          &lt;name&gt;PacketOut&lt;/name&gt;
          &lt;synopsis&gt;Normal packet output port group&lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;IPv4&lt;/ref&gt;
              &lt;ref&gt;IPv6&lt;/ref&gt;
            &lt;/frameProduced&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
    &lt;/LFBClassDef&gt;
    &lt;LFBClassDef LFBClassID="65544"&gt;
      &lt;name&gt;ArbitraryClassifierLFB&lt;/name&gt;
      &lt;!--XXX:Needs further discussion--&gt;
      &lt;synopsis&gt;A classifier which can test packet or metadata, and on
      that basis set meta-data a pick an output port.&lt;/synopsis&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;inputPorts&gt;
        &lt;inputPort group="true"&gt;
          &lt;name&gt;PacketsToClassify&lt;/name&gt;
          &lt;synopsis&gt;
               The group of ports to received packets over
             &lt;/synopsis&gt;
          &lt;expectation&gt;
            &lt;frameExpected&gt;
              &lt;ref&gt;taggedFrame&lt;/ref&gt;
            &lt;/frameExpected&gt;
&lt;!-- no metadataExpected item as any and all meta data is allowed --&gt;
          &lt;/expectation&gt;
        &lt;/inputPort&gt;
      &lt;/inputPorts&gt;
      &lt;outputPorts&gt;
        &lt;outputPort group="true"&gt;
          &lt;name&gt;SuccessOutput&lt;/name&gt;
          &lt;synopsis&gt;
               The group of ports used by the classifer for output
               when a successful match is found.
             &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;taggedFrame&lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;!-- no metaDataProduced as anything can be produced --&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
        &lt;outputPort group="false"&gt;
          &lt;name&gt;FailOutput&lt;/name&gt;
          &lt;synopsis&gt;
               The port to send packets that do not match any entries.
             &lt;/synopsis&gt;
          &lt;product&gt;
            &lt;frameProduced&gt;
              &lt;ref&gt;taggedFrame&lt;/ref&gt;
            &lt;/frameProduced&gt;
            &lt;!-- no metaDataProduced as anything can be produced --&gt;
          &lt;/product&gt;
        &lt;/outputPort&gt;
      &lt;/outputPorts&gt;
      &lt;components&gt;
        &lt;component componentID="1" access="read-write"&gt;
          &lt;name&gt;ClassifierTable&lt;/name&gt;
          &lt;synopsis&gt;The table of classifier entries. Each entry is
          tested until one succeeds. Each entry contains an optional
          port test, an array of packet and meta data tests, an array
          of metadata actions, and an exit selection.&lt;/synopsis&gt;
          &lt;array type="variable-size"&gt;
            &lt;struct&gt;
              &lt;component componentID="1"&gt;
                &lt;name&gt;InputPortTest&lt;/name&gt;
                &lt;synopsis&gt;If present,this match will only match packets
                arriving over the specified port.&lt;/synopsis&gt;
                &lt;optional/&gt;
                &lt;typeRef&gt;uint32&lt;/typeRef&gt;
              &lt;/component&gt;
              &lt;component componentID="2"&gt;
                &lt;name&gt;TestConditions&lt;/name&gt;
                &lt;synopsis&gt;The array of conditions to test&lt;/synopsis&gt;
                &lt;array type="variable-size"&gt;
                  &lt;typeRef&gt;MatchCondition&lt;/typeRef&gt;
                &lt;/array&gt;
              &lt;/component&gt;
              &lt;component componentID="3"&gt;
                &lt;name&gt;MetaDataActions&lt;/name&gt;
                &lt;synopsis&gt;The array of meta data modifications to make
                when the match succeeds.&lt;/synopsis&gt;
                &lt;array type="variable-size"&gt;
                  &lt;typeRef&gt;MatchMetaDataAction&lt;/typeRef&gt;
                &lt;/array&gt;
              &lt;/component&gt;
              &lt;component componentID="4"&gt;
                &lt;name&gt;MatchOutputPort&lt;/name&gt;
                &lt;synopsis&gt;The port within the success group to send
                packets which match these tests.&lt;/synopsis&gt;
                &lt;typeRef&gt;uint32&lt;/typeRef&gt;
              &lt;/component&gt;
            &lt;/struct&gt;
          &lt;/array&gt;
        &lt;/component&gt;
      &lt;/components&gt;
    &lt;/LFBClassDef&gt;
  &lt;/LFBClassDefs&gt;
&lt;/LFBLibrary&gt;
</pre></div><p>

      
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
LFB Use Case</h3>

<p>Editorial:This section is supposed to discuss how we can build some basic applications define by WG charter such as IPV4 forwarding etc.
</p>
<p>Putting together LFBs to form a specific packet processing application
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Contributors</h3>

<p>
       The authors would like to thank Jamal Hadi Salim and Ligang Dong who made a major contribution to the development of this
   document.
</p>
<p>
        </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
      Jamal Hadi Salim 
      Mojatatu Networks <br />

      Ottawa, Ontario <br />

      Canada <br />

      Email: hadi@mojatatu.com <br />

          
</dd>
<dt></dt>
<dd>
     Ligang Dong 
     Zhejiang Gongshang University <br />

     149 Jiaogong Road <br />

     Hangzhou 310035 <br />

     P.R.China <br />

     Phone: +86-571-28877751 <br />

     EMail: donglg@mail.zjgsu.edu.cn <br />

          
</dd>
</dl></blockquote><p>
      
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p>This document is based on earlier documents from Joel Halpern, Ligang Dong, Fenggen Jia and Weiming Wang.
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
IANA Considerations</h3>

<p>This memo includes no request to IANA.
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Security Considerations</h3>

<p>These definitions if used by an FE to support ForCES create
   manipulable entities on the FE. Manipulation of such objects can
   produce almost unlimited effects on the FE. FEs should ensure that
   only properly authenticated ForCES protocol participants are
   performing such manipulations.  Thus the security issues
   with this protocol are defined in the <a class='info' href='#I-D.ietf-forces-protocol'>FE-protocol<span> (</span><span class='info'>Dong, L., Doria, A., Gopal, R., HAAS, R., Salim, J., Khosravi, H., and W. Wang, &ldquo;ForCES Protocol Specification,&rdquo; March&nbsp;2009.</span><span>)</span></a> [I&#8209;D.ietf&#8209;forces&#8209;protocol].

</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-forces-model">[I-D.ietf-forces-model]</a></td>
<td class="author-text">Halpern, J. and J. Salim, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-forces-model-16.txt">ForCES Forwarding Element Model</a>,&rdquo; draft-ietf-forces-model-16 (work in progress), October&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-forces-model-16.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-forces-protocol">[I-D.ietf-forces-protocol]</a></td>
<td class="author-text">Dong, L., Doria, A., Gopal, R., HAAS, R., Salim, J., Khosravi, H., and W. Wang, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-forces-protocol-22.txt">ForCES Protocol Specification</a>,&rdquo; draft-ietf-forces-protocol-22 (work in progress), March&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-forces-protocol-22.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2629">[RFC2629]</a></td>
<td class="author-text"><a href="mailto:mrose@not.invisible.net">Rose, M.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2629">Writing I-Ds and RFCs using XML</a>,&rdquo; RFC&nbsp;2629, June&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2629.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2629.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2629.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3552">[RFC3552]</a></td>
<td class="author-text">Rescorla, E. and B. Korver, &ldquo;<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>,&rdquo; BCP&nbsp;72, RFC&nbsp;3552, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3552.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3654">[RFC3654]</a></td>
<td class="author-text">Khosravi, H. and T. Anderson, &ldquo;<a href="http://tools.ietf.org/html/rfc3654">Requirements for Separation of IP Control and Forwarding</a>,&rdquo; RFC&nbsp;3654, November&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3654.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3746">[RFC3746]</a></td>
<td class="author-text">Yang, L., Dantu, R., Anderson, T., and R. Gopal, &ldquo;<a href="http://tools.ietf.org/html/rfc3746">Forwarding and Control Element Separation (ForCES) Framework</a>,&rdquo; RFC&nbsp;3746, April&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3746.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5226">[RFC5226]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5226.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Weiming Wang</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Zhejiang Gongshang University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">18, Xuezheng Str., Xiasha University Town</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Hangzhou,   310018</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.R.China</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+86-571-28877721</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:wmwang@mail.zjgsu.edu.cn">wmwang@mail.zjgsu.edu.cn</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Evangelos Haleplidis</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University of Patras</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Patras,   </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Greece</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ehalep@ece.upatras.gr">ehalep@ece.upatras.gr</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Kentaro Ogawa</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NTT Corporation</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tokyo,   </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Japan</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ogawa.kentaro@lab.ntt.co.jp">ogawa.kentaro@lab.ntt.co.jp</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Fenggen Jia</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">National Digital Switching Center(NDSC)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jianxue Road</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Zhengzhou,   452000</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.R.China</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+86-571-28877751</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jfg@mail.ndsc.com.cn,fgjia@mail.zjgsu.edu.cn">jfg@mail.ndsc.com.cn,fgjia@mail.zjgsu.edu.cn</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Halpern Joel</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ericsson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 6049</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Leesburg,   20178</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">VA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 703 371 3043</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jhalpern@redback.com">jhalpern@redback.com</a></td></tr>
</table>
</body></html>
