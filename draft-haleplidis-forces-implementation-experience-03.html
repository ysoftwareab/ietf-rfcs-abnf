<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>ForCES Implementation Experience Draft</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Terminology and Conventions">
<link href="#rfc.section.2" rel="Chapter" title="2 Introduction">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Document Goal">
<link href="#rfc.section.3" rel="Chapter" title="3 ForCES Architecture">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Pre-association setup - Initial Configuration">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 TML">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Model">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Components">
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 LFBs">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Protocol">
<link href="#rfc.section.3.4.1" rel="Chapter" title="3.4.1 TLVs">
<link href="#rfc.section.3.4.2" rel="Chapter" title="3.4.2 Message Deserialization">
<link href="#rfc.section.3.4.3" rel="Chapter" title="3.4.3 Message Serialization">
<link href="#rfc.section.4" rel="Chapter" title="4 Development Platforms">
<link href="#rfc.section.5" rel="Chapter" title="5 Acknowledgements">
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="The Forwarding and Control Element Separation (ForCES) protocol defines a standard communication and control mechanism through which a Control Element (CE) can control the behavior of a Forwarding Element (FE). This document captures the experience of implementing the ForCES protocol and model. Its aim is to help others by providing examples and possible strategies for implementing the ForCES protocol." />
  <meta name="description" content="The Forwarding and Control Element Separation (ForCES) protocol defines a standard communication and control mechanism through which a Control Element (CE) can control the behavior of a Forwarding Element (FE). This document captures the experience of implementing the ForCES protocol and model. Its aim is to help others by providing examples and possible strategies for implementing the ForCES protocol." />
  <meta name="keywords" content="ForCES, Interoperability, Implementation, Experience" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">E.H. Haleplidis</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">O.K. Koufopavlou</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">S.D. Denazis</td>
</tr>
<tr>
<td class="left">Expires: December 25, 2011</td>
<td class="right">University of Patras</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">June 23, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">ForCES Implementation Experience Draft<br />
  <span class="filename">draft-haleplidis-forces-implementation-experience-03</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The Forwarding and Control Element Separation (ForCES) protocol defines a standard communication and control mechanism through which a Control Element (CE) can control the behavior of a Forwarding Element (FE). This document captures the experience of implementing the ForCES protocol and model. Its aim is to help others by providing examples and possible strategies for implementing the ForCES protocol.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 25, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Terminology and Conventions</a>
</li>
<li>2.   <a href="#rfc.section.2">Introduction</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Document Goal</a>
</li>
<li>3.   <a href="#rfc.section.3">ForCES Architecture</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Pre-association setup - Initial Configuration</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">TML</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Model</a>
</li>
<li>3.3.1.   <a href="#rfc.section.3.3.1">Components</a>
</li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">LFBs</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Protocol</a>
</li>
<li>3.4.1.   <a href="#rfc.section.3.4.1">TLVs</a>
</li>
<li>3.4.2.   <a href="#rfc.section.3.4.2">Message Deserialization</a>
</li>
<li>3.4.3.   <a href="#rfc.section.3.4.3">Message Serialization</a>
</li>
<li>4.   <a href="#rfc.section.4">Development Platforms</a>
</li>
<li>5.   <a href="#rfc.section.5">Acknowledgements</a>
</li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<li>8.   <a href="#rfc.references">References</a>
</li>
<li>8.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Terminology and Conventions</h1>
<p id="rfc.section.1.p.1">The terminology used in this document is the same as in the <a href="#RFC5810">Forwarding and Control Element Separation Protocol </a> <cite title="NONE">[RFC5810]</cite> and part of it is copied in this document.</p>
<p id="rfc.section.1.p.2">Control Element (CE): A logical entity that implements the ForCES protocol and uses it to instruct one or more FEs on how to process packets. CEs handle functionality such as the execution of control and signaling protocols.</p>
<p id="rfc.section.1.p.3">Forwarding Element (FE): A logical entity that implements the ForCES protocol.  FEs use the underlying hardware to provide per-packet processing and handling as directed/controlled by one or more CEs via the ForCES protocol.</p>
<p id="rfc.section.1.p.4">LFB (Logical Function Block): The basic building block that is operated on by the ForCES protocol. The LFB is a well-defined, logically separable functional block that resides in an FE and is controlled by the CE via the ForCES protocol. The LFB may reside at the FE's data path and process packets or may be purely an FE control or configuration entity that is operated on by the CE. Note that the LFB is a functionally accurate abstraction of the FE's processing capabilities, but not a hardware-accurate representation of the FE implementation.</p>
<p id="rfc.section.1.p.5">LFB Class and LFB Instance: LFBs are categorized by LFB classes.  An LFB instance represents an LFB class (or type) existence. There may be multiple instances of the same LFB class (or type) in an FE.  An LFB class is represented by an LFB class ID, and an LFB instance is represented by an LFB instance ID. As a result, an LFB class ID associated with an LFB instance ID uniquely specifies an LFB existence.</p>
<p id="rfc.section.1.p.6">LFB Component: Operational parameters of the LFBs that must be visible to the CEs are conceptualized in the FE model as the LFB components. The LFB components include, for example, flags, single parameter arguments, complex arguments, and tables that the CE can read and/or write via the ForCES protocol.</p>
<p id="rfc.section.1.p.7">ForCES Protocol: While there may be multiple protocols used within the overall ForCES architecture, the terms "ForCES protocol" and "protocol" refer to the Fp reference points in the <a href="#RFC3746">ForCES framework</a> <cite title="NONE">[RFC3746]</cite>. This protocol does not apply to CE-to-CE communication, FE-to-FE communication, or communication between FE and CE managers. Basically, the ForCES protocol works in a master-slave mode in which FEs are slaves and CEs are masters. This document defines the specifications for this ForCES protocol.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Introduction</h1>
<p id="rfc.section.2.p.1">Forwarding and Control Element Separation (ForCES) defines an architectural framework and associated protocols to standardize information exchange between the control plane and the forwarding plane in a ForCES Network Element (ForCES NE).  <a href="#RFC3654">[RFC3654]</a> has defined the ForCES requirements, and <a href="#RFC3746">[RFC3746]</a>  has defined the ForCES framework.</p>
<p id="rfc.section.2.p.2">The ForCES protocol works in a master-slave mode in which FEs are slaves and CEs are masters.  The protocol includes commands for transport of Logical Functional Block (LFB) configuration information, association setup, status, and event notifications, etc. The reader is encouraged to read the <a href="#RFC5810">Forwarding and Control Element Separation Protocol</a> <cite title="NONE">[RFC5810]</cite> for further information.</p>
<p><a href="#RFC5812">[RFC5812]</a> presents a formal way to define FE Logical Functional Blocks (LFBs) using XML.  LFB configuration components, capabilities, and associated events are defined when LFBs are formally created.  The LFBs within the Forwarding Element (FE) are accordingly controlled in a standardized way by the ForCES protocol.</p>
<p id="rfc.section.2.p.4">The Transport Mapping Layer (TML) transports the protocol messages.  The TML is where the issues of how to achieve transport level reliability, congestion control, multicast, ordering, etc., are handled.  It is expected that more than one TML will be standardized.  The various possible TMLs could vary their implementations based on the capabilities of underlying media and transport.  However, since each TML is standardized, interoperability is guaranteed as long as both endpoints support the same TML.  All ForCES Protocol Layer implementations must be portable across all TMLs.  Although more than one TML may be standardized for the ForCES Protocol, all ForCES implementations must implement the <a href="#RFC5811">SCTP TML</a> <cite title="NONE">[RFC5811]</cite>.</p>
<p id="rfc.section.2.p.5">The <a href="#RFC6041">Forwarding and Control Element Separation Applicability Statement</a> <cite title="NONE">[RFC6041]</cite> captures the applicable areas in which ForCES can be used.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Document Goal</h1>
<p id="rfc.section.2.1.p.1">This document captures the experience of implementing the ForCES protocol and model, and its main goal is not to tell others how to implement, but to provide alternatives, ideas and proposals as how it can be implemented.</p>
<p id="rfc.section.2.1.p.2">Also, this document mentions possible problems and potential choices that can be made, in an attempt to help implementors develop their own products.</p>
<p id="rfc.section.2.1.p.3">Additionally this document takes into account that the reader has become familiar with the three main ForCES RFCs, the <a href="#RFC5810">Forwarding and Control Element Separation Protocol</a> <cite title="NONE">[RFC5810]</cite>, the <a href="#RFC5812">Forwarding and Control Element Separation Forwarding Element Model</a> <cite title="NONE">[RFC5812]</cite> and the <a href="#RFC5811">SCTP-Based Transport Mapping Layer (TML) for the Forwarding and Control Element Separation Protocol</a> <cite title="NONE">[RFC5811]</cite>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> ForCES Architecture</h1>
<p id="rfc.section.3.p.1">In general ForCES has undergone two successfull interoperability tests, where very few issues were caught and resolved.</p>
<p id="rfc.section.3.p.2">This section discusses the ForCES architecture, implementation challenges and how to overcome them.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Pre-association setup - Initial Configuration</h1>
<p id="rfc.section.3.1.p.1">The initial configuration of the FE and the Control Element (CE) is done respectively by the FE Manager and the CE Manager.  These entities have not as yet been standardized.</p>
<p id="rfc.section.3.1.p.2">The simplest solution, are static configuration files, which play the role of the Managers and are read by FEs and CEs.</p>
<p id="rfc.section.3.1.p.3">For more dynamic solutions however, it is expected that the Managers will be entities that will talk to each other and exchange details regarding the associations. Any developer can create any Manager, but they should at least be able to exchange the following details:</p>
<p id="rfc.section.3.1.p.4">From the FE Manager side:</p>
<p></p>

<ol>
<li>FE Identifiers (FEIDs)</li>
<li>FE IP addresses, if the FEs and CEs will be communicating via network.</li>
<li>TML. The TML that will be used. If this is omitted, then SCTP must be chosen as default.</li>
<li>TML Priority ports. If this is omitted as well, then the CE must use the default values from the respective TML RFC.</li>
</ol>
<p id="rfc.section.3.1.p.6">From the CE Manager side:</p>
<p></p>

<ol>
<li>CE Identifiers (CEIDs)</li>
<li>CE IP addresses, if the FEs and CEs will be communicating via network.</li>
<li>TML. The TML that will be used. If this is omitted, then SCTP must be chosen as default.</li>
<li>TML Priority ports. If this is omitted as well, then the FE must use the default values from the respective TML RFC.</li>
</ol>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> TML</h1>
<p id="rfc.section.3.2.p.1">All ForCES implementations must support the SCTP as TML. Even if another TML will be chosen by the developer, SCTP is mandatory and must be supported.</p>
<p id="rfc.section.3.2.p.2">There are several issues that should concern a developer for the TML.</p>
<p></p>

<ol>
<li>Security. TML must be secure according to the respective RFC. For SCTP you have to use IPsec.</li>
<li>Remote connection. While ForCES is meant to be used locally, both interoperability tests have proven that ForCES can be deployed everywhere where SCTP/IP is available. In both interoperability tests there were connections between Greece and China and the performance was very satisfactory. However in order for the FE and CE to work in a not local environment if they are behind NATs an implementor must ensure that the SCTP-TML ports are forwarded to the CE and/or FE and if there is a firewall it will allow the SCTP ports through. These were identified during the first ForCES interoperability test and documented in the <a href="#RFC6053">Implementation Report for Forwarding and Control Element Separation</a> <cite title="NONE">[RFC6053]</cite>.</li>
</ol>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> Model</h1>
<p id="rfc.section.3.3.p.1">The ForCES model inherently is very dynamic. Using basic atomic data types that are specified in the model, new datatypes can be built using atomic (single valued) and/or compound (structures and arrays). Thus developers are free to create their own LFBs. One other advantage that the ForCES model provides is inheritance. New versions of existing LFBs can be created to suit any extra developer requirements.</p>
<p id="rfc.section.3.3.p.2">The difficulty for a developer is to create an architecture that is completely scalable so there is no need to write the same code for new LFBs, or for new components, etc. Just create code for the defined atomic values and then new components can be built based on already written code thus re-using it.</p>
<p id="rfc.section.3.3.p.3">The model itself provides the key which is inheritance.</p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> Components</h1>
<p id="rfc.section.3.3.1.p.1">First, a basic component needs to be created as the mother of all the components with the basic parameters of all the components:</p>
<p></p>

<ul>
<li>The ID of the component.</li>
<li>The access rights of that component.</li>
<li>If it is an optional component.</li>
<li>If it is of variable size.</li>
<li>Minimum data size.</li>
<li>Maximum data size.</li>
</ul>
<p id="rfc.section.3.3.1.p.3">If the data size of the component is not variable, then the size is either the minimum or the maximum size, as both should have the same value.</p>
<p id="rfc.section.3.3.1.p.4">Next, some basic functions are in order:</p>
<p></p>

<ul>
<li>A common constructor.</li>
<li>A common destructor.</li>
<li>Retrieve Component ID.</li>
<li>Retrieve access right property.</li>
<li>Query if it is an optional component.</li>
<li>Get Full Data.</li>
<li>Set Full Data.</li>
<li>Get Sparse Data.</li>
<li>Set Sparse Data.</li>
<li>Del Full Data.</li>
<li>Del Sparse Data.</li>
<li>Get Property</li>
<li>Set Property</li>
<li>Get Value.</li>
<li>Set Value.</li>
<li>Del Value.</li>
<li>Get Data.</li>
<li>Clone component.</li>
</ul>
<p id="rfc.section.3.3.1.p.6">The Get/Set/Del Full/Sparse Data and Get/Set Property functions handle the respective ForCES commands and return the respective TLV, for example the Set Full Data should return a Result TLV. The Get/Set/Del Value are called from the Get/Set/Del Full/Sparse Data respectively and provide the interface to the actual values in the hardware, separating the forces handling logic from the interface to the actual values.</p>
<p id="rfc.section.3.3.1.p.7">The Get Data function should return the value of the data only, not in TLV format.</p>
<p id="rfc.section.3.3.1.p.8">The last function seems out of place. That function must return a new component that has the exact same values and attributes. This function is useful in array components as described further.</p>
<p id="rfc.section.3.3.1.p.9">The only requirement is to implement the base atomic data types. Any new atomic datatype can be built as a child of a base data type which will inherit all the functions and if necessary override them.</p>
<p id="rfc.section.3.3.1.p.10">The struct component can then be built. A struct component is a component by itself, but consists of a number of atomic components. These atomic components create a static array within the struct. The ID of each atomic component is the array's index. The Clone function, for a struct component, must create and return an exact copy of the struct component with the same static array.</p>
<p id="rfc.section.3.3.1.p.11">The most difficult component to be built is the array. The difficulty lies in the actual benefit of the model. You have absolute freedom over what you build. An array is an array of components. In all rows you have the exact same type of component either a single component or a struct. The struct can have multiple single components, or a combination of single components, structs and arrays and so on. So, the difficulty lies in how to create a new row, a new component by itself. This is where the Clone function is very useful. For the array a mother component that can spawn new components exactly like itself is needed. Once a Set command is received, the mother component can spawn a new component, if the targeted row does not exists, and add it into the array, and with the Set Full Data the value is set in the recently spawned component, as the spawned component knows how the data is created. In order to distinguish these spawned components from each other and their functionality, some kind of index is required that will also reflect on how the actual data of the specific component is stored on the hardware.</p>
<p id="rfc.section.3.3.1.p.12">Once the basic constructors of all possible components are created, then a developer only has to create his LFB components or datatypes as a child of one of the already created components and the only thing the developer really needs to add, is the three functions of Get/Set/Del value of each component which is platform dependent. The rest stays the same.</p>
<h1 id="rfc.section.3.3.2">
<a href="#rfc.section.3.3.2">3.3.2.</a> LFBs</h1>
<p id="rfc.section.3.3.2.p.1">The same architecture in the components can be used for the LFBs, allowing a developer to write LFB handling code only once. The parent LFB has some basic attributes:</p>
<p></p>

<ul>
<li>The LFB Class ID.</li>
<li>The LFB Instance ID.</li>
<li>An Array of Components.</li>
<li>An Array of Capabilities.</li>
<li>An Array of Events.</li>
</ul>
<p id="rfc.section.3.3.2.p.3">Then some common functions:</p>
<p></p>

<ul>
<li>Handle Configuration Command.</li>
<li>Handle Query Command.</li>
<li>Get Class ID.</li>
<li>Get Instance ID.</li>
</ul>
<p id="rfc.section.3.3.2.p.5">Once these are created each LFB can inherit all these from the parent and the only thing it has to do is to add the components that have already been created.</p>
<p id="rfc.section.3.3.2.p.6">An example can be seen in <a href="#Figure%201">Figure 1</a>. The following code creates a part of FEProtocolLFB:</p>
<div id="#rfc.figure.1"></div>
<div id="#Figure 1"></div>
<pre>
//FEID
cui = new Component_uInt(FEPO_FEID, ACCESS_READ_ONLY, FE_id); 
Components[cui-&gt;get_ComponentId()]=cui; //Add component to array list

//Current FEHB Policy Value
cub = new Component_uByte(FEPO_FEHBPolicy, ACCESS_READ_WRITE, 0); 
Components[cub-&gt;get_ComponentId()]=cub; //Add component to array list

//FEIDs for BackupCEs Array
cui = new Component_uInt(0, ACCESS_READ_WRITE, 0); 
ca = new Component_Array(FEPO_BackupCEs, ACCESS_READ_WRITE);
ca-&gt;AddRow(cui, 1);
ca-&gt;AddMotherComponent(cui);
Components[ca-&gt;get_ComponentId()]=ca; //Add component to array list
</pre>
<p id="rfc.section.3.3.2.p.7">The same concept can be applied to handling LFBs as one FE. An FE is a collection of LFBs.  Thus all LFBs can be stored in an array based on the LFB's class id, version and instance. Then what is required is an LFBHandler that will handle the array of the LFBs. A specific LFB, for example, can be addressed using the following scheme:</p>
<p id="rfc.section.3.3.2.p.8">LFBs[ClassID][Version][InstanceID].</p>
<p id="rfc.section.3.3.2.p.9">Note: While an array can be used in components, capabilities and events, a hash table or a similar concept is better suited for storing LFBs using the component ID as the hash key with linked lists for collision handling, as the created array can have large gaps if the values of LFB Class ID vary greatly.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> Protocol</h1>
<h1 id="rfc.section.3.4.1">
<a href="#rfc.section.3.4.1">3.4.1.</a> TLVs</h1>
<p id="rfc.section.3.4.1.p.1">The goal, for protocol handling, is to create a general and scalable architecture that handles all protocol messages instead of something implementation specific. There are certain difficulties that have to be overcome first.</p>
<p id="rfc.section.3.4.1.p.2">Since the model allows a developer to define any LFB required, the protocol has been thus created to give the user the freedom to configure and query any component whatever the underlying model. While this being a strong point for the protocol itself, one difficulty lies with the unkwown underlying model and the unlimited number of types of messages that can be created, making creating generic code a daunting task. </p>
<p id="rfc.section.3.4.1.p.3">Additionally the protocol also allows two different path approaches to LFB components and the CE or FE must handle both or even a mix of them making a generic decoding of the protocol message difficult.</p>
<p id="rfc.section.3.4.1.p.4">Another difficulty also arises from the batching capabilities of the protocol. You can have multiple Operations within a message, you can select more than one LFB to command, and more than one component to manipulate.</p>
<p id="rfc.section.3.4.1.p.5">Possible solution is again provided by inheritance. There are two basic components in a protocol message.</p>
<p></p>

<ol>
<li>The common header.</li>
<li>The rest of the message.</li>
</ol>
<p id="rfc.section.3.4.1.p.7">The rest of the message is divided in Type-Length-Value (TLV) units, and in one case Index-Length-Value (ILV) units.</p>
<p id="rfc.section.3.4.1.p.8">The TLV hierarchy can be seen in the <a href="#Figure%202">Figure 2</a>:</p>
<div id="#rfc.figure.2"></div>
<div id="#Figure 2"></div>
<pre>
         Common Header
               |
   +-----------+----------+-----------+
   |           |          |           |
Redirect   LFBSelect   ASResult   ASTreason
  TLV         TLV        TLV         TLV
               |
               |
           Operation 
              TLV
               |
               |            Optional
            PathData  ---&gt; KeyInfo TLV
              TLV                   
               |
    +----------+---------+----------+        
    |          |         |          |       
SparseData   Result   FullData   PathData
   TLV        TLV       TLV        TLV
</pre>
<p id="rfc.section.3.4.1.p.9">The above figure shows only the basic hierarchy level of TLVs and does not show batching. Also this figure does not show the recursion that can occur at the last level of the hierarchy. The figure shows one kind of recursion with PathData within PathData. FullData can be within FullData and SparseData. The possible combination of TLVs are described in detail in the <a href="#RFC5810">Forwarding and Control Element Separation Protocol</a> <cite title="NONE">[RFC5810]</cite> as well as the data packing rules.</p>
<p id="rfc.section.3.4.1.p.10">A TLV's main attributes are:</p>
<p></p>

<ul>
<li>Type</li>
<li>Length</li>
<li>Data</li>
<li>An array of TLVs.</li>
</ul>
<p id="rfc.section.3.4.1.p.12">The array of TLVs is the next hierarchy level of TLVs nested in this TLV.</p>
<p id="rfc.section.3.4.1.p.13">A TLVs common function could be:</p>
<p></p>

<ul>
<li>A basic constructor.</li>
<li>A constructor using data from the wire.</li>
<li>Add a new TLV for next level.</li>
<li>Get the next TLV of next level.</li>
<li>Get a specific TLV of next level.</li>
<li>Replace a TLV of next level.</li>
<li>Get the Data.</li>
<li>Get the Length.</li>
<li>Set the Data.</li>
<li>Set the Length.</li>
<li>Set the Type.</li>
<li>Serialize the header.</li>
<li>Serialize the TLV to be written on the wire.</li>
</ul>
<p id="rfc.section.3.4.1.p.15">All TLVs inherit these functions and attributes and either override them or create new where it is required.</p>
<h1 id="rfc.section.3.4.2">
<a href="#rfc.section.3.4.2">3.4.2.</a> Message Deserialization</h1>
<p id="rfc.section.3.4.2.p.1">What follows is a the algorithm for deserializing any protocol message:</p>
<p></p>

<ol>
<li>Get the message header.</li>
<li>Read the length.</li>
<li>Check the message type to understand what kind of message this is.</li>
<li>If the length is larger than the message header then there is data for this message.</li>
<li>A check can be made here regarding the message type and the length of the message</li>
</ol>
<p id="rfc.section.3.4.2.p.3">If the message is a Query or Config type then for this level there are LFBSelector TLVs:</p>
<p></p>

<ol>
<li>Read the next 2 shorts(type-length). If the type is an LFBSelector then the message is valid.</li>
<li>Read the necessary length for this LFBSelector and create the LFBSelector from the data of the wire.</li>
<li>Add this LFBSelector to the main header array of LFBSelectors</li>
<li>Repeat all above steps until the rest of the message has finished.</li>
</ol>
<p id="rfc.section.3.4.2.p.5">The next level of TLVs are Operation TLVs</p>
<p></p>

<ol>
<li>Read the next 2 shorts(type-length). If the type is an OperationTLV then the message is valid.</li>
<li>Read the necessary length for this OperationTLV and create the OperationTLV from the data of the wire.</li>
<li>Add this OperationTLV to the LFBSelector array of TLVs.</li>
<li>Do this until the rest of the LFBSelector TLV has finished.</li>
</ol>
<p id="rfc.section.3.4.2.p.7">The next level of TLVs are PathData TLVs</p>
<p></p>

<ol>
<li>Read the next 2 shorts(type-length). If the type is a PathData then the message is valid.</li>
<li>Read the necessary length for this PathDataTLV and create the PathDataTLV from the data of the wire.</li>
<li>Add this PathData TLV to the Operation TLV's array of TLVs.</li>
<li>Do this until the rest of the Operation TLV is finished.</li>
</ol>
<p id="rfc.section.3.4.2.p.9">Here it gets interesting, as the next level of PathDataTLVs can be either:</p>
<p></p>

<ul>
<li>PathData TLVs.</li>
<li>FullData TLV.</li>
<li>SparseData TLV.</li>
<li>Result TLV.</li>
</ul>
<p id="rfc.section.3.4.2.p.11">The solution to this difficulty is recursion. If the next TLV is PathDataTLV then the PathDataTLV that is created uses the same kind of deserialisation until it reaches a FullDataTLV or SparseDataTLV. There can be only one FullDataTLV or SparseData within a PathData.</p>
<p></p>

<ol>
<li>Read the next 2 shorts(type-length).</li>
<li>If the Type is a PathDataTLV then do again the previous algorithm but add the PathDataTLV to this PathDataTLV's array of TLVs.</li>
<li>Do this until the rest of the PathData TVL is finished.</li>
<li>If the Type is a FullDataTLV then create the FullData TLV from the message and add this to the PathData's array of TLVs.</li>
<li>If the Type is a SparseDataTLV then create the SparseData TLV from the message and add this to the PathData's array of TLVs.</li>
<li>If the Type is a ResultTLV then create the Result TLV from the message and add this to the PathData's array of TLVs.</li>
</ol>
<p id="rfc.section.3.4.2.p.13">If the message is a Query it must not have any kind of data inside the PathData.</p>
<p id="rfc.section.3.4.2.p.14">If the message is a Query Response then it must either have a ResultTLV or a FullData TLV.</p>
<p id="rfc.section.3.4.2.p.15">If the message is a Config it must contain either a FullDataTLV or a SparseData TLV.</p>
<p id="rfc.section.3.4.2.p.16">If the message is a Config Reponse, it must contain a ResultTLV.</p>
<p id="rfc.section.3.4.2.p.17">More details regarding message validation can be be read in Section 7 of the <a href="#RFC5810">Forwarding and Control Element Separation Protocol</a> <cite title="NONE">[RFC5810]</cite>.</p>
<p id="rfc.section.3.4.2.p.18">Note: When deserializing, implementors must take care to ignore padding of TLVs as all must be 32-bit aligned. The length value in TLVs includes the Type and Length (4 bytes) but does not include padding.</p>
<h1 id="rfc.section.3.4.3">
<a href="#rfc.section.3.4.3">3.4.3.</a> Message Serialization</h1>
<p id="rfc.section.3.4.3.p.1">The same concept can be applied in the message creation process. Having the TLVs ready, a developer can go bottom up. All that is required is the serialization function that will transform the TLV into bytes ready to be transfered on the network.</p>
<p id="rfc.section.3.4.3.p.2">For example for the creation of a simple query from the CE to the FE, all the PathData are created. Then they will be serialized and inserted into an Operation TLV, which in turn will be serialized and inserted into an LFB Selector and in turn serialized and entered into the Common Header which will be passed to the TML to be transported to the FE.</p>
<p id="rfc.section.3.4.3.p.3">Having an array of TLVs inside a TLV that are next in the TLV hierarchy, allows the developer to insert any number of next level TLVs thus creating any kind of message.</p>
<p id="rfc.section.3.4.3.p.4">Note: When the TLV is serialized to be written on the wire, implementors must take care to include padding to TLVs as all must be 32-bit aligned.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Development Platforms</h1>
<p id="rfc.section.4.p.1">Any development platform that can support the SCTP TML and the TML of the developer's choosing is available for use.</p>
<p><a href="#Figure%203">Figure 3</a> provides an initial survey of SCTP support for C/C++ and Java at present time.</p>
<div id="#rfc.figure.3"></div>
<div id="#Figure 3"></div>
<pre>
/-------------+-------------+-------------+-------------\
|\ Platform   |             |             |             |
| ----------\ |   Windows   |    Linux    |   Solaris   |
|  Language  \|             |             |             |
+-------------+-------------+-------------+-------------+
|             |             |             |             |
|    C/C++    |  Supported  |  Supported  |  Supported  |
|             |             |             |             |
+-------------+-------------+-------------+-------------+
|             |   Limited   |             |             |
|    Java     | Third Party |  Supported  |  Supported  |
|             | Not from SUN|             |             |
\-------------+-------------+-------------+-------------/
</pre>
<p id="rfc.section.4.p.3">A developer should be aware of some limitations regarding Java implementations.</p>
<p id="rfc.section.4.p.4">Java inherently does not support unsigned types. A workaround this can be found in the creation of classes that do the translation of unsigned to java types. The problem is that the unsigned long cannot be used as is in the Java platform.  <a href="#Java%20Unsigned%20Types">The proposed set of classes can be found in </a> <cite title="NONE">[Java Unsigned Types]</cite>.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#Acknowledgments" id="Acknowledgments">Acknowledgements</a>
</h1>
<p id="rfc.section.5.p.1">The authors would like to thank Adrian Farrel for sponsoring this document and Jamal Hadi Salim for discussions to make this document better.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.6.p.1">This memo includes no request to IANA.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.7.p.1">Developers of ForCES FEs and CEs must take the security considerations of the <a href="#RFC3746">Forwarding and Control Element Separation Framework</a> <cite title="NONE">[RFC3746]</cite> and the <a href="#RFC5810">Forwarding and Control Element Separation Protocol</a> <cite title="NONE">[RFC5810]</cite> into account.</p>
<p id="rfc.section.7.p.2">Also, as specified in the security considerations section of the <a href="#RFC5811">SCTP-Based Transport Mapping Layer (TML) for the Forwarding and Control Element Separation Protocol</a> <cite title="NONE">[RFC5811]</cite> the transport-level security, has to be ensured by IPsec.</p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC5810">[RFC5810]</b></td>
<td class="top">
<a>Doria, A.</a>, <a>Hadi Salim, J.</a>, <a>Haas, R.</a>, <a>Khosravi, H.</a>, <a>Wang, W.</a>, <a>Dong, L.</a>, <a>Gopal, R.</a> and <a>J. Halpern</a>, "<a href="http://tools.ietf.org/html/rfc5810">Forwarding and Control Element Separation (ForCES) Protocol Specification</a>", RFC 5810, March 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5811">[RFC5811]</b></td>
<td class="top">
<a>Hadi Salim, J.</a> and <a>K. Ogawa</a>, "<a href="http://tools.ietf.org/html/rfc5811">SCTP-Based Transport Mapping Layer (TML) for the Forwarding and Control Element Separation (ForCES) Protocol</a>", RFC 5811, March 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5812">[RFC5812]</b></td>
<td class="top">
<a>Halpern, J.</a> and <a>J. Hadi Salim</a>, "<a href="http://tools.ietf.org/html/rfc5812">Forwarding and Control Element Separation (ForCES) Forwarding Element Model</a>", RFC 5812, March 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6041">[RFC6041]</b></td>
<td class="top">
<a>Crouch, A.</a>, <a>Khosravi, H.</a>, <a>Doria, A.</a>, <a>Wang, X.</a> and <a>K. Ogawa</a>, "<a href="http://tools.ietf.org/html/rfc6041">Forwarding and Control Element Separation (ForCES) Applicability Statement</a>", RFC 6041, October 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6053">[RFC6053]</b></td>
<td class="top">
<a>Haleplidis, E.</a>, <a>Ogawa, K.</a>, <a>Wang, W.</a> and <a>J. Hadi Salim</a>, "<a href="http://tools.ietf.org/html/rfc6053">Implementation Report for Forwarding and Control Element Separation (ForCES)</a>", RFC 6053, November 2010.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3654">[RFC3654]</b></td>
<td class="top">
<a>Khosravi, H.</a> and <a>T. Anderson</a>, "<a href="http://tools.ietf.org/html/rfc3654">Requirements for Separation of IP Control and Forwarding</a>", RFC 3654, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3746">[RFC3746]</b></td>
<td class="top">
<a>Yang, L.</a>, <a>Dantu, R.</a>, <a>Anderson, T.</a> and <a>R. Gopal</a>, "<a href="http://tools.ietf.org/html/rfc3746">Forwarding and Control Element Separation (ForCES) Framework</a>", RFC 3746, April 2004.</td>
</tr>
<tr>
<td class="reference"><b id="Java Unsigned Types">[Java Unsigned Types]</b></td>
<td class="top">
<a>Classes that support unsigned primitive types for Java. All except the unsigned long</a>", .</td>, "</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Evangelos Haleplidis</span> 
	  <span class="n hidden">
		<span class="family-name">Haleplidis</span>
	  </span>
	</span>
	<span class="org vcardline">University of Patras</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Patras</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Greece</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ehalep@ece.upatras.gr">ehalep@ece.upatras.gr</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Odysseas Koufopavlou</span> 
	  <span class="n hidden">
		<span class="family-name">Koufopavlou</span>
	  </span>
	</span>
	<span class="org vcardline">University of Patras</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Patras</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Greece</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:odysseas@ece.upatras.gr">odysseas@ece.upatras.gr</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Spyros Denazis</span> 
	  <span class="n hidden">
		<span class="family-name">Denazis</span>
	  </span>
	</span>
	<span class="org vcardline">University of Patras</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Patras</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Greece</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:sdena@upatras.gr">sdena@upatras.gr</a></span>

  </address>
</div>

</body>
</html>