<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Generic UDP Tunnelling (GUT)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Generic UDP Tunnelling (GUT)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">J. Manner</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">N. Varis</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">TKK</td></tr>
<tr><td class="header">Expires: March 18, 2010</td><td class="header">September 14, 2009</td></tr>
</table></td></tr></table>
<h1><br />Generic UDP Tunnelling (GUT)<br />draft-manner-tsvwg-gut-00.txt</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on March 18, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>

Deploying new transport protocols on the Internet is a well-known problem, as 
NATs and firewall drop packets with new protocol types. Tunnelling over UDP 
is one way to make IP packets hide the actual payload and enable end-to-end 
delivery. This draft proposes a simple UDP tunnelling encapsulation and 
end-host operation to enable new IP payloads, e.g., new transport protocols, 
to be deployed on the Internet.

	
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Terminology<br />
<a href="#anchor2">2.</a>&nbsp;
Introduction<br />
<a href="#anchor3">3.</a>&nbsp;
Basic operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.1.</a>&nbsp;
Sender operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.2.</a>&nbsp;
Receiver operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.3.</a>&nbsp;
Example with one NAT in between<br />
<a href="#anchor7">4.</a>&nbsp;
Deployment Considerations<br />
<a href="#anchor8">5.</a>&nbsp;
Encapsulation of other protocols<br />
<a href="#anchor9">6.</a>&nbsp;
Security Considerations<br />
<a href="#anchor10">7.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor11">8.</a>&nbsp;
Summary<br />
<a href="#rfc.references1">9.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">9.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">9.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Terminology</h3>

<p> 

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document 
are to be interpreted as described in BCP 14, RFC 2119 <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>. 


</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Introduction</h3>

<p>

New transport layer technology, such as SCTP <a class='info' href='#RFC4960'>[RFC4960]<span> (</span><span class='info'>Stewart, R., &ldquo;Stream Control Transmission Protocol,&rdquo; September&nbsp;2007.</span><span>)</span></a> and DCCP 
<a class='info' href='#RFC4340'>[RFC4340]<span> (</span><span class='info'>Kohler, E., Handley, M., and S. Floyd, &ldquo;Datagram Congestion Control Protocol (DCCP),&rdquo; March&nbsp;2006.</span><span>)</span></a>, have well-known problems with deployment on the 
Internet. Firewalls drop IP packets with unknown (too new) transport protocol 
types, and NAT boxes do not know how to translate these protocols.


</p>
<p>

Tunnelling over UDP has often been mentioned as a means to traverse 
middleboxes. Mostly the solutions are ad-hoc and protocol-specific. In order 
to make deployment of UDP tunnelling at least somewhat consistent, this draft 
proposes a simple mechanism to realise the goal. The benefit is that with a 
generic solution we avoid the need to define tunneling specifications for 
each transport protocol.


</p>
<p>

IP-in-IP encapsulation is also one potential solution. However, if the 
communicating hosts are behind NATs, they have private source addresses 
within the inner IP headers, which will break any communication. Moreover, if 
NATs and firewalls probe deeper into the packet, they will encounter 
potentially an unknown transport protocol and drop the packet.


</p>
<p>

The basic idea of GUT is to encapsulate the original transport protocol and 
its payload (in general the whole IP payload) within a UDP packet destined to 
the well-known port GUT_P. Between the outer UDP header and the inner 
transport header, we have a magic number and original protocol type. The 
purpose of the magic number is to enable the recipient to distinguish between 
GUT traffic and sporadic packets sent to the GUT_P port, e.g., due to port 
scanning, and to reconstruct the original IP packet with the correct IP 
protocol type. The protocol does not require back-and-forth signalling, it 
just encapsulates the original transport protocol and its payload - to any 
middlebox on the way this looks like a normal UDP flow to port GUT_P. 


</p>
<p>

If the inner transport protocol has a handshake or any back-and-forth
messaging, these are run automatically within the UDP-tunnel created by
GUT: GUT is meant to be fully transparent to the inner transport
protocol. Note that GUT can also tunnel protocol types which do not have
any port informations, such as RSVP or ICMP. The GUT encapsulation
is agnostic to the IP protocol version being used (IPv4 or IPv6).


</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Basic operation</h3>

<p>

The basic idea of the protocol is to encapsulate the transport protocol
header and possible payload within a UDP header and send the packet to a
well-known UDP port GUT_P. The receiver will get the UDP packets, check
the magic number, and if it matches the expected well-known value,
reconstruct the original IP packet, and forward it for further
processing within the OS stack. <a class='info' href='#f:stack'>Figure&nbsp;1<span> (</span><span class='info'>GUT encapsulation</span><span>)</span></a> shows the
encapsulation.


</p><br /><hr class="insert" />
<a name="f:stack"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

        +------------------+           +------------------+
        |                  |  ------&gt;  |                  |
        |                  |           |                  |
        |   Payload data   |  ------&gt;  |   Payload data   |
        |                  |           |                  |
        |                  |  ------&gt;  |                  |
        +------------------+           +------------------+
        |                  |  ------&gt;  |                  |
        | Orig. transport  |           | Orig. transport  |
        | (DCCP, SCTP,...) |           | (DCCP, SCTP,...) |
        |                  |  ------&gt;  |                  |
        +------------------+           +------------------+
        |                  |           |   protocol #|    |
        |    IP header     | \         |   Magic number   |
        |                  |  \        +------------------+
        +------------------+   \       |                  |
                                \      |    UDP header    |
                                 \     +------------------+
                                  \    |                  |
                                   \-&gt; |    IP header     |
                                       |                  |
                                       +------------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: GUT encapsulation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>

The magic number MAGIC_N is a 32-bit value allocated by IANA. After the
magic number we have 24-bits reserved for future use, and the original
encapsulated 8-bit protocol number. All in all, this header is thus 64
bits.


</p>
<p>

The 24-bit reserved field is currently unused, but we may need to use
some of it for fragmentation and/or for use with IP options, as
discussed below.


</p><br /><hr class="insert" />
<a name="f:header"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

 0                                31
+---------------------------------+
|       32-bit magic number       |
+---------------------------------+
|  Reserved          | Protocol # |
+---------------------------------+


</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: GUT header&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>

Discussion: 


</p>
<p>

</p>
<ul class="text">
<li>

Basically, we could drop the GUT header and just encapsulate the 
original IP payload into a UDP datagram. However, this results in two 
challenges at the receiver: (1) we need to do pattern matching or some data 
analysis to figure out what the original IP payload (e.g. transport protocol) 
was, and (2) we end up building IP packets from all the traffic arriving at the 
GUT_P UDP port.


</li>
</ul><p>


</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Sender operation</h3>

<p>

A GUT sender operates basically as any data sender. It receives data (from 
transport protocol Y going to port X) and sends it out to the GUT_P port over 
UDP. The source port MAY be chosen freely, although if the encapsulated 
protocol had a notion of port numners, the sender MAY choose the same source 
port. The IP header indicates a UDP transport, the GUT header is the first 
bytes of the UDP payload and gives the inner protocol number. The IP header 
length obviously gives the length of the whole GUT packet including the 
encapsulated transport protocol packet.


</p>
<p>

The current value of GUT_P is 4887 (rule of thumb 1-800-GUTP)


</p>
<p>

Discussion: 


</p>
<p>

</p>
<ul class="text">
<li>

Fragmentation issues. GUT adds 16 octets of headers (UDP+GUT) 
which may cause fragmentation to happen. We could do fragmentation at the IP 
layer or within GUT by using the bits in the GUT header to indicate the 
offset. We have bits unused in the GUT header and could use them to
implement fragmentation within GUT; the question is, is IP fragmentation
a problem with firewall and NAT traversal?


</li>
<li>

IP options are a bit problematic. We could hide the IP options
within the GUT encapsulation, thus they would be forwarded unoticed
within the network, between the sender and receiver. The could also copy or move 
them to the outer header and make them visible in the network when 
the encapsulated packet is routed. However, this may result in unwanted behavior. For 
example, if we have a RAO option in the original IP packet, and we keep this 
visible in the GUT-encapsulated datagram, any node on the path that wants to 
check the IP payload after the RAO option will encounter a UDP header and a 
GUT header, which the node most probably will not recognize. The IP options 
to be left visible between the two GUT nodes must be decided case-by-case.


</li>
</ul><p>


</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Receiver operation</h3>

<p>

Receiving GUT encapsulated traffic is done through normal transport
player receive mechanisms. GUT must be able to receive packets with two
distinct destination ports, GUT_P and the original source port. The
former is when the node receiving a packet is the flow destination,
i.e., it will receive packets to the GUT_P port as indicated above. The
latter case happens for a 2-way flow and the node is the flow source,
i.e., it will receive upstream packets to the initial source port it
chose when sending the very first packet of the flow.


</p>
<p>

When the host receives packets to port GUT_P, i.e., it is the destination of 
the flow, it MUST store the source IP, encapsulated protocol number and any 
port numbers. This state information is needed to send back packets belonging 
to the same flow - it is not strictly needed, e.g., if the flow is 
unidirectional, but since GUT may not know this, storing the 
state is needed.


</p>
<p>

On receiving a packet to the GUT_P UDP port, the GUT process MUST first check 
the magic number. If this matches, the host can continue processing, 
otherwise, it MUST discard the packet silently.


</p>
<p>

After decapsulation of the 64-bit GUT header, the GUT processing reconstructs 
the original IP packet by using the included protocol number, and injects the 
resulting packet into the host stack for further processing. The packet may 
now be subject to host firewall rules. If there are no listening sockets for 
the encapsulated protocol Y, the host packet processing takes care of this event. So 
essentially, GUT operates as a transparent encapsulation (well, sort of, we 
still receive packets for the GUT_P port which obviously is not 
"transparent").


</p>
<p>

Since the encapsulated payload may have had a different IP header at the
source, and thus a different transport header checksum, on building the
new IP packet, the checksum field of the original header (if any) must
be recomputed. The IP header may differ (original vs. received), for
example, because the sender was behind a NAT, or the receiver was behind NAT
with port forwarding enabled.


</p>
<p>

Discussion: 


</p>
<p>

</p>
<ul class="text">
<li>
Fragmentation and reassembly. This will be determined once we fix 
whether framentation would be an IP layer or GUT function.


</li>
<li>
Handling IP options: TBD once the final solution is determined.

</li>
</ul><p>


</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Example with one NAT in between</h3>

<p>

The following figure describes how various protocol fields are mapped on
a two-way signaling session. The example shows a DCCP-transfer going
from A to B. The figure presents the content of IP packets as they are
sent out from a component on the path. Note that if the encapsulated
protocol does not have port numbers, the GUT processing is even simpler.


</p><br /><hr class="insert" />
<a name="f:example"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

[Source, IP A]  [GUT@A] [NAT, ext IP C] [GUT@B] [Dest, IP B]

------------- Source A to destination B -------------------
1. [IP: A-&gt;B, DCCP]
2. [DCCP: E-&gt;F]

3.              [IP: A-&gt;B, UDP]
4.              [UDP: X-&gt;GUT]
5.              [GUT-hdr, DCCP]
6.              [DCCP: E-&gt;F]

7.                      [IP: C-&gt;B, UDP]
8.                      [UDP: P-&gt;GUT]
                        [GUT-hdr, DCCP]
                        ...

9.                                      [IP: C-&gt;B, DCCP]
10.                                     [DCCP: E-&gt;F]

------------- Destination B to source A -------------------
11.                                             [IP: B-&gt;C,DCCP]
12.                                             [DCCP: F-&gt;E]

13.                                     [IP: B-&gt;C, UDP]
14.                                     [UDP: GUT-&gt;P ]
15.                                     [GUT-hdr, DCCP]
16.                                     [DCCP: F-&gt;E]

17.                     [IP: B-&gt;A, UDP]
18.                     [UDP: GUT-&gt;X]
                        ...

19.             [IP: B-&gt;A, DCCP]
20.             [DCCP: F-&gt;E]
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: GUT encapsulation example&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>

A few details from the figure above:


</p>
<p>

</p>
<ul class="text">
<li>

Line 4: the GUT process takes GUT_P as the destination port, and chooses 
a source port, either randomly or a fixed port called "X" in the figure.


</li>
<li>

Line 8: the NAT may choose a new source port P, instead of X, and rewrite 
the UDP header.


</li>
<li>

Line 10: before sending the packet out, the GUT process takes note of the 
source IP and port numbers, and the encapsulated protocol.


</li>
<li>

Line 11-12: the tunneled protocol has not seen the GUT encapsulation, thus, 
it will use the encapsulated port numbers in the reverse traffic.


</li>
<li>

- Lines 13-16: the GUT process has earlier stored state about the flow, knows 
now that the packet is for an existing stream, and can direct the flow to the 
right destination port "P", instead of sending it to GUT_P, as if the packet 
belonged to a new stream.

</li>
</ul><p>


</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Deployment Considerations</h3>

<p>

The basic goal of GUT is to look like generic UDP messaging to any middlebox 
on the path. If the inner transport protocol has support for congestion 
control, GUT encapsulated packets that are lost will trigger the inner 
transport to react.


</p>
<p>

As GUT only encapsulates the original transport header, any ECN <a class='info' href='#RFC3168'>[RFC3168]<span> (</span><span class='info'>Ramakrishnan, K., Floyd, S., and D. Black, &ldquo;The Addition of Explicit Congestion Notification (ECN) to IP,&rdquo; September&nbsp;2001.</span><span>)</span></a> marking are kept. Specifically, if the inner transport 
protocol has support for ECN, and the receiver wants to send congestion 
notifications to the sender, this information is encoded into the inner 
transport header and carried intact all the way back to the sender. The GUT 
end-points have to note ECN and operate as follows:


</p>
<p>

</p>
<ol class="text">
<li>Sender: If the outgoing transport protocol wants to indicate it supports 
ECN, this information MUST be kept intact in GUT processing. 
</li>
<li>Receiver: If the IP header has the ECN CE codepoint, this MUST be 
propagated to the inner transport protocol stack. (If the receiver wants to 
send ECN congestion notifications back to the sender, it uses its own 
mechanism to do that, inside GUT.)
</li>
</ol><p>


</p>
<p>

In general, GUT does not carry any ECN information by itself, it works as a 
transparent layer between the inner transport protocol and the IP layer. How 
the codepoint information is propagated by and through GUT is an 
implementation issue.


</p>
<p>

As GUT-encapsulated traffic looks like an ordinary stream of UDP packets, 
existing NAT traversal protocols and techniques work out of the box. For 
example, a receiving GUT-daemon can, when needed, maintain the GUT_P open at 
the NAT using any suitable NAT-traversal protocol.


</p>
<p>

GUT was originally designed to be used for host-to-host communication. Yet, 
nothing actually prohibits to have a network node that takes the IP packets 
coming from a host, and tunnels them through GUT. Similarly, a network node on 
the receiving side of the connection can decapsulate the packets before they 
actually hit the receiving end-host, so essentially making a GUT-proxy service.


</p>
<p>

There is yet one issue to consider, namely when to encapsulate a transport 
protocol in GUT, and when not. This can be done automatically, e.g., when 
replies to a transport protocol Y's connection initiation are not received. 
Using GUT can also be a configuration parameter, say, e.g., the host always 
encapsulates DCCP packets into GUT; this operation is fully transparent to 
the inner transport protocol.


</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Encapsulation of other protocols</h3>

<p>

GUT is originally designed to counter the problems of deploying relatively 
new transport protocols on existing Internet. Yet, GUT can also be used to 
encapsulate any other protocol, e.g., RSVP or HIP. 


</p>
<p>

Note that some protocols may not involve port numbers, e.g., RSVP. In such 
cases, GUT is free to choose a random port for the sender's port number; the 
receiver's port is always GUT_P.


</p>
<p>

TBA: more discussion on other encapsulation?


</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p>

Using GUT opens up a trivial DoS attack: the host can be bombarded with UDP 
packets to GUT_P with a valid magic number. The host can diminish this case 
by closing the GUT_P listening socket (and NAT binding) when there are no 
listening sockets open that require GUT; GUT is only active when an 
application is running, expecting to receive data.


</p>
<p>

The use of GUT must not bypass the host's internal firewall rules, i.e., if a 
packet it received through GUT, after GUT processing, the packet MUST be 
forward through the firewall rule chain as if it came directly from the 
network. GUT must operate transparently to most of the host software.


</p>
<p>

GUT itself does not employ any security functions for content protection. 
Yet, one could use any one-way mechanism, or purely rely on the security 
functions of the inner payload. If security measures are used on GUT, it 
should be a one-way scheme, which does not rely on back-and-forth
signalling; we don't want to force two-way signaling within GUT, this
may or may not happen due to the inner protocol being tunneled.


</p>
<p>

GUT enables hosts to payloads through firewalls that would otherwise we
dropped. Thus, it enables by-passing firewall rules, which the network
admin may not appreciate. However, it would be trivial to block also
GUT, by disabling traffic to port GUT_P. Obviously one could run GUT
over any UDP port, and thus force a strict firewall to look for the
magic number in the UDP payload. However, how to block GUT properly and
completely is out of scope of this specification.


</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>

This document requests IANA to allocate two values:


</p>
<p> 1. A new UDP port number GUT_P as referred to in the document. 
</p>
<p> 2. A 56-bit "magic number" to be used in filtering actual GUT packets. 

</p>
<p>

TBA: a discussion on what the value of this magic number should be. We 
probably should not just take any random value but choose it such that there 
would be a very small probability that it is something often used in a 
UDP-based transport protocol. Choosing a good value may involve some 
statistical analysis of current UDP traffic.


</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Summary</h3>

<p>

Essentially this draft proposes to define a generic mechanism for
tunneling any IP payload over a UDP tunnel. The concrete steps to be
specified are:


</p>
<p>1. Allocate a well-known port number for end-hosts to send
UDP-encapsulated traffic to. This is important because the sender would
need to know what port a receiver has open for GUT traffic. Also,
firewall administrators may want to choose if they allow UDP tunneling
to happen. 
</p>
<p>2. Define the encapsulation and decapsulation procedure so that the
receiver knows how to rebuild the original IP packet.
</p>
<p>3. Define the fragmentation and handling of IP options in a unified way.
</p>
<p>
The benefits are:


</p>
<p>

</p>
<ol class="text">
<li>Existing IP protocols, with or without port information, work without
changes. Yet, if they employ IP options, we need to make this possible.

</li>
<li>Deployment can be done on the end-host or a network proxy.
</li>
<li>No changes are required for existing NAT and firewall devices.
</li>
</ol><p>


</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC3168">[RFC3168]</a></td>
<td class="author-text">Ramakrishnan, K., Floyd, S., and D. Black, &ldquo;<a href="http://tools.ietf.org/html/rfc3168">The Addition of Explicit Congestion Notification (ECN) to IP</a>,&rdquo; RFC&nbsp;3168, September&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3168.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4340">[RFC4340]</a></td>
<td class="author-text">Kohler, E., Handley, M., and S. Floyd, &ldquo;<a href="http://tools.ietf.org/html/rfc4340">Datagram Congestion Control Protocol (DCCP)</a>,&rdquo; RFC&nbsp;4340, March&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4340.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4960">[RFC4960]</a></td>
<td class="author-text">Stewart, R., &ldquo;<a href="http://tools.ietf.org/html/rfc4960">Stream Control Transmission Protocol</a>,&rdquo; RFC&nbsp;4960, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4960.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jukka Manner</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Helsinki University of Technology (TKK)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 3000</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Espoo  FIN-02015 TKK</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+358 9 451 2481</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jukka.manner@tkk.fi">jukka.manner@tkk.fi</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.netlab.tkk.fi/~jmanner/">http://www.netlab.tkk.fi/~jmanner/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nuutti Varis</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Helsinki University of Technology 
(TKK)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 3000</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Espoo  FIN-02015 TKK</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:nvaris@cc.hut.fi">nvaris@cc.hut.fi</a></td></tr>
</table>
</body></html>
