<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Lightweight Secure Router Protocol in Dymanmic Sensor Networks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Lightweight Secure Router Protocol in Dymanmic Sensor Networks">
<meta name="keywords" content="Wireless Sensor Networks, Authentication, Energy Efficiency, Scalability">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">6lowpan Working Group</td><td class="header">Y. Qiu</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">J. Zhou</td></tr>
<tr><td class="header">Expires: April 29, 2011</td><td class="header">F. Bao</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Institute for Infocomm Research</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">October 26, 2010</td></tr>
</table></td></tr></table>
<h1><br />Lightweight Secure Router Protocol in Dymanmic Sensor Networks<br />draft-qiu-6lowpan-secure-router-00</h1>

<h3>Abstract</h3>

<p>
When a sensor node roams within a very large and distributed wireless sensor network, which consists of numerous sensor nodes, its routing path and neighborhood keep changing. In order to provide a high level of security in this environment, the moving sensor node needs to be authenticated to new neighboring nodes and a key established for secure communication. The document proposes an efficient and scalable protocol to establish and update the authentication key in a dynamic wireless sensor network environment. The protocol guarantees that two sensor nodes share at least one key with probability 1 (100%) with less memory and energy cost, while not causing considerable communication overhead.

</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on April 29, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#sec:intro">1.</a>&nbsp;
Introduction<br />
<a href="#sec:assump">2.</a>&nbsp;
Network Assumptions<br />
<a href="#sec:sharedkey">3.</a>&nbsp;
Shared-Key Discovery<br />
<a href="#sec:dynamickey">4.</a>&nbsp;
Dynamic Authentication and Key Establishment Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:dynamickey:basic">4.1.</a>&nbsp;
Basic Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:dynamickey:keyman">4.2.</a>&nbsp;
Key Management<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:dynamickey:distrib">4.3.</a>&nbsp;
Distribution Mode<br />
<a href="#sec:analysis">5.</a>&nbsp;
Security Consideration<br />
<a href="#sec:IANA">6.</a>&nbsp;
IANA Consideration<br />
<a href="#sec:conclus">7.</a>&nbsp;
Conclusions <br />
<a href="#rfc.references1">8.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="sec:intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The demand of wireless sensor networks (WSNs) is growing exponentially. It has turned out that the sensor networks can be widely applied in the areas of healthcare, environment monitoring, and the military. One of the surveys on WSNs points out that, in the near future, wireless sensor networks will be an integral part of our lives, more so than the present-day personal computer [1].
  
</p>
<p>
A sensor node has low capability in terms of power, computation, storage and communication. A wireless sensor network is composed of a large number of wireless sensor nodes and multi-hop communication is desired in WSNs. As a result, security in wireless sensor networks has six challenges to overcome: (i) the wireless nature of communication, (ii) resource limitations of sensor nodes, (iii) very large and dense WSNs, (iv) lack of fixed infrastructure, (v) unknown network topology prior to deployment, (vi) high risk of physical attacks on unattended sensors [2]. 

</p>
<p>
With the aforementioned limitations of the existing solutions in mind, we now propose a secure protocol in dynamic WSN, addressing all of the following issues: 

</p>
<ul class="text">
<li>A moving sensor node needs to change its attached routers (or cluster heads) frequently.
</li>
<li>A router (or cluster head) needs to ensure a joining node is not a malicious sensor. 
</li>
<li>A moving node needs to establish a secure tunnel with the new router (or cluster head).
</li>
<li>The energy consumption for establishing the secure tunnel must be minimal.
</li>
</ul>
<p>
One of the important novel features of the proposed protocol is that the cluster heads is employed as sub-base-stations to execute key establishment. This way, the total dependency on the base station for key establishment can be avoided. Also, this approach reduces the hops between two communicating ends and hence results in reduction of the communication cost. 

</p>
<a name="sec:assump"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Network Assumptions</h3>

<p>
In this paper, we consider a scenario in which a sensor node roams within a very large and distributed WSN, consisting of a large number of sensor nodes. It is a typical scenario that is widely adopted in hospital environments as the patients or doctors equipped with sensors roam across each department in the hospital. A patient who carries the sensor nodes can move freely within the range of a hospital. When a wireless sensor node is moving, its routing path and neighborhood keep changing. The moving node needs to be authenticated to the new neighbors and to establish a key for secure communication.

</p>
<p>
This scenario reflects the problems described in Section 1: (a) composition by a large number of sensor nodes; (b) communication based on wireless multi-hop mechanism; (c) no fixed infrastructure; (d) the possible location change of sensor node (patient). Therefore, the challenges of this network assumption are how to establish a secure channel with these routers.  

</p>
<a name="sec:sharedkey"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Shared-Key Discovery</h3>

<p>In the WSN environment, as data transmission consumes much more energy than computation, the probabilistic solution is widely accepted in order to reduce the storage and communication overhead during key establishment. 

</p>
<p>
So far in the literature, numerous random key pre-distribution schemes have been proposed. For example, in Chan et al.¡¯s scheme [21], each sensor node stores a random set of Np dedicated pair-wise keys to achieve the probability p that two nodes share a key. At the key setup phase, each node ID is matched with Np other randomly selected node IDs with probability p. A distinct pair-wise key is generated for each ID pair, and is stored in both nodes¡¯ key-chain along with the ID of the other party. During the shared-key discovery phase, each node broadcasts its ID so that neighboring nodes can tell if they share a common pair-wise key. Note that Chan et al.¡¯s scheme reduces the storage overhead by sacrificing key connectivity, but it still provides perfect key resilience.

</p>
<p>
In this protocol, it is assumed that a sensor node (carried by a patient) can move within a special range (e.g. hospital). As each sensor¡¯s memory is severely constrained, each sensor may only store a small set of keys randomly selected from a key pool at the deployment. Two nodes may use any existing key discovery protocol (e.g., the solution proposed in [21]) to find a common key from their own sets. If the common key is not found, the key establishment scheme will be initiated. The reason why binding a general pre-shared key discovery phase to the protocol is to reduce the energy cost as much as possible.


</p>
<a name="sec:dynamickey"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Dynamic Authentication and Key Establishment Protocol</h3>

<a name="sec:dynamickey:basic"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Basic Protocol</h3>

<p>
Due to the limited storage of sensor nodes, the pre-shared key-pair is not always available between the roaming node and its new neighbors in the circumstance of a dynamic node roaming within large WSNs (e.g., in hospitals and nuclear power plants). Therefore it requires an efficient and scalable protocol to establish and update the keys among nodes for secure communications.

</p>
<p>
Figure 2 shows the basic architecture and message flow of our protocol for authentication and key establishment in dynamic WSNs. When a dynamic sensor node moves to a new area and wants to attach to a router or a cluster head in this area, it first sends a request message to the base station (refer to Figure 2).

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
req={Src=SN, Dst= BS, RT||R0||MAC(KBN, SN||RT||R0)}			(1)
</pre></div>
<p>
where Src and Dst denote the source and destination address of a message respectively. SN, BS and RT are identifiers for sensor node, base station and router, respectively. R0 denotes a random number generated by the sensor node. MAC indicates the message authentication code algorithm with a key and KBN is the shared secret key between the base station and the sensor node. 

</p>
<p>
After receiving the req message, the base station will check its revocation list whether the sensor node has been revoked. If the sensor node is acceptable, then the base station verifies the MAC message. If the result is positive, the base station will generate a session key KNR for the roaming sensor node and the router (or cluster head). 

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
KNR = H(KBN, SN||R0||R1)						(2)
</pre></div>
<p>
where H is a keyed one-way hash function, and R1 is the random number selected by the base station. The base station then sends an approval message appv with the session key to the router: 

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
appv = {Src=BS, Dst=RT, E(KBT, SN||R0||R1||KNR)}				(3)
</pre></div>
<p>
where E is an encryption algorithm, and KBT is the shared secret key between the base station and 
the router. 

</p>
<p>
After receiving the appv message, the router decrypts the payload and extracts the session key KNR, and then sends a notice to the sensor node. 

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
notice = {Src=RT, Dst=SN, R0||R1|| MAC(KNR, RT||SN|| R0||R1)}			(4)
</pre></div>
<p>
Upon getting the notice message, the sensor node extracts the random numbers R0 and R1. After checking if 
the received random number R0 is equal to the original R0, the sensor node recalculates the session key KNR = H(KBN, SN||R0||R1) and then verifies the MAC value. If the result is positive, the sensor node will use the session key for the communication with this router afterwards. In practice, the router could be any sensor node that the dynamic sensor node wants to connect to. 

</p>
<a name="sec:dynamickey:keyman"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Key Management</h3>

<p>
In order to manage the keys, every sensor node maintains a table, called ¡°Key Cache¡±. Table 1 shows the structure of the Key Cache.

</p>
<p>
In order to manage the keys, every sensor node maintains a table, called ¡°Key Cache¡±. Table 1 shows the structure of the Key Cache.

</p>
<p>
When a sensor node, say node N, wants to connect to other sensor node, say node R, it executes the following procedure:

</p>
<blockquote class="text"><dl>
<dt>(1)</dt>
<dd> Checks first if there is an existing key pair between them. 
</dd>
<dt>(2)</dt>
<dd> Otherwise, processes the subroutine of shared-key discovery to find a common key between node N and node R based on those ¡°PreSharedKeys¡± in their key caches. 
</dd>
<dt>(3)</dt>
<dd> If there is still no common key between them, the sensor node allocates an entry in the key cache, and assigns Node ID as nodeR, Key Stuff as the random number R0 and Key Lifetime as 0, as shown in Table 2. 
</dd>
<dt>(4)</dt>
<dd> Then the sensor node initiates the procedure of key establishment described in the above section. After receiving the notice message, and recalculating the session key KNR, the sensor node updates the entry¡¯s key stuff and key lifetime accordingly. 
</dd>
<dt>(5)</dt>
<dd> When the key lifetime is expired, the dynamic sensor node should re-initiate the procedure of key establishment described in the above section. 
</dd>
<dt>(6)</dt>
<dd> When the sensor node leaves the range of the connected router, the sensor node deletes the related entry from its cache table in order to save the storage. In case there is no space for adding a new entry, it may first delete the oldest key which has expired or will expire soon. 
</dd>
</dl></blockquote>
<p>
The base station also maintains a key table (Table 3) that includes the secret keys shared with all of the sensor nodes in the network. 

</p>
<p>
If a node is compromised and revoked, its field of key lifetime would be marked as negative.

</p>
<a name="sec:dynamickey:distrib"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Distribution Mode</h3>

<p>
In WSNs, the more hops between two communicating ends exist, the poorer the traffic performance becomes and the more energy consumption is required. To overcome these problems, we introduce the distribution mode.

</p>
<p>
The major idea of distribution mode is to deploy the cluster heads as the sub-base-stations because a cluster head is more powerful than normal sensor nodes. The distribution mode includes the 
following steps:

</p>
<blockquote class="text"><dl>
<dt>(1)</dt>
<dd>Each cluster head manages to establish the shared key with its neighboring cluster heads after deployment. There are several ways to do this. One could embed those keys in advance if the topology is known at deployment, or use the basic protocol described in the above sections, via the base station. (As this is a one-time operation, the overheads may be acceptable.)
</dd>
<dt>(2)</dt>
<dd>Each sensor node keeps two base station identifiers (IDs): one is a real base station ID; the other is a sub-base-station (the cluster head) ID. Initially, the ID of sub-base-station is a real base station. 
</dd>
<dt>(3)</dt>
<dd>After deployment, the first round for a mobile node to establish the shared key with the nearest cluster head uses the basic protocol, too.
</dd>
<dt>(4)</dt>
<dd>When the mobile node moves, use the basic protocol to establish the shared key with the new cluster head, via the sub-base-station (old cluster head) rather than the real base station.
</dd>
<dt>(5)</dt>
<dd>After successfully establishing the keys, the sensor node updates the ID of sub-base-station with the current cluster head.
</dd>
<dt>(6)</dt>
<dd>For security reasons, each sensor node must reset its sub-base-station ID to the real base station at a specified interval (say a few hours or days, depending on the various applications) and re-establish keys with its near cluster heads via the real base station. If the base station does not receive any request from a sensor node, it considers the sensor node has been compromised.
</dd>
</dl></blockquote>
<p>The distribution mode could provide an efficient and low energy-cost solution for the shared-key establishment. The basic protocol can provide the stronger protection since it can immediately block and revoke compromised nodes.

</p>
<a name="sec:analysis"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Security Consideration</h3>

<p>
In this proposed protocol, the session key KNR between the sensor node and the router is generated by the base station and sensor node respectively, and the session key is directly sent to the router from the base station by an encrypted packet. Hence, the session key KNR is never disclosed during transmission. The session key KNR is only known by the related peers, i.e., the sensor node, the base station and the router.

</p>
<p>
Referring to equation (2), the session key KNR is generated by a keyed hash function with the shared key KBN between sensor node and base station as well as two random numbers, R0 and R1, which are generated by the sensor node and base station respectively. As both R0 and R1 are used only one time, there are not the same session keys KNR. This property is useful to against the replication attacks. 

</p>
<p>
Since the session key KNR is generated by a keyed hash function with the secret key KBN between the sensor node and the base station, the different sensor nodes will have different session keys. This feature is useful to protect sensor node privacy.

</p>
<p>
 Even though an eavesdropper at the edge of the sensor node can monitor and capture the random numbers R0 and R1 as well as the identity of the sensor node, it is still not able to regenerate the session key KNR due to lack of the secret key KBN. Without a proper session key, the routers will not forward the packets to next nodes. This attribute could prevent camouflage and traffic attacks. 

</p>
<p>
Due to the fact that no trusted connection is established between sensor node and new router before the connection between them, the proposed protocol employs a random number R1 issued by the base station. The sensor node needs to recalculate the KNR first based on the R1 together with KBN and R0. Then using the calculated session key KNR to verify the received session key KNR and the random number R1. If the result is positive, then the sensor node will trust that the router is authorized by the base station.

</p>
<p>
Besides the function of informing the sensor node that the new session key KNR is ready to use in the router, the notice message also plays an important role to check if the sensor node¡¯s address is reachable. Without this reachability check, the sensor node may claim that it is at any location rather than its real location. It could launch redirecting attacks. 

</p>
<p>
The path between the base station and the router is secure because the packet between them is encrypted with a pre-shared key KBT.

</p>
<p>
The messages from the sensor node to the base station and from the router to the sensor node are authenticated by a keyed hash function. Before accepting the inward message and making further processing, the receivers must verify the authentication. Since the cost of a hash algorithm is very small, the base station and sensor node could avoid the attacks of denial of service.

</p>
<p>
In order to achieve high efficiency and low energy cost, the protocol deploys a distribution mode which uses the cluster headers as the sub-base-stations. Due to the capability of cluster header, it is not able to recognize any compromised sensor nodes in time; the protocol requires each sensor node to reset its sub-base-station ID to the real base station regularly, and to re-establish keys with its near cluster heads via the real base station. This step is also useful to avoid a sensor node binding a compromised cluster head for long time.

</p>
<p>
According to the above analysis, this proposed protocol, which is simple and easy to implement, can provide relatively strong protection for sensor node networks.

</p>
<a name="sec:IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
IANA Consideration</h3>

<p>This version does not need new values to be assigned by IANA.

</p>
<a name="sec:conclus"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Conclusions </h3>

<p>
In this paper, we have proposed an efficient and scalable protocol to establish and update the authentication key between any pair of sensor nodes in a dynamic wireless sensor network. Our protocol has the following features:

</p>
<ul class="text">
<li>It is suitable for both static and dynamic WSNs. Any pair of nodes can establish a key for secure communication.
</li>
<li>A roaming node only deals with its closest router for security. There is no need to change the rest of routing path to the base station.
</li>
<li>The base station can manage a revocation list for lost or compromised roaming nodes.
</li>
<li>The system is scalable and resilient against node compromise.
</li>
</ul>
<p>
After comparing with some of the popular and latest protocols used in WSNs, our protocol could save about 30% in communication energy, and has the higher probability (100%) of sharing a key between two sensor nodes with less memory cost than those pre-distribution schemes, without incurring in a considerable amount of communication.
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>8.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[1]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.ietf.org/rfc/rfc2119.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ying Qiu</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Institute for Infocomm Research, Singapore</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1 Fusionopolis Way</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">#21-01 Connexis (South Tower)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Singapore  138632</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+65-6408 2053</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:qiuying@i2r.a-star.edu.sg">qiuying@i2r.a-star.edu.sg</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jianying Zhou</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Institute for Infocomm Research, Singapore</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1 Fusionopolis Way</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">#21-01 Connexis (South Tower)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Singapore  138632</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+65-6408 2075</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jyyzhou@i2r.a-star.edu.sg">jyyzhou@i2r.a-star.edu.sg</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Feng Bao</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Institute for Infocomm Research, Singapore</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1 Fusionopolis Way</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">#21-01 Connexis (South Tower)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Singapore  138632</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+65-6408 2073</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:baofeng@i2r.a-star.edu.sg">baofeng@i2r.a-star.edu.sg</a></td></tr>
</table>
</body></html>
